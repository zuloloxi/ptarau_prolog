; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\engine.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DF@NFEFGKK@stub?0?5THREADS?5on?5the?5way?5to?5be?5i@ ; `string'
_BSS	SEGMENT
_engine_unique_id DD 01H DUP (?)
_tsync_initialized DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_nothreads DD	FLAT:??_C@_0DF@NFEFGKK@stub?0?5THREADS?5on?5the?5way?5to?5be?5i@
_DATA	ENDS
;	COMDAT ??_C@_0DF@NFEFGKK@stub?0?5THREADS?5on?5the?5way?5to?5be?5i@
CONST	SEGMENT
??_C@_0DF@NFEFGKK@stub?0?5THREADS?5on?5the?5way?5to?5be?5i@ DB 'stub, THR'
	DB	'EADS on the way to be implemented for WIN32', 00H ; `string'
CONST	ENDS
EXTRN	_hcount:DWORD
EXTRN	_newatom:DWORD
EXTRN	_newlex:DWORD
EXTRN	_opcount:DWORD
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\engine.c
;	COMDAT _set_bak
_TEXT	SEGMENT
_set_bak PROC						; COMDAT

; 195  :   bak_ctop = ctop;

  00000	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380

; 196  :   g.bak_opcount = opcount;

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opcount

; 197  :   g.bak_newlex = newlex;

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _newlex
  00011	a3 80 01 00 00	 mov	 DWORD PTR _g+384, eax

; 198  : 
; 199  :   g.bak_newatom = newatom;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _newatom
  0001b	89 0d 18 01 00
	00		 mov	 DWORD PTR _g+280, ecx

; 200  :   g.bak_hcount = hcount;

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hcount
  00027	89 15 1c 01 00
	00		 mov	 DWORD PTR _g+284, edx
  0002d	a3 10 01 00 00	 mov	 DWORD PTR _g+272, eax
  00032	89 0d 14 01 00
	00		 mov	 DWORD PTR _g+276, ecx

; 201  : }

  00038	c3		 ret	 0
_set_bak ENDP
_TEXT	ENDS
EXTRN	_hcommit:PROC
EXTRN	_atomcommit:PROC
EXTRN	_atombak:PROC
EXTRN	_hbak:PROC
; Function compile flags: /Ogtpy
;	COMDAT _push_code
_TEXT	SEGMENT
_push_code PROC						; COMDAT

; 204  :   hbak(RUNTIME);

  00000	6a 02		 push	 2
  00002	e8 00 00 00 00	 call	 _hbak

; 205  :   atombak(RUNTIME);

  00007	6a 02		 push	 2
  00009	e8 00 00 00 00	 call	 _atombak

; 206  :   atomcommit(LOADTIME);

  0000e	6a 01		 push	 1
  00010	e8 00 00 00 00	 call	 _atomcommit

; 207  :   hcommit(LOADTIME);

  00015	6a 01		 push	 1
  00017	e8 00 00 00 00	 call	 _hcommit

; 208  :   set_bak(wam);

  0001c	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opcount
  00027	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _newlex
  0002d	a3 80 01 00 00	 mov	 DWORD PTR _g+384, eax
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR _newatom
  00037	89 0d 18 01 00
	00		 mov	 DWORD PTR _g+280, ecx
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hcount
  00043	89 15 1c 01 00
	00		 mov	 DWORD PTR _g+284, edx

; 209  :   g.shared[BBoardStk].top = g.shared[BBoardStk].base;

  00049	8b 15 a8 01 00
	00		 mov	 edx, DWORD PTR _g+424
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	a3 10 01 00 00	 mov	 DWORD PTR _g+272, eax
  00057	89 0d 14 01 00
	00		 mov	 DWORD PTR _g+276, ecx
  0005d	89 15 a0 01 00
	00		 mov	 DWORD PTR _g+416, edx

; 210  : }

  00063	c3		 ret	 0
_push_code ENDP
_TEXT	ENDS
PUBLIC	_init_orig_wam
EXTRN	_cputime:PROC
; Function compile flags: /Ogtpy
;	COMDAT _init_orig_wam
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_init_orig_wam PROC					; COMDAT

; 213  :   set_bak(wam);

  00000	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opcount
  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _newlex
  00011	a3 80 01 00 00	 mov	 DWORD PTR _g+384, eax
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _newatom
  0001b	89 0d 18 01 00
	00		 mov	 DWORD PTR _g+280, ecx
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hcount
  00027	89 15 1c 01 00
	00		 mov	 DWORD PTR _g+284, edx
  0002d	a3 10 01 00 00	 mov	 DWORD PTR _g+272, eax
  00032	89 0d 14 01 00
	00		 mov	 DWORD PTR _g+276, ecx

; 214  : 
; 215  :   g.rtime = cputime();

  00038	e8 00 00 00 00	 call	 _cputime
  0003d	a3 24 01 00 00	 mov	 DWORD PTR _g+292, eax

; 216  :   g.total_gctime = ZERO;

  00042	33 c0		 xor	 eax, eax
  00044	a3 28 01 00 00	 mov	 DWORD PTR _g+296, eax

; 217  :   g.gctime = ZERO;

  00049	a3 2c 01 00 00	 mov	 DWORD PTR _g+300, eax

; 218  : }

  0004e	c3		 ret	 0
_init_orig_wam ENDP
_TEXT	ENDS
PUBLIC	_restart_orig
EXTRN	_seen_told:PROC
; Function compile flags: /Ogtpy
;	COMDAT _restart_orig
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_restart_orig PROC					; COMDAT

; 221  :   ctop = bak_ctop;

  00000	a1 80 01 00 00	 mov	 eax, DWORD PTR _g+384

; 222  :   opcount = g.bak_opcount;

  00005	8b 0d 18 01 00
	00		 mov	 ecx, DWORD PTR _g+280

; 223  :   newlex = g.bak_newlex;

  0000b	8b 15 1c 01 00
	00		 mov	 edx, DWORD PTR _g+284

; 224  :   hbak(LOADTIME);

  00011	6a 01		 push	 1
  00013	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  00018	89 0d 00 00 00
	00		 mov	 DWORD PTR _opcount, ecx
  0001e	89 15 00 00 00
	00		 mov	 DWORD PTR _newlex, edx
  00024	e8 00 00 00 00	 call	 _hbak

; 225  :   atombak(LOADTIME);

  00029	6a 01		 push	 1
  0002b	e8 00 00 00 00	 call	 _atombak

; 226  : 
; 227  :   ASSERT2(newatom==g.bak_newatom,g.true); ASSERT2(hcount==(bp_long)g.bak_hcount,g.true);
; 228  : 
; 229  :   seen_told(0);

  00030	6a 00		 push	 0
  00032	e8 00 00 00 00	 call	 _seen_told

; 230  :   seen_told(1);

  00037	6a 01		 push	 1
  00039	e8 00 00 00 00	 call	 _seen_told

; 231  : 
; 232  :   g.shared[BBoardStk].top = g.shared[BBoardStk].base;

  0003e	a1 a8 01 00 00	 mov	 eax, DWORD PTR _g+424
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	a3 a0 01 00 00	 mov	 DWORD PTR _g+416, eax

; 233  : }

  0004b	c3		 ret	 0
_restart_orig ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@IEICGOJH@integer?5expected?5in?5halt?11?$AA@ ; `string'
PUBLIC	_heap_or_bp_halt
EXTRN	_bp_halt:PROC
EXTRN	_warnmes:PROC
;	COMDAT ??_C@_0BL@IEICGOJH@integer?5expected?5in?5halt?11?$AA@
CONST	SEGMENT
??_C@_0BL@IEICGOJH@integer?5expected?5in?5halt?11?$AA@ DB 'integer expect'
	DB	'ed in halt/1', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _heap_or_bp_halt
_TEXT	SEGMENT
_H$ = 8							; size = 4
_regs$ = 12						; size = 4
_wam$ = 16						; size = 4
_heap_or_bp_halt PROC					; COMDAT

; 236  :   cell xval;
; 237  :   bp_long ires;
; 238  :   xval = X(1);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _regs$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]

; 239  :   if (!INTEGER(xval)) {

  00009	8b cf		 mov	 ecx, edi
  0000b	80 e1 03	 and	 cl, 3
  0000e	80 f9 01	 cmp	 cl, 1
  00011	74 14		 je	 SHORT $LN4@heap_or_bp

; 240  :     warnmes("integer expected in halt/1");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IEICGOJH@integer?5expected?5in?5halt?11?$AA@
  00018	e8 00 00 00 00	 call	 _warnmes

; 241  :     ires = 1;

  0001d	be 01 00 00 00	 mov	 esi, 1

; 242  :     xval = INPUT_INT(ires);

  00022	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00025	eb 13		 jmp	 SHORT $LN7@heap_or_bp
$LN4@heap_or_bp:

; 243  :   }
; 244  :   else ires = OUTPUT_INT(xval);

  00027	8b f7		 mov	 esi, edi
  00029	c1 fe 02	 sar	 esi, 2

; 245  : 
; 246  :   if (ires > 999) {

  0002c	81 fe e7 03 00
	00		 cmp	 esi, 999		; 000003e7H
  00032	7e 09		 jle	 SHORT $LN2@heap_or_bp

; 247  :     bp_halt(ires);

  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 _bp_halt
$LN7@heap_or_bp:
  0003a	83 c4 04	 add	 esp, 4
$LN2@heap_or_bp:

; 248  :     /* FORCED halt. bp_halt should be called,
; 249  :      given that exit(N) is caught, to ensure
; 250  :      foreign modules cannot kill the system
; 251  :      */
; 252  :   }
; 253  : 
; 254  :   SET_ENGINE_ERROR(ires);

  0003d	8b 44 24 14	 mov	 eax, DWORD PTR _wam$[esp+4]
  00041	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  00044	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]

; 255  :   g.err.id = xval;
; 256  : 
; 257  :   /*fprintf(STD_err,"$$ heap_or_bp_halt(%d)\n",ires); */
; 258  : 
; 259  :   if (ires > 0) return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	83 ca 01	 or	 edx, 1
  00050	85 f6		 test	 esi, esi
  00052	0f 9f c0	 setg	 al
  00055	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  00058	89 3d 5c 01 00
	00		 mov	 DWORD PTR _g+348, edi
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	48		 dec	 eax
  00061	23 44 24 04	 and	 eax, DWORD PTR _H$[esp-4]

; 260  :   return H;
; 261  : }

  00065	c3		 ret	 0
_heap_or_bp_halt ENDP
_TEXT	ENDS
PUBLIC	_unwind_trail
; Function compile flags: /Ogtpy
;	COMDAT _unwind_trail
_TEXT	SEGMENT
_new0$ = 8						; size = 4
_old$ = 12						; size = 4
_unwind_trail PROC					; COMDAT

; 276  :   register term adr;
; 277  :   register cell tag;
; 278  : 
; 279  :   while (old < new0) {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _new0$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _old$[esp]
  00009	3b f0		 cmp	 esi, eax
  0000b	73 22		 jae	 SHORT $LN1@unwind_tra
  0000d	57		 push	 edi
  0000e	8b ff		 npad	 2
$LL2@unwind_tra:

; 280  :     new0--;
; 281  :     adr = *new0;

  00010	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00013	83 e8 04	 sub	 eax, 4

; 282  :     tag = /*!!*/((cell) adr & TR_VTAG);

  00016	8b d1		 mov	 edx, ecx
  00018	83 e2 01	 and	 edx, 1

; 283  :     adr = (term) ((cell) adr - tag);
; 284  :     *adr = (cell) (new0[-(bp_long) tag]);

  0001b	8d 3c 95 00 00
	00 00		 lea	 edi, DWORD PTR [edx*4]
  00022	2b c7		 sub	 eax, edi
  00024	2b ca		 sub	 ecx, edx
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	89 11		 mov	 DWORD PTR [ecx], edx
  0002a	3b f0		 cmp	 esi, eax
  0002c	72 e2		 jb	 SHORT $LL2@unwind_tra
  0002e	5f		 pop	 edi
$LN1@unwind_tra:
  0002f	5e		 pop	 esi

; 285  :     new0 -= tag;
; 286  :   }
; 287  :   return new0;
; 288  : }

  00030	c3		 ret	 0
_unwind_trail ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@MGKEAMMC@?$CK?$CK?$CK?5bad?5instruction?3?5?$FL?$CFlu?$FN?5?$CK?$CK?$CK?6?$AA@ ; `string'
PUBLIC	_bad_instr
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0CA@MGKEAMMC@?$CK?$CK?$CK?5bad?5instruction?3?5?$FL?$CFlu?$FN?5?$CK?$CK?$CK?6?$AA@
CONST	SEGMENT
??_C@_0CA@MGKEAMMC@?$CK?$CK?$CK?5bad?5instruction?3?5?$FL?$CFlu?$FN?5?$CK?$CK?$CK?6?$AA@ DB '*'
	DB	'** bad instruction: [%lu] ***', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bad_instr
_TEXT	SEGMENT
_P$ = 8							; size = 4
_bad_instr PROC						; COMDAT

; 430  :   fprintf(STD_err, "*** bad instruction: [%lu] ***\n", GETOP(P));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _P$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0000c	51		 push	 ecx
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MGKEAMMC@?$CK?$CK?$CK?5bad?5instruction?3?5?$FL?$CFlu?$FN?5?$CK?$CK?$CK?6?$AA@
  00012	e8 00 00 00 00	 call	 ___iob_func
  00017	83 c0 40	 add	 eax, 64			; 00000040H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fprintf
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :   bp_halt(8);

  00023	c7 44 24 04 08
	00 00 00	 mov	 DWORD PTR _P$[esp-4], 8
  0002b	e9 00 00 00 00	 jmp	 _bp_halt
_bad_instr ENDP
_TEXT	ENDS
PUBLIC	_bp_abort
EXTRN	_link_halt:PROC
; Function compile flags: /Ogtpy
;	COMDAT _bp_abort
_TEXT	SEGMENT
_H$ = 8							; size = 4
_P$ = 12						; size = 4
_A$ = 16						; size = 4
_wam$ = 20						; size = 4
_mes$ = 24						; size = 4
_bp_abort PROC						; COMDAT

; 602  :   if (mes) warnmes(mes);

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 09		 je	 SHORT $LN1@bp_abort
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _warnmes
  0000e	83 c4 04	 add	 esp, 4
$LN1@bp_abort:

; 603  :   link_halt();

  00011	e8 00 00 00 00	 call	 _link_halt

; 604  :   SET_ENGINE_ERROR(ENGINE_ABORT);

  00016	8b 44 24 10	 mov	 eax, DWORD PTR _wam$[esp-4]
  0001a	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]

; 605  :   SAVE_HAP();

  0001d	8b 54 24 04	 mov	 edx, DWORD PTR _H$[esp-4]
  00021	c7 41 18 fd ff
	ff ff		 mov	 DWORD PTR [ecx+24], -3	; fffffffdH
  00028	8b 4c 24 0c	 mov	 ecx, DWORD PTR _A$[esp-4]
  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002f	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  00032	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  00035	8b 44 24 08	 mov	 eax, DWORD PTR _P$[esp-4]
  00039	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 606  :   return NULL;

  0003c	33 c0		 xor	 eax, eax

; 607  : }

  0003e	c3		 ret	 0
_bp_abort ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@HMDEMNIG@undefined?5in?5EXEC?$AA@	; `string'
PUBLIC	_exec_link
EXTRN	_local_error:PROC
EXTRN	_hget:PROC
;	COMDAT ??_C@_0BC@HMDEMNIG@undefined?5in?5EXEC?$AA@
CONST	SEGMENT
??_C@_0BC@HMDEMNIG@undefined?5in?5EXEC?$AA@ DB 'undefined in EXEC', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _exec_link
_TEXT	SEGMENT
_H$ = 8							; size = 4
_P$ = 12						; size = 4
_A$ = 16						; size = 4
_wam$ = 20						; size = 4
_exec_link PROC						; COMDAT

; 616  :   instr NewP;
; 617  :   if (!(NewP = GETPRED(P))) {

  00000	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  00005	53		 push	 ebx
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _P$[esp+4]
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _hget
  00012	8b d8		 mov	 ebx, eax
  00014	83 c4 08	 add	 esp, 8
  00017	85 db		 test	 ebx, ebx
  00019	75 3a		 jne	 SHORT $LN5@exec_link

; 618  :     (void) LOCAL_ERR((cell)P,"undefined in EXEC");

  0001b	56		 push	 esi
  0001c	8b 74 24 1c	 mov	 esi, DWORD PTR _wam$[esp+8]
  00020	56		 push	 esi
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HMDEMNIG@undefined?5in?5EXEC?$AA@
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _local_error
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 619  :     (void) bp_abort(H, P, A, wam, NULL);

  0002f	e8 00 00 00 00	 call	 _link_halt
  00034	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00037	8b 44 24 18	 mov	 eax, DWORD PTR _A$[esp+8]
  0003b	8b 54 24 10	 mov	 edx, DWORD PTR _H$[esp+8]
  0003f	c7 41 18 fd ff
	ff ff		 mov	 DWORD PTR [ecx+24], -3	; fffffffdH
  00046	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00049	89 46 50	 mov	 DWORD PTR [esi+80], eax
  0004c	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0004f	89 79 08	 mov	 DWORD PTR [ecx+8], edi

; 620  :   }
; 621  :   return NewP;

  00052	8b c3		 mov	 eax, ebx
  00054	5e		 pop	 esi
$LN5@exec_link:

; 622  : }

  00055	5f		 pop	 edi
  00056	5b		 pop	 ebx
  00057	c3		 ret	 0
_exec_link ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@COGAOFPN@load?5engine?3?5error?5in?5copy_to_en@ ; `string'
PUBLIC	??_C@_0BI@EPPKIDMI@load_engine?3?5bad?5engine?$AA@ ; `string'
PUBLIC	_load_engine
EXTRN	_copy_to_engine:PROC
EXTRN	_set_engine_prop:PROC
EXTRN	_init_var_array:PROC
EXTRN	_is_engine:PROC
;	COMDAT ??_C@_0CF@COGAOFPN@load?5engine?3?5error?5in?5copy_to_en@
CONST	SEGMENT
??_C@_0CF@COGAOFPN@load?5engine?3?5error?5in?5copy_to_en@ DB 'load engine'
	DB	': error in copy_to_engine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EPPKIDMI@load_engine?3?5bad?5engine?$AA@
CONST	SEGMENT
??_C@_0BI@EPPKIDMI@load_engine?3?5bad?5engine?$AA@ DB 'load_engine: bad e'
	DB	'ngine', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_engine
_TEXT	SEGMENT
_P$ = -8						; size = 4
_regs$ = -8						; size = 4
_H$ = -4						; size = 4
_wam$ = 8						; size = 4
_goal$ = 12						; size = 4
_answer$ = 16						; size = 4
_load_engine PROC					; COMDAT

; 629  : term load_engine(register stack wam, cell goal, cell answer) {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi

; 630  :   register term regs;
; 631  :   register term H;
; 632  :   register term *A;
; 633  :   register instr P;
; 634  :   if (!is_engine(wam)) {

  00004	8b 74 24 10	 mov	 esi, DWORD PTR _wam$[esp+8]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 _is_engine
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 14		 jne	 SHORT $LN7@load_engin

; 635  :     warnmes("load_engine: bad engine");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EPPKIDMI@load_engine?3?5bad?5engine?$AA@
  0001a	e8 00 00 00 00	 call	 _warnmes
  0001f	83 c4 04	 add	 esp, 4

; 636  :     return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	5e		 pop	 esi

; 668  :   return H;
; 669  : }

  00025	83 c4 08	 add	 esp, 8
  00028	c3		 ret	 0
$LN7@load_engin:

; 637  :   }
; 638  : 
; 639  :   INIT_NEW_INTERP();

  00029	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0002c	53		 push	 ebx
  0002d	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00030	55		 push	 ebp
  00031	8b 6e 58	 mov	 ebp, DWORD PTR [esi+88]
  00034	57		 push	 edi
  00035	8d 7b 20	 lea	 edi, DWORD PTR [ebx+32]
  00038	81 c3 20 1c 00
	00		 add	 ebx, 7200		; 00001c20H
  0003e	68 ff 00 00 00	 push	 255			; 000000ffH
  00043	89 7c 24 14	 mov	 DWORD PTR _regs$[esp+28], edi
  00047	53		 push	 ebx
  00048	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0004b	81 c7 fc 1f 00
	00		 add	 edi, 8188		; 00001ffcH
  00051	e8 00 00 00 00	 call	 _init_var_array
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _engine_unique_id
  0005c	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0005f	89 03		 mov	 DWORD PTR [ebx], eax
  00061	89 00		 mov	 DWORD PTR [eax], eax
  00063	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0006a	83 c8 01	 or	 eax, 1
  0006d	41		 inc	 ecx
  0006e	50		 push	 eax
  0006f	89 0d 00 00 00
	00		 mov	 DWORD PTR _engine_unique_id, ecx
  00075	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00078	6a 07		 push	 7
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _set_engine_prop

; 640  : 
; 641  :   {
; 642  :     term t, ct;
; 643  :     t = H;
; 644  :     H[0] = g.DOT;

  00080	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _g+36

; 645  :     H[1] = goal;

  00086	8b 44 24 34	 mov	 eax, DWORD PTR _goal$[esp+40]

; 646  :     H[2] = answer;

  0008a	8b 4c 24 38	 mov	 ecx, DWORD PTR _answer$[esp+40]
  0008e	89 17		 mov	 DWORD PTR [edi], edx

; 647  :     H += 3;

  00090	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]

; 648  :     wam[HeapStk].top = (term *) H;
; 649  :     ct = copy_to_engine(wam, t);

  00093	57		 push	 edi
  00094	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00097	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0009a	56		 push	 esi
  0009b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0009e	e8 00 00 00 00	 call	 _copy_to_engine

; 650  :     H = (term) wam[HeapStk].top;

  000a3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a6	89 4c 24 30	 mov	 DWORD PTR _H$[esp+52], ecx

; 651  :     {
; 652  :       cell xval;
; 653  :       DEREF2(ct,xval);

  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	83 c4 1c	 add	 esp, 28			; 0000001cH
  000af	f6 c1 03	 test	 cl, 3
  000b2	75 0d		 jne	 SHORT $LN5@load_engin
$LL6@load_engin:
  000b4	3b c1		 cmp	 eax, ecx
  000b6	74 09		 je	 SHORT $LN5@load_engin
  000b8	8b c1		 mov	 eax, ecx
  000ba	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000bc	f6 c1 03	 test	 cl, 3
  000bf	74 f3		 je	 SHORT $LL6@load_engin
$LN5@load_engin:

; 654  :     }
; 655  :     if (g.DOT != ct[0]) {

  000c1	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _g+36
  000c7	3b 10		 cmp	 edx, DWORD PTR [eax]
  000c9	74 17		 je	 SHORT $LN4@load_engin

; 656  :       warnmes("load engine: error in copy_to_engine");

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@COGAOFPN@load?5engine?3?5error?5in?5copy_to_en@
  000d0	e8 00 00 00 00	 call	 _warnmes
  000d5	83 c4 04	 add	 esp, 4
  000d8	5f		 pop	 edi
  000d9	5d		 pop	 ebp
  000da	5b		 pop	 ebx

; 657  :       return NULL;

  000db	33 c0		 xor	 eax, eax
  000dd	5e		 pop	 esi

; 668  :   return H;
; 669  : }

  000de	83 c4 08	 add	 esp, 8
  000e1	c3		 ret	 0
$LN4@load_engin:

; 658  :     }
; 659  :     goal = (cell) (ct + 1);
; 660  :     answer = (cell) (ct + 2);
; 661  :   }
; 662  : 
; 663  :   PREP_CALL(goal);

  000e2	8b 54 24 10	 mov	 edx, DWORD PTR _regs$[esp+24]
  000e6	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  000e9	83 c0 08	 add	 eax, 8
  000ec	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  000ef	89 44 24 24	 mov	 DWORD PTR _answer$[esp+20], eax
  000f3	a1 64 00 00 00	 mov	 eax, DWORD PTR _g+100
  000f8	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g
  00101	89 4c 24 10	 mov	 DWORD PTR _P$[esp+24], ecx
  00105	8d 4d 08	 lea	 ecx, DWORD PTR [ebp+8]
  00108	2b d5		 sub	 edx, ebp
  0010a	bf 02 00 00 00	 mov	 edi, 2
  0010f	90		 npad	 1
$LL3@load_engin:
  00110	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
  00115	83 e9 04	 sub	 ecx, 4
  00118	4f		 dec	 edi
  00119	75 f5		 jne	 SHORT $LL3@load_engin
  0011b	8b 44 24 14	 mov	 eax, DWORD PTR _H$[esp+24]
  0011f	89 45 0c	 mov	 DWORD PTR [ebp+12], eax
  00122	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00125	89 4d 10	 mov	 DWORD PTR [ebp+16], ecx
  00128	8b 15 84 01 00
	00		 mov	 edx, DWORD PTR _g+388
  0012e	83 c5 14	 add	 ebp, 20			; 00000014H
  00131	89 55 00	 mov	 DWORD PTR [ebp], edx

; 664  :   SET_ENGINE_TYPE(LOADED_ENGINE);

  00134	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00137	c7 01 09 00 00
	00		 mov	 DWORD PTR [ecx], 9

; 665  :   SET_ENGINE(ENGINE_GOAL,goal);

  0013d	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00140	89 5a 0c	 mov	 DWORD PTR [edx+12], ebx

; 666  :   SET_ENGINE(ENGINE_ANSWER,answer);

  00143	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00146	8b 54 24 24	 mov	 edx, DWORD PTR _answer$[esp+20]
  0014a	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 667  :   SAVE_HAP();

  0014d	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00150	8b 54 24 10	 mov	 edx, DWORD PTR _P$[esp+24]
  00154	5f		 pop	 edi
  00155	89 6e 50	 mov	 DWORD PTR [esi+80], ebp
  00158	5d		 pop	 ebp
  00159	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0015c	5b		 pop	 ebx
  0015d	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00160	5e		 pop	 esi

; 668  :   return H;
; 669  : }

  00161	83 c4 08	 add	 esp, 8
  00164	c3		 ret	 0
_load_engine ENDP
_TEXT	ENDS
PUBLIC	_load_engine0
; Function compile flags: /Ogtpy
;	COMDAT _load_engine0
_TEXT	SEGMENT
_regs$ = 8						; size = 4
_load_engine0 PROC					; COMDAT

; 672  :   return load_engine(INT2PTR(X(1)), /* handle i.e. struct wam */
; 673  :   X(2), /* goal */
; 674  :   X(3) /* answer variable */
; 675  :   );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _regs$[esp-4]
  00004	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00007	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  0000a	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	48		 dec	 eax
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _load_engine
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 676  : }

  00019	c3		 ret	 0
_load_engine0 ENDP
_TEXT	ENDS
PUBLIC	_call_engine
; Function compile flags: /Ogtpy
;	COMDAT _call_engine
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_call_engine PROC					; COMDAT

; 678  : term call_engine(register stack wam) {

  00000	56		 push	 esi

; 679  :   register term regs;
; 680  :   register term H;
; 681  :   register term *A;
; 682  :   register instr P;
; 683  :   term bp(register term regs, register term H, register instr P,
; 684  :       register term *A, register stack wam);
; 685  :   if (!is_engine(wam)) return NULL; TRACE_ENGINE("==> entering call_engine");

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _wam$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _is_engine
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	75 02		 jne	 SHORT $LN2@call_engin
  00012	5e		 pop	 esi

; 691  :   /*warnmes("dead_engine");*/
; 692  :   TRACE_ENGINE("<== exiting call_engine");
; 693  :   return H;
; 694  : }

  00013	c3		 ret	 0
$LN2@call_engin:

; 686  :   RESTORE_HAP();

  00014	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00017	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0001a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001d	57		 push	 edi
  0001e	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 687  :   regs = LOCATEREGS();

  00021	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 688  :   TRACE_ENGINE("==> entering new bp in call_engine");
; 689  :   H = bp(regs, H, P, A, wam);

  00024	56		 push	 esi
  00025	52		 push	 edx
  00026	57		 push	 edi
  00027	83 c0 20	 add	 eax, 32			; 00000020H
  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _bp
  00031	83 c4 14	 add	 esp, 20			; 00000014H
  00034	5f		 pop	 edi

; 690  :   if (!H) SET_ENGINE_TYPE(DEAD_ENGINE);

  00035	85 c0		 test	 eax, eax
  00037	75 09		 jne	 SHORT $LN3@call_engin
  00039	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  0003c	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN3@call_engin:
  00042	5e		 pop	 esi

; 691  :   /*warnmes("dead_engine");*/
; 692  :   TRACE_ENGINE("<== exiting call_engine");
; 693  :   return H;
; 694  : }

  00043	c3		 ret	 0
_call_engine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GMNLFOFF@ask_engine?3?5bad?5engine?5type?$AA@ ; `string'
PUBLIC	_ask_engine
;	COMDAT ??_C@_0BM@GMNLFOFF@ask_engine?3?5bad?5engine?5type?$AA@
CONST	SEGMENT
??_C@_0BM@GMNLFOFF@ask_engine?3?5bad?5engine?5type?$AA@ DB 'ask_engine: b'
	DB	'ad engine type', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _ask_engine
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_ask_engine PROC					; COMDAT

; 696  : term ask_engine(register stack wam) {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 697  :   bp_long curr_type;
; 698  :   TRACE_ENGINE("ask_engine");
; 699  :   curr_type = GET_ENGINE_TYPE();

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _wam$[esp+4]
  00006	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	8b f0		 mov	 esi, eax
  0000d	c1 fe 02	 sar	 esi, 2

; 700  :   switch (curr_type) {

  00010	8d 4e fe	 lea	 ecx, DWORD PTR [esi-2]
  00013	83 f9 03	 cmp	 ecx, 3
  00016	77 3c		 ja	 SHORT $LN1@ask_engine
  00018	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN10@ask_engine[ecx*4]
$LN5@ask_engine:

; 701  :     case LOADED_ENGINE:
; 702  :     case RUNNING_ENGINE:
; 703  :     case HALTED_ENGINE:
; 704  :       if (call_engine(wam)) {

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 _call_engine
  00025	83 c4 04	 add	 esp, 4
  00028	85 c0		 test	 eax, eax
  0002a	74 3e		 je	 SHORT $LN6@ask_engine

; 705  :         if (SUSPENDED_ENGINE == GET_ENGINE_TYPE()) {

  0002c	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00034	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00037	75 15		 jne	 SHORT $LN3@ask_engine

; 706  :           SET_ENGINE_TYPE(curr_type);

  00039	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
  00040	83 ca 01	 or	 edx, 1
  00043	89 10		 mov	 DWORD PTR [eax], edx

; 707  :           return (term) GET_ENGINE(ENGINE_RETURN);

  00045	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00048	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 725  : }

  0004d	c3		 ret	 0
$LN3@ask_engine:

; 708  :         }
; 709  :         return (term) GET_ENGINE(ENGINE_ANSWER);

  0004e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 725  : }

  00053	c3		 ret	 0
$LN1@ask_engine:

; 710  :       }
; 711  :     break;
; 712  : 
; 713  :     case DEAD_ENGINE:
; 714  : #ifdef AUTO_DESTR
; 715  :       (void)destroy_engine(wam);
; 716  : #endif
; 717  :     break;
; 718  : 
; 719  :     default:
; 720  :       (void) local_error(T2C(GET_ENGINE(ENGINE_TYPE)),
; 721  :           "ask_engine: bad engine type", wam);

  00054	57		 push	 edi
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GMNLFOFF@ask_engine?3?5bad?5engine?5type?$AA@
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _local_error

; 722  :       bp_halt(18);

  00060	6a 12		 push	 18			; 00000012H
  00062	e8 00 00 00 00	 call	 _bp_halt
  00067	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@ask_engine:

; 723  :   }
; 724  :   return NULL;

  0006a	5f		 pop	 edi
  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 725  : }

  0006e	c3		 ret	 0
  0006f	90		 npad	 1
$LN10@ask_engine:
  00070	00 00 00 00	 DD	 $LN5@ask_engine
  00074	00 00 00 00	 DD	 $LN5@ask_engine
  00078	00 00 00 00	 DD	 $LN6@ask_engine
  0007c	00 00 00 00	 DD	 $LN5@ask_engine
_ask_engine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GENADHGN@answer?3?5bad?5engine?5type?$AA@ ; `string'
PUBLIC	??_C@_0CC@LOFJBMPP@answer?5requested?5from?5DEAD_ENGIN@ ; `string'
PUBLIC	_answer
;	COMDAT ??_C@_0BI@GENADHGN@answer?3?5bad?5engine?5type?$AA@
CONST	SEGMENT
??_C@_0BI@GENADHGN@answer?3?5bad?5engine?5type?$AA@ DB 'answer: bad engin'
	DB	'e type', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LOFJBMPP@answer?5requested?5from?5DEAD_ENGIN@
CONST	SEGMENT
??_C@_0CC@LOFJBMPP@answer?5requested?5from?5DEAD_ENGIN@ DB 'answer reques'
	DB	'ted from DEAD_ENGINE', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _answer
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_H$ = 12						; size = 4
_A$ = 16						; size = 4
_P$ = 20						; size = 4
_answer	PROC						; COMDAT

; 730  : {

  00000	56		 push	 esi

; 731  :   TRACE_ENGINE("PROCEED->answer")
; 732  :   switch (GET_ENGINE_TYPE()) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _wam$[esp]
  00005	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	83 f8 04	 cmp	 eax, 4
  00010	77 3e		 ja	 SHORT $LN1@answer
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@answer[eax*4]
$LN5@answer:

; 733  :     case LOADED_ENGINE:
; 734  :       SET_ENGINE_TYPE(HALTED_ENGINE);

  00019	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
$LN4@answer:

; 735  :     case ROOT_ENGINE:
; 736  :       SAVE_HAP()

  0001f	8b 4c 24 10	 mov	 ecx, DWORD PTR _A$[esp]
  00023	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp]

; 737  :       ;

  00027	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  0002a	89 4e 50	 mov	 DWORD PTR [esi+80], ecx
  0002d	8b 4c 24 14	 mov	 ecx, DWORD PTR _P$[esp]
  00031	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00034	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00037	5e		 pop	 esi

; 754  : }

  00038	c3		 ret	 0
$LN3@answer:

; 738  :       return H;
; 739  : 
; 740  :     case HALTED_ENGINE:
; 741  :       SET_ENGINE_TYPE(LOADED_ENGINE);

  00039	c7 01 09 00 00
	00		 mov	 DWORD PTR [ecx], 9

; 752  :   }
; 753  :   return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	5e		 pop	 esi

; 754  : }

  00042	c3		 ret	 0
$LN2@answer:

; 742  :     break;
; 743  : 
; 744  :     case DEAD_ENGINE:
; 745  :       warnmes("answer requested from DEAD_ENGINE");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LOFJBMPP@answer?5requested?5from?5DEAD_ENGIN@
  00048	e8 00 00 00 00	 call	 _warnmes
  0004d	83 c4 04	 add	 esp, 4
$LN1@answer:

; 746  :       /*break;*/
; 747  : 
; 748  :     default:
; 749  :       (void) local_error(T2C(GET_ENGINE(ENGINE_TYPE)),
; 750  :           "answer: bad engine type", wam);

  00050	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  00053	8b 02		 mov	 eax, DWORD PTR [edx]
  00055	56		 push	 esi
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GENADHGN@answer?3?5bad?5engine?5type?$AA@
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _local_error

; 751  :       bp_halt(16);

  00061	6a 10		 push	 16			; 00000010H
  00063	e8 00 00 00 00	 call	 _bp_halt
  00068	83 c4 10	 add	 esp, 16			; 00000010H

; 752  :   }
; 753  :   return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 754  : }

  0006e	c3		 ret	 0
  0006f	90		 npad	 1
$LN10@answer:
  00070	00 00 00 00	 DD	 $LN4@answer
  00074	00 00 00 00	 DD	 $LN1@answer
  00078	00 00 00 00	 DD	 $LN5@answer
  0007c	00 00 00 00	 DD	 $LN3@answer
  00080	00 00 00 00	 DD	 $LN2@answer
_answer	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@JMNNHFDE@ask_thread?3?5bad?5engine?$AA@ ; `string'
PUBLIC	_ask_thread@4
EXTRN	_init_random:PROC
;	COMDAT ??_C@_0BH@JMNNHFDE@ask_thread?3?5bad?5engine?$AA@
CONST	SEGMENT
??_C@_0BH@JMNNHFDE@ask_thread?3?5bad?5engine?$AA@ DB 'ask_thread: bad eng'
	DB	'ine', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _ask_thread@4
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_ask_thread@4 PROC					; COMDAT

; 760  : void FORCE_STDCALL ask_thread(register stack wam) {

  00000	56		 push	 esi

; 761  :   if (!is_engine(wam)) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _wam$[esp]
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _is_engine
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN1@ask_thread

; 762  :     warnmes("ask_thread: bad engine");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JMNNHFDE@ask_thread?3?5bad?5engine?$AA@
  00017	e8 00 00 00 00	 call	 _warnmes
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi

; 767  : }

  00020	c2 04 00	 ret	 4
$LN1@ask_thread:

; 763  :     return;
; 764  :   }
; 765  :   init_random(0);

  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 _init_random

; 766  :   ask_engine(wam);

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _ask_engine
  00030	83 c4 08	 add	 esp, 8
  00033	5e		 pop	 esi

; 767  : }

  00034	c2 04 00	 ret	 4
_ask_thread@4 ENDP
_TEXT	ENDS
PUBLIC	_tcreate
EXTRN	__beginthreadex:PROC
; Function compile flags: /Ogtpy
;	COMDAT _tcreate
_TEXT	SEGMENT
_taddr$ = -4						; size = 4
_start_func$ = 8					; size = 4
_arg$ = 12						; size = 4
_tcreate PROC						; COMDAT

; 787  : bp_long tcreate(void *start_func, void *arg) {

  00000	51		 push	 ecx

; 788  :   HANDLE tid; unsigned int taddr;
; 789  :   tid = (HANDLE) _beginthreadex(
; 790  :       NULL,
; 791  :       0,
; 792  :       start_func,
; 793  :       arg,
; 794  :       0, /*CREATE_SUSPENDED*/
; 795  :       &taddr
; 796  :   );

  00001	8b 4c 24 0c	 mov	 ecx, DWORD PTR _arg$[esp]
  00005	8b 54 24 08	 mov	 edx, DWORD PTR _start_func$[esp]
  00009	8d 04 24	 lea	 eax, DWORD PTR _taddr$[esp+4]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	51		 push	 ecx
  00010	52		 push	 edx
  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	e8 00 00 00 00	 call	 __beginthreadex

; 797  : 
; 798  :   return (bp_long)tid;
; 799  : }

  0001a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0001d	c3		 ret	 0
_tcreate ENDP
_TEXT	ENDS
PUBLIC	_current_thread
EXTRN	_get_engine_thread:PROC
; Function compile flags: /Ogtpy
;	COMDAT _current_thread
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_current_thread PROC					; COMDAT

; 802  :   return get_engine_thread(wam);

  00000	e9 00 00 00 00	 jmp	 _get_engine_thread
_current_thread ENDP
_TEXT	ENDS
PUBLIC	_thread_exit
EXTRN	__endthreadex:PROC
; Function compile flags: /Ogtpy
;	COMDAT _thread_exit
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_thread_exit PROC					; COMDAT

; 806  :   /*warnmes("entering thread_exit: this does not close HANDLE");*/
; 807  :   set_engine_prop(PTR2INT(wam),ENGINE_TYPE,INPUT_INT(DEAD_ENGINE));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _wam$[esp-4]
  00004	6a 11		 push	 17			; 00000011H
  00006	40		 inc	 eax
  00007	6a 00		 push	 0
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _set_engine_prop
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 808  :   _endthreadex(0);

  00012	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _wam$[esp-4], 0
  0001a	e9 00 00 00 00	 jmp	 __endthreadex
_thread_exit ENDP
_TEXT	ENDS
PUBLIC	_thread_destroy
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__TerminateThread@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT _thread_destroy
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_thread_destroy PROC					; COMDAT

; 811  : bp_long thread_destroy(bp_long tid) {

  00000	56		 push	 esi

; 812  :   TerminateThread((HANDLE)tid,0);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _tid$[esp]
  00005	6a 00		 push	 0
  00007	56		 push	 esi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 813  :   CloseHandle((HANDLE)tid);

  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 814  :   return 1;

  00015	b8 01 00 00 00	 mov	 eax, 1
  0001a	5e		 pop	 esi

; 815  : }

  0001b	c3		 ret	 0
_thread_destroy ENDP
_TEXT	ENDS
PUBLIC	_thread_join
EXTRN	__imp__WaitForSingleObject@8:PROC
; Function compile flags: /Ogtpy
;	COMDAT _thread_join
_TEXT	SEGMENT
_tid$ = 8						; size = 4
_thread_join PROC					; COMDAT

; 817  : void thread_join(bp_long tid) {

  00000	56		 push	 esi

; 818  :   WaitForSingleObject((HANDLE)tid,INFINITE);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _tid$[esp]
  00005	6a ff		 push	 -1
  00007	56		 push	 esi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 819  :   CloseHandle((HANDLE)tid);

  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  00015	5e		 pop	 esi

; 820  : }

  00016	c3		 ret	 0
_thread_join ENDP
_TEXT	ENDS
PUBLIC	_init_mutexes
EXTRN	__imp__CreateMutexA@12:PROC
_BSS	SEGMENT
_all_tsyncs DD	0400H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _init_mutexes
_TEXT	SEGMENT
_init_mutexes PROC					; COMDAT

; 832  :   if(!tsync_initialized) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tsync_initialized, 0
  00007	75 2e		 jne	 SHORT $LN4@init_mutex

; 833  :     bp_long k;
; 834  :     for(k=0;k<MAXTSYNC;k++) {

  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CreateMutexA@12
  00011	be 00 00 00 00	 mov	 esi, OFFSET _all_tsyncs
$LL3@init_mutex:

; 835  :       all_tsyncs[k].mp = CreateMutex( NULL, FALSE, NULL );

  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	6a 00		 push	 0
  0001c	ff d7		 call	 edi
  0001e	89 06		 mov	 DWORD PTR [esi], eax
  00020	83 c6 04	 add	 esi, 4
  00023	81 fe 00 10 00
	00		 cmp	 esi, OFFSET _all_tsyncs+4096
  00029	7c eb		 jl	 SHORT $LL3@init_mutex

; 836  :     }
; 837  :     tsync_initialized=1;

  0002b	5f		 pop	 edi
  0002c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tsync_initialized, 1
  00036	5e		 pop	 esi
$LN4@init_mutex:

; 838  :   }
; 839  : }

  00037	c3		 ret	 0
_init_mutexes ENDP
_TEXT	ENDS
PUBLIC	_release_mutexes
EXTRN	__imp__ReleaseMutex@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _release_mutexes
_TEXT	SEGMENT
_release_mutexes PROC					; COMDAT

; 842  :   if(tsync_initialized) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tsync_initialized, 0
  00007	74 39		 je	 SHORT $LN4@release_mu

; 843  :     bp_long k;
; 844  :     for(k=0;k<MAXTSYNC;k++) {

  00009	53		 push	 ebx
  0000a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CloseHandle@4
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ReleaseMutex@4
  00018	be 00 00 00 00	 mov	 esi, OFFSET _all_tsyncs
  0001d	8d 49 00	 npad	 3
$LL3@release_mu:

; 845  :       ReleaseMutex(all_tsyncs[k].mp);

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	50		 push	 eax
  00023	ff d7		 call	 edi

; 846  :       CloseHandle(all_tsyncs[k].mp);

  00025	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00027	51		 push	 ecx
  00028	ff d3		 call	 ebx
  0002a	83 c6 04	 add	 esi, 4
  0002d	81 fe 00 10 00
	00		 cmp	 esi, OFFSET _all_tsyncs+4096
  00033	7c eb		 jl	 SHORT $LL3@release_mu

; 847  :     }
; 848  :     tsync_initialized=0;

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tsync_initialized, 0
  00041	5b		 pop	 ebx
$LN4@release_mu:

; 849  :   }
; 850  : }

  00042	c3		 ret	 0
_release_mutexes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@PEAOKHBH@BAD?5tsync_op?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@FECBCEOM@request?5to?5suspend?5main?5thread?5i@ ; `string'
PUBLIC	??_C@_0CG@BAODONFH@request?5to?5resume?5main?5thread?5ig@ ; `string'
PUBLIC	??_C@_0BE@PMHLEONP@3?04?05?5unimplemented?$AA@	; `string'
PUBLIC	??_C@_0CG@OFKDFOIN@tsync?13?5error?3?5op?$DN?$CFd?0ts_no?$DN?$CFd?0ar@ ; `string'
PUBLIC	??_C@_0DI@KCJJFNEN@should?5happen?5once?5each?3?5initial@ ; `string'
PUBLIC	_tsync_op
EXTRN	__imp__SuspendThread@4:PROC
EXTRN	__imp__ResumeThread@4:PROC
;	COMDAT ??_C@_0BC@PEAOKHBH@BAD?5tsync_op?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@PEAOKHBH@BAD?5tsync_op?3?5?$CFd?6?$AA@ DB 'BAD tsync_op: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FECBCEOM@request?5to?5suspend?5main?5thread?5i@
CONST	SEGMENT
??_C@_0CH@FECBCEOM@request?5to?5suspend?5main?5thread?5i@ DB 'request to '
	DB	'suspend main thread ignored', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BAODONFH@request?5to?5resume?5main?5thread?5ig@
CONST	SEGMENT
??_C@_0CG@BAODONFH@request?5to?5resume?5main?5thread?5ig@ DB 'request to '
	DB	'resume main thread ignored', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMHLEONP@3?04?05?5unimplemented?$AA@
CONST	SEGMENT
??_C@_0BE@PMHLEONP@3?04?05?5unimplemented?$AA@ DB '3,4,5 unimplemented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFKDFOIN@tsync?13?5error?3?5op?$DN?$CFd?0ts_no?$DN?$CFd?0ar@
CONST	SEGMENT
??_C@_0CG@OFKDFOIN@tsync?13?5error?3?5op?$DN?$CFd?0ts_no?$DN?$CFd?0ar@ DB 't'
	DB	'sync/3 error: op=%d,ts_no=%d,arg=%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KCJJFNEN@should?5happen?5once?5each?3?5initial@
CONST	SEGMENT
??_C@_0DI@KCJJFNEN@should?5happen?5once?5each?3?5initial@ DB 'should happ'
	DB	'en once each: initialising/releasing mutexes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _tsync_op
_TEXT	SEGMENT
_ts$ = 8						; size = 4
_i$ = 8							; size = 4
_ts_no$ = 12						; size = 4
_arg$ = 16						; size = 4
_tsync_op PROC						; COMDAT

; 853  :   tsync_data ts; bp_long result=1;
; 854  :   /* init_mutexes();
; 855  :    happens in ru.c
; 856  :    */
; 857  : 
; 858  : #if TTRACE>0
; 859  :   fprintf(STD_err,
; 860  :       "entering tsync op: i=%d: ts_no=%d arg=%d\n",
; 861  :       i,ts_no,arg);
; 862  : #endif
; 863  : 
; 864  :   if(i<6 && (ts_no<0 || ts_no>=MAXTSYNC))

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _ts_no$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _i$[esp+8]
  0000b	be 01 00 00 00	 mov	 esi, 1
  00010	83 ff 06	 cmp	 edi, 6
  00013	7d 13		 jge	 SHORT $LN21@tsync_op
  00015	85 c0		 test	 eax, eax
  00017	78 07		 js	 SHORT $LN20@tsync_op
  00019	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0001e	7c 08		 jl	 SHORT $LN21@tsync_op
$LN20@tsync_op:

; 865  :   result=0;
; 866  :   else {

  00020	8b 5c 24 10	 mov	 ebx, DWORD PTR _ts$[esp+8]
  00024	33 f6		 xor	 esi, esi
  00026	eb 53		 jmp	 SHORT $LN24@tsync_op
$LN21@tsync_op:

; 867  :     ts=all_tsyncs+ts_no;

  00028	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR _all_tsyncs[eax*4]

; 868  : 
; 869  :     switch(i) {

  0002f	83 ff 08	 cmp	 edi, 8
  00032	0f 87 df 00 00
	00		 ja	 $LN2@tsync_op
  00038	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN25@tsync_op[edi*4]
$LN16@tsync_op:

; 870  :       case 0: /* not intended to be used */
; 871  :       warnmes("should happen once each: initialising/releasing mutexes");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KCJJFNEN@should?5happen?5once?5each?3?5initial@
  00044	e8 00 00 00 00	 call	 _warnmes
  00049	83 c4 04	 add	 esp, 4
  0004c	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx

; 976  : }

  00051	c3		 ret	 0
$LN15@tsync_op:

; 872  :       /* if(ts_no==0) release_mutexes();
; 873  :        else init_mutexes();
; 874  :        */
; 875  :       break;
; 876  : 
; 877  :       case 1:
; 878  :       { DWORD code;
; 879  :         if(arg==0) arg=INFINITE;

  00052	8b 44 24 18	 mov	 eax, DWORD PTR _arg$[esp+8]
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN14@tsync_op
  0005a	83 c8 ff	 or	 eax, -1
  0005d	89 44 24 18	 mov	 DWORD PTR _arg$[esp+8], eax
$LN14@tsync_op:

; 880  : 
; 881  : #if TTRACE>0
; 882  :         fprintf(STD_err,"thread waits for: %d\n",ts_no);
; 883  : #endif
; 884  :         code=WaitForSingleObject(ts->mp, arg);

  00061	50		 push	 eax
  00062	8b 03		 mov	 eax, DWORD PTR [ebx]
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 885  :         result=(WAIT_TIMEOUT!=code);

  0006b	33 c9		 xor	 ecx, ecx
  0006d	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00072	0f 95 c1	 setne	 cl
  00075	8b f1		 mov	 esi, ecx
$LN17@tsync_op:

; 961  :     }
; 962  :   }
; 963  : 
; 964  :   /* end else */
; 965  : 
; 966  :   if(result==0)

  00077	85 f6		 test	 esi, esi
  00079	75 1d		 jne	 SHORT $LN1@tsync_op
$LN24@tsync_op:

; 967  :   fprintf(STD_err,"tsync/3 error: op=%d,ts_no=%d,arg=%d\n",i,ts,arg);

  0007b	8b 44 24 18	 mov	 eax, DWORD PTR _arg$[esp+8]
  0007f	50		 push	 eax
  00080	53		 push	 ebx
  00081	57		 push	 edi
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFKDFOIN@tsync?13?5error?3?5op?$DN?$CFd?0ts_no?$DN?$CFd?0ar@
  00087	e8 00 00 00 00	 call	 ___iob_func
  0008c	83 c0 40	 add	 eax, 64			; 00000040H
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _fprintf
  00095	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@tsync_op:

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  00098	5f		 pop	 edi
  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 976  : }

  0009d	c3		 ret	 0
$LN13@tsync_op:

; 886  :         /* EnterCriticalSection(&(ts->mp)); */
; 887  : #if TTRACE>0
; 888  :         fprintf(STD_err,"thread locks: %d\n",ts_no);
; 889  : #endif
; 890  :       }
; 891  :       break;
; 892  : 
; 893  :       case 2:
; 894  : #if TTRACE>0
; 895  :       fprintf(STD_err,"thread: unlocks: %d\n",ts_no);
; 896  : #endif
; 897  :       /* LeaveCriticalSection(&(ts->mp)); */
; 898  :       ReleaseMutex(ts->mp);

  0009e	8b 13		 mov	 edx, DWORD PTR [ebx]
  000a0	52		 push	 edx
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  000a7	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  000a8	8b c6		 mov	 eax, esi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx

; 976  : }

  000ac	c3		 ret	 0
$LN12@tsync_op:

; 899  :       break;
; 900  : 
; 901  :       case 3:
; 902  :       case 4:
; 903  :       case 5:
; 904  :       warnmes("3,4,5 unimplemented");

  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PMHLEONP@3?04?05?5unimplemented?$AA@
  000b2	e8 00 00 00 00	 call	 _warnmes
  000b7	83 c4 04	 add	 esp, 4

; 905  :       result=0;

  000ba	33 f6		 xor	 esi, esi

; 906  :       break;

  000bc	eb bd		 jmp	 SHORT $LN24@tsync_op
$LN11@tsync_op:

; 907  : 
; 908  :       case 6:
; 909  :       if(ts_no==0) {

  000be	85 c0		 test	 eax, eax
  000c0	74 d6		 je	 SHORT $LN1@tsync_op

; 910  :         /* warnmes("request to destroy main thread ignored"); */
; 911  :       }
; 912  :       else
; 913  :       result=thread_destroy(ts_no); /* 1 if ok 0 if fails */

  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _thread_destroy
  000c8	83 c4 04	 add	 esp, 4
  000cb	8b f0		 mov	 esi, eax

; 914  :       break;

  000cd	eb a8		 jmp	 SHORT $LN17@tsync_op
$LN8@tsync_op:

; 915  : 
; 916  :       case 7:
; 917  :       if(ts_no==0)

  000cf	85 c0		 test	 eax, eax
  000d1	75 13		 jne	 SHORT $LN7@tsync_op

; 918  :       warnmes("request to resume main thread ignored");

  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BAODONFH@request?5to?5resume?5main?5thread?5ig@
  000d8	e8 00 00 00 00	 call	 _warnmes
  000dd	83 c4 04	 add	 esp, 4
  000e0	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  000e1	8b c6		 mov	 eax, esi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx

; 976  : }

  000e5	c3		 ret	 0
$LN7@tsync_op:

; 919  :       else
; 920  :       ResumeThread((HANDLE)ts_no);

  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResumeThread@4
  000ed	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  000ee	8b c6		 mov	 eax, esi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx

; 976  : }

  000f2	c3		 ret	 0
$LN5@tsync_op:

; 921  :       break;
; 922  : 
; 923  :       case 8:
; 924  :       if(ts_no==0)

  000f3	85 c0		 test	 eax, eax
  000f5	75 13		 jne	 SHORT $LN4@tsync_op

; 925  :       warnmes("request to suspend main thread ignored");

  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FECBCEOM@request?5to?5suspend?5main?5thread?5i@
  000fc	e8 00 00 00 00	 call	 _warnmes
  00101	83 c4 04	 add	 esp, 4
  00104	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  00105	8b c6		 mov	 eax, esi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx

; 976  : }

  00109	c3		 ret	 0
$LN4@tsync_op:

; 926  :       else
; 927  :       SuspendThread((HANDLE)ts_no);

  0010a	50		 push	 eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SuspendThread@4
  00111	5f		 pop	 edi

; 968  : 
; 969  : #if TTRACE>0
; 970  :   fprintf(STD_err,
; 971  :       "exiting tsync: %d guard?: %d arg: %d returns=> %d\n",
; 972  :       i,ts_no,arg,result);
; 973  : #endif
; 974  : 
; 975  :   return result;

  00112	8b c6		 mov	 eax, esi
  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx

; 976  : }

  00116	c3		 ret	 0
$LN2@tsync_op:

; 928  :       break;
; 929  : 
; 930  :       /*
; 931  :        case 10:
; 932  :        if(ts->done>0) {
; 933  :        warnmes("deleting critical section");
; 934  :        ts->done=0;
; 935  :        DeleteCriticalSection(&(ts->mp));
; 936  :        }
; 937  :        break;
; 938  : 
; 939  :        case 11: {
; 940  :        if(!ts->done) {
; 941  :        ts->done++;
; 942  :        InitializeCriticalSection(&(ts->mp));
; 943  :        }
; 944  :        EnterCriticalSection(&(ts->mp));
; 945  :        }
; 946  :        break;
; 947  : 
; 948  :        case 12:
; 949  :        if(!ts->done) {
; 950  :        warnmes("nonexisting critical section");
; 951  :        }
; 952  :        else {
; 953  :        LeaveCriticalSection(&(ts->mp));
; 954  :        }
; 955  :        break;
; 956  :        */
; 957  : 
; 958  :       default:
; 959  :       fprintf(STD_err,"BAD tsync_op: %d\n",i);

  00117	57		 push	 edi
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PEAOKHBH@BAD?5tsync_op?3?5?$CFd?6?$AA@
  0011d	e8 00 00 00 00	 call	 ___iob_func
  00122	83 c0 40	 add	 eax, 64			; 00000040H
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _fprintf
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 960  :       result=0;

  0012e	33 f6		 xor	 esi, esi

; 961  :     }
; 962  :   }
; 963  : 
; 964  :   /* end else */
; 965  : 
; 966  :   if(result==0)

  00130	e9 46 ff ff ff	 jmp	 $LN24@tsync_op
  00135	8d 49 00	 npad	 3
$LN25@tsync_op:

; 976  : }

  00138	00 00 00 00	 DD	 $LN16@tsync_op
  0013c	00 00 00 00	 DD	 $LN15@tsync_op
  00140	00 00 00 00	 DD	 $LN13@tsync_op
  00144	00 00 00 00	 DD	 $LN12@tsync_op
  00148	00 00 00 00	 DD	 $LN12@tsync_op
  0014c	00 00 00 00	 DD	 $LN12@tsync_op
  00150	00 00 00 00	 DD	 $LN11@tsync_op
  00154	00 00 00 00	 DD	 $LN8@tsync_op
  00158	00 00 00 00	 DD	 $LN5@tsync_op
_tsync_op ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@GIDPBEIK@value?5trailing?$AA@		; `string'
PUBLIC	??_C@_05MHFJMGKG@unify?$AA@			; `string'
PUBLIC	??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@	; `string'
PUBLIC	_unify_to
EXTRN	_overflow_by:PROC
;	COMDAT ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
CONST	SEGMENT
??_C@_0P@GIDPBEIK@value?5trailing?$AA@ DB 'value trailing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MHFJMGKG@unify?$AA@
CONST	SEGMENT
??_C@_05MHFJMGKG@unify?$AA@ DB 'unify', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
CONST	SEGMENT
??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@ DB 'trailing in unify', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _unify_to
_TEXT	SEGMENT
_t2$82826 = -4						; size = 4
_t1$82827 = 8						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_wam$ = 16						; size = 4
_A$ = 20						; size = 4
_unify_to PROC						; COMDAT

; 1352 : {

  00000	51		 push	 ecx

; 1353 :   register term U = (term) A;
; 1354 : 
; 1355 :   PUSH(U,v1);

  00001	8b 44 24 14	 mov	 eax, DWORD PTR _A$[esp]
  00005	8b 4c 24 08	 mov	 ecx, DWORD PTR _v1$[esp]

; 1356 :   PUSH(U,v2); /* push v1 _then_ v2 */

  00009	8b 54 24 0c	 mov	 edx, DWORD PTR _v2$[esp]
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  00013	89 0e		 mov	 DWORD PTR [esi], ecx
  00015	83 c6 04	 add	 esi, 4
  00018	57		 push	 edi
  00019	89 16		 mov	 DWORD PTR [esi], edx

; 1357 : 
; 1358 :   while (NOTEMPTY(U,A)) {

  0001b	3b f0		 cmp	 esi, eax
  0001d	0f 86 e2 01 00
	00		 jbe	 $LN22@unify_to
  00023	8b 7c 24 20	 mov	 edi, DWORD PTR _wam$[esp+16]
$LL23@unify_to:

; 1359 :     register term t2 = U--, t1 = U--; /* pop ref t2 _then_ ref t1 */
; 1360 :     DEREF2(t1,v1);

  00027	8b 5e fc	 mov	 ebx, DWORD PTR [esi-4]
  0002a	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  0002d	8b ee		 mov	 ebp, esi
  0002f	83 ee 08	 sub	 esi, 8
  00032	89 6c 24 10	 mov	 DWORD PTR _t2$82826[esp+20], ebp
  00036	89 4c 24 18	 mov	 DWORD PTR _t1$82827[esp+16], ecx
  0003a	f6 c3 03	 test	 bl, 3
  0003d	75 14		 jne	 SHORT $LN32@unify_to
  0003f	90		 npad	 1
$LL21@unify_to:
  00040	3b cb		 cmp	 ecx, ebx
  00042	74 0f		 je	 SHORT $LN32@unify_to
  00044	89 5c 24 18	 mov	 DWORD PTR _t1$82827[esp+16], ebx
  00048	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0004a	8b 4c 24 18	 mov	 ecx, DWORD PTR _t1$82827[esp+16]
  0004e	f6 c3 03	 test	 bl, 3
  00051	74 ed		 je	 SHORT $LL21@unify_to
$LN32@unify_to:

; 1361 :     DEREF2(t2,v2);

  00053	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00056	89 54 24 1c	 mov	 DWORD PTR _v2$[esp+16], edx
  0005a	f6 c2 03	 test	 dl, 3
  0005d	75 16		 jne	 SHORT $LN18@unify_to
  0005f	90		 npad	 1
$LL19@unify_to:
  00060	3b ea		 cmp	 ebp, edx
  00062	74 0d		 je	 SHORT $LN47@unify_to
  00064	8b ea		 mov	 ebp, edx
  00066	8b 12		 mov	 edx, DWORD PTR [edx]
  00068	89 54 24 1c	 mov	 DWORD PTR _v2$[esp+16], edx
  0006c	f6 c2 03	 test	 dl, 3
  0006f	74 ef		 je	 SHORT $LL19@unify_to
$LN47@unify_to:
  00071	89 6c 24 10	 mov	 DWORD PTR _t2$82826[esp+20], ebp
$LN18@unify_to:

; 1362 :     if (t1 != t2) {

  00075	3b cd		 cmp	 ecx, ebp
  00077	0f 84 7e 01 00
	00		 je	 $LN45@unify_to

; 1363 :       if (VAR(v1)) /* unb. var. v1 */

  0007d	8b c3		 mov	 eax, ebx
  0007f	83 e0 03	 and	 eax, 3
  00082	75 7e		 jne	 SHORT $LN16@unify_to

; 1364 :       {
; 1365 :         if (VAR(v2)) /*unb. var. v2 */

  00084	8b c2		 mov	 eax, edx
  00086	83 e0 03	 and	 eax, 3
  00089	75 38		 jne	 SHORT $LN15@unify_to

; 1366 :         {
; 1367 :           SETCELL(C2T(v2),v1);

  0008b	89 1a		 mov	 DWORD PTR [edx], ebx

; 1368 :           TRAIL_IT(C2T(v2));

  0008d	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00090	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  00093	0f 82 a3 00 00
	00		 jb	 $LN42@unify_to
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  0009e	57		 push	 edi
  0009f	6a 01		 push	 1
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _overflow_by
  000a7	6a 0c		 push	 12			; 0000000cH
  000a9	e8 00 00 00 00	 call	 _bp_halt
  000ae	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000b1	8b 54 24 30	 mov	 edx, DWORD PTR _v2$[esp+36]
  000b5	83 c4 14	 add	 esp, 20			; 00000014H
  000b8	89 10		 mov	 DWORD PTR [eax], edx
  000ba	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  000be	e9 38 01 00 00	 jmp	 $LN45@unify_to
$LN15@unify_to:

; 1369 :         }
; 1370 : else          BIND_IT(C2T(v1),t2,v2)

  000c3	83 f8 03	 cmp	 eax, 3
  000c6	75 0a		 jne	 SHORT $LN26@unify_to
  000c8	f7 c2 00 00 00
	ff		 test	 edx, -16777216		; ff000000H
  000ce	74 02		 je	 SHORT $LN26@unify_to
  000d0	8b d5		 mov	 edx, ebp
$LN26@unify_to:
  000d2	89 13		 mov	 DWORD PTR [ebx], edx
  000d4	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000d7	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  000da	72 18		 jb	 SHORT $LN41@unify_to
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  000e1	57		 push	 edi
  000e2	6a 01		 push	 1
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _overflow_by
  000ea	6a 0c		 push	 12			; 0000000cH
  000ec	e8 00 00 00 00	 call	 _bp_halt
  000f1	83 c4 14	 add	 esp, 20			; 00000014H
$LN41@unify_to:
  000f4	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000f7	89 19		 mov	 DWORD PTR [ecx], ebx
  000f9	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  000fd	e9 f9 00 00 00	 jmp	 $LN45@unify_to
$LN16@unify_to:

; 1371 :         }
; 1372 :         else if(VAR(v2)) /* v1 is NONVAR */

  00102	f6 c2 03	 test	 dl, 3
  00105	75 43		 jne	 SHORT $LN10@unify_to

; 1373 :         BIND_IT((term)v2,t1,v1)

  00107	83 f8 03	 cmp	 eax, 3
  0010a	75 0a		 jne	 SHORT $LN28@unify_to
  0010c	f7 c3 00 00 00
	ff		 test	 ebx, -16777216		; ff000000H
  00112	74 02		 je	 SHORT $LN28@unify_to
  00114	8b d9		 mov	 ebx, ecx
$LN28@unify_to:
  00116	89 1a		 mov	 DWORD PTR [edx], ebx
  00118	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0011b	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  0011e	72 1c		 jb	 SHORT $LN42@unify_to
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00125	57		 push	 edi
  00126	6a 01		 push	 1
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _overflow_by
  0012e	6a 0c		 push	 12			; 0000000cH
  00130	e8 00 00 00 00	 call	 _bp_halt
  00135	8b 54 24 30	 mov	 edx, DWORD PTR _v2$[esp+36]
  00139	83 c4 14	 add	 esp, 20			; 00000014H
$LN42@unify_to:
  0013c	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0013f	89 10		 mov	 DWORD PTR [eax], edx
  00141	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  00145	e9 b1 00 00 00	 jmp	 $LN45@unify_to
$LN10@unify_to:

; 1374 :         else if(v1!=v2) /* both are NONVAR and diff */

  0014a	3b da		 cmp	 ebx, edx
  0014c	0f 85 be 00 00
	00		 jne	 $LN34@unify_to

; 1376 :         else /* NONVAR and equal */
; 1377 :         { register no arity=GETARITY(v1);

  00152	c1 eb 18	 shr	 ebx, 24			; 00000018H

; 1378 : 
; 1379 :           if(IDENTIFIER(v1) && arity)

  00155	83 f8 03	 cmp	 eax, 3
  00158	0f 85 9d 00 00
	00		 jne	 $LN45@unify_to
  0015e	85 db		 test	 ebx, ebx
  00160	0f 84 95 00 00
	00		 je	 $LN45@unify_to

; 1380 :           { /* they have the same FUNCTOR, v1==v2 */
; 1381 :             IF_OVER("unify",(term *)U,ChoiceStk,bp_halt(10));

  00166	3b 77 5c	 cmp	 esi, DWORD PTR [edi+92]
  00169	72 20		 jb	 SHORT $LN43@unify_to
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_05MHFJMGKG@unify?$AA@
  00170	57		 push	 edi
  00171	6a 02		 push	 2
  00173	56		 push	 esi
  00174	e8 00 00 00 00	 call	 _overflow_by
  00179	6a 0a		 push	 10			; 0000000aH
  0017b	e8 00 00 00 00	 call	 _bp_halt
  00180	8b 54 24 30	 mov	 edx, DWORD PTR _v2$[esp+36]
  00184	8b 4c 24 2c	 mov	 ecx, DWORD PTR _t1$82827[esp+36]
  00188	83 c4 14	 add	 esp, 20			; 00000014H
$LN43@unify_to:

; 1382 :             PUSH(U,t1+arity); PUSH(U,t2+arity);

  0018b	8d 04 99	 lea	 eax, DWORD PTR [ecx+ebx*4]
  0018e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00191	83 c6 08	 add	 esi, 8
  00194	8d 44 9d 00	 lea	 eax, DWORD PTR [ebp+ebx*4]

; 1383 :             while(--arity)

  00198	4b		 dec	 ebx
  00199	89 06		 mov	 DWORD PTR [esi], eax
  0019b	74 21		 je	 SHORT $LN44@unify_to
  0019d	8d 44 9d 00	 lea	 eax, DWORD PTR [ebp+ebx*4]
  001a1	2b cd		 sub	 ecx, ebp
$LL3@unify_to:

; 1384 :             {
; 1385 :               PUSH(U,t1[arity]);

  001a3	8b 2c 01	 mov	 ebp, DWORD PTR [ecx+eax]
  001a6	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 1386 :               PUSH(U,t2[arity]);

  001a9	8b 28		 mov	 ebp, DWORD PTR [eax]
  001ab	83 c6 08	 add	 esi, 8
  001ae	83 e8 04	 sub	 eax, 4
  001b1	4b		 dec	 ebx
  001b2	89 2e		 mov	 DWORD PTR [esi], ebp
  001b4	75 ed		 jne	 SHORT $LL3@unify_to

; 1383 :             while(--arity)

  001b6	8b 6c 24 10	 mov	 ebp, DWORD PTR _t2$82826[esp+20]
  001ba	8b 4c 24 18	 mov	 ecx, DWORD PTR _t1$82827[esp+16]
$LN44@unify_to:

; 1387 :             }
; 1388 : #if (/*0 && $$$*/ !defined NO_VALUE_TRAIL)
; 1389 :             /* BUG("unify_to: VTRAIL_IT called"); */
; 1390 :             VTRAIL_IT(t2,v2);

  001be	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001c1	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  001c4	72 20		 jb	 SHORT $LN1@unify_to
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  001cb	57		 push	 edi
  001cc	6a 01		 push	 1
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _overflow_by
  001d4	6a 0e		 push	 14			; 0000000eH
  001d6	e8 00 00 00 00	 call	 _bp_halt
  001db	8b 54 24 30	 mov	 edx, DWORD PTR _v2$[esp+36]
  001df	8b 4c 24 2c	 mov	 ecx, DWORD PTR _t1$82827[esp+36]
  001e3	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@unify_to:
  001e6	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001e9	89 10		 mov	 DWORD PTR [eax], edx
  001eb	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001ee	8d 55 01	 lea	 edx, DWORD PTR [ebp+1]
  001f1	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001f4	83 47 2c 08	 add	 DWORD PTR [edi+44], 8

; 1391 :             SETREF(t2,t1);

  001f8	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$LN45@unify_to:

; 1357 : 
; 1358 :   while (NOTEMPTY(U,A)) {

  001fb	3b 74 24 24	 cmp	 esi, DWORD PTR _A$[esp+16]
  001ff	0f 87 22 fe ff
	ff		 ja	 $LL23@unify_to
$LN22@unify_to:
  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	5d		 pop	 ebp

; 1392 : #endif
; 1393 :           }
; 1394 :         }
; 1395 :       }
; 1396 :     }
; 1397 :     return TRUE;

  00208	b8 01 00 00 00	 mov	 eax, 1
  0020d	5b		 pop	 ebx

; 1398 :   }

  0020e	59		 pop	 ecx
  0020f	c3		 ret	 0
$LN34@unify_to:
  00210	5f		 pop	 edi
  00211	5e		 pop	 esi
  00212	5d		 pop	 ebp

; 1375 :         return FALSE;

  00213	33 c0		 xor	 eax, eax
  00215	5b		 pop	 ebx

; 1398 :   }

  00216	59		 pop	 ecx
  00217	c3		 ret	 0
_unify_to ENDP
_TEXT	ENDS
PUBLIC	_unify
; Function compile flags: /Ogtpy
;	COMDAT _unify
_TEXT	SEGMENT
_t1$83013 = -4						; size = 4
_v1$ = 8						; size = 4
_t2$83012 = 12						; size = 4
_v2$ = 12						; size = 4
_wam$ = 16						; size = 4
_A$ = 20						; size = 4
_unify	PROC						; COMDAT

; 1402 : {

  00000	51		 push	 ecx

; 1403 :   register term U = (term) A;
; 1404 :   /* top of push down list:  therefore the OR-stack should have
; 1405 :    MAXARITY or more left after the margin */
; 1406 : 
; 1407 :   PUSH(U,v1);

  00001	8b 44 24 14	 mov	 eax, DWORD PTR _A$[esp]
  00005	8b 4c 24 08	 mov	 ecx, DWORD PTR _v1$[esp]

; 1408 :   PUSH(U,v2); /* push v1 _then_ v2 */

  00009	8b 54 24 0c	 mov	 edx, DWORD PTR _v2$[esp]
  0000d	53		 push	 ebx
  0000e	55		 push	 ebp
  0000f	8d 68 04	 lea	 ebp, DWORD PTR [eax+4]
  00012	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  00015	83 c5 04	 add	 ebp, 4
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	89 55 00	 mov	 DWORD PTR [ebp], edx

; 1409 : 
; 1410 :   while (NOTEMPTY(U,A)) {

  0001d	3b e8		 cmp	 ebp, eax
  0001f	0f 86 75 02 00
	00		 jbe	 $LN30@unify
  00025	8b 7c 24 20	 mov	 edi, DWORD PTR _wam$[esp+16]
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL31@unify:

; 1411 :     register term t2 = U--, t1 = U--; /* pop ref t2 _then_ ref t1 */
; 1412 :     DEREF2(t1,v1);

  00030	8b 45 fc	 mov	 eax, DWORD PTR [ebp-4]
  00033	8d 4d fc	 lea	 ecx, DWORD PTR [ebp-4]
  00036	8b f5		 mov	 esi, ebp
  00038	83 ed 08	 sub	 ebp, 8
  0003b	89 74 24 1c	 mov	 DWORD PTR _t2$83012[esp+16], esi
  0003f	89 4c 24 10	 mov	 DWORD PTR _t1$83013[esp+20], ecx
  00043	89 44 24 18	 mov	 DWORD PTR _v1$[esp+16], eax
  00047	a8 03		 test	 al, 3
  00049	75 1b		 jne	 SHORT $LN40@unify
  0004b	eb 03 8d 49 00	 npad	 5
$LL29@unify:
  00050	3b c8		 cmp	 ecx, eax
  00052	74 12		 je	 SHORT $LN40@unify
  00054	89 44 24 10	 mov	 DWORD PTR _t1$83013[esp+20], eax
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	8b 4c 24 10	 mov	 ecx, DWORD PTR _t1$83013[esp+20]
  0005e	89 44 24 18	 mov	 DWORD PTR _v1$[esp+16], eax
  00062	a8 03		 test	 al, 3
  00064	74 ea		 je	 SHORT $LL29@unify
$LN40@unify:

; 1413 :     DEREF2(t2,v2);

  00066	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00068	f6 c3 03	 test	 bl, 3
  0006b	75 16		 jne	 SHORT $LN26@unify
  0006d	8d 49 00	 npad	 3
$LL27@unify:
  00070	3b f3		 cmp	 esi, ebx
  00072	74 0f		 je	 SHORT $LN26@unify
  00074	89 5c 24 1c	 mov	 DWORD PTR _t2$83012[esp+16], ebx
  00078	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  0007a	8b 74 24 1c	 mov	 esi, DWORD PTR _t2$83012[esp+16]
  0007e	f6 c3 03	 test	 bl, 3
  00081	74 ed		 je	 SHORT $LL27@unify
$LN26@unify:

; 1414 :     if (t1 != t2) {

  00083	3b ce		 cmp	 ecx, esi
  00085	0f 84 05 02 00
	00		 je	 $LN50@unify

; 1415 :       if (VAR(v1)) /* unb. var. v1 */

  0008b	8b d0		 mov	 edx, eax
  0008d	83 e2 03	 and	 edx, 3
  00090	0f 85 98 00 00
	00		 jne	 $LN24@unify

; 1416 :       {
; 1417 :         if (VAR(v2) && v2 > v1) /*unb. var. v2 */

  00096	8b cb		 mov	 ecx, ebx
  00098	83 e1 03	 and	 ecx, 3
  0009b	75 41		 jne	 SHORT $LN23@unify
  0009d	3b d8		 cmp	 ebx, eax
  0009f	76 3d		 jbe	 SHORT $LN23@unify

; 1418 :         {
; 1419 :           SETCELL(C2T(v2),v1);

  000a1	89 03		 mov	 DWORD PTR [ebx], eax

; 1420 :           TRAIL_IF(C2T(v2));

  000a3	8b 44 24 24	 mov	 eax, DWORD PTR _A$[esp+16]
  000a7	3b 58 f8	 cmp	 ebx, DWORD PTR [eax-8]
  000aa	0f 83 e0 01 00
	00		 jae	 $LN50@unify
  000b0	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000b3	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  000b6	72 18		 jb	 SHORT $LN21@unify
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  000bd	57		 push	 edi
  000be	6a 01		 push	 1
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _overflow_by
  000c6	6a 0c		 push	 12			; 0000000cH
  000c8	e8 00 00 00 00	 call	 _bp_halt
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@unify:
  000d0	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000d3	89 19		 mov	 DWORD PTR [ecx], ebx
  000d5	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  000d9	e9 b2 01 00 00	 jmp	 $LN50@unify
$LN23@unify:

; 1421 :         }
; 1422 : else          BIND(C2T(v1),t2,v2)

  000de	83 f9 03	 cmp	 ecx, 3
  000e1	75 0a		 jne	 SHORT $LN34@unify
  000e3	f7 c3 00 00 00
	ff		 test	 ebx, -16777216		; ff000000H
  000e9	74 02		 je	 SHORT $LN34@unify
  000eb	8b de		 mov	 ebx, esi
$LN34@unify:
  000ed	8b 54 24 24	 mov	 edx, DWORD PTR _A$[esp+16]
  000f1	89 18		 mov	 DWORD PTR [eax], ebx
  000f3	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  000f6	0f 83 94 01 00
	00		 jae	 $LN50@unify
  000fc	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  000ff	3b 4f 38	 cmp	 ecx, DWORD PTR [edi+56]
  00102	72 1c		 jb	 SHORT $LN18@unify
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00109	57		 push	 edi
  0010a	6a 01		 push	 1
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _overflow_by
  00112	6a 0c		 push	 12			; 0000000cH
  00114	e8 00 00 00 00	 call	 _bp_halt
  00119	8b 44 24 2c	 mov	 eax, DWORD PTR _v1$[esp+36]
  0011d	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@unify:
  00120	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00123	89 01		 mov	 DWORD PTR [ecx], eax
  00125	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  00129	e9 62 01 00 00	 jmp	 $LN50@unify
$LN24@unify:

; 1423 :         }
; 1424 :         else if(VAR(v2)) /* v1 is NONVAR */

  0012e	f6 c3 03	 test	 bl, 3
  00131	75 4b		 jne	 SHORT $LN16@unify

; 1425 :         BIND((term)v2,t1,v1)

  00133	83 fa 03	 cmp	 edx, 3
  00136	75 09		 jne	 SHORT $LN36@unify
  00138	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0013d	74 02		 je	 SHORT $LN36@unify
  0013f	8b c1		 mov	 eax, ecx
$LN36@unify:
  00141	8b 54 24 24	 mov	 edx, DWORD PTR _A$[esp+16]
  00145	89 03		 mov	 DWORD PTR [ebx], eax
  00147	3b 5a f8	 cmp	 ebx, DWORD PTR [edx-8]
  0014a	0f 83 40 01 00
	00		 jae	 $LN50@unify
  00150	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00153	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  00156	72 18		 jb	 SHORT $LN14@unify
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  0015d	57		 push	 edi
  0015e	6a 01		 push	 1
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _overflow_by
  00166	6a 0c		 push	 12			; 0000000cH
  00168	e8 00 00 00 00	 call	 _bp_halt
  0016d	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@unify:
  00170	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00173	89 18		 mov	 DWORD PTR [eax], ebx
  00175	83 47 2c 04	 add	 DWORD PTR [edi+44], 4
  00179	e9 12 01 00 00	 jmp	 $LN50@unify
$LN16@unify:

; 1426 :         else if(v1!=v2) /* both are NONVAR */

  0017e	3b c3		 cmp	 eax, ebx
  00180	0f 85 1f 01 00
	00		 jne	 $LN42@unify

; 1428 :         else
; 1429 :         { register no arity=GETARITY(v1);

  00186	8b f0		 mov	 esi, eax
  00188	c1 ee 18	 shr	 esi, 24			; 00000018H

; 1430 :           if(IDENTIFIER(v1) && arity)

  0018b	83 fa 03	 cmp	 edx, 3
  0018e	0f 85 fc 00 00
	00		 jne	 $LN50@unify
  00194	85 f6		 test	 esi, esi
  00196	0f 84 f4 00 00
	00		 je	 $LN50@unify

; 1431 :           { /* they have the same FUNCTOR, v1==v2 */
; 1432 :             IF_OVER("unify",(term *)U,ChoiceStk,bp_halt(10));

  0019c	3b 6f 5c	 cmp	 ebp, DWORD PTR [edi+92]
  0019f	72 20		 jb	 SHORT $LN48@unify
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_05MHFJMGKG@unify?$AA@
  001a6	57		 push	 edi
  001a7	6a 02		 push	 2
  001a9	55		 push	 ebp
  001aa	e8 00 00 00 00	 call	 _overflow_by
  001af	6a 0a		 push	 10			; 0000000aH
  001b1	e8 00 00 00 00	 call	 _bp_halt
  001b6	8b 4c 24 24	 mov	 ecx, DWORD PTR _t1$83013[esp+40]
  001ba	8b 44 24 2c	 mov	 eax, DWORD PTR _v1$[esp+36]
  001be	83 c4 14	 add	 esp, 20			; 00000014H
$LN48@unify:

; 1433 :             PUSH(U,t1+arity); PUSH(U,t2+arity);

  001c1	8d 14 b1	 lea	 edx, DWORD PTR [ecx+esi*4]
  001c4	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  001c7	8b 54 24 1c	 mov	 edx, DWORD PTR _t2$83012[esp+16]
  001cb	83 c5 08	 add	 ebp, 8
  001ce	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]

; 1434 :             while(--arity)

  001d1	4e		 dec	 esi
  001d2	89 55 00	 mov	 DWORD PTR [ebp], edx
  001d5	74 25		 je	 SHORT $LN49@unify

; 1433 :             PUSH(U,t1+arity); PUSH(U,t2+arity);

  001d7	8b 54 24 1c	 mov	 edx, DWORD PTR _t2$83012[esp+16]
  001db	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]

; 1434 :             while(--arity)

  001de	2b ca		 sub	 ecx, edx
$LL8@unify:

; 1435 :             {
; 1436 :               PUSH(U,t1[arity]);

  001e0	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  001e3	89 55 04	 mov	 DWORD PTR [ebp+4], edx

; 1437 :               PUSH(U,t2[arity]);

  001e6	8b 10		 mov	 edx, DWORD PTR [eax]
  001e8	83 c5 08	 add	 ebp, 8
  001eb	83 e8 04	 sub	 eax, 4
  001ee	4e		 dec	 esi
  001ef	89 55 00	 mov	 DWORD PTR [ebp], edx
  001f2	75 ec		 jne	 SHORT $LL8@unify

; 1434 :             while(--arity)

  001f4	8b 4c 24 10	 mov	 ecx, DWORD PTR _t1$83013[esp+20]
  001f8	8b 44 24 18	 mov	 eax, DWORD PTR _v1$[esp+16]
$LN49@unify:
  001fc	8b 74 24 1c	 mov	 esi, DWORD PTR _t2$83012[esp+16]

; 1438 :             }
; 1439 : #if (!defined NO_VALUE_TRAIL)
; 1440 :             /* BUG("unify: VTRAIL_IF called - only if not in same segment"); */
; 1441 :             if(t2>t1)

  00200	3b f1		 cmp	 esi, ecx
  00202	76 43		 jbe	 SHORT $LN6@unify

; 1442 :             {
; 1443 :               VTRAIL_IF(t2,v2);

  00204	8b 44 24 24	 mov	 eax, DWORD PTR _A$[esp+16]
  00208	3b 70 f8	 cmp	 esi, DWORD PTR [eax-8]
  0020b	73 36		 jae	 SHORT $LN5@unify
  0020d	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00210	3b 47 38	 cmp	 eax, DWORD PTR [edi+56]
  00213	72 1c		 jb	 SHORT $LN4@unify
  00215	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  0021a	57		 push	 edi
  0021b	6a 01		 push	 1
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _overflow_by
  00223	6a 0e		 push	 14			; 0000000eH
  00225	e8 00 00 00 00	 call	 _bp_halt
  0022a	8b 4c 24 24	 mov	 ecx, DWORD PTR _t1$83013[esp+40]
  0022e	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@unify:
  00231	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00234	89 1a		 mov	 DWORD PTR [edx], ebx
  00236	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00239	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0023c	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0023f	83 47 2c 08	 add	 DWORD PTR [edi+44], 8
$LN5@unify:

; 1444 :               SETREF(t2,t1);

  00243	89 0e		 mov	 DWORD PTR [esi], ecx

; 1445 :             }
; 1446 :             else

  00245	eb 49		 jmp	 SHORT $LN50@unify
$LN6@unify:

; 1447 :             {
; 1448 :               VTRAIL_IF(t1,v1);

  00247	8b 54 24 24	 mov	 edx, DWORD PTR _A$[esp+16]
  0024b	3b 4a f8	 cmp	 ecx, DWORD PTR [edx-8]
  0024e	73 3e		 jae	 SHORT $LN2@unify
  00250	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00253	3b 57 38	 cmp	 edx, DWORD PTR [edi+56]
  00256	72 24		 jb	 SHORT $LN1@unify
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  0025d	57		 push	 edi
  0025e	6a 01		 push	 1
  00260	52		 push	 edx
  00261	e8 00 00 00 00	 call	 _overflow_by
  00266	6a 0e		 push	 14			; 0000000eH
  00268	e8 00 00 00 00	 call	 _bp_halt
  0026d	8b 4c 24 24	 mov	 ecx, DWORD PTR _t1$83013[esp+40]
  00271	8b 74 24 30	 mov	 esi, DWORD PTR _t2$83012[esp+36]
  00275	8b 44 24 2c	 mov	 eax, DWORD PTR _v1$[esp+36]
  00279	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@unify:
  0027c	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0027f	89 02		 mov	 DWORD PTR [edx], eax
  00281	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  00284	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00287	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0028a	83 47 2c 08	 add	 DWORD PTR [edi+44], 8
$LN2@unify:

; 1449 :               SETREF(t1,t2);

  0028e	89 31		 mov	 DWORD PTR [ecx], esi
$LN50@unify:

; 1409 : 
; 1410 :   while (NOTEMPTY(U,A)) {

  00290	3b 6c 24 24	 cmp	 ebp, DWORD PTR _A$[esp+16]
  00294	0f 87 96 fd ff
	ff		 ja	 $LL31@unify
$LN30@unify:
  0029a	5f		 pop	 edi
  0029b	5e		 pop	 esi
  0029c	5d		 pop	 ebp

; 1450 :             }
; 1451 : #endif
; 1452 :           }
; 1453 :         }
; 1454 :       }
; 1455 :     }
; 1456 :     return TRUE;

  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	5b		 pop	 ebx

; 1457 :   }

  002a3	59		 pop	 ecx
  002a4	c3		 ret	 0
$LN42@unify:
  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
  002a7	5d		 pop	 ebp

; 1427 :         return FALSE;

  002a8	33 c0		 xor	 eax, eax
  002aa	5b		 pop	 ebx

; 1457 :   }

  002ab	59		 pop	 ecx
  002ac	c3		 ret	 0
_unify	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@LGCBDFFN@fcall?13?5builtin?5not?5implemented?$AA@ ; `string'
PUBLIC	??_C@_0CK@MIJFHGF@fatal?5error?5string2list?5in?5SOCK_@ ; `string'
PUBLIC	??_C@_0CI@EPDMONLP@arg?51?5of?5untrail_to?11?5should?5be?5@ ; `string'
PUBLIC	??_C@_0CJ@KMFIFFAF@bad?5args?5in?5get_engine_prop?$CINo?0A@ ; `string'
PUBLIC	??_C@_0BI@BCNJLFIO@error?5in?5list_engines?11?$AA@ ; `string'
PUBLIC	??_C@_0BI@EOKIIOGO@bad?5input?5in?5tsync_op?13?$AA@ ; `string'
PUBLIC	??_C@_0BD@CKAJPEJ@ARGS?3?5?$CFld?5?$CFld?5?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KFOMLNGG@error?5in?5tsync_op?13?$AA@	; `string'
PUBLIC	??_C@_0CG@IAJGJMEG@integer?5arg?5expected?5in?5join_thr@ ; `string'
PUBLIC	??_C@_0BL@OAGLCGIM@bad?5engine?5in?5ask_thread?12?$AA@ ; `string'
PUBLIC	??_C@_0BL@OFHHPKJP@bad?5engine?5in?5ask_engine?12?$AA@ ; `string'
PUBLIC	??_C@_0BE@FLBCDNAM@error?5in?5unix_pid?11?$AA@	; `string'
PUBLIC	??_C@_0BF@PAIJDAHP@error?5in?5unix_fork?11?$AA@	; `string'
PUBLIC	??_C@_0BD@NKGLIFDI@error?5in?5bb_list?12?$AA@	; `string'
PUBLIC	??_C@_0BN@OPJCLFFO@heap_overflow?5in?5copy_term?12?$AA@ ; `string'
PUBLIC	??_C@_0O@KIFKLKPM@bad?5string?5op?$AA@		; `string'
PUBLIC	??_C@_0BP@PLMPOGIE@fatal?5error?5in?5STRING_OP?$CI4?0?4?4?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CA@GOIADPDP@fatal?5error?5in?5STRING_OP?$CI3?0?4?4?4?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CA@MIPHDEIL@fatal?5error?5in?5STRING_OP?$CI2?0?4?4?4?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CA@LNHJFFBE@old?5sread?5not?5supported?5anymore?$AA@ ; `string'
PUBLIC	??_C@_0BC@JLMAFMNA@unexpected?5NONDET?$AA@	; `string'
PUBLIC	??_C@_0BH@DPJLIEHM@unexpected?5TRY_ME_ONLY?$AA@	; `string'
PUBLIC	??_C@_0M@IIDJDDPG@TRY_ME_ELSE?$AA@		; `string'
PUBLIC	??_C@_0BJ@LAEMLNBC@unexpected?5push_variable?$AA@ ; `string'
PUBLIC	??_C@_0CF@NHKCDLMJ@END_C_CHUNK?5should?5never?5be?5exec@ ; `string'
PUBLIC	??_C@_0BL@IHOLGNBJ@bad?5first?5arg?5in?5host2ip?12?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DCEPMJDH@bad?5first?5arg?5in?5sleep?11?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BOCIIDNN@bad?5arg?52?5in?5sock2file?12?$AA@ ; `string'
PUBLIC	??_C@_0BN@MECHBFDI@bad?5first?5arg?5in?5sock2file?12?$AA@ ; `string'
PUBLIC	??_C@_0BN@NAHFBO@bad?5first?5arg?5in?5file2sock?12?$AA@ ; `string'
PUBLIC	??_C@_0CH@GICKHGDB@bad?5non?9list?5arg?52?5in?5sock_write@ ; `string'
PUBLIC	??_C@_0CF@MOPLBJIL@unexpected?5arg?52?5in?5sock_write?$CIl@ ; `string'
PUBLIC	??_C@_0CP@EHMGJDOH@integer?5first?5arg?5expected?5in?5so@ ; `string'
PUBLIC	??_C@_0CO@GPDIIDMM@integer?53?9rd?5arg?5expected?5in?5soc@ ; `string'
PUBLIC	??_C@_0CB@DAMPPDMM@bad?5first?5arg?5in?5sock_read?$CIln?$CJ?12@ ; `string'
PUBLIC	??_C@_0CA@OFDIOJI@bad?5first?5arg?5in?5close_socket?11?$AA@ ; `string'
PUBLIC	??_C@_0BN@PCKHPNLL@bad?5first?5arg?5in?5peer_port?12?$AA@ ; `string'
PUBLIC	??_C@_0BN@JDACKHPM@bad?5first?5arg?5in?5peer_addr?12?$AA@ ; `string'
PUBLIC	??_C@_0CA@MGACNCEH@bad?5second?5arg?5in?5new_service?13?$AA@ ; `string'
PUBLIC	??_C@_0BP@NHBDMAFI@bad?5first?5arg?5in?5new_service?13?$AA@ ; `string'
PUBLIC	??_C@_0BO@OPGGOAG@bad?5first?5arg?5in?5new_server?12?$AA@ ; `string'
PUBLIC	??_C@_0CH@JLKFDJNK@bad?5host?5name?5in?5arg?51?5of?5new_se@ ; `string'
PUBLIC	??_C@_0BP@GFLJDAK@bad?5second?5arg?5in?5new_client?13?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GFDHHNNK@bad?5first?5arg?5in?5fsize?11?$AA@ ; `string'
PUBLIC	??_C@_0BK@MINACFOE@bad?5first?5arg?5in?5fflush?11?$AA@ ; `string'
PUBLIC	??_C@_0CD@GOEKJLMG@byte?5in?50?4?4255?5expected?5in?5fputc@ ; `string'
PUBLIC	??_C@_0BG@DEMKKJAC@file?5error?5in?5fputc?11?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JBLNBHNJ@bad?5first?5arg?5in?5fputc?12?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DABCLHAC@bad?5first?5arg?5in?5fgetc?12?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NKGJFKHF@bad?5data?5or?5heap_overflow?5in?5cde@ ; `string'
PUBLIC	??_C@_0CM@NBICNKMK@bad?5data?5or?5heap_overflow?5in?5cme@ ; `string'
PUBLIC	??_C@_0DM@EAAFBHNF@large?5or?5cyclic?51st?5arg?5in?5deep_@ ; `string'
PUBLIC	??_C@_0CK@IANFFGNM@deep_hash?8s?53nd?5arg?5?$CImod?$CJ?5must?5b@ ; `string'
PUBLIC	??_C@_0DB@KKPNJCHL@deep_hash?8s?52nd?5arg?5?$CIrec?4?5level?$CJ@ ; `string'
PUBLIC	??_C@_0CE@DEDAKFBO@arg?13?8s?51st?5arg?5must?5be?5in?51?4?4ar@ ; `string'
PUBLIC	??_C@_0BP@PIJIHPDP@arg?13?8s?52nd?5arg?5must?5be?5nonvar?$AA@ ; `string'
PUBLIC	??_C@_0CA@NFCHOHFJ@arg?13?8s?51st?5arg?5must?5be?5integer?$AA@ ; `string'
PUBLIC	??_C@_0BK@DGBBHJGD@integer?5expected?5in?5put?11?$AA@ ; `string'
PUBLIC	??_C@_0N@EDEAEALJ@divided?5by?50?$AA@		; `string'
PUBLIC	??_C@_0O@CBEJIEKE@mod?50?5invalid?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	_H$GSCopy$
PUBLIC	_wam$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_if0:PROC
EXTRN	_for_entry:PROC
EXTRN	_member_entry:PROC
EXTRN	_bb_reset:PROC
EXTRN	_stats0:PROC
EXTRN	_load_1:PROC
EXTRN	_name2list:PROC
EXTRN	_functor:PROC
EXTRN	_new_builtin:PROC
EXTRN	_term_store_op:PROC
EXTRN	_qprint:PROC
EXTRN	_host2ip:PROC
EXTRN	_unix_sleep:PROC
EXTRN	_sock2file:PROC
EXTRN	_file2sock:PROC
EXTRN	_sock_writeln:PROC
EXTRN	_sock_write:PROC
EXTRN	_string2list_with_length:PROC
EXTRN	_sock_readln:PROC
EXTRN	_sock_read:PROC
EXTRN	_close_socket:PROC
EXTRN	_peer_port:PROC
EXTRN	_new_func:PROC
EXTRN	_peer_addr:PROC
EXTRN	_new_service:PROC
EXTRN	_new_server:PROC
EXTRN	_new_client:PROC
EXTRN	_atomtable:DWORD
EXTRN	_new_name:PROC
EXTRN	_system0:PROC
EXTRN	_fsize:PROC
EXTRN	_close_stream:PROC
EXTRN	_open_stream:PROC
EXTRN	_cdel_scan:PROC
EXTRN	_cmember_scan:PROC
EXTRN	_member_scan:PROC
EXTRN	_override:PROC
EXTRN	_get_engine_prop:PROC
EXTRN	_list_engines:PROC
EXTRN	_destroy_engine:PROC
EXTRN	_create_engine:PROC
EXTRN	_unix_kill:PROC
EXTRN	_unix_pid:PROC
EXTRN	_unix_fork:PROC
EXTRN	_unix_cd:PROC
EXTRN	_unix_access:PROC
EXTRN	_unix_getenv:PROC
EXTRN	_unix_argv:PROC
EXTRN	_hlist:PROC
EXTRN	_input_float:PROC
EXTRN	_float_fun2:PROC
EXTRN	_float_fun:PROC
EXTRN	_dcg_tell:PROC
EXTRN	_strip_cont0:PROC
EXTRN	_term_append:PROC
EXTRN	_copy_term:PROC
EXTRN	_det_append0:PROC
EXTRN	_op0:PROC
EXTRN	_list2buf:PROC
EXTRN	_qsout:PROC
EXTRN	_string2list:PROC
EXTRN	_sout:PROC
EXTRN	_seeing_telling_at:PROC
EXTRN	_see_tell_at:PROC
EXTRN	_see_tell:PROC
EXTRN	_older_file:PROC
EXTRN	_add_instr:PROC
EXTRN	_call_external:PROC
EXTRN	_term2list:PROC
EXTRN	_list2term:PROC
EXTRN	_dcg_connect:PROC
EXTRN	_popq0:PROC
EXTRN	_pushq0:PROC
EXTRN	_addq0:PROC
EXTRN	_free:PROC
EXTRN	_make_var_array:PROC
EXTRN	_untval:PROC
EXTRN	_array_ref:PROC
EXTRN	_get_asserted:PROC
EXTRN	_tlet:PROC
EXTRN	_tval:PROC
EXTRN	_deep_hash:PROC
EXTRN	_namecat:PROC
EXTRN	_symcat:PROC
EXTRN	_lval:PROC
EXTRN	_set:PROC
EXTRN	_def:PROC
EXTRN	_change_arg:PROC
EXTRN	_setarg:PROC
EXTRN	_compare:PROC
EXTRN	_putc:PROC
EXTRN	_getc:PROC
EXTRN	_clearerr:PROC
EXTRN	_feof:PROC
EXTRN	_rand:PROC
EXTRN	_float_op:PROC
EXTRN	_fflush:PROC
EXTRN	_fout:PROC
EXTRN	_apply:PROC
EXTRN	_trigger_gc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0CA@LGCBDFFN@fcall?13?5builtin?5not?5implemented?$AA@
CONST	SEGMENT
??_C@_0CA@LGCBDFFN@fcall?13?5builtin?5not?5implemented?$AA@ DB 'fcall/3 b'
	DB	'uiltin not implemented', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MIJFHGF@fatal?5error?5string2list?5in?5SOCK_@
CONST	SEGMENT
??_C@_0CK@MIJFHGF@fatal?5error?5string2list?5in?5SOCK_@ DB 'fatal error s'
	DB	'tring2list in SOCK_READ(...)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EPDMONLP@arg?51?5of?5untrail_to?11?5should?5be?5@
CONST	SEGMENT
??_C@_0CI@EPDMONLP@arg?51?5of?5untrail_to?11?5should?5be?5@ DB 'arg 1 of '
	DB	'untrail_to/1 should be integer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KMFIFFAF@bad?5args?5in?5get_engine_prop?$CINo?0A@
CONST	SEGMENT
??_C@_0CJ@KMFIFFAF@bad?5args?5in?5get_engine_prop?$CINo?0A@ DB 'bad args '
	DB	'in get_engine_prop(No,Attr,Val)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BCNJLFIO@error?5in?5list_engines?11?$AA@
CONST	SEGMENT
??_C@_0BI@BCNJLFIO@error?5in?5list_engines?11?$AA@ DB 'error in list_engi'
	DB	'nes/1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EOKIIOGO@bad?5input?5in?5tsync_op?13?$AA@
CONST	SEGMENT
??_C@_0BI@EOKIIOGO@bad?5input?5in?5tsync_op?13?$AA@ DB 'bad input in tsyn'
	DB	'c_op/3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKAJPEJ@ARGS?3?5?$CFld?5?$CFld?5?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BD@CKAJPEJ@ARGS?3?5?$CFld?5?$CFld?5?$CFld?6?$AA@ DB 'ARGS: %ld %ld'
	DB	' %ld', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KFOMLNGG@error?5in?5tsync_op?13?$AA@
CONST	SEGMENT
??_C@_0BE@KFOMLNGG@error?5in?5tsync_op?13?$AA@ DB 'error in tsync_op/3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IAJGJMEG@integer?5arg?5expected?5in?5join_thr@
CONST	SEGMENT
??_C@_0CG@IAJGJMEG@integer?5arg?5expected?5in?5join_thr@ DB 'integer arg '
	DB	'expected in join_thread/1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OAGLCGIM@bad?5engine?5in?5ask_thread?12?$AA@
CONST	SEGMENT
??_C@_0BL@OAGLCGIM@bad?5engine?5in?5ask_thread?12?$AA@ DB 'bad engine in '
	DB	'ask_thread/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OFHHPKJP@bad?5engine?5in?5ask_engine?12?$AA@
CONST	SEGMENT
??_C@_0BL@OFHHPKJP@bad?5engine?5in?5ask_engine?12?$AA@ DB 'bad engine in '
	DB	'ask_engine/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FLBCDNAM@error?5in?5unix_pid?11?$AA@
CONST	SEGMENT
??_C@_0BE@FLBCDNAM@error?5in?5unix_pid?11?$AA@ DB 'error in unix_pid/1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PAIJDAHP@error?5in?5unix_fork?11?$AA@
CONST	SEGMENT
??_C@_0BF@PAIJDAHP@error?5in?5unix_fork?11?$AA@ DB 'error in unix_fork/1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKGLIFDI@error?5in?5bb_list?12?$AA@
CONST	SEGMENT
??_C@_0BD@NKGLIFDI@error?5in?5bb_list?12?$AA@ DB 'error in bb_list/2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OPJCLFFO@heap_overflow?5in?5copy_term?12?$AA@
CONST	SEGMENT
??_C@_0BN@OPJCLFFO@heap_overflow?5in?5copy_term?12?$AA@ DB 'heap_overflow'
	DB	' in copy_term/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KIFKLKPM@bad?5string?5op?$AA@
CONST	SEGMENT
??_C@_0O@KIFKLKPM@bad?5string?5op?$AA@ DB 'bad string op', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PLMPOGIE@fatal?5error?5in?5STRING_OP?$CI4?0?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@PLMPOGIE@fatal?5error?5in?5STRING_OP?$CI4?0?4?4?$CJ?$AA@ DB 'fa'
	DB	'tal error in STRING_OP(4,..)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GOIADPDP@fatal?5error?5in?5STRING_OP?$CI3?0?4?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@GOIADPDP@fatal?5error?5in?5STRING_OP?$CI3?0?4?4?4?$CJ?$AA@ DB 'f'
	DB	'atal error in STRING_OP(3,...)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MIPHDEIL@fatal?5error?5in?5STRING_OP?$CI2?0?4?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@MIPHDEIL@fatal?5error?5in?5STRING_OP?$CI2?0?4?4?4?$CJ?$AA@ DB 'f'
	DB	'atal error in STRING_OP(2,...)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LNHJFFBE@old?5sread?5not?5supported?5anymore?$AA@
CONST	SEGMENT
??_C@_0CA@LNHJFFBE@old?5sread?5not?5supported?5anymore?$AA@ DB 'old sread'
	DB	' not supported anymore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JLMAFMNA@unexpected?5NONDET?$AA@
CONST	SEGMENT
??_C@_0BC@JLMAFMNA@unexpected?5NONDET?$AA@ DB 'unexpected NONDET', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPJLIEHM@unexpected?5TRY_ME_ONLY?$AA@
CONST	SEGMENT
??_C@_0BH@DPJLIEHM@unexpected?5TRY_ME_ONLY?$AA@ DB 'unexpected TRY_ME_ONL'
	DB	'Y', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIDJDDPG@TRY_ME_ELSE?$AA@
CONST	SEGMENT
??_C@_0M@IIDJDDPG@TRY_ME_ELSE?$AA@ DB 'TRY_ME_ELSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LAEMLNBC@unexpected?5push_variable?$AA@
CONST	SEGMENT
??_C@_0BJ@LAEMLNBC@unexpected?5push_variable?$AA@ DB 'unexpected push_var'
	DB	'iable', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NHKCDLMJ@END_C_CHUNK?5should?5never?5be?5exec@
CONST	SEGMENT
??_C@_0CF@NHKCDLMJ@END_C_CHUNK?5should?5never?5be?5exec@ DB 'END_C_CHUNK '
	DB	'should never be executed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHOLGNBJ@bad?5first?5arg?5in?5host2ip?12?$AA@
CONST	SEGMENT
??_C@_0BL@IHOLGNBJ@bad?5first?5arg?5in?5host2ip?12?$AA@ DB 'bad first arg'
	DB	' in host2ip/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DCEPMJDH@bad?5first?5arg?5in?5sleep?11?$AA@
CONST	SEGMENT
??_C@_0BJ@DCEPMJDH@bad?5first?5arg?5in?5sleep?11?$AA@ DB 'bad first arg i'
	DB	'n sleep/1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BOCIIDNN@bad?5arg?52?5in?5sock2file?12?$AA@
CONST	SEGMENT
??_C@_0BJ@BOCIIDNN@bad?5arg?52?5in?5sock2file?12?$AA@ DB 'bad arg 2 in so'
	DB	'ck2file/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MECHBFDI@bad?5first?5arg?5in?5sock2file?12?$AA@
CONST	SEGMENT
??_C@_0BN@MECHBFDI@bad?5first?5arg?5in?5sock2file?12?$AA@ DB 'bad first a'
	DB	'rg in sock2file/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NAHFBO@bad?5first?5arg?5in?5file2sock?12?$AA@
CONST	SEGMENT
??_C@_0BN@NAHFBO@bad?5first?5arg?5in?5file2sock?12?$AA@ DB 'bad first arg'
	DB	' in file2sock/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GICKHGDB@bad?5non?9list?5arg?52?5in?5sock_write@
CONST	SEGMENT
??_C@_0CH@GICKHGDB@bad?5non?9list?5arg?52?5in?5sock_write@ DB 'bad non-li'
	DB	'st arg 2 in sock_write(ln)/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MOPLBJIL@unexpected?5arg?52?5in?5sock_write?$CIl@
CONST	SEGMENT
??_C@_0CF@MOPLBJIL@unexpected?5arg?52?5in?5sock_write?$CIl@ DB 'unexpecte'
	DB	'd arg 2 in sock_write(ln)/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EHMGJDOH@integer?5first?5arg?5expected?5in?5so@
CONST	SEGMENT
??_C@_0CP@EHMGJDOH@integer?5first?5arg?5expected?5in?5so@ DB 'integer fir'
	DB	'st arg expected in sock_write(ln)/2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GPDIIDMM@integer?53?9rd?5arg?5expected?5in?5soc@
CONST	SEGMENT
??_C@_0CO@GPDIIDMM@integer?53?9rd?5arg?5expected?5in?5soc@ DB 'integer 3-'
	DB	'rd arg expected in sock_write(ln)/2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DAMPPDMM@bad?5first?5arg?5in?5sock_read?$CIln?$CJ?12@
CONST	SEGMENT
??_C@_0CB@DAMPPDMM@bad?5first?5arg?5in?5sock_read?$CIln?$CJ?12@ DB 'bad f'
	DB	'irst arg in sock_read(ln)/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFDIOJI@bad?5first?5arg?5in?5close_socket?11?$AA@
CONST	SEGMENT
??_C@_0CA@OFDIOJI@bad?5first?5arg?5in?5close_socket?11?$AA@ DB 'bad first'
	DB	' arg in close_socket/1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PCKHPNLL@bad?5first?5arg?5in?5peer_port?12?$AA@
CONST	SEGMENT
??_C@_0BN@PCKHPNLL@bad?5first?5arg?5in?5peer_port?12?$AA@ DB 'bad first a'
	DB	'rg in peer_port/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JDACKHPM@bad?5first?5arg?5in?5peer_addr?12?$AA@
CONST	SEGMENT
??_C@_0BN@JDACKHPM@bad?5first?5arg?5in?5peer_addr?12?$AA@ DB 'bad first a'
	DB	'rg in peer_addr/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MGACNCEH@bad?5second?5arg?5in?5new_service?13?$AA@
CONST	SEGMENT
??_C@_0CA@MGACNCEH@bad?5second?5arg?5in?5new_service?13?$AA@ DB 'bad seco'
	DB	'nd arg in new_service/3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NHBDMAFI@bad?5first?5arg?5in?5new_service?13?$AA@
CONST	SEGMENT
??_C@_0BP@NHBDMAFI@bad?5first?5arg?5in?5new_service?13?$AA@ DB 'bad first'
	DB	' arg in new_service/3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OPGGOAG@bad?5first?5arg?5in?5new_server?12?$AA@
CONST	SEGMENT
??_C@_0BO@OPGGOAG@bad?5first?5arg?5in?5new_server?12?$AA@ DB 'bad first a'
	DB	'rg in new_server/2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JLKFDJNK@bad?5host?5name?5in?5arg?51?5of?5new_se@
CONST	SEGMENT
??_C@_0CH@JLKFDJNK@bad?5host?5name?5in?5arg?51?5of?5new_se@ DB 'bad host '
	DB	'name in arg 1 of new_server/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GFLJDAK@bad?5second?5arg?5in?5new_client?13?$AA@
CONST	SEGMENT
??_C@_0BP@GFLJDAK@bad?5second?5arg?5in?5new_client?13?$AA@ DB 'bad second'
	DB	' arg in new_client/3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GFDHHNNK@bad?5first?5arg?5in?5fsize?11?$AA@
CONST	SEGMENT
??_C@_0BJ@GFDHHNNK@bad?5first?5arg?5in?5fsize?11?$AA@ DB 'bad first arg i'
	DB	'n fsize/1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MINACFOE@bad?5first?5arg?5in?5fflush?11?$AA@
CONST	SEGMENT
??_C@_0BK@MINACFOE@bad?5first?5arg?5in?5fflush?11?$AA@ DB 'bad first arg '
	DB	'in fflush/1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOEKJLMG@byte?5in?50?4?4255?5expected?5in?5fputc@
CONST	SEGMENT
??_C@_0CD@GOEKJLMG@byte?5in?50?4?4255?5expected?5in?5fputc@ DB 'byte in 0'
	DB	'..255 expected in fputc/1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEMKKJAC@file?5error?5in?5fputc?11?$AA@
CONST	SEGMENT
??_C@_0BG@DEMKKJAC@file?5error?5in?5fputc?11?$AA@ DB 'file error in fputc'
	DB	'/1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JBLNBHNJ@bad?5first?5arg?5in?5fputc?12?$AA@
CONST	SEGMENT
??_C@_0BJ@JBLNBHNJ@bad?5first?5arg?5in?5fputc?12?$AA@ DB 'bad first arg i'
	DB	'n fputc/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DABCLHAC@bad?5first?5arg?5in?5fgetc?12?$AA@
CONST	SEGMENT
??_C@_0BJ@DABCLHAC@bad?5first?5arg?5in?5fgetc?12?$AA@ DB 'bad first arg i'
	DB	'n fgetc/2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NKGJFKHF@bad?5data?5or?5heap_overflow?5in?5cde@
CONST	SEGMENT
??_C@_0CJ@NKGJFKHF@bad?5data?5or?5heap_overflow?5in?5cde@ DB 'bad data or'
	DB	' heap_overflow in cdel_scan/3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NBICNKMK@bad?5data?5or?5heap_overflow?5in?5cme@
CONST	SEGMENT
??_C@_0CM@NBICNKMK@bad?5data?5or?5heap_overflow?5in?5cme@ DB 'bad data or'
	DB	' heap_overflow in cmember_scan/3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EAAFBHNF@large?5or?5cyclic?51st?5arg?5in?5deep_@
CONST	SEGMENT
??_C@_0DM@EAAFBHNF@large?5or?5cyclic?51st?5arg?5in?5deep_@ DB 'large or c'
	DB	'yclic 1st arg in deep_hash: recursion depth error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IANFFGNM@deep_hash?8s?53nd?5arg?5?$CImod?$CJ?5must?5b@
CONST	SEGMENT
??_C@_0CK@IANFFGNM@deep_hash?8s?53nd?5arg?5?$CImod?$CJ?5must?5b@ DB 'deep'
	DB	'_hash''s 3nd arg (mod) must be integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KKPNJCHL@deep_hash?8s?52nd?5arg?5?$CIrec?4?5level?$CJ@
CONST	SEGMENT
??_C@_0DB@KKPNJCHL@deep_hash?8s?52nd?5arg?5?$CIrec?4?5level?$CJ@ DB 'deep'
	DB	'_hash''s 2nd arg (rec. level) must be integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DEDAKFBO@arg?13?8s?51st?5arg?5must?5be?5in?51?4?4ar@
CONST	SEGMENT
??_C@_0CE@DEDAKFBO@arg?13?8s?51st?5arg?5must?5be?5in?51?4?4ar@ DB 'arg/3'''
	DB	's 1st arg must be in 1..arity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PIJIHPDP@arg?13?8s?52nd?5arg?5must?5be?5nonvar?$AA@
CONST	SEGMENT
??_C@_0BP@PIJIHPDP@arg?13?8s?52nd?5arg?5must?5be?5nonvar?$AA@ DB 'arg/3'''
	DB	's 2nd arg must be nonvar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NFCHOHFJ@arg?13?8s?51st?5arg?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0CA@NFCHOHFJ@arg?13?8s?51st?5arg?5must?5be?5integer?$AA@ DB 'arg/3'''
	DB	's 1st arg must be integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DGBBHJGD@integer?5expected?5in?5put?11?$AA@
CONST	SEGMENT
??_C@_0BK@DGBBHJGD@integer?5expected?5in?5put?11?$AA@ DB 'integer expecte'
	DB	'd in put/1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EDEAEALJ@divided?5by?50?$AA@
CONST	SEGMENT
??_C@_0N@EDEAEALJ@divided?5by?50?$AA@ DB 'divided by 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBEJIEKE@mod?50?5invalid?$AA@
CONST	SEGMENT
??_C@_0O@CBEJIEKE@mod?50?5invalid?$AA@ DB 'mod 0 invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bp
_TEXT	SEGMENT
_wam$GSCopy$ = -262180					; size = 4
_H$GSCopy$ = -262176					; size = 4
_xref$83215 = -262172					; size = 4
_ires$83218 = -262168					; size = 4
_xval$83216 = -262168					; size = 4
_fields$83217 = -262168					; size = 4
_S$ = -262164						; size = 4
tv7619 = -262160					; size = 4
tv6030 = -262160					; size = 4
_cutB$ = -262160					; size = 4
_ok$89911 = -262156					; size = 4
_ok$89934 = -262152					; size = 4
_sbuf$ = -262148					; size = 262144
__$ArrayPad$ = -4					; size = 4
_regs$ = 8						; size = 4
_H$ = 12						; size = 4
_P$ = 16						; size = 4
_A$ = 20						; size = 4
_wam$ = 24						; size = 4
_bp	PROC						; COMDAT

; 1461 : {

  00000	b8 24 00 04 00	 mov	 eax, 262180		; 00040024H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 20 00
	04 00		 mov	 DWORD PTR __$ArrayPad$[esp+262180], eax
  00018	8b 8c 24 38 00
	04 00		 mov	 ecx, DWORD PTR _wam$[esp+262176]
  0001f	8b 84 24 2c 00
	04 00		 mov	 eax, DWORD PTR _H$[esp+262176]
  00026	53		 push	 ebx
  00027	8b 9c 24 34 00
	04 00		 mov	 ebx, DWORD PTR _P$[esp+262180]
  0002e	55		 push	 ebp
  0002f	8b ac 24 3c 00
	04 00		 mov	 ebp, DWORD PTR _A$[esp+262184]
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	8b bc 24 38 00
	04 00		 mov	 edi, DWORD PTR _regs$[esp+262192]

; 2347 :         ;
; 2348 : 
; 2349 :       case HVAL_2:
; 2350 :         xref = H;

  0003f	89 4c 24 10	 mov	 DWORD PTR _wam$GSCopy$[esp+262196], ecx
  00043	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  0004b	89 5c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebx
$LN1758@bp:
  0004f	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
$LL1041@bp:

; 1462 :   register cell S = (cell) ZERO;
; 1463 :   register cell cutB = (cell) P;
; 1464 : 
; 1465 :   char sbuf[MAXSBUF];
; 1466 : 
; 1467 :   for (;;) {
; 1468 :     register term xref;
; 1469 :     register cell xval;
; 1470 :     register cell fields;
; 1471 :     register bp_long ires;
; 1472 : 
; 1473 : #if TRACE>1 || PROF
; 1474 :     profiler(1,P,A,H,wam);
; 1475 : #endif
; 1476 :     ASSERT2(RUNTIME==g.timestamp,H);
; 1477 : 
; 1478 :     /*if(g.stopper) {
; 1479 :      fprintf(STD_err,"OPCODE: %d->%d H=%d P=%d\n",
; 1480 :      GETOPCODE(),(GETOPCODE())>>g.stopper,H,P);
; 1481 :      }
; 1482 :      switch((GETOPCODE())>>g.stopper) 10% slowdown
; 1483 :      */
; 1484 :     switch (GETOPCODE()) {

  00053	8b 33		 mov	 esi, DWORD PTR [ebx]
  00055	8b c6		 mov	 eax, esi
  00057	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0005c	3d da 00 00 00	 cmp	 eax, 218		; 000000daH
  00061	0f 87 8c 3d 00
	00		 ja	 $LN1@bp
  00067	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1798@bp[eax*4]
$LN1036@bp:

; 1485 : 
; 1486 :       case END: /* assert(*cbase==END); */
; 1487 :         /*fprintf(STD_err,"END: reached%d\n",g.stopper);*/
; 1488 :         return NULL;
; 1489 : 
; 1490 :       case UNIFY_VARIABLE:
; 1491 :         if (S) {

  0006e	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
  00072	85 c0		 test	 eax, eax
  00074	74 12		 je	 SHORT $LN1035@bp

; 1492 :           READARG(An);

  00076	c1 ee 15	 shr	 esi, 21			; 00000015H
  00079	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  0007c	83 c0 04	 add	 eax, 4
  0007f	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax
$LN6@bp:

; 1493 :           NEXT(1)

  00083	83 c3 04	 add	 ebx, 4

; 1494 :           ;

  00086	eb cb		 jmp	 SHORT $LL1041@bp
$LN1035@bp:

; 1495 :         }
; 1496 :       case WRITE_VARIABLE:
; 1497 :         NEWVAR(An)

  00088	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1498 :         ;

  0008c	c1 ee 15	 shr	 esi, 21			; 00000015H
  0008f	89 00		 mov	 DWORD PTR [eax], eax
  00091	89 04 3e	 mov	 DWORD PTR [esi+edi], eax

; 1509 :         ;
; 1510 :         NEXT(1)
; 1511 :         ;
; 1512 : 
; 1513 :       case WRITE_VALUE:
; 1514 :         W_VAL(An)

  00094	83 c0 04	 add	 eax, 4
  00097	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 1576 :           NEXT(1)

  0009b	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  0009e	eb b3		 jmp	 SHORT $LL1041@bp
$LN1033@bp:

; 1499 :         NEXT(1)
; 1500 :         ;
; 1501 : 
; 1502 :       case UNIFY_VALUE:
; 1503 :         if (S) {
; 1504 :           READVAL(An);

  000a0	c1 ee 15	 shr	 esi, 21			; 00000015H
  000a3	83 7c 24 20 00	 cmp	 DWORD PTR _S$[esp+262196], 0
  000a8	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  000ab	74 26		 je	 SHORT $LN1032@bp
  000ad	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  000b1	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
  000b5	55		 push	 ebp
  000b6	52		 push	 edx
  000b7	50		 push	 eax
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _unify
  000be	83 c4 10	 add	 esp, 16			; 00000010H
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 27 3b 00
	00		 je	 $LN1747@bp
  000c9	83 44 24 20 04	 add	 DWORD PTR _S$[esp+262196], 4

; 1576 :           NEXT(1)

  000ce	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  000d1	eb 80		 jmp	 SHORT $LL1041@bp
$LN1032@bp:

; 1505 :           NEXT(1)
; 1506 :           ;
; 1507 :         }
; 1508 :         PUSHDERVAL(An)

  000d3	f6 c1 03	 test	 cl, 3
  000d6	74 04		 je	 SHORT $LN1564@bp
  000d8	8b c1		 mov	 eax, ecx
  000da	eb 35		 jmp	 SHORT $LN1020@bp
$LN1564@bp:
  000dc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000de	a8 03		 test	 al, 3
  000e0	75 2f		 jne	 SHORT $LN1020@bp
$LL1028@bp:
  000e2	3b c8		 cmp	 ecx, eax
  000e4	74 2b		 je	 SHORT $LN1020@bp
  000e6	8b c8		 mov	 ecx, eax
  000e8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ea	a8 03		 test	 al, 3
  000ec	74 f4		 je	 SHORT $LL1028@bp
  000ee	eb 21		 jmp	 SHORT $LN1020@bp
$LN1024@bp:

; 1509 :         ;
; 1510 :         NEXT(1)
; 1511 :         ;
; 1512 : 
; 1513 :       case WRITE_VALUE:
; 1514 :         W_VAL(An)

  000f0	c1 ee 15	 shr	 esi, 21			; 00000015H
  000f3	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  000f6	f6 c1 03	 test	 cl, 3
  000f9	74 04		 je	 SHORT $LN1565@bp
  000fb	8b c1		 mov	 eax, ecx
  000fd	eb 12		 jmp	 SHORT $LN1020@bp
$LN1565@bp:
  000ff	8b 01		 mov	 eax, DWORD PTR [ecx]
  00101	a8 03		 test	 al, 3
  00103	75 0c		 jne	 SHORT $LN1020@bp
$LL1021@bp:
  00105	3b c8		 cmp	 ecx, eax
  00107	74 08		 je	 SHORT $LN1020@bp
  00109	8b c8		 mov	 ecx, eax
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	a8 03		 test	 al, 3
  0010f	74 f4		 je	 SHORT $LL1021@bp
$LN1020@bp:
  00111	8b d0		 mov	 edx, eax
  00113	83 e2 03	 and	 edx, 3
  00116	80 fa 03	 cmp	 dl, 3
  00119	75 1c		 jne	 SHORT $LN1019@bp
  0011b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00120	74 15		 je	 SHORT $LN1019@bp
  00122	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00126	89 08		 mov	 DWORD PTR [eax], ecx
  00128	83 c0 04	 add	 eax, 4
  0012b	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 1576 :           NEXT(1)

  0012f	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  00132	e9 1c ff ff ff	 jmp	 $LL1041@bp
$LN1019@bp:

; 1509 :         ;
; 1510 :         NEXT(1)
; 1511 :         ;
; 1512 : 
; 1513 :       case WRITE_VALUE:
; 1514 :         W_VAL(An)

  00137	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0013b	89 01		 mov	 DWORD PTR [ecx], eax
  0013d	83 c1 04	 add	 ecx, 4
  00140	89 4c 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], ecx

; 1576 :           NEXT(1)

  00144	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  00147	e9 07 ff ff ff	 jmp	 $LL1041@bp
$LN1017@bp:

; 1515 :         ;
; 1516 :         NEXT(1)
; 1517 :         ;
; 1518 : 
; 1519 :       case GET_STRUCTURE:
; 1520 :         GSTR(EMPTY,EMPTY,EMPTY,SNEXT(1),EMPTY,EMPTY,HNEXT(1),2)

  0014c	c1 ee 15	 shr	 esi, 21			; 00000015H
  0014f	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00152	89 44 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], eax
  00156	a8 03		 test	 al, 3
  00158	74 04		 je	 SHORT $LN1566@bp
  0015a	8b c8		 mov	 ecx, eax
  0015c	eb 23		 jmp	 SHORT $LN1013@bp
$LN1566@bp:
  0015e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00160	f6 c1 03	 test	 cl, 3
  00163	0f 85 85 00 00
	00		 jne	 $LN1012@bp
  00169	8d a4 24 00 00
	00 00		 npad	 7
$LL1014@bp:
  00170	3b c1		 cmp	 eax, ecx
  00172	74 09		 je	 SHORT $LN1738@bp
  00174	8b c1		 mov	 eax, ecx
  00176	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00178	f6 c1 03	 test	 cl, 3
  0017b	74 f3		 je	 SHORT $LL1014@bp
$LN1738@bp:
  0017d	89 44 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], eax
$LN1013@bp:
  00181	f6 c1 03	 test	 cl, 3
  00184	75 68		 jne	 SHORT $LN1012@bp
  00186	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  0018e	3b 45 f8	 cmp	 eax, DWORD PTR [ebp-8]
  00191	73 37		 jae	 SHORT $LN1715@bp
  00193	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  00197	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0019a	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  0019d	72 22		 jb	 SHORT $LN1010@bp
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  001a4	8b c1		 mov	 eax, ecx
  001a6	50		 push	 eax
  001a7	6a 01		 push	 1
  001a9	52		 push	 edx
  001aa	e8 00 00 00 00	 call	 _overflow_by
  001af	6a 0c		 push	 12			; 0000000cH
  001b1	e8 00 00 00 00	 call	 _bp_halt
  001b6	8b 44 24 2c	 mov	 eax, DWORD PTR _xref$83215[esp+262216]
  001ba	8b 4c 24 24	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262216]
  001be	83 c4 14	 add	 esp, 20			; 00000014H
$LN1010@bp:
  001c1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001c4	89 02		 mov	 DWORD PTR [edx], eax
  001c6	83 41 2c 04	 add	 DWORD PTR [ecx+44], 4
$LN1715@bp:
  001ca	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  001ce	89 08		 mov	 DWORD PTR [eax], ecx
  001d0	83 c0 08	 add	 eax, 8
  001d3	3b c8		 cmp	 ecx, eax
  001d5	1b c0		 sbb	 eax, eax
  001d7	f7 d8		 neg	 eax
  001d9	f7 d8		 neg	 eax
  001db	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001de	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001e1	89 08		 mov	 DWORD PTR [eax], ecx
  001e3	83 c0 04	 add	 eax, 4
  001e6	83 c3 08	 add	 ebx, 8
  001e9	e9 61 fe ff ff	 jmp	 $LN1758@bp
$LN1012@bp:
  001ee	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  001f1	0f 85 f9 39 00
	00		 jne	 $LN1747@bp
  001f7	83 c0 04	 add	 eax, 4
  001fa	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax
  001fe	83 c3 08	 add	 ebx, 8

; 1521 :         ;

  00201	e9 4d fe ff ff	 jmp	 $LL1041@bp
$LN1008@bp:

; 1522 : 
; 1523 :       case PUT_STRUCTURE:
; 1524 :         PSTR()

  00206	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00209	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1525 :         ;

  0020d	c1 ee 15	 shr	 esi, 21			; 00000015H
  00210	89 10		 mov	 DWORD PTR [eax], edx
  00212	89 04 3e	 mov	 DWORD PTR [esi+edi], eax

; 1526 :         HNEXT(1);

  00215	83 c0 04	 add	 eax, 4

; 1527 :         NEXT(2)

  00218	83 c3 08	 add	 ebx, 8

; 1528 :         ;

  0021b	e9 2f fe ff ff	 jmp	 $LN1758@bp
$LN1007@bp:

; 1529 : 
; 1530 :       case MOVE_REG:
; 1531 :         An = Ai;

  00220	8b c6		 mov	 eax, esi
  00222	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00225	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0022a	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  0022d	c1 ee 15	 shr	 esi, 21			; 00000015H
  00230	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx

; 1576 :           NEXT(1)

  00233	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  00236	e9 18 fe ff ff	 jmp	 $LL1041@bp
$LN1006@bp:

; 1532 :         NEXT(1)
; 1533 :         ;
; 1534 : 
; 1535 :       case PUT_VARIABLE:
; 1536 :         NEWVAR2(An,Ai)

  0023b	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1537 :         ;

  0023f	8b d6		 mov	 edx, esi
  00241	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00244	89 00		 mov	 DWORD PTR [eax], eax
  00246	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0024c	c1 ee 15	 shr	 esi, 21			; 00000015H
  0024f	89 04 3a	 mov	 DWORD PTR [edx+edi], eax
  00252	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  00255	83 c0 04	 add	 eax, 4
  00258	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 1576 :           NEXT(1)

  0025c	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  0025f	e9 ef fd ff ff	 jmp	 $LL1041@bp
$LN1005@bp:

; 1538 :         NEXT(1)
; 1539 :         ;
; 1540 : 
; 1541 :       case GET_VALUE:
; 1542 :         UNIFAIL(An,Ai)

  00264	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  00268	8b ce		 mov	 ecx, esi
  0026a	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  0026d	55		 push	 ebp
  0026e	50		 push	 eax
  0026f	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00275	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]
  00278	c1 ee 15	 shr	 esi, 21			; 00000015H
  0027b	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  0027e	52		 push	 edx
  0027f	50		 push	 eax
  00280	e8 00 00 00 00	 call	 _unify
  00285	e9 9f 1b 00 00	 jmp	 $LN1789@bp
$LN1003@bp:

; 1543 :         NEXT(1)
; 1544 :         ;
; 1545 : 
; 1546 : #if STRUCT_COMPRESS
; 1547 :       case MOVE_REGx2:
; 1548 :         An = Ai;

  0028a	8b ce		 mov	 ecx, esi
  0028c	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  0028f	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00295	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]
  00298	c1 ee 15	 shr	 esi, 21			; 00000015H
  0029b	89 14 3e	 mov	 DWORD PTR [esi+edi], edx

; 1549 :         GETFIELDS(1);

  0029e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1550 :         An = Ai;

  002a1	8b c8		 mov	 ecx, eax
  002a3	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  002a6	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  002ac	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]
  002af	c1 e8 15	 shr	 eax, 21			; 00000015H
  002b2	89 14 38	 mov	 DWORD PTR [eax+edi], edx

; 1551 :         NEXT(2)

  002b5	83 c3 08	 add	 ebx, 8

; 1552 :         ;

  002b8	e9 96 fd ff ff	 jmp	 $LL1041@bp
$LN1002@bp:

; 1553 : 
; 1554 :       case UNIFY_VAR_VAR:
; 1555 :         if (S) {

  002bd	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
  002c1	85 c0		 test	 eax, eax
  002c3	74 0a		 je	 SHORT $LN1001@bp

; 1556 :           SREADARG(0,An);

  002c5	8b ce		 mov	 ecx, esi
  002c7	c1 e9 15	 shr	 ecx, 21			; 00000015H
  002ca	89 04 39	 mov	 DWORD PTR [ecx+edi], eax

; 1557 :           SREADARG(1,Ai);
; 1558 :           SNEXT(2);
; 1559 :           NEXT(1)
; 1560 :           ;

  002cd	eb 5d		 jmp	 SHORT $LN1755@bp
$LN1001@bp:

; 1561 :         }
; 1562 :       case WRITE_VAR_VAR:
; 1563 :         HNEWVAR(0,An)

  002cf	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  002d3	8b c6		 mov	 eax, esi
  002d5	c1 e8 15	 shr	 eax, 21			; 00000015H
  002d8	89 0c 38	 mov	 DWORD PTR [eax+edi], ecx

; 1564 :         ;
; 1565 :         HNEWVAR(1,Ai)

  002db	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  002de	89 09		 mov	 DWORD PTR [ecx], ecx
  002e0	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  002e3	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH

; 1566 :         ;
; 1567 :         HNEXT(2);

  002e9	83 c1 08	 add	 ecx, 8
  002ec	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  002ef	89 00		 mov	 DWORD PTR [eax], eax
  002f1	89 4c 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], ecx

; 1568 :         NEXT(1)

  002f5	83 c3 04	 add	 ebx, 4

; 1569 :         ;

  002f8	e9 56 fd ff ff	 jmp	 $LL1041@bp
$LN999@bp:

; 1570 : 
; 1571 :       case UNIFY_VAL_VAR:
; 1572 :         if (S) {
; 1573 :           SREADVAL(0,An);

  002fd	8b c6		 mov	 eax, esi
  002ff	c1 e8 15	 shr	 eax, 21			; 00000015H
  00302	83 7c 24 20 00	 cmp	 DWORD PTR _S$[esp+262196], 0
  00307	74 41		 je	 SHORT $LN998@bp
  00309	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0030d	8b 54 24 20	 mov	 edx, DWORD PTR _S$[esp+262196]
  00311	55		 push	 ebp
  00312	51		 push	 ecx
  00313	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00316	52		 push	 edx
  00317	51		 push	 ecx
  00318	e8 00 00 00 00	 call	 _unify
  0031d	83 c4 10	 add	 esp, 16			; 00000010H
  00320	85 c0		 test	 eax, eax
  00322	0f 84 c8 38 00
	00		 je	 $LN1747@bp

; 1574 :           SREADARG(1,Ai);

  00328	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
$LN1755@bp:
  0032c	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  0032f	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00332	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH

; 1575 :           SNEXT(2);

  00338	83 c0 08	 add	 eax, 8
  0033b	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
  0033e	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax

; 1576 :           NEXT(1)

  00342	83 c3 04	 add	 ebx, 4

; 1577 :           ;

  00345	e9 09 fd ff ff	 jmp	 $LL1041@bp
$LN998@bp:

; 1578 :         }
; 1579 : #if EAGER_DEREF==0
; 1580 :         case WRITE_VAL_VAR:
; 1581 : #endif
; 1582 :         HNEWVAL(0,An)

  0034a	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  0034d	f6 c1 03	 test	 cl, 3
  00350	74 04		 je	 SHORT $LN1567@bp
  00352	8b c1		 mov	 eax, ecx
  00354	eb 3b		 jmp	 SHORT $LN986@bp
$LN1567@bp:
  00356	8b 01		 mov	 eax, DWORD PTR [ecx]
  00358	a8 03		 test	 al, 3
  0035a	75 35		 jne	 SHORT $LN986@bp
  0035c	8d 64 24 00	 npad	 4
$LL994@bp:
  00360	3b c8		 cmp	 ecx, eax
  00362	74 2d		 je	 SHORT $LN986@bp
  00364	8b c8		 mov	 ecx, eax
  00366	8b 00		 mov	 eax, DWORD PTR [eax]
  00368	a8 03		 test	 al, 3
  0036a	74 f4		 je	 SHORT $LL994@bp
  0036c	eb 23		 jmp	 SHORT $LN986@bp
$LN990@bp:

; 1583 :         ;
; 1584 :         HNEWVAR(1,Ai)
; 1585 :         ;
; 1586 :         HNEXT(2);
; 1587 :         NEXT(1)
; 1588 :         ;
; 1589 : 
; 1590 : #if EAGER_DEREF>0
; 1591 :       case WRITE_VAL_VAR:
; 1592 :         HW_VAL(0,An)

  0036e	8b c6		 mov	 eax, esi
  00370	c1 e8 15	 shr	 eax, 21			; 00000015H
  00373	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00376	f6 c1 03	 test	 cl, 3
  00379	74 04		 je	 SHORT $LN1568@bp
  0037b	8b c1		 mov	 eax, ecx
  0037d	eb 12		 jmp	 SHORT $LN986@bp
$LN1568@bp:
  0037f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00381	a8 03		 test	 al, 3
  00383	75 0c		 jne	 SHORT $LN986@bp
$LL987@bp:
  00385	3b c8		 cmp	 ecx, eax
  00387	74 08		 je	 SHORT $LN986@bp
  00389	8b c8		 mov	 ecx, eax
  0038b	8b 00		 mov	 eax, DWORD PTR [eax]
  0038d	a8 03		 test	 al, 3
  0038f	74 f4		 je	 SHORT $LL987@bp
$LN986@bp:
  00391	8b d0		 mov	 edx, eax
  00393	83 e2 03	 and	 edx, 3
  00396	80 fa 03	 cmp	 dl, 3
  00399	75 0f		 jne	 SHORT $LN985@bp
  0039b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  003a0	74 08		 je	 SHORT $LN985@bp
  003a2	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  003a6	89 0a		 mov	 DWORD PTR [edx], ecx
  003a8	eb 06		 jmp	 SHORT $LN984@bp
$LN985@bp:
  003aa	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  003ae	89 02		 mov	 DWORD PTR [edx], eax
$LN984@bp:

; 1593 :         ;
; 1594 :         HNEWVAR(1,Ai)

  003b0	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  003b3	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  003b6	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH

; 1595 :         ;
; 1596 :         HNEXT(2);

  003bc	83 c2 08	 add	 edx, 8
  003bf	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  003c2	89 00		 mov	 DWORD PTR [eax], eax
  003c4	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx

; 1597 :         NEXT(1)

  003c8	83 c3 04	 add	 ebx, 4

; 1598 :         ;

  003cb	e9 83 fc ff ff	 jmp	 $LL1041@bp
$LN983@bp:

; 1599 : #endif
; 1600 : 
; 1601 :       case UNIFY_VAL_VAL:
; 1602 :         if (S) {

  003d0	83 7c 24 20 00	 cmp	 DWORD PTR _S$[esp+262196], 0
  003d5	74 57		 je	 SHORT $LN982@bp

; 1603 :           SREADVAL(0,An);

  003d7	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  003db	8b 4c 24 20	 mov	 ecx, DWORD PTR _S$[esp+262196]
  003df	55		 push	 ebp
  003e0	50		 push	 eax
  003e1	8b d6		 mov	 edx, esi
  003e3	c1 ea 15	 shr	 edx, 21			; 00000015H
  003e6	8b 04 3a	 mov	 eax, DWORD PTR [edx+edi]
  003e9	51		 push	 ecx
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 _unify
  003f0	83 c4 10	 add	 esp, 16			; 00000010H
  003f3	85 c0		 test	 eax, eax
  003f5	0f 84 f5 37 00
	00		 je	 $LN1747@bp

; 1604 :           SREADVAL(1,Ai);

  003fb	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  003ff	8b 54 24 20	 mov	 edx, DWORD PTR _S$[esp+262196]
  00403	55		 push	 ebp
  00404	51		 push	 ecx
  00405	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00408	83 c2 04	 add	 edx, 4
  0040b	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00411	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00414	52		 push	 edx
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 _unify
  0041b	83 c4 10	 add	 esp, 16			; 00000010H
  0041e	85 c0		 test	 eax, eax
  00420	0f 85 39 01 00
	00		 jne	 $LN952@bp

; 3141 :         OUT_RESULT(xval);

  00426	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  00429	e9 25 fc ff ff	 jmp	 $LL1041@bp
$LN982@bp:

; 1605 :           SNEXT(2);
; 1606 :           NEXT(1)
; 1607 :           ;
; 1608 :         }
; 1609 : #if EAGER_DEREF==0
; 1610 :         case WRITE_VAL_VAL:
; 1611 : #endif
; 1612 :         HNEWVAL(0,An)

  0042e	8b ce		 mov	 ecx, esi
  00430	c1 e9 15	 shr	 ecx, 21			; 00000015H
  00433	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  00436	f6 c1 03	 test	 cl, 3
  00439	74 04		 je	 SHORT $LN1569@bp
  0043b	8b c1		 mov	 eax, ecx
  0043d	eb 12		 jmp	 SHORT $LN976@bp
$LN1569@bp:
  0043f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00441	a8 03		 test	 al, 3
  00443	75 0c		 jne	 SHORT $LN976@bp
$LL977@bp:
  00445	3b c8		 cmp	 ecx, eax
  00447	74 08		 je	 SHORT $LN976@bp
  00449	8b c8		 mov	 ecx, eax
  0044b	8b 00		 mov	 eax, DWORD PTR [eax]
  0044d	a8 03		 test	 al, 3
  0044f	74 f4		 je	 SHORT $LL977@bp
$LN976@bp:
  00451	8b d0		 mov	 edx, eax
  00453	83 e2 03	 and	 edx, 3
  00456	80 fa 03	 cmp	 dl, 3
  00459	75 0f		 jne	 SHORT $LN1716@bp
  0045b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00460	74 08		 je	 SHORT $LN1716@bp
  00462	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00466	89 08		 mov	 DWORD PTR [eax], ecx
  00468	eb 06		 jmp	 SHORT $LN974@bp
$LN1716@bp:
  0046a	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0046e	89 01		 mov	 DWORD PTR [ecx], eax
$LN974@bp:

; 1613 :         ;
; 1614 :         HNEWVAL(1,Ai)

  00470	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00473	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00479	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  0047c	f6 c1 03	 test	 cl, 3
  0047f	74 07		 je	 SHORT $LN1570@bp
  00481	8b c1		 mov	 eax, ecx
  00483	e9 54 01 00 00	 jmp	 $LN941@bp
$LN1570@bp:
  00488	8b 01		 mov	 eax, DWORD PTR [ecx]
  0048a	a8 03		 test	 al, 3
  0048c	0f 85 4a 01 00
	00		 jne	 $LN941@bp
$LL971@bp:
  00492	3b c8		 cmp	 ecx, eax
  00494	0f 84 42 01 00
	00		 je	 $LN941@bp
  0049a	8b c8		 mov	 ecx, eax
  0049c	8b 00		 mov	 eax, DWORD PTR [eax]
  0049e	a8 03		 test	 al, 3
  004a0	74 f0		 je	 SHORT $LL971@bp
  004a2	e9 35 01 00 00	 jmp	 $LN941@bp
$LN967@bp:

; 1615 :         ;
; 1616 :         HNEXT(2);
; 1617 :         NEXT(1)
; 1618 :         ;
; 1619 : 
; 1620 : #if EAGER_DEREF>0
; 1621 :       case WRITE_VAL_VAL:
; 1622 :         HW_VAL(0,An)

  004a7	8b d6		 mov	 edx, esi
  004a9	c1 ea 15	 shr	 edx, 21			; 00000015H
  004ac	8b 0c 3a	 mov	 ecx, DWORD PTR [edx+edi]
  004af	f6 c1 03	 test	 cl, 3
  004b2	74 04		 je	 SHORT $LN1571@bp
  004b4	8b c1		 mov	 eax, ecx
  004b6	eb 14		 jmp	 SHORT $LN963@bp
$LN1571@bp:
  004b8	8b 01		 mov	 eax, DWORD PTR [ecx]
  004ba	a8 03		 test	 al, 3
  004bc	75 0e		 jne	 SHORT $LN963@bp
  004be	8b ff		 npad	 2
$LL964@bp:
  004c0	3b c8		 cmp	 ecx, eax
  004c2	74 08		 je	 SHORT $LN963@bp
  004c4	8b c8		 mov	 ecx, eax
  004c6	8b 00		 mov	 eax, DWORD PTR [eax]
  004c8	a8 03		 test	 al, 3
  004ca	74 f4		 je	 SHORT $LL964@bp
$LN963@bp:
  004cc	8b d0		 mov	 edx, eax
  004ce	83 e2 03	 and	 edx, 3
  004d1	80 fa 03	 cmp	 dl, 3
  004d4	75 0f		 jne	 SHORT $LN1717@bp
  004d6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  004db	74 08		 je	 SHORT $LN1717@bp
  004dd	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  004e1	89 08		 mov	 DWORD PTR [eax], ecx
  004e3	eb 06		 jmp	 SHORT $LN961@bp
$LN1717@bp:
  004e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  004e9	89 01		 mov	 DWORD PTR [ecx], eax
$LN961@bp:

; 1623 :         ;
; 1624 :         HW_VAL(1,Ai)

  004eb	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  004ee	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  004f4	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  004f7	f6 c1 03	 test	 cl, 3
  004fa	74 07		 je	 SHORT $LN1572@bp
  004fc	8b c1		 mov	 eax, ecx
  004fe	e9 d9 00 00 00	 jmp	 $LN941@bp
$LN1572@bp:
  00503	8b 01		 mov	 eax, DWORD PTR [ecx]
  00505	a8 03		 test	 al, 3
  00507	0f 85 cf 00 00
	00		 jne	 $LN941@bp
  0050d	8d 49 00	 npad	 3
$LL958@bp:
  00510	3b c8		 cmp	 ecx, eax
  00512	0f 84 c4 00 00
	00		 je	 $LN941@bp
  00518	8b c8		 mov	 ecx, eax
  0051a	8b 00		 mov	 eax, DWORD PTR [eax]
  0051c	a8 03		 test	 al, 3
  0051e	74 f0		 je	 SHORT $LL958@bp
  00520	e9 b7 00 00 00	 jmp	 $LN941@bp
$LN954@bp:

; 1625 :         ;
; 1626 :         HNEXT(2);
; 1627 :         NEXT(1)
; 1628 :         ;
; 1629 : #endif
; 1630 : 
; 1631 :       case UNIFY_VAR_VAL:
; 1632 :         if (S) {

  00525	83 7c 24 20 00	 cmp	 DWORD PTR _S$[esp+262196], 0
  0052a	74 40		 je	 SHORT $LN953@bp

; 1633 :           SREADARG(0,An);

  0052c	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]

; 1634 :           SREADVAL(1,Ai);

  00530	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  00534	8b d6		 mov	 edx, esi
  00536	c1 ea 15	 shr	 edx, 21			; 00000015H
  00539	55		 push	 ebp
  0053a	89 04 3a	 mov	 DWORD PTR [edx+edi], eax
  0053d	51		 push	 ecx
  0053e	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00541	83 c0 04	 add	 eax, 4
  00544	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  0054a	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  0054d	50		 push	 eax
  0054e	52		 push	 edx
  0054f	e8 00 00 00 00	 call	 _unify
  00554	83 c4 10	 add	 esp, 16			; 00000010H
  00557	85 c0		 test	 eax, eax
  00559	0f 84 91 36 00
	00		 je	 $LN1747@bp
$LN952@bp:

; 1635 :           SNEXT(2);

  0055f	83 44 24 20 08	 add	 DWORD PTR _S$[esp+262196], 8

; 1636 :           NEXT(1)

  00564	83 c3 04	 add	 ebx, 4

; 1637 :           ;

  00567	e9 e7 fa ff ff	 jmp	 $LL1041@bp
$LN953@bp:

; 1638 :         }
; 1639 : #if EAGER_DEREF==0
; 1640 :         case WRITE_VAR_VAL:
; 1641 : #endif
; 1642 :         HNEWVAR(0,An)

  0056c	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00570	8b ce		 mov	 ecx, esi
  00572	c1 e9 15	 shr	 ecx, 21			; 00000015H

; 1643 :         ;
; 1644 :         HNEWVAL(1,Ai)

  00575	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00578	89 04 39	 mov	 DWORD PTR [ecx+edi], eax
  0057b	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00581	89 00		 mov	 DWORD PTR [eax], eax
  00583	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00586	f6 c1 03	 test	 cl, 3
  00589	74 04		 je	 SHORT $LN1573@bp
  0058b	8b c1		 mov	 eax, ecx
  0058d	eb 4d		 jmp	 SHORT $LN941@bp
$LN1573@bp:
  0058f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00591	a8 03		 test	 al, 3
  00593	75 47		 jne	 SHORT $LN941@bp
$LL949@bp:
  00595	3b c8		 cmp	 ecx, eax
  00597	74 43		 je	 SHORT $LN941@bp
  00599	8b c8		 mov	 ecx, eax
  0059b	8b 00		 mov	 eax, DWORD PTR [eax]
  0059d	a8 03		 test	 al, 3
  0059f	74 f4		 je	 SHORT $LL949@bp
  005a1	eb 39		 jmp	 SHORT $LN941@bp
$LN945@bp:

; 1645 :         ;
; 1646 :         HNEXT(2);
; 1647 :         NEXT(1)
; 1648 :         ;
; 1649 : 
; 1650 : #if EAGER_DEREF>0
; 1651 :       case WRITE_VAR_VAL:
; 1652 :         HNEWVAR(0,An)

  005a3	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  005a7	8b d6		 mov	 edx, esi
  005a9	c1 ea 15	 shr	 edx, 21			; 00000015H

; 1653 :         ;
; 1654 :         HW_VAL(1,Ai)

  005ac	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  005af	89 04 3a	 mov	 DWORD PTR [edx+edi], eax
  005b2	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  005b8	89 00		 mov	 DWORD PTR [eax], eax
  005ba	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  005bd	f6 c1 03	 test	 cl, 3
  005c0	74 04		 je	 SHORT $LN1574@bp
  005c2	8b c1		 mov	 eax, ecx
  005c4	eb 16		 jmp	 SHORT $LN941@bp
$LN1574@bp:
  005c6	8b 01		 mov	 eax, DWORD PTR [ecx]
  005c8	a8 03		 test	 al, 3
  005ca	75 10		 jne	 SHORT $LN941@bp
  005cc	8d 64 24 00	 npad	 4
$LL942@bp:
  005d0	3b c8		 cmp	 ecx, eax
  005d2	74 08		 je	 SHORT $LN941@bp
  005d4	8b c8		 mov	 ecx, eax
  005d6	8b 00		 mov	 eax, DWORD PTR [eax]
  005d8	a8 03		 test	 al, 3
  005da	74 f4		 je	 SHORT $LL942@bp
$LN941@bp:
  005dc	8b d0		 mov	 edx, eax
  005de	83 e2 03	 and	 edx, 3
  005e1	80 fa 03	 cmp	 dl, 3
  005e4	75 1b		 jne	 SHORT $LN940@bp
  005e6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  005eb	74 14		 je	 SHORT $LN940@bp
  005ed	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1655 :         ;
; 1656 :         HNEXT(2);

  005f1	83 44 24 14 08	 add	 DWORD PTR _H$GSCopy$[esp+262196], 8
  005f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1657 :         NEXT(1)

  005f9	83 c3 04	 add	 ebx, 4

; 1658 :         ;

  005fc	e9 52 fa ff ff	 jmp	 $LL1041@bp
$LN940@bp:

; 1653 :         ;
; 1654 :         HW_VAL(1,Ai)

  00601	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]

; 1655 :         ;
; 1656 :         HNEXT(2);

  00605	83 44 24 14 08	 add	 DWORD PTR _H$GSCopy$[esp+262196], 8
  0060a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1657 :         NEXT(1)

  0060d	83 c3 04	 add	 ebx, 4

; 1658 :         ;

  00610	e9 3e fa ff ff	 jmp	 $LL1041@bp
$LN938@bp:

; 1659 : #endif
; 1660 : 
; 1661 : #endif
; 1662 : 
; 1663 :       case UNIFY_CONSTANT:
; 1664 :         if (S) {

  00615	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
  00619	85 c0		 test	 eax, eax
  0061b	74 3d		 je	 SHORT $LN1718@bp

; 1665 :           xref = (term) GETREF((term)GETARG());

  0061d	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1666 :           NEXTARG();

  0061f	83 c0 04	 add	 eax, 4
  00622	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00626	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax

; 1667 :           FDEREF(xref);

  0062a	f6 c1 03	 test	 cl, 3
  0062d	74 04		 je	 SHORT $LN1575@bp
  0062f	8b c1		 mov	 eax, ecx
  00631	eb 64		 jmp	 SHORT $LN920@bp
$LN1575@bp:
  00633	8b 01		 mov	 eax, DWORD PTR [ecx]
  00635	a8 03		 test	 al, 3
  00637	0f 85 a9 00 00
	00		 jne	 $LN919@bp
  0063d	8d 49 00	 npad	 3
$LL934@bp:
  00640	3b c8		 cmp	 ecx, eax
  00642	74 4f		 je	 SHORT $LN1740@bp
  00644	8b c8		 mov	 ecx, eax
  00646	8b 00		 mov	 eax, DWORD PTR [eax]
  00648	a8 03		 test	 al, 3
  0064a	74 f4		 je	 SHORT $LL934@bp

; 1668 :           if (VAR(xval)) {
; 1669 :             SETCELL(xref,GETFUN(P));
; 1670 :             SAFE_TRAIL_IF(xref);

  0064c	eb 45		 jmp	 SHORT $LN1740@bp
$LN927@bp:

; 1671 :           }
; 1672 :           else if (xval != GETFUN(P))
; 1673 :           FAILURE()
; 1674 :           NEXT(2)
; 1675 :           ;
; 1676 :         }
; 1677 :         PUSHVAL(GETFUN(P));
; 1678 :         NEXT(2)
; 1679 :         ;
; 1680 : 
; 1681 :       case PUSH_STRUCTURE:
; 1682 :         PUSH_TO_REG()
; 1683 :         ;

  0064e	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00652	c1 ee 15	 shr	 esi, 21			; 00000015H
  00655	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  00658	89 02		 mov	 DWORD PTR [edx], eax
$LN1718@bp:

; 1684 :       case WRITE_CONSTANT:
; 1685 :         PUSHVAL(GETFUN(P));

  0065a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0065d	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00661	89 08		 mov	 DWORD PTR [eax], ecx
  00663	83 c0 04	 add	 eax, 4

; 1686 :         NEXT(2)

  00666	83 c3 08	 add	 ebx, 8

; 1687 :         ;

  00669	e9 e1 f9 ff ff	 jmp	 $LN1758@bp
$LN924@bp:

; 1691 : 
; 1692 :       case GET_CONSTANT:
; 1693 :         FDEREF(An)

  0066e	c1 ee 15	 shr	 esi, 21			; 00000015H
  00671	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00674	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00678	f6 c1 03	 test	 cl, 3
  0067b	74 04		 je	 SHORT $LN1576@bp
  0067d	8b c1		 mov	 eax, ecx
  0067f	eb 16		 jmp	 SHORT $LN920@bp
$LN1576@bp:
  00681	8b 01		 mov	 eax, DWORD PTR [ecx]
  00683	a8 03		 test	 al, 3
  00685	75 5f		 jne	 SHORT $LN919@bp
$LL921@bp:
  00687	3b c8		 cmp	 ecx, eax
  00689	74 08		 je	 SHORT $LN1740@bp
  0068b	8b c8		 mov	 ecx, eax
  0068d	8b 00		 mov	 eax, DWORD PTR [eax]
  0068f	a8 03		 test	 al, 3
  00691	74 f4		 je	 SHORT $LL921@bp
$LN1740@bp:
  00693	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
$LN920@bp:

; 1694 :         ;
; 1695 :         if (VAR(xval)) {

  00697	a8 03		 test	 al, 3
  00699	75 4b		 jne	 SHORT $LN919@bp

; 1696 :           SETCELL(xref, GETFUN(P)); /*fill the unb. VAR with a const*/

  0069b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0069e	89 11		 mov	 DWORD PTR [ecx], edx

; 1697 :           SAFE_TRAIL_IF(xref);

  006a0	3b 4d f8	 cmp	 ecx, DWORD PTR [ebp-8]
  006a3	0f 83 d7 0c 00
	00		 jae	 $LN1705@bp
  006a9	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  006ad	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  006b0	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  006b3	72 20		 jb	 SHORT $LN917@bp
  006b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  006ba	50		 push	 eax
  006bb	6a 01		 push	 1
  006bd	52		 push	 edx
  006be	e8 00 00 00 00	 call	 _overflow_by
  006c3	6a 0c		 push	 12			; 0000000cH
  006c5	e8 00 00 00 00	 call	 _bp_halt
  006ca	8b 4c 24 2c	 mov	 ecx, DWORD PTR _xref$83215[esp+262216]
  006ce	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  006d2	83 c4 14	 add	 esp, 20			; 00000014H
$LN917@bp:
  006d5	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  006d8	89 0a		 mov	 DWORD PTR [edx], ecx
  006da	83 40 2c 04	 add	 DWORD PTR [eax+44], 4

; 1984 :         NEXT(2)

  006de	83 c3 08	 add	 ebx, 8

; 1985 :         ;

  006e1	e9 6d f9 ff ff	 jmp	 $LL1041@bp
$LN919@bp:

; 1698 :         }
; 1699 :         else if (xval != GETFUN(P))

  006e6	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  006e9	0f 84 91 0c 00
	00		 je	 $LN1705@bp

; 3141 :         OUT_RESULT(xval);

  006ef	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  006f2	e9 5c f9 ff ff	 jmp	 $LL1041@bp
$LN914@bp:

; 1700 :         FAILURE()
; 1701 :         NEXT(2)
; 1702 :         ;
; 1703 : 
; 1704 :       case PUT_CONSTANT:
; 1705 :         An = GETFUN(P);

  006f7	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  006fa	c1 ee 15	 shr	 esi, 21			; 00000015H
  006fd	89 04 3e	 mov	 DWORD PTR [esi+edi], eax

; 1706 :         NEXT(2)

  00700	83 c3 08	 add	 ebx, 8

; 1707 :         ;

  00703	e9 4b f9 ff ff	 jmp	 $LL1041@bp
$LN913@bp:

; 1708 : 
; 1709 :       case PUSH_CUT:
; 1710 :         PUSHVAL(CUT2INT(cutB));

  00708	8b 4c 24 24	 mov	 ecx, DWORD PTR _cutB$[esp+262196]
  0070c	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00710	41		 inc	 ecx
  00711	89 08		 mov	 DWORD PTR [eax], ecx
  00713	83 c0 04	 add	 eax, 4

; 1711 :         NEXT(1)

  00716	83 c3 04	 add	 ebx, 4

; 1712 :         ;

  00719	e9 31 f9 ff ff	 jmp	 $LN1758@bp
$LN912@bp:

; 1713 : 
; 1714 :       case PUT_CUT:
; 1715 :         A = (term *) cutB;

  0071e	8b 6c 24 24	 mov	 ebp, DWORD PTR _cutB$[esp+262196]

; 1716 :         TIDY_TRAIL();
; 1717 :         NEXT(1)

  00722	83 c3 04	 add	 ebx, 4

; 1718 :         ;

  00725	e9 29 f9 ff ff	 jmp	 $LL1041@bp
$LN911@bp:

; 1719 : 
; 1720 :       case GET_CUT:
; 1721 :         FDEREF(regs[1])

  0072a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0072d	f6 c1 03	 test	 cl, 3
  00730	74 0d		 je	 SHORT $LN1577@bp
  00732	8b c1		 mov	 eax, ecx

; 1722 :         ;
; 1723 :         A = (term *) INT2CUT(xval);

  00734	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]

; 1724 :         TIDY_TRAIL();
; 1725 :         NEXT(1)

  00737	83 c3 04	 add	 ebx, 4

; 1726 :         ;

  0073a	e9 14 f9 ff ff	 jmp	 $LL1041@bp
$LN1577@bp:

; 1719 : 
; 1720 :       case GET_CUT:
; 1721 :         FDEREF(regs[1])

  0073f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00741	a8 03		 test	 al, 3
  00743	75 0c		 jne	 SHORT $LN907@bp
$LL908@bp:
  00745	3b c8		 cmp	 ecx, eax
  00747	74 08		 je	 SHORT $LN907@bp
  00749	8b c8		 mov	 ecx, eax
  0074b	8b 00		 mov	 eax, DWORD PTR [eax]
  0074d	a8 03		 test	 al, 3
  0074f	74 f4		 je	 SHORT $LL908@bp
$LN907@bp:

; 1722 :         ;
; 1723 :         A = (term *) INT2CUT(xval);

  00751	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]

; 1724 :         TIDY_TRAIL();
; 1725 :         NEXT(1)

  00754	83 c3 04	 add	 ebx, 4

; 1726 :         ;

  00757	e9 f7 f8 ff ff	 jmp	 $LL1041@bp
$LN906@bp:

; 1727 : 
; 1728 :       case EXECUTE:
; 1729 :         EXEC()

  0075c	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  0075f	f6 c3 03	 test	 bl, 3
  00762	74 1a		 je	 SHORT $LN1719@bp
  00764	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  00768	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  0076c	52		 push	 edx
  0076d	55		 push	 ebp
  0076e	53		 push	 ebx
  0076f	50		 push	 eax
  00770	e8 00 00 00 00	 call	 _exec_link
  00775	8b d8		 mov	 ebx, eax
  00777	83 c4 10	 add	 esp, 16			; 00000010H
  0077a	85 db		 test	 ebx, ebx
  0077c	74 5a		 je	 SHORT $LN1037@bp
$LN1719@bp:
  0077e	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  00785	75 51		 jne	 SHORT $LN1037@bp
  00787	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0078b	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  0078f	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  00793	3b 4a 14	 cmp	 ecx, DWORD PTR [edx+20]
  00796	0f 82 b7 f8 ff
	ff		 jb	 $LL1041@bp
  0079c	8b f2		 mov	 esi, edx
  0079e	56		 push	 esi
  0079f	53		 push	 ebx
  007a0	55		 push	 ebp
  007a1	57		 push	 edi
  007a2	8b c1		 mov	 eax, ecx
$LN1797@bp:

; 2036 :         CUT_AND_CHECK_HEAP()

  007a4	50		 push	 eax
  007a5	e8 00 00 00 00	 call	 _trigger_gc
  007aa	83 c4 14	 add	 esp, 20			; 00000014H
  007ad	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  007b1	85 c0		 test	 eax, eax
  007b3	0f 85 9a f8 ff
	ff		 jne	 $LL1041@bp
$LN1617@bp:

; 1727 : 
; 1728 :       case EXECUTE:
; 1729 :         EXEC()

  007b9	e8 00 00 00 00	 call	 _link_halt
  007be	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  007c1	c7 41 18 fd ff
	ff ff		 mov	 DWORD PTR [ecx+24], -3	; fffffffdH
  007c8	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  007cb	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  007d2	89 6e 50	 mov	 DWORD PTR [esi+80], ebp
  007d5	89 5a 08	 mov	 DWORD PTR [edx+8], ebx
$LN1037@bp:
  007d8	33 c0		 xor	 eax, eax
  007da	e9 d0 38 00 00	 jmp	 $LN1040@bp
$LN901@bp:

; 1730 :         ;
; 1731 :         continue;
; 1732 : 
; 1733 :       case PROCEED:
; 1734 :         H = answer(wam, H, A, P);

  007df	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  007e3	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  007e7	53		 push	 ebx
  007e8	55		 push	 ebp
  007e9	51		 push	 ecx
  007ea	52		 push	 edx
  007eb	e8 00 00 00 00	 call	 _answer
  007f0	83 c4 10	 add	 esp, 16			; 00000010H
  007f3	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 1735 :         if (H) return H;

  007f7	85 c0		 test	 eax, eax
  007f9	0f 85 b0 38 00
	00		 jne	 $LN1040@bp

; 3141 :         OUT_RESULT(xval);

  007ff	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  00802	e9 4c f8 ff ff	 jmp	 $LL1041@bp
$LN899@bp:

; 1736 :         FAILURE()
; 1737 :         ;
; 1738 : 
; 1739 : #if JUMP_COMPRESS
; 1740 :       case EXEC_SWITCH:
; 1741 :         EXEC0()

  00807	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  0080e	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00811	75 c5		 jne	 SHORT $LN1037@bp
  00813	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00817	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0081b	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  0081f	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00822	72 1d		 jb	 SHORT $LN896@bp
  00824	8b f1		 mov	 esi, ecx
  00826	56		 push	 esi
  00827	53		 push	 ebx
  00828	55		 push	 ebp
  00829	8b d0		 mov	 edx, eax
  0082b	57		 push	 edi
  0082c	52		 push	 edx
  0082d	e8 00 00 00 00	 call	 _trigger_gc
  00832	83 c4 14	 add	 esp, 20			; 00000014H
  00835	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  00839	85 c0		 test	 eax, eax
  0083b	0f 84 8a 0e 00
	00		 je	 $LN1620@bp
$LN896@bp:

; 1742 :         ;
; 1743 : #endif
; 1744 :       case SWITCH:
; 1745 :         FDEREF(regs[1])

  00841	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00844	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00848	f6 c1 03	 test	 cl, 3
  0084b	74 04		 je	 SHORT $LN1578@bp
  0084d	8b c1		 mov	 eax, ecx
  0084f	eb 16		 jmp	 SHORT $LN891@bp
$LN1578@bp:
  00851	8b 01		 mov	 eax, DWORD PTR [ecx]
  00853	a8 03		 test	 al, 3
  00855	75 1c		 jne	 SHORT $LN890@bp
$LL892@bp:
  00857	3b c8		 cmp	 ecx, eax
  00859	74 0c		 je	 SHORT $LN891@bp
  0085b	8b c8		 mov	 ecx, eax
  0085d	8b 00		 mov	 eax, DWORD PTR [eax]
  0085f	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00863	a8 03		 test	 al, 3
  00865	74 f0		 je	 SHORT $LL892@bp
$LN891@bp:

; 1746 :         ;
; 1747 :         if (VAR(xval)) {/* regs[1]=xval; */

  00867	a8 03		 test	 al, 3
  00869	75 08		 jne	 SHORT $LN890@bp

; 1748 :           NEXT(2)

  0086b	83 c3 08	 add	 ebx, 8

; 1749 :           ;

  0086e	e9 e0 f7 ff ff	 jmp	 $LL1041@bp
$LN890@bp:

; 1750 :         }
; 1751 :         if (!(P = (instr) hget(GETFUN(P), xval)))

  00873	50		 push	 eax
  00874	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00877	50		 push	 eax
  00878	e8 00 00 00 00	 call	 _hget
  0087d	8b d8		 mov	 ebx, eax
  0087f	83 c4 08	 add	 esp, 8
  00882	85 db		 test	 ebx, ebx

; 1752 :         FAILURE()

  00884	0f 84 66 33 00
	00		 je	 $LN1747@bp

; 1753 : #if STRUCT_COMPRESS
; 1754 :         /* $$$ to check */
; 1755 :         S = T2C(xref+1);

  0088a	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  0088e	83 c1 04	 add	 ecx, 4
  00891	89 4c 24 20	 mov	 DWORD PTR _S$[esp+262196], ecx

; 1756 :         NEXT(2)

  00895	83 c3 08	 add	 ebx, 8

; 1757 :         ;

  00898	e9 b6 f7 ff ff	 jmp	 $LL1041@bp
$LN888@bp:

; 1758 : #else
; 1759 :         continue;
; 1760 : #endif
; 1761 : 
; 1762 :         /* the OFFSETS optimization replaces H++=.. with H[i]=.. and H+=N..*/
; 1763 : 
; 1764 : #if JUMP_COMPRESS
; 1765 :       case EXEC_JUMP_IF:
; 1766 :         EXEC0()

  0089d	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  008a4	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  008a7	0f 85 2b ff ff
	ff		 jne	 $LN1037@bp
  008ad	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  008b1	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  008b5	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  008b9	3b 50 14	 cmp	 edx, DWORD PTR [eax+20]
  008bc	72 1d		 jb	 SHORT $LN885@bp
  008be	8b f0		 mov	 esi, eax
  008c0	56		 push	 esi
  008c1	53		 push	 ebx
  008c2	55		 push	 ebp
  008c3	8b ca		 mov	 ecx, edx
  008c5	57		 push	 edi
  008c6	51		 push	 ecx
  008c7	e8 00 00 00 00	 call	 _trigger_gc
  008cc	83 c4 14	 add	 esp, 20			; 00000014H
  008cf	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  008d3	85 c0		 test	 eax, eax
  008d5	0f 84 8d 0e 00
	00		 je	 $LN1622@bp
$LN885@bp:

; 1767 :         ;
; 1768 : #endif
; 1769 :       case JUMP_IF:
; 1770 :         FDEREF(regs[1])

  008db	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  008de	f6 c1 03	 test	 cl, 3
  008e1	74 04		 je	 SHORT $LN1579@bp
  008e3	8b c1		 mov	 eax, ecx
  008e5	eb 15		 jmp	 SHORT $LN880@bp
$LN1579@bp:
  008e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  008e9	a8 03		 test	 al, 3
  008eb	75 1b		 jne	 SHORT $LN879@bp
  008ed	8d 49 00	 npad	 3
$LL881@bp:
  008f0	3b c8		 cmp	 ecx, eax
  008f2	74 08		 je	 SHORT $LN880@bp
  008f4	8b c8		 mov	 ecx, eax
  008f6	8b 00		 mov	 eax, DWORD PTR [eax]
  008f8	a8 03		 test	 al, 3
  008fa	74 f4		 je	 SHORT $LL881@bp
$LN880@bp:

; 1771 :         ;
; 1772 :         if (VAR(xval)) {/* regs[1]=xval; */

  008fc	a8 03		 test	 al, 3
  008fe	75 08		 jne	 SHORT $LN879@bp

; 1773 :           NEXT(2)

  00900	83 c3 08	 add	 ebx, 8

; 1774 :           ;

  00903	e9 4b f7 ff ff	 jmp	 $LL1041@bp
$LN879@bp:

; 1775 :         }
; 1776 :         {
; 1777 :           register instr label = GETLABEL(P);

  00908	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 1778 :           if (xval != GETFUN(label)) {

  0090b	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0090e	74 08		 je	 SHORT $LN878@bp

; 1779 :             NEXT(4)

  00910	83 c3 10	 add	 ebx, 16			; 00000010H

; 1780 :             ;

  00913	e9 3b f7 ff ff	 jmp	 $LL1041@bp
$LN878@bp:

; 1781 :           }
; 1782 : #if STRUCT_COMPRESS
; 1783 :           S = T2C(xref);
; 1784 :           fields = *(term) (label + 2);

  00918	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 1785 :           SREADARG(1,An);

  0091b	8b d8		 mov	 ebx, eax
  0091d	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00920	c1 eb 15	 shr	 ebx, 21			; 00000015H
  00923	89 34 3b	 mov	 DWORD PTR [ebx+edi], esi

; 1786 :           SREADARG(2,Ai);

  00926	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00929	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  0092c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH

; 1787 :           SNEXT(3);

  00931	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00934	89 34 38	 mov	 DWORD PTR [eax+edi], esi
  00937	89 4c 24 20	 mov	 DWORD PTR _S$[esp+262196], ecx

; 1788 :           P = label + 3;

  0093b	8d 5a 0c	 lea	 ebx, DWORD PTR [edx+12]

; 1789 : #else
; 1790 :           P=label;
; 1791 : #endif
; 1792 :           continue;

  0093e	e9 10 f7 ff ff	 jmp	 $LL1041@bp
$LN877@bp:

; 1793 :         }
; 1794 : 
; 1795 : #if STRUCT_COMPRESS
; 1796 :       case GET_UNIFY_VAL_VAR:
; 1797 :         GSTR3(SREADVAL(1,An),SREADARG(2,Ai),HNEWVAL(1,An),HNEWVAR(2,Ai))

  00943	c1 ee 15	 shr	 esi, 21			; 00000015H
  00946	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00949	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  0094d	f6 c1 03	 test	 cl, 3
  00950	74 04		 je	 SHORT $LN1580@bp
  00952	8b c1		 mov	 eax, ecx
  00954	eb 1a		 jmp	 SHORT $LN873@bp
$LN1580@bp:
  00956	8b 01		 mov	 eax, DWORD PTR [ecx]
  00958	a8 03		 test	 al, 3
  0095a	0f 85 d9 00 00
	00		 jne	 $LN872@bp
$LL874@bp:
  00960	3b c8		 cmp	 ecx, eax
  00962	74 08		 je	 SHORT $LN1741@bp
  00964	8b c8		 mov	 ecx, eax
  00966	8b 00		 mov	 eax, DWORD PTR [eax]
  00968	a8 03		 test	 al, 3
  0096a	74 f4		 je	 SHORT $LL874@bp
$LN1741@bp:
  0096c	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
$LN873@bp:
  00970	a8 03		 test	 al, 3
  00972	0f 85 c1 00 00
	00		 jne	 $LN872@bp
  00978	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  00980	3b 4d f8	 cmp	 ecx, DWORD PTR [ebp-8]
  00983	73 35		 jae	 SHORT $LN871@bp
  00985	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  00989	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  0098c	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  0098f	72 20		 jb	 SHORT $LN870@bp
  00991	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00996	50		 push	 eax
  00997	6a 01		 push	 1
  00999	52		 push	 edx
  0099a	e8 00 00 00 00	 call	 _overflow_by
  0099f	6a 0c		 push	 12			; 0000000cH
  009a1	e8 00 00 00 00	 call	 _bp_halt
  009a6	8b 4c 24 2c	 mov	 ecx, DWORD PTR _xref$83215[esp+262216]
  009aa	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  009ae	83 c4 14	 add	 esp, 20			; 00000014H
$LN870@bp:
  009b1	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  009b4	89 0a		 mov	 DWORD PTR [edx], ecx
  009b6	83 40 2c 04	 add	 DWORD PTR [eax+44], 4
$LN871@bp:
  009ba	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  009be	89 01		 mov	 DWORD PTR [ecx], eax
  009c0	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  009c3	83 c1 08	 add	 ecx, 8
  009c6	3b c1		 cmp	 eax, ecx
  009c8	1b c9		 sbb	 ecx, ecx
  009ca	f7 d9		 neg	 ecx
  009cc	f7 d9		 neg	 ecx
  009ce	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  009d1	89 11		 mov	 DWORD PTR [ecx], edx
  009d3	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  009d6	8b c6		 mov	 eax, esi
  009d8	c1 e8 15	 shr	 eax, 21			; 00000015H
  009db	8b 14 38	 mov	 edx, DWORD PTR [eax+edi]
  009de	89 54 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], edx
  009e2	f6 c2 03	 test	 dl, 3
  009e5	74 04		 je	 SHORT $LN1581@bp
  009e7	8b c2		 mov	 eax, edx
  009e9	eb 16		 jmp	 SHORT $LN866@bp
$LN1581@bp:
  009eb	8b 02		 mov	 eax, DWORD PTR [edx]
  009ed	a8 03		 test	 al, 3
  009ef	75 10		 jne	 SHORT $LN866@bp
$LL867@bp:
  009f1	3b d0		 cmp	 edx, eax
  009f3	74 0c		 je	 SHORT $LN866@bp
  009f5	8b d0		 mov	 edx, eax
  009f7	8b 00		 mov	 eax, DWORD PTR [eax]
  009f9	89 54 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], edx
  009fd	a8 03		 test	 al, 3
  009ff	74 f0		 je	 SHORT $LL867@bp
$LN866@bp:
  00a01	8b d0		 mov	 edx, eax
  00a03	83 e2 03	 and	 edx, 3
  00a06	80 fa 03	 cmp	 dl, 3
  00a09	75 0b		 jne	 SHORT $LN865@bp
  00a0b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00a10	74 04		 je	 SHORT $LN865@bp
  00a12	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
$LN865@bp:
  00a16	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00a19	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00a1c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00a1f	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH

; 1819 :         ;
; 1820 :         HNEXT(3);

  00a25	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00a28	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  00a2b	89 00		 mov	 DWORD PTR [eax], eax
  00a2d	89 4c 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], ecx

; 1821 :         NEXT(3)

  00a31	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1822 :         ;

  00a34	e9 1a f6 ff ff	 jmp	 $LL1041@bp
$LN872@bp:

; 1793 :         }
; 1794 : 
; 1795 : #if STRUCT_COMPRESS
; 1796 :       case GET_UNIFY_VAL_VAR:
; 1797 :         GSTR3(SREADVAL(1,An),SREADARG(2,Ai),HNEWVAL(1,An),HNEWVAR(2,Ai))

  00a39	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00a3c	0f 85 ae 31 00
	00		 jne	 $LN1747@bp
  00a42	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  00a46	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00a49	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  00a4d	55		 push	 ebp
  00a4e	89 44 24 24	 mov	 DWORD PTR _S$[esp+262200], eax
  00a52	51		 push	 ecx
  00a53	83 c0 04	 add	 eax, 4
  00a56	8b d6		 mov	 edx, esi
  00a58	50		 push	 eax
  00a59	c1 ea 15	 shr	 edx, 21			; 00000015H
  00a5c	8b 04 3a	 mov	 eax, DWORD PTR [edx+edi]
  00a5f	50		 push	 eax
  00a60	e8 00 00 00 00	 call	 _unify
  00a65	83 c4 10	 add	 esp, 16			; 00000010H
  00a68	85 c0		 test	 eax, eax
  00a6a	0f 84 80 31 00
	00		 je	 $LN1747@bp
  00a70	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  00a74	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00a77	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  00a7a	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00a80	83 c0 0c	 add	 eax, 12			; 0000000cH
  00a83	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
  00a86	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax

; 1821 :         NEXT(3)

  00a8a	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1822 :         ;

  00a8d	e9 c1 f5 ff ff	 jmp	 $LL1041@bp
$LN861@bp:

; 1798 :         ;
; 1799 : 
; 1800 :       case GET_UNIFY_VAL_VAL:
; 1801 :         GSTR3(SREADVAL(1,An),SREADVAL(2,Ai),HNEWVAL(1,An),HNEWVAL(2,Ai))

  00a92	c1 ee 15	 shr	 esi, 21			; 00000015H
  00a95	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00a98	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00a9c	f6 c1 03	 test	 cl, 3
  00a9f	74 04		 je	 SHORT $LN1582@bp
  00aa1	8b c1		 mov	 eax, ecx
  00aa3	eb 1b		 jmp	 SHORT $LN857@bp
$LN1582@bp:
  00aa5	8b 01		 mov	 eax, DWORD PTR [ecx]
  00aa7	a8 03		 test	 al, 3
  00aa9	0f 85 f6 00 00
	00		 jne	 $LN856@bp
  00aaf	90		 npad	 1
$LL858@bp:
  00ab0	3b c8		 cmp	 ecx, eax
  00ab2	74 08		 je	 SHORT $LN1742@bp
  00ab4	8b c8		 mov	 ecx, eax
  00ab6	8b 00		 mov	 eax, DWORD PTR [eax]
  00ab8	a8 03		 test	 al, 3
  00aba	74 f4		 je	 SHORT $LL858@bp
$LN1742@bp:
  00abc	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
$LN857@bp:
  00ac0	a8 03		 test	 al, 3
  00ac2	0f 85 dd 00 00
	00		 jne	 $LN856@bp
  00ac8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  00ad0	3b 4d f8	 cmp	 ecx, DWORD PTR [ebp-8]
  00ad3	73 35		 jae	 SHORT $LN855@bp
  00ad5	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  00ad9	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00adc	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  00adf	72 20		 jb	 SHORT $LN854@bp
  00ae1	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00ae6	50		 push	 eax
  00ae7	6a 01		 push	 1
  00ae9	52		 push	 edx
  00aea	e8 00 00 00 00	 call	 _overflow_by
  00aef	6a 0c		 push	 12			; 0000000cH
  00af1	e8 00 00 00 00	 call	 _bp_halt
  00af6	8b 4c 24 2c	 mov	 ecx, DWORD PTR _xref$83215[esp+262216]
  00afa	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  00afe	83 c4 14	 add	 esp, 20			; 00000014H
$LN854@bp:
  00b01	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00b04	89 0a		 mov	 DWORD PTR [edx], ecx
  00b06	83 40 2c 04	 add	 DWORD PTR [eax+44], 4
$LN855@bp:
  00b0a	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00b0e	89 01		 mov	 DWORD PTR [ecx], eax
  00b10	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00b13	83 c1 08	 add	 ecx, 8
  00b16	3b c1		 cmp	 eax, ecx
  00b18	1b c9		 sbb	 ecx, ecx
  00b1a	f7 d9		 neg	 ecx
  00b1c	f7 d9		 neg	 ecx
  00b1e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00b21	89 10		 mov	 DWORD PTR [eax], edx
  00b23	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00b26	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  00b2a	8b c6		 mov	 eax, esi
  00b2c	c1 e8 15	 shr	 eax, 21			; 00000015H
  00b2f	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00b32	f6 c1 03	 test	 cl, 3
  00b35	74 04		 je	 SHORT $LN1583@bp
  00b37	8b c1		 mov	 eax, ecx
  00b39	eb 12		 jmp	 SHORT $LN850@bp
$LN1583@bp:
  00b3b	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b3d	a8 03		 test	 al, 3
  00b3f	75 0c		 jne	 SHORT $LN850@bp
$LL851@bp:
  00b41	3b c8		 cmp	 ecx, eax
  00b43	74 08		 je	 SHORT $LN850@bp
  00b45	8b c8		 mov	 ecx, eax
  00b47	8b 00		 mov	 eax, DWORD PTR [eax]
  00b49	a8 03		 test	 al, 3
  00b4b	74 f4		 je	 SHORT $LL851@bp
$LN850@bp:
  00b4d	8b d0		 mov	 edx, eax
  00b4f	83 e2 03	 and	 edx, 3
  00b52	80 fa 03	 cmp	 dl, 3
  00b55	75 10		 jne	 SHORT $LN1720@bp
  00b57	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00b5c	74 09		 je	 SHORT $LN1720@bp
  00b5e	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00b62	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00b65	eb 07		 jmp	 SHORT $LN848@bp
$LN1720@bp:
  00b67	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  00b6b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN848@bp:
  00b6e	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00b71	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00b77	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00b7a	f6 c1 03	 test	 cl, 3
  00b7d	74 07		 je	 SHORT $LN1584@bp
  00b7f	8b c1		 mov	 eax, ecx
  00b81	e9 8e 05 00 00	 jmp	 $LN764@bp
$LN1584@bp:
  00b86	8b 01		 mov	 eax, DWORD PTR [ecx]
  00b88	a8 03		 test	 al, 3
  00b8a	0f 85 84 05 00
	00		 jne	 $LN764@bp
$LL845@bp:
  00b90	3b c8		 cmp	 ecx, eax
  00b92	0f 84 7c 05 00
	00		 je	 $LN764@bp
  00b98	8b c8		 mov	 ecx, eax
  00b9a	8b 00		 mov	 eax, DWORD PTR [eax]
  00b9c	a8 03		 test	 al, 3
  00b9e	74 f0		 je	 SHORT $LL845@bp
  00ba0	e9 6f 05 00 00	 jmp	 $LN764@bp
$LN856@bp:
  00ba5	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00ba8	0f 85 42 30 00
	00		 jne	 $LN1747@bp
  00bae	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  00bb2	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  00bb6	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]
  00bb9	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax
  00bbd	55		 push	 ebp
  00bbe	83 c0 04	 add	 eax, 4
  00bc1	52		 push	 edx
  00bc2	50		 push	 eax
  00bc3	8b c6		 mov	 eax, esi
  00bc5	c1 e8 15	 shr	 eax, 21			; 00000015H
  00bc8	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  00bcb	51		 push	 ecx
  00bcc	e8 00 00 00 00	 call	 _unify
  00bd1	83 c4 10	 add	 esp, 16			; 00000010H
  00bd4	85 c0		 test	 eax, eax
  00bd6	0f 84 14 30 00
	00		 je	 $LN1747@bp
  00bdc	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  00be0	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  00be4	55		 push	 ebp
  00be5	52		 push	 edx
  00be6	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00be9	83 c0 08	 add	 eax, 8
  00bec	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00bf2	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00bf5	50		 push	 eax
  00bf6	51		 push	 ecx
  00bf7	e8 00 00 00 00	 call	 _unify
  00bfc	83 c4 10	 add	 esp, 16			; 00000010H
  00bff	85 c0		 test	 eax, eax
  00c01	0f 84 e9 2f 00
	00		 je	 $LN1747@bp
  00c07	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  00c0b	83 c2 0c	 add	 edx, 12			; 0000000cH
  00c0e	89 54 24 20	 mov	 DWORD PTR _S$[esp+262196], edx

; 1821 :         NEXT(3)

  00c12	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1822 :         ;

  00c15	e9 39 f4 ff ff	 jmp	 $LL1041@bp
$LN838@bp:

; 1802 :         ;
; 1803 : 
; 1804 :       case GET_UNIFY_VAR_VAR:
; 1805 :         GSTR3(SREADARG(1,An),SREADARG(2,Ai),HNEWVAR(1,An),HNEWVAR(2,Ai))

  00c1a	c1 ee 15	 shr	 esi, 21			; 00000015H
  00c1d	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00c20	89 44 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], eax
  00c24	a8 03		 test	 al, 3
  00c26	74 04		 je	 SHORT $LN1585@bp
  00c28	8b c8		 mov	 ecx, eax
  00c2a	eb 1c		 jmp	 SHORT $LN834@bp
$LN1585@bp:
  00c2c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c2e	f6 c1 03	 test	 cl, 3
  00c31	0f 85 78 00 00
	00		 jne	 $LN833@bp
$LL835@bp:
  00c37	3b c1		 cmp	 eax, ecx
  00c39	74 09		 je	 SHORT $LN1743@bp
  00c3b	8b c1		 mov	 eax, ecx
  00c3d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00c3f	f6 c1 03	 test	 cl, 3
  00c42	74 f3		 je	 SHORT $LL835@bp
$LN1743@bp:
  00c44	89 44 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], eax
$LN834@bp:
  00c48	f6 c1 03	 test	 cl, 3
  00c4b	75 62		 jne	 SHORT $LN833@bp
  00c4d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  00c55	3b 45 f8	 cmp	 eax, DWORD PTR [ebp-8]
  00c58	73 37		 jae	 SHORT $LN832@bp
  00c5a	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  00c5e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c61	3b 51 38	 cmp	 edx, DWORD PTR [ecx+56]
  00c64	72 22		 jb	 SHORT $LN831@bp
  00c66	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00c6b	8b c1		 mov	 eax, ecx
  00c6d	50		 push	 eax
  00c6e	6a 01		 push	 1
  00c70	52		 push	 edx
  00c71	e8 00 00 00 00	 call	 _overflow_by
  00c76	6a 0c		 push	 12			; 0000000cH
  00c78	e8 00 00 00 00	 call	 _bp_halt
  00c7d	8b 44 24 2c	 mov	 eax, DWORD PTR _xref$83215[esp+262216]
  00c81	8b 4c 24 24	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262216]
  00c85	83 c4 14	 add	 esp, 20			; 00000014H
$LN831@bp:
  00c88	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c8b	89 02		 mov	 DWORD PTR [edx], eax
  00c8d	83 41 2c 04	 add	 DWORD PTR [ecx+44], 4
$LN832@bp:
  00c91	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  00c95	89 08		 mov	 DWORD PTR [eax], ecx
  00c97	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00c9a	83 c0 08	 add	 eax, 8
  00c9d	3b c8		 cmp	 ecx, eax
  00c9f	1b c0		 sbb	 eax, eax
  00ca1	f7 d8		 neg	 eax
  00ca3	f7 d8		 neg	 eax
  00ca5	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00ca8	89 11		 mov	 DWORD PTR [ecx], edx
  00caa	e9 91 01 00 00	 jmp	 $LN1752@bp
$LN833@bp:
  00caf	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  00cb2	0f 85 38 2f 00
	00		 jne	 $LN1747@bp
  00cb8	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00cbb	8b f1		 mov	 esi, ecx
  00cbd	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  00cc0	c1 ee 15	 shr	 esi, 21			; 00000015H
  00cc3	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
  00cc6	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00cc9	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
  00ccc	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00cd2	83 c0 0c	 add	 eax, 12			; 0000000cH
  00cd5	89 14 39	 mov	 DWORD PTR [ecx+edi], edx
  00cd8	89 44 24 20	 mov	 DWORD PTR _S$[esp+262196], eax
  00cdc	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1806 :         ;

  00cdf	e9 6f f3 ff ff	 jmp	 $LL1041@bp
$LN829@bp:

; 1807 : 
; 1808 :       case GET_UNIFY_VAR_VAL:
; 1809 :         GSTR3(SREADARG(1,An),SREADVAL(2,Ai),HNEWVAR(1,An),HNEWVAL(2,Ai))

  00ce4	c1 ee 15	 shr	 esi, 21			; 00000015H
  00ce7	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00cea	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  00cee	f6 c1 03	 test	 cl, 3
  00cf1	74 04		 je	 SHORT $LN1586@bp
  00cf3	8b c1		 mov	 eax, ecx
  00cf5	eb 1a		 jmp	 SHORT $LN825@bp
$LN1586@bp:
  00cf7	8b 01		 mov	 eax, DWORD PTR [ecx]
  00cf9	a8 03		 test	 al, 3
  00cfb	0f 85 d8 00 00
	00		 jne	 $LN824@bp
$LL826@bp:
  00d01	3b c8		 cmp	 ecx, eax
  00d03	74 08		 je	 SHORT $LN1744@bp
  00d05	8b c8		 mov	 ecx, eax
  00d07	8b 00		 mov	 eax, DWORD PTR [eax]
  00d09	a8 03		 test	 al, 3
  00d0b	74 f4		 je	 SHORT $LL826@bp
$LN1744@bp:
  00d0d	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
$LN825@bp:
  00d11	a8 03		 test	 al, 3
  00d13	0f 85 c0 00 00
	00		 jne	 $LN824@bp
  00d19	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _S$[esp+262196], 0
  00d21	3b 4d f8	 cmp	 ecx, DWORD PTR [ebp-8]
  00d24	73 35		 jae	 SHORT $LN823@bp
  00d26	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  00d2a	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00d2d	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  00d30	72 20		 jb	 SHORT $LN822@bp
  00d32	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OCCOLGAN@trailing?5in?5unify?$AA@
  00d37	50		 push	 eax
  00d38	6a 01		 push	 1
  00d3a	52		 push	 edx
  00d3b	e8 00 00 00 00	 call	 _overflow_by
  00d40	6a 0c		 push	 12			; 0000000cH
  00d42	e8 00 00 00 00	 call	 _bp_halt
  00d47	8b 4c 24 2c	 mov	 ecx, DWORD PTR _xref$83215[esp+262216]
  00d4b	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  00d4f	83 c4 14	 add	 esp, 20			; 00000014H
$LN822@bp:
  00d52	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00d55	89 0a		 mov	 DWORD PTR [edx], ecx
  00d57	83 40 2c 04	 add	 DWORD PTR [eax+44], 4
$LN823@bp:
  00d5b	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00d5f	89 01		 mov	 DWORD PTR [ecx], eax
  00d61	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00d64	83 c1 08	 add	 ecx, 8
  00d67	3b c1		 cmp	 eax, ecx
  00d69	1b c9		 sbb	 ecx, ecx
  00d6b	f7 d9		 neg	 ecx
  00d6d	f7 d9		 neg	 ecx
  00d6f	8d 34 88	 lea	 esi, DWORD PTR [eax+ecx*4]
  00d72	89 16		 mov	 DWORD PTR [esi], edx
  00d74	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00d77	8b d0		 mov	 edx, eax
  00d79	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00d7c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00d7f	c1 ea 15	 shr	 edx, 21			; 00000015H
  00d82	89 0c 3a	 mov	 DWORD PTR [edx+edi], ecx
  00d85	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00d8a	89 09		 mov	 DWORD PTR [ecx], ecx
  00d8c	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00d8f	a8 03		 test	 al, 3
  00d91	74 04		 je	 SHORT $LN1587@bp
  00d93	8b c8		 mov	 ecx, eax
  00d95	eb 16		 jmp	 SHORT $LN818@bp
$LN1587@bp:
  00d97	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d99	f6 c1 03	 test	 cl, 3
  00d9c	75 0f		 jne	 SHORT $LN818@bp
  00d9e	8b ff		 npad	 2
$LL819@bp:
  00da0	3b c1		 cmp	 eax, ecx
  00da2	74 09		 je	 SHORT $LN818@bp
  00da4	8b c1		 mov	 eax, ecx
  00da6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00da8	f6 c1 03	 test	 cl, 3
  00dab	74 f3		 je	 SHORT $LL819@bp
$LN818@bp:
  00dad	8b d1		 mov	 edx, ecx
  00daf	83 e2 03	 and	 edx, 3
  00db2	80 fa 03	 cmp	 dl, 3
  00db5	0f 85 06 04 00
	00		 jne	 $LN755@bp
  00dbb	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00dc1	0f 84 fa 03 00
	00		 je	 $LN755@bp
  00dc7	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1911 :         ;
; 1912 :         HNEXT(3);

  00dca	83 c6 0c	 add	 esi, 12			; 0000000cH
  00dcd	89 74 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], esi

; 1913 :         NEXT(3)

  00dd1	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1914 :         ;

  00dd4	e9 7a f2 ff ff	 jmp	 $LL1041@bp
$LN824@bp:

; 1807 : 
; 1808 :       case GET_UNIFY_VAR_VAL:
; 1809 :         GSTR3(SREADARG(1,An),SREADVAL(2,Ai),HNEWVAR(1,An),HNEWVAL(2,Ai))

  00dd9	3b 43 04	 cmp	 eax, DWORD PTR [ebx+4]
  00ddc	0f 85 0e 2e 00
	00		 jne	 $LN1747@bp
  00de2	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00de5	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  00de9	8b f0		 mov	 esi, eax
  00deb	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00dee	c1 ee 15	 shr	 esi, 21			; 00000015H
  00df1	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
  00df4	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  00df8	55		 push	 ebp
  00df9	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00dfc	89 4c 24 24	 mov	 DWORD PTR _S$[esp+262200], ecx
  00e00	52		 push	 edx
  00e01	83 c1 08	 add	 ecx, 8
  00e04	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00e09	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00e0c	51		 push	 ecx
  00e0d	50		 push	 eax
  00e0e	e8 00 00 00 00	 call	 _unify
  00e13	83 c4 10	 add	 esp, 16			; 00000010H
  00e16	85 c0		 test	 eax, eax
  00e18	0f 84 d2 2d 00
	00		 je	 $LN1747@bp
  00e1e	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  00e22	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00e25	89 4c 24 20	 mov	 DWORD PTR _S$[esp+262196], ecx
  00e29	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1810 :         ;

  00e2c	e9 22 f2 ff ff	 jmp	 $LL1041@bp
$LN813@bp:

; 1811 : 
; 1812 :       case PUT_WRITE_VAR_VAR:
; 1813 :         PSTR()

  00e31	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00e34	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]

; 1814 :         ;

  00e38	c1 ee 15	 shr	 esi, 21			; 00000015H
  00e3b	89 11		 mov	 DWORD PTR [ecx], edx
  00e3d	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
$LN1752@bp:

; 1815 :         GETFIELDS(2);

  00e40	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 1816 :         HNEWVAR(1,An)

  00e43	8b f0		 mov	 esi, eax
  00e45	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00e48	c1 ee 15	 shr	 esi, 21			; 00000015H
  00e4b	89 14 3e	 mov	 DWORD PTR [esi+edi], edx

; 1817 :         ;

  00e4e	89 12		 mov	 DWORD PTR [edx], edx

; 1818 :         HNEWVAR(2,Ai)

  00e50	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00e53	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  00e56	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH

; 1819 :         ;
; 1820 :         HNEXT(3);

  00e5b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00e5e	89 14 38	 mov	 DWORD PTR [eax+edi], edx
  00e61	89 12		 mov	 DWORD PTR [edx], edx
  00e63	89 4c 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], ecx

; 1821 :         NEXT(3)

  00e67	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1822 :         ;

  00e6a	e9 e4 f1 ff ff	 jmp	 $LL1041@bp
$LN812@bp:

; 1823 : 
; 1824 :       case PUT_WRITE_VAL_VAR:
; 1825 :         PSTR()

  00e6f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00e72	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1826 :         ;

  00e76	c1 ee 15	 shr	 esi, 21			; 00000015H
  00e79	89 08		 mov	 DWORD PTR [eax], ecx
  00e7b	89 04 3e	 mov	 DWORD PTR [esi+edi], eax

; 1827 :         GETFIELDS(2);

  00e7e	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1828 :         HW_VAL(1,An)

  00e81	8b d6		 mov	 edx, esi
  00e83	c1 ea 15	 shr	 edx, 21			; 00000015H
  00e86	8b 0c 3a	 mov	 ecx, DWORD PTR [edx+edi]
  00e89	f6 c1 03	 test	 cl, 3
  00e8c	74 07		 je	 SHORT $LN1588@bp
  00e8e	8b c1		 mov	 eax, ecx
  00e90	e9 b7 01 00 00	 jmp	 $LN778@bp
$LN1588@bp:
  00e95	8b 01		 mov	 eax, DWORD PTR [ecx]
  00e97	a8 03		 test	 al, 3
  00e99	0f 85 ad 01 00
	00		 jne	 $LN778@bp
  00e9f	90		 npad	 1
$LL809@bp:
  00ea0	3b c8		 cmp	 ecx, eax
  00ea2	0f 84 a4 01 00
	00		 je	 $LN778@bp
  00ea8	8b c8		 mov	 ecx, eax
  00eaa	8b 00		 mov	 eax, DWORD PTR [eax]
  00eac	a8 03		 test	 al, 3
  00eae	74 f0		 je	 SHORT $LL809@bp
  00eb0	e9 97 01 00 00	 jmp	 $LN778@bp
$LN805@bp:

; 1829 :         ;
; 1830 :         HNEWVAR(2,Ai)
; 1831 :         ;
; 1832 :         HNEXT(3);
; 1833 :         NEXT(3)
; 1834 :         ;
; 1835 : 
; 1836 :       case PUT_WRITE_VAL_VAL:
; 1837 :         PSTR()

  00eb5	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00eb8	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1838 :         ;

  00ebc	c1 ee 15	 shr	 esi, 21			; 00000015H
  00ebf	89 08		 mov	 DWORD PTR [eax], ecx
  00ec1	89 04 3e	 mov	 DWORD PTR [esi+edi], eax

; 1839 :         GETFIELDS(2);

  00ec4	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1840 :         HW_VAL(1,An)

  00ec7	8b d6		 mov	 edx, esi
  00ec9	c1 ea 15	 shr	 edx, 21			; 00000015H
  00ecc	8b 0c 3a	 mov	 ecx, DWORD PTR [edx+edi]
  00ecf	f6 c1 03	 test	 cl, 3
  00ed2	74 04		 je	 SHORT $LN1589@bp
  00ed4	8b c1		 mov	 eax, ecx
  00ed6	eb 14		 jmp	 SHORT $LN801@bp
$LN1589@bp:
  00ed8	8b 01		 mov	 eax, DWORD PTR [ecx]
  00eda	a8 03		 test	 al, 3
  00edc	75 0e		 jne	 SHORT $LN801@bp
  00ede	8b ff		 npad	 2
$LL802@bp:
  00ee0	3b c8		 cmp	 ecx, eax
  00ee2	74 08		 je	 SHORT $LN801@bp
  00ee4	8b c8		 mov	 ecx, eax
  00ee6	8b 00		 mov	 eax, DWORD PTR [eax]
  00ee8	a8 03		 test	 al, 3
  00eea	74 f4		 je	 SHORT $LL802@bp
$LN801@bp:
  00eec	8b d0		 mov	 edx, eax
  00eee	83 e2 03	 and	 edx, 3
  00ef1	80 fa 03	 cmp	 dl, 3
  00ef4	75 10		 jne	 SHORT $LN1721@bp
  00ef6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00efb	74 09		 je	 SHORT $LN1721@bp
  00efd	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  00f01	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00f04	eb 07		 jmp	 SHORT $LN799@bp
$LN1721@bp:
  00f06	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  00f0a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN799@bp:

; 1841 :         ;
; 1842 :         HW_VAL(2,Ai)

  00f0d	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  00f10	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  00f16	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  00f19	f6 c1 03	 test	 cl, 3
  00f1c	74 07		 je	 SHORT $LN1590@bp
  00f1e	8b c1		 mov	 eax, ecx
  00f20	e9 ef 01 00 00	 jmp	 $LN764@bp
$LN1590@bp:
  00f25	8b 01		 mov	 eax, DWORD PTR [ecx]
  00f27	a8 03		 test	 al, 3
  00f29	0f 85 e5 01 00
	00		 jne	 $LN764@bp
  00f2f	90		 npad	 1
$LL796@bp:
  00f30	3b c8		 cmp	 ecx, eax
  00f32	0f 84 dc 01 00
	00		 je	 $LN764@bp
  00f38	8b c8		 mov	 ecx, eax
  00f3a	8b 00		 mov	 eax, DWORD PTR [eax]
  00f3c	a8 03		 test	 al, 3
  00f3e	74 f0		 je	 SHORT $LL796@bp
  00f40	e9 cf 01 00 00	 jmp	 $LN764@bp
$LN792@bp:

; 1843 :         ;
; 1844 :         HNEXT(3);
; 1845 :         NEXT(3)
; 1846 :         ;
; 1847 : 
; 1848 :       case PUT_WRITE_VAR_VAL:
; 1849 :         PSTR()

  00f45	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00f48	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  00f4c	89 11		 mov	 DWORD PTR [ecx], edx

; 1850 :         ;

  00f4e	c1 ee 15	 shr	 esi, 21			; 00000015H
  00f51	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx

; 1851 :         GETFIELDS(2);

  00f54	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 1852 :         HNEWVAR(1,An)

  00f57	8b d0		 mov	 edx, eax
  00f59	83 c1 04	 add	 ecx, 4

; 1853 :         ;
; 1854 :         HW_VAL(2,Ai)

  00f5c	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00f5f	c1 ea 15	 shr	 edx, 21			; 00000015H
  00f62	89 0c 3a	 mov	 DWORD PTR [edx+edi], ecx
  00f65	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00f6a	89 09		 mov	 DWORD PTR [ecx], ecx
  00f6c	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00f6f	a8 03		 test	 al, 3
  00f71	74 04		 je	 SHORT $LN1591@bp
  00f73	8b c8		 mov	 ecx, eax
  00f75	eb 16		 jmp	 SHORT $LN788@bp
$LN1591@bp:
  00f77	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f79	f6 c1 03	 test	 cl, 3
  00f7c	75 0f		 jne	 SHORT $LN788@bp
  00f7e	8b ff		 npad	 2
$LL789@bp:
  00f80	3b c1		 cmp	 eax, ecx
  00f82	74 09		 je	 SHORT $LN788@bp
  00f84	8b c1		 mov	 eax, ecx
  00f86	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f88	f6 c1 03	 test	 cl, 3
  00f8b	74 f3		 je	 SHORT $LL789@bp
$LN788@bp:
  00f8d	8b d1		 mov	 edx, ecx
  00f8f	83 e2 03	 and	 edx, 3
  00f92	80 fa 03	 cmp	 dl, 3
  00f95	75 1c		 jne	 SHORT $LN787@bp
  00f97	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00f9d	74 14		 je	 SHORT $LN787@bp
  00f9f	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]

; 1855 :         ;
; 1856 :         HNEXT(3);

  00fa3	83 44 24 14 0c	 add	 DWORD PTR _H$GSCopy$[esp+262196], 12 ; 0000000cH
  00fa8	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1857 :         NEXT(3)

  00fab	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1858 :         ;

  00fae	e9 a0 f0 ff ff	 jmp	 $LL1041@bp
$LN787@bp:

; 1853 :         ;
; 1854 :         HW_VAL(2,Ai)

  00fb3	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]

; 1855 :         ;
; 1856 :         HNEXT(3);

  00fb7	83 44 24 14 0c	 add	 DWORD PTR _H$GSCopy$[esp+262196], 12 ; 0000000cH
  00fbc	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1857 :         NEXT(3)

  00fbf	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1858 :         ;

  00fc2	e9 8c f0 ff ff	 jmp	 $LL1041@bp
$LN785@bp:

; 1859 : 
; 1860 :       case PUSH_VAR_VAR:
; 1861 :         PUSH_TO_REG()
; 1862 :         ;

  00fc7	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  00fcb	c1 ee 15	 shr	 esi, 21			; 00000015H
  00fce	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  00fd1	89 10		 mov	 DWORD PTR [eax], edx
  00fd3	eb 04		 jmp	 SHORT $LN784@bp
$LN1722@bp:
  00fd5	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
$LN784@bp:

; 1863 :       case CONSTANT_VAR_VAR:
; 1864 :         HNEWFUN(P);

  00fd9	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00fdc	89 0a		 mov	 DWORD PTR [edx], ecx

; 1865 :         GETFIELDS(2);

  00fde	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 1866 :         HNEWVAR(1,An)

  00fe1	8b f0		 mov	 esi, eax
  00fe3	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  00fe6	c1 ee 15	 shr	 esi, 21			; 00000015H
  00fe9	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx

; 1867 :         ;

  00fec	89 09		 mov	 DWORD PTR [ecx], ecx

; 1868 :         HNEWVAR(2,Ai)

  00fee	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  00ff1	8d 4a 08	 lea	 ecx, DWORD PTR [edx+8]
  00ff4	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH

; 1869 :         ;
; 1870 :         HNEXT(3);

  00ff9	83 c2 0c	 add	 edx, 12			; 0000000cH
  00ffc	89 0c 38	 mov	 DWORD PTR [eax+edi], ecx
  00fff	89 09		 mov	 DWORD PTR [ecx], ecx
  01001	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx

; 1871 :         NEXT(3)

  01005	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1872 :         ;

  01008	e9 46 f0 ff ff	 jmp	 $LL1041@bp
$LN783@bp:

; 1873 : 
; 1874 :       case PUSH_VAL_VAR:
; 1875 :         PUSH_TO_REG()
; 1876 :         ;

  0100d	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  01011	c1 ee 15	 shr	 esi, 21			; 00000015H
  01014	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01017	89 02		 mov	 DWORD PTR [edx], eax
$LN1723@bp:

; 1877 :       case CONSTANT_VAL_VAR:
; 1878 :         HNEWFUN(P);

  01019	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0101c	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  01020	89 0a		 mov	 DWORD PTR [edx], ecx

; 1879 :         GETFIELDS(2);

  01022	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1880 :         HW_VAL(1,An)

  01025	8b c6		 mov	 eax, esi
  01027	c1 e8 15	 shr	 eax, 21			; 00000015H
  0102a	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  0102d	f6 c1 03	 test	 cl, 3
  01030	74 04		 je	 SHORT $LN1592@bp
  01032	8b c1		 mov	 eax, ecx
  01034	eb 16		 jmp	 SHORT $LN778@bp
$LN1592@bp:
  01036	8b 01		 mov	 eax, DWORD PTR [ecx]
  01038	a8 03		 test	 al, 3
  0103a	75 10		 jne	 SHORT $LN778@bp
  0103c	8d 64 24 00	 npad	 4
$LL779@bp:
  01040	3b c8		 cmp	 ecx, eax
  01042	74 08		 je	 SHORT $LN778@bp
  01044	8b c8		 mov	 ecx, eax
  01046	8b 00		 mov	 eax, DWORD PTR [eax]
  01048	a8 03		 test	 al, 3
  0104a	74 f4		 je	 SHORT $LL779@bp
$LN778@bp:
  0104c	8b d0		 mov	 edx, eax
  0104e	83 e2 03	 and	 edx, 3
  01051	80 fa 03	 cmp	 dl, 3
  01054	75 10		 jne	 SHORT $LN777@bp
  01056	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0105b	74 09		 je	 SHORT $LN777@bp
  0105d	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  01061	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  01064	eb 07		 jmp	 SHORT $LN776@bp
$LN777@bp:
  01066	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  0106a	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN776@bp:

; 1881 :         ;
; 1882 :         HNEWVAR(2,Ai)

  0106d	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  01070	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  01073	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH

; 1883 :         ;
; 1884 :         HNEXT(3);

  01079	83 c2 0c	 add	 edx, 12			; 0000000cH
  0107c	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  0107f	89 00		 mov	 DWORD PTR [eax], eax
  01081	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx

; 1885 :         NEXT(3)

  01085	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1886 :         ;

  01088	e9 c6 ef ff ff	 jmp	 $LL1041@bp
$LN775@bp:

; 1887 : 
; 1888 :       case PUSH_VAL_VAL:
; 1889 :         PUSH_TO_REG()
; 1890 :         ;

  0108d	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  01091	c1 ee 15	 shr	 esi, 21			; 00000015H
  01094	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  01097	89 08		 mov	 DWORD PTR [eax], ecx
$LN1724@bp:

; 1891 :       case CONSTANT_VAL_VAL:
; 1892 :         HNEWFUN(P);

  01099	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0109c	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  010a0	89 10		 mov	 DWORD PTR [eax], edx

; 1893 :         GETFIELDS(2);

  010a2	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 1894 :         HW_VAL(1,An)

  010a5	8b ce		 mov	 ecx, esi
  010a7	c1 e9 15	 shr	 ecx, 21			; 00000015H
  010aa	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  010ad	f6 c1 03	 test	 cl, 3
  010b0	74 04		 je	 SHORT $LN1593@bp
  010b2	8b c1		 mov	 eax, ecx
  010b4	eb 16		 jmp	 SHORT $LN770@bp
$LN1593@bp:
  010b6	8b 01		 mov	 eax, DWORD PTR [ecx]
  010b8	a8 03		 test	 al, 3
  010ba	75 10		 jne	 SHORT $LN770@bp
  010bc	8d 64 24 00	 npad	 4
$LL771@bp:
  010c0	3b c8		 cmp	 ecx, eax
  010c2	74 08		 je	 SHORT $LN770@bp
  010c4	8b c8		 mov	 ecx, eax
  010c6	8b 00		 mov	 eax, DWORD PTR [eax]
  010c8	a8 03		 test	 al, 3
  010ca	74 f4		 je	 SHORT $LL771@bp
$LN770@bp:
  010cc	8b d0		 mov	 edx, eax
  010ce	83 e2 03	 and	 edx, 3
  010d1	80 fa 03	 cmp	 dl, 3
  010d4	75 10		 jne	 SHORT $LN1725@bp
  010d6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  010db	74 09		 je	 SHORT $LN1725@bp
  010dd	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  010e1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  010e4	eb 07		 jmp	 SHORT $LN768@bp
$LN1725@bp:
  010e6	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  010ea	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN768@bp:

; 1895 :         ;
; 1896 :         HW_VAL(2,Ai)

  010ed	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  010f0	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  010f6	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  010f9	f6 c1 03	 test	 cl, 3
  010fc	74 04		 je	 SHORT $LN1594@bp
  010fe	8b c1		 mov	 eax, ecx
  01100	eb 12		 jmp	 SHORT $LN764@bp
$LN1594@bp:
  01102	8b 01		 mov	 eax, DWORD PTR [ecx]
  01104	a8 03		 test	 al, 3
  01106	75 0c		 jne	 SHORT $LN764@bp
$LL765@bp:
  01108	3b c8		 cmp	 ecx, eax
  0110a	74 08		 je	 SHORT $LN764@bp
  0110c	8b c8		 mov	 ecx, eax
  0110e	8b 00		 mov	 eax, DWORD PTR [eax]
  01110	a8 03		 test	 al, 3
  01112	74 f4		 je	 SHORT $LL765@bp
$LN764@bp:
  01114	8b d0		 mov	 edx, eax
  01116	83 e2 03	 and	 edx, 3
  01119	80 fa 03	 cmp	 dl, 3
  0111c	75 1b		 jne	 SHORT $LN763@bp
  0111e	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  01123	74 14		 je	 SHORT $LN763@bp
  01125	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 1897 :         ;
; 1898 :         HNEXT(3);

  01129	83 44 24 14 0c	 add	 DWORD PTR _H$GSCopy$[esp+262196], 12 ; 0000000cH
  0112e	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1899 :         NEXT(3)

  01131	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1900 :         ;

  01134	e9 1a ef ff ff	 jmp	 $LL1041@bp
$LN763@bp:

; 1895 :         ;
; 1896 :         HW_VAL(2,Ai)

  01139	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]

; 1897 :         ;
; 1898 :         HNEXT(3);

  0113d	83 44 24 14 0c	 add	 DWORD PTR _H$GSCopy$[esp+262196], 12 ; 0000000cH
  01142	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1899 :         NEXT(3)

  01145	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1900 :         ;

  01148	e9 06 ef ff ff	 jmp	 $LL1041@bp
$LN761@bp:

; 1901 : 
; 1902 :       case PUSH_VAR_VAL:
; 1903 :         PUSH_TO_REG()

  0114d	c1 ee 15	 shr	 esi, 21			; 00000015H
  01150	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]

; 1904 :         ;

  01153	8b 74 24 14	 mov	 esi, DWORD PTR _H$GSCopy$[esp+262196]
  01157	89 32		 mov	 DWORD PTR [edx], esi
  01159	eb 04		 jmp	 SHORT $LN760@bp
$LN1726@bp:
  0115b	8b 74 24 14	 mov	 esi, DWORD PTR _H$GSCopy$[esp+262196]
$LN760@bp:

; 1905 :       case CONSTANT_VAR_VAL:
; 1906 :         HNEWFUN(P);

  0115f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  01162	89 06		 mov	 DWORD PTR [esi], eax

; 1907 :         GETFIELDS(2);

  01164	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 1908 :         HNEWVAR(1,An)

  01167	8b d0		 mov	 edx, eax

; 1909 :         ;
; 1910 :         HW_VAL(2,Ai)

  01169	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  0116c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0116f	c1 ea 15	 shr	 edx, 21			; 00000015H
  01172	89 0c 3a	 mov	 DWORD PTR [edx+edi], ecx
  01175	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0117a	89 09		 mov	 DWORD PTR [ecx], ecx
  0117c	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0117f	a8 03		 test	 al, 3
  01181	74 04		 je	 SHORT $LN1595@bp
  01183	8b c8		 mov	 ecx, eax
  01185	eb 16		 jmp	 SHORT $LN756@bp
$LN1595@bp:
  01187	8b 08		 mov	 ecx, DWORD PTR [eax]
  01189	f6 c1 03	 test	 cl, 3
  0118c	75 0f		 jne	 SHORT $LN756@bp
  0118e	8b ff		 npad	 2
$LL757@bp:
  01190	3b c1		 cmp	 eax, ecx
  01192	74 09		 je	 SHORT $LN756@bp
  01194	8b c1		 mov	 eax, ecx
  01196	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01198	f6 c1 03	 test	 cl, 3
  0119b	74 f3		 je	 SHORT $LL757@bp
$LN756@bp:
  0119d	8b d1		 mov	 edx, ecx
  0119f	83 e2 03	 and	 edx, 3
  011a2	80 fa 03	 cmp	 dl, 3
  011a5	75 1a		 jne	 SHORT $LN755@bp
  011a7	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  011ad	74 12		 je	 SHORT $LN755@bp
  011af	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1911 :         ;
; 1912 :         HNEXT(3);

  011b2	83 c6 0c	 add	 esi, 12			; 0000000cH
  011b5	89 74 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], esi

; 1913 :         NEXT(3)

  011b9	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1914 :         ;

  011bc	e9 92 ee ff ff	 jmp	 $LL1041@bp
$LN755@bp:

; 1909 :         ;
; 1910 :         HW_VAL(2,Ai)

  011c1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 1911 :         ;
; 1912 :         HNEXT(3);

  011c4	83 c6 0c	 add	 esi, 12			; 0000000cH
  011c7	89 74 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], esi

; 1913 :         NEXT(3)

  011cb	83 c3 0c	 add	 ebx, 12			; 0000000cH

; 1914 :         ;

  011ce	e9 80 ee ff ff	 jmp	 $LL1041@bp
$LN753@bp:

; 1915 : #endif
; 1916 : 
; 1917 : #if JUMP_COMPRESS
; 1918 :       case EXEC_TRY:
; 1919 :         EXEC0()

  011d3	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  011da	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  011dd	0f 85 f5 f5 ff
	ff		 jne	 $LN1037@bp
  011e3	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  011e7	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  011eb	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  011ef	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  011f2	72 1b		 jb	 SHORT $LN750@bp
  011f4	8b d1		 mov	 edx, ecx
  011f6	52		 push	 edx
  011f7	53		 push	 ebx
  011f8	55		 push	 ebp
  011f9	57		 push	 edi
  011fa	50		 push	 eax
  011fb	e8 00 00 00 00	 call	 _trigger_gc
  01200	83 c4 14	 add	 esp, 20			; 00000014H
  01203	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  01207	85 c0		 test	 eax, eax
  01209	0f 84 17 2c 00
	00		 je	 $LN1624@bp
$LN750@bp:

; 1920 :         ;
; 1921 :         GETFIELDS(0);

  0120f	8b 33		 mov	 esi, DWORD PTR [ebx]
$LN749@bp:

; 1922 : #endif
; 1923 : 
; 1924 :       case TRY_ME_ELSE:
; 1925 :         xval = REGFIELD;
; 1926 :         IF_OVER("TRY_ME_ELSE",A,ChoiceStk,RECOVER())

  01211	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01215	c1 ee 17	 shr	 esi, 23			; 00000017H
  01218	89 74 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], esi
  0121c	3b 69 5c	 cmp	 ebp, DWORD PTR [ecx+92]
  0121f	0f 83 2b 2c 00
	00		 jae	 $LN1625@bp

; 1927 :         ;
; 1928 :         MAKE_CHOICE_POINT(GETLABEL(P),xval)

  01225	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0122c	85 c9		 test	 ecx, ecx
  0122e	74 18		 je	 SHORT $LN745@bp
  01230	8b d7		 mov	 edx, edi
  01232	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  01235	2b d5		 sub	 edx, ebp
$LL747@bp:
  01237	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  0123a	89 30		 mov	 DWORD PTR [eax], esi
  0123c	83 e8 04	 sub	 eax, 4
  0123f	83 e9 04	 sub	 ecx, 4
  01242	75 f3		 jne	 SHORT $LL747@bp
  01244	8b 74 24 1c	 mov	 esi, DWORD PTR _xval$83216[esp+262196]
$LN745@bp:
  01248	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  0124c	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  01250	8d 6c b5 0c	 lea	 ebp, DWORD PTR [ebp+esi*4+12]
  01254	89 55 f8	 mov	 DWORD PTR [ebp-8], edx
  01257	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0125a	89 4d fc	 mov	 DWORD PTR [ebp-4], ecx

; 1929 :         ;

  0125d	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01260	89 55 00	 mov	 DWORD PTR [ebp], edx

; 1930 :         NEXT(2)

  01263	83 c3 08	 add	 ebx, 8

; 1931 :         ;

  01266	e9 e8 ed ff ff	 jmp	 $LL1041@bp
$LN744@bp:

; 1932 : 
; 1933 :       case RETRY_ME_ELSE:
; 1934 :         xval = REGFIELD;
; 1935 :         SAVED_P = GETLABEL(P); /* also: SAVED_P=GETLABEL(SAVED_P); */

  0126b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 1936 :         RESTORE_STATE(xval)

  0126e	8b 4d fc	 mov	 ecx, DWORD PTR [ebp-4]
  01271	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  01275	89 45 00	 mov	 DWORD PTR [ebp], eax
  01278	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0127b	51		 push	 ecx
  0127c	50		 push	 eax
  0127d	c1 ee 17	 shr	 esi, 23			; 00000017H
  01280	e8 00 00 00 00	 call	 _unwind_trail
  01285	8b 4c 24 18	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262204]
  01289	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  0128c	8b 55 f8	 mov	 edx, DWORD PTR [ebp-8]
  0128f	8d 0c b5 0c 00
	00 00		 lea	 ecx, DWORD PTR [esi*4+12]
  01296	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  0129d	83 c4 08	 add	 esp, 8
  012a0	2b e9		 sub	 ebp, ecx
  012a2	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx
  012a6	89 4c 24 24	 mov	 DWORD PTR tv6030[esp+262196], ecx
  012aa	85 c0		 test	 eax, eax
  012ac	74 18		 je	 SHORT $LN741@bp
  012ae	8b f5		 mov	 esi, ebp
  012b0	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  012b3	2b f7		 sub	 esi, edi
$LL743@bp:
  012b5	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  012b8	89 11		 mov	 DWORD PTR [ecx], edx
  012ba	83 e9 04	 sub	 ecx, 4
  012bd	83 e8 04	 sub	 eax, 4
  012c0	75 f3		 jne	 SHORT $LL743@bp
  012c2	8b 4c 24 24	 mov	 ecx, DWORD PTR tv6030[esp+262196]
$LN741@bp:

; 1937 :         ;

  012c6	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp

; 1938 :         A += xval + 3;

  012ca	03 e9		 add	 ebp, ecx

; 1939 :         NEXT(2)

  012cc	83 c3 08	 add	 ebx, 8

; 1940 :         ;

  012cf	e9 7f ed ff ff	 jmp	 $LL1041@bp
$LN740@bp:

; 1941 : 
; 1942 :       case TRUST_ME_ELSE:
; 1943 :         xval = REGFIELD;
; 1944 :         RESTORE_STATE(xval)

  012d4	8b 45 fc	 mov	 eax, DWORD PTR [ebp-4]
  012d7	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  012db	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  012de	50		 push	 eax
  012df	52		 push	 edx
  012e0	c1 ee 17	 shr	 esi, 23			; 00000017H
  012e3	e8 00 00 00 00	 call	 _unwind_trail
  012e8	8b 4c 24 18	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262204]
  012ec	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  012ef	8b 55 f8	 mov	 edx, DWORD PTR [ebp-8]
  012f2	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  012f7	2b c6		 sub	 eax, esi
  012f9	8d 6c 85 00	 lea	 ebp, DWORD PTR [ebp+eax*4]
  012fd	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  01304	83 c4 08	 add	 esp, 8
  01307	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx
  0130b	85 c0		 test	 eax, eax
  0130d	74 14		 je	 SHORT $LN737@bp
  0130f	8b d5		 mov	 edx, ebp
  01311	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  01314	2b d7		 sub	 edx, edi
$LL739@bp:
  01316	8b 34 11	 mov	 esi, DWORD PTR [ecx+edx]
  01319	89 31		 mov	 DWORD PTR [ecx], esi
  0131b	83 e9 04	 sub	 ecx, 4
  0131e	83 e8 04	 sub	 eax, 4
  01321	75 f3		 jne	 SHORT $LL739@bp
$LN737@bp:

; 1945 :         ;

  01323	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp

; 1946 :         NEXT(2)

  01327	83 c3 08	 add	 ebx, 8

; 1947 :         ;

  0132a	e9 24 ed ff ff	 jmp	 $LL1041@bp
$LN734@bp:

; 1959 : #else
; 1960 :         NEXT(2);
; 1961 : #endif
; 1962 : 
; 1963 :       case UNIFY_VOID:
; 1964 :         if (S) {

  0132f	8b 44 24 20	 mov	 eax, DWORD PTR _S$[esp+262196]
  01333	85 c0		 test	 eax, eax
  01335	74 12		 je	 SHORT $LN1727@bp

; 1965 :           xval = On;

  01337	c1 ee 17	 shr	 esi, 23			; 00000017H

; 1966 :           SNEXT(xval);

  0133a	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  0133d	89 4c 24 20	 mov	 DWORD PTR _S$[esp+262196], ecx

; 1967 :           NEXT(1)

  01341	83 c3 04	 add	 ebx, 4

; 1968 :           ;

  01344	e9 0a ed ff ff	 jmp	 $LL1041@bp
$LN1727@bp:

; 1969 :         }
; 1970 :       case WRITE_VOID:
; 1971 :         xval = On;
; 1972 :         xref = H;
; 1973 :         HNEXT(xval);

  01349	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  0134d	c1 ee 17	 shr	 esi, 23			; 00000017H
  01350	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
  01353	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 1974 :         while (xval--)

  01357	85 f6		 test	 esi, esi
  01359	74 0d		 je	 SHORT $LN1728@bp
  0135b	eb 03 8d 49 00	 npad	 5
$LL731@bp:
  01360	83 e8 04	 sub	 eax, 4
  01363	4e		 dec	 esi

; 1975 :           xref[xval] = T2C(xref+xval);

  01364	89 00		 mov	 DWORD PTR [eax], eax
  01366	75 f8		 jne	 SHORT $LL731@bp
$LN1728@bp:

; 1976 :         NEXT(1)

  01368	83 c3 04	 add	 ebx, 4

; 1977 :         ;

  0136b	e9 e3 ec ff ff	 jmp	 $LL1041@bp
$LN729@bp:

; 1978 : 
; 1979 :         /* INLINE ARGUMENT LOADERS */
; 1980 : 
; 1981 :       case LOAD_CONSTANT:
; 1982 :         xval = REGFIELD;
; 1983 :         X((bp_long)xval) = GETFUN(P);

  01370	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  01373	c1 ee 17	 shr	 esi, 23			; 00000017H
  01376	03 f6		 add	 esi, esi
  01378	03 f6		 add	 esi, esi
  0137a	8b c7		 mov	 eax, edi
  0137c	2b c6		 sub	 eax, esi
  0137e	89 08		 mov	 DWORD PTR [eax], ecx
$LN1705@bp:

; 1984 :         NEXT(2)

  01380	83 c3 08	 add	 ebx, 8

; 1985 :         ;

  01383	e9 cb ec ff ff	 jmp	 $LL1041@bp
$LN728@bp:

; 1986 : 
; 1987 : #if STRUCT_COMPRESS
; 1988 :       case LOAD_VAL_SHORT:
; 1989 :         xval = REGFIELD;

  01388	8b d6		 mov	 edx, esi

; 1990 :         X(2) = xval;
; 1991 :         IN_VALUE(1,Ai)

  0138a	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  0138d	c1 ea 17	 shr	 edx, 23			; 00000017H
  01390	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  01396	89 57 f8	 mov	 DWORD PTR [edi-8], edx
  01399	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  0139c	f6 c1 03	 test	 cl, 3
  0139f	74 0b		 je	 SHORT $LN1600@bp
  013a1	89 4f fc	 mov	 DWORD PTR [edi-4], ecx

; 1992 :         ;
; 1993 :         NEXT(1)

  013a4	83 c3 04	 add	 ebx, 4

; 1994 :         ;

  013a7	e9 a7 ec ff ff	 jmp	 $LL1041@bp
$LN1600@bp:

; 1990 :         X(2) = xval;
; 1991 :         IN_VALUE(1,Ai)

  013ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  013ae	a8 03		 test	 al, 3
  013b0	75 0c		 jne	 SHORT $LN724@bp
$LL725@bp:
  013b2	3b c8		 cmp	 ecx, eax
  013b4	74 08		 je	 SHORT $LN724@bp
  013b6	8b c8		 mov	 ecx, eax
  013b8	8b 00		 mov	 eax, DWORD PTR [eax]
  013ba	a8 03		 test	 al, 3
  013bc	74 f4		 je	 SHORT $LL725@bp
$LN724@bp:
  013be	8b d0		 mov	 edx, eax
  013c0	83 e2 03	 and	 edx, 3
  013c3	80 fa 03	 cmp	 dl, 3
  013c6	75 09		 jne	 SHORT $LN1044@bp
  013c8	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  013cd	74 02		 je	 SHORT $LN1044@bp
  013cf	8b c1		 mov	 eax, ecx
$LN1044@bp:
  013d1	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 1992 :         ;
; 1993 :         NEXT(1)

  013d4	83 c3 04	 add	 ebx, 4

; 1994 :         ;

  013d7	e9 77 ec ff ff	 jmp	 $LL1041@bp
$LN723@bp:

; 1995 : 
; 1996 :       case LOAD_VALUEx2:
; 1997 :         IN_VALUE(1,Ai)

  013dc	8b c6		 mov	 eax, esi
  013de	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  013e1	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  013e6	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]
  013e9	f6 c1 03	 test	 cl, 3
  013ec	74 05		 je	 SHORT $LN1601@bp
  013ee	89 4f fc	 mov	 DWORD PTR [edi-4], ecx
  013f1	eb 2f		 jmp	 SHORT $LN721@bp
$LN1601@bp:
  013f3	8b 01		 mov	 eax, DWORD PTR [ecx]
  013f5	a8 03		 test	 al, 3
  013f7	75 13		 jne	 SHORT $LN719@bp
  013f9	8d a4 24 00 00
	00 00		 npad	 7
$LL720@bp:
  01400	3b c8		 cmp	 ecx, eax
  01402	74 08		 je	 SHORT $LN719@bp
  01404	8b c8		 mov	 ecx, eax
  01406	8b 00		 mov	 eax, DWORD PTR [eax]
  01408	a8 03		 test	 al, 3
  0140a	74 f4		 je	 SHORT $LL720@bp
$LN719@bp:
  0140c	8b d0		 mov	 edx, eax
  0140e	83 e2 03	 and	 edx, 3
  01411	80 fa 03	 cmp	 dl, 3
  01414	75 09		 jne	 SHORT $LN1729@bp
  01416	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0141b	74 02		 je	 SHORT $LN1729@bp
  0141d	8b c1		 mov	 eax, ecx
$LN1729@bp:
  0141f	89 47 fc	 mov	 DWORD PTR [edi-4], eax
$LN721@bp:

; 1998 :         ;
; 1999 :         IN_VALUE(2,An)

  01422	c1 ee 15	 shr	 esi, 21			; 00000015H
  01425	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  01428	f6 c1 03	 test	 cl, 3
  0142b	74 0b		 je	 SHORT $LN1602@bp
  0142d	89 4f f8	 mov	 DWORD PTR [edi-8], ecx

; 2000 :         ;
; 2001 :         NEXT(1)

  01430	83 c3 04	 add	 ebx, 4

; 2002 :         ;

  01433	e9 1b ec ff ff	 jmp	 $LL1041@bp
$LN1602@bp:

; 1998 :         ;
; 1999 :         IN_VALUE(2,An)

  01438	8b 01		 mov	 eax, DWORD PTR [ecx]
  0143a	a8 03		 test	 al, 3
  0143c	75 0e		 jne	 SHORT $LN715@bp
  0143e	8b ff		 npad	 2
$LL716@bp:
  01440	3b c8		 cmp	 ecx, eax
  01442	74 08		 je	 SHORT $LN715@bp
  01444	8b c8		 mov	 ecx, eax
  01446	8b 00		 mov	 eax, DWORD PTR [eax]
  01448	a8 03		 test	 al, 3
  0144a	74 f4		 je	 SHORT $LL716@bp
$LN715@bp:
  0144c	8b d0		 mov	 edx, eax
  0144e	83 e2 03	 and	 edx, 3
  01451	80 fa 03	 cmp	 dl, 3
  01454	75 09		 jne	 SHORT $LN1048@bp
  01456	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0145b	74 02		 je	 SHORT $LN1048@bp
  0145d	8b c1		 mov	 eax, ecx
$LN1048@bp:
  0145f	89 47 f8	 mov	 DWORD PTR [edi-8], eax

; 2000 :         ;
; 2001 :         NEXT(1)

  01462	83 c3 04	 add	 ebx, 4

; 2002 :         ;

  01465	e9 e9 eb ff ff	 jmp	 $LL1041@bp
$LN714@bp:

; 2003 : #endif
; 2004 : 
; 2005 :       case LOAD_VALUE:
; 2006 :         ires = REGFIELD;

  0146a	8b c6		 mov	 eax, esi

; 2007 :         IN_VALUE(ires,Ai)

  0146c	c1 ee 0a	 shr	 esi, 10			; 0000000aH
  0146f	81 e6 ff 07 00
	00		 and	 esi, 2047		; 000007ffH
  01475	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  01478	c1 e8 17	 shr	 eax, 23			; 00000017H
  0147b	89 44 24 1c	 mov	 DWORD PTR _ires$83218[esp+262196], eax
  0147f	f6 c1 03	 test	 cl, 3
  01482	74 12		 je	 SHORT $LN1603@bp
  01484	03 c0		 add	 eax, eax
  01486	03 c0		 add	 eax, eax
  01488	8b d7		 mov	 edx, edi
  0148a	2b d0		 sub	 edx, eax
  0148c	89 0a		 mov	 DWORD PTR [edx], ecx

; 2008 :         ;
; 2009 :         NEXT(1)

  0148e	83 c3 04	 add	 ebx, 4

; 2010 :         ;

  01491	e9 bd eb ff ff	 jmp	 $LL1041@bp
$LN1603@bp:

; 2007 :         IN_VALUE(ires,Ai)

  01496	8b 01		 mov	 eax, DWORD PTR [ecx]
  01498	a8 03		 test	 al, 3
  0149a	75 10		 jne	 SHORT $LN710@bp
  0149c	8d 64 24 00	 npad	 4
$LL711@bp:
  014a0	3b c8		 cmp	 ecx, eax
  014a2	74 08		 je	 SHORT $LN710@bp
  014a4	8b c8		 mov	 ecx, eax
  014a6	8b 00		 mov	 eax, DWORD PTR [eax]
  014a8	a8 03		 test	 al, 3
  014aa	74 f4		 je	 SHORT $LL711@bp
$LN710@bp:
  014ac	8b d0		 mov	 edx, eax
  014ae	83 e2 03	 and	 edx, 3
  014b1	80 fa 03	 cmp	 dl, 3
  014b4	75 09		 jne	 SHORT $LN1050@bp
  014b6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  014bb	74 02		 je	 SHORT $LN1050@bp
  014bd	8b c1		 mov	 eax, ecx
$LN1050@bp:
  014bf	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ires$83218[esp+262196]
  014c3	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  014ca	8b cf		 mov	 ecx, edi
  014cc	2b ca		 sub	 ecx, edx
  014ce	89 01		 mov	 DWORD PTR [ecx], eax

; 2008 :         ;
; 2009 :         NEXT(1)

  014d0	83 c3 04	 add	 ebx, 4

; 2010 :         ;

  014d3	e9 7b eb ff ff	 jmp	 $LL1041@bp
$LN709@bp:

; 2011 : 
; 2012 :         /* needed to load floats X->$float(i1,I2,I3) */
; 2013 :       case LOAD_VARIABLE:
; 2014 :         ires = REGFIELD;
; 2015 :         NEWVAR2(X(ires),Ai)

  014d8	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 2016 :         ;

  014dc	8b d6		 mov	 edx, esi
  014de	c1 ee 17	 shr	 esi, 23			; 00000017H
  014e1	03 f6		 add	 esi, esi
  014e3	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  014e6	03 f6		 add	 esi, esi
  014e8	89 00		 mov	 DWORD PTR [eax], eax
  014ea	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  014f0	8b cf		 mov	 ecx, edi
  014f2	2b ce		 sub	 ecx, esi
  014f4	89 04 3a	 mov	 DWORD PTR [edx+edi], eax
  014f7	89 01		 mov	 DWORD PTR [ecx], eax
  014f9	83 c0 04	 add	 eax, 4

; 2017 :         NEXT(1)

  014fc	83 c3 04	 add	 ebx, 4

; 2018 :         ;

  014ff	e9 4b eb ff ff	 jmp	 $LN1758@bp
$LN708@bp:

; 2019 : 
; 2020 :         /* OLD SPECIAL BUILTINS */
; 2021 : 
; 2022 :       case TRUE_0:
; 2023 :         FDEREF(regs[1])

  01504	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  01507	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  0150b	f6 c1 03	 test	 cl, 3
  0150e	74 06		 je	 SHORT $LN1604@bp
  01510	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  01514	eb 1e		 jmp	 SHORT $LN704@bp
$LN1604@bp:
  01516	8b 01		 mov	 eax, DWORD PTR [ecx]
  01518	89 44 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], eax
  0151c	a8 03		 test	 al, 3
  0151e	75 14		 jne	 SHORT $LN704@bp
$LL705@bp:
  01520	3b c8		 cmp	 ecx, eax
  01522	74 0c		 je	 SHORT $LN1745@bp
  01524	8b c8		 mov	 ecx, eax
  01526	8b 00		 mov	 eax, DWORD PTR [eax]
  01528	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  0152c	a8 03		 test	 al, 3
  0152e	74 f0		 je	 SHORT $LL705@bp
$LN1745@bp:
  01530	89 44 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], eax
$LN704@bp:

; 2024 :         ;
; 2025 :         P = GETPRED(xval);

  01534	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  01538	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  0153d	52		 push	 edx
  0153e	50		 push	 eax
  0153f	e8 00 00 00 00	 call	 _hget

; 2026 :         fields = GETARITY(xval);

  01544	8b 74 24 24	 mov	 esi, DWORD PTR _xval$83216[esp+262204]
  01548	8b d8		 mov	 ebx, eax
  0154a	c1 ee 18	 shr	 esi, 24			; 00000018H
  0154d	83 c4 08	 add	 esp, 8
  01550	89 74 24 1c	 mov	 DWORD PTR _fields$83217[esp+262196], esi

; 2027 :         if (!P) {

  01554	85 db		 test	 ebx, ebx
  01556	75 0b		 jne	 SHORT $LN703@bp

; 2028 :           P = g.metatrue;

  01558	8b 1d 14 00 00
	00		 mov	 ebx, DWORD PTR _g+20

; 2029 :           continue;

  0155e	e9 f0 ea ff ff	 jmp	 $LL1041@bp
$LN703@bp:

; 2030 :           /*
; 2031 :            WARFUN(PUTARITY(xval,fields-1),
; 2032 :            "undefined predicate as continuation")
; 2033 :            */
; 2034 :         }
; 2035 :         COPY_REGS()

  01563	85 f6		 test	 esi, esi
  01565	74 4a		 je	 SHORT $LN702@bp
  01567	8d 0c b5 fc ff
	ff ff		 lea	 ecx, DWORD PTR [esi*4-4]
  0156e	85 c9		 test	 ecx, ecx
  01570	74 1f		 je	 SHORT $LN1707@bp
  01572	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  01576	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  01579	2b d7		 sub	 edx, edi
  0157b	eb 03 8d 49 00	 npad	 5
$LL701@bp:
  01580	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  01583	89 30		 mov	 DWORD PTR [eax], esi
  01585	83 e8 04	 sub	 eax, 4
  01588	83 e9 04	 sub	 ecx, 4
  0158b	75 f3		 jne	 SHORT $LL701@bp
  0158d	8b 74 24 1c	 mov	 esi, DWORD PTR _fields$83217[esp+262196]
$LN1707@bp:
  01591	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  01595	8b 04 b1	 mov	 eax, DWORD PTR [ecx+esi*4]
  01598	8d 0c b1	 lea	 ecx, DWORD PTR [ecx+esi*4]
  0159b	8b d0		 mov	 edx, eax
  0159d	83 e2 03	 and	 edx, 3
  015a0	80 fa 03	 cmp	 dl, 3
  015a3	75 09		 jne	 SHORT $LN698@bp
  015a5	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  015aa	74 02		 je	 SHORT $LN698@bp
  015ac	8b c1		 mov	 eax, ecx
$LN698@bp:
  015ae	89 04 b7	 mov	 DWORD PTR [edi+esi*4], eax
$LN702@bp:

; 2036 :         CUT_AND_CHECK_HEAP()

  015b1	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  015b8	0f 85 1a f2 ff
	ff		 jne	 $LN1037@bp
  015be	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  015c2	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  015c6	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  015ca	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  015cd	0f 82 80 ea ff
	ff		 jb	 $LL1041@bp
  015d3	56		 push	 esi
  015d4	53		 push	 ebx
  015d5	55		 push	 ebp
  015d6	57		 push	 edi

; 2037 :         ;
; 2038 :         continue;

  015d7	e9 c8 f1 ff ff	 jmp	 $LN1797@bp
$LN694@bp:

; 2039 : 
; 2040 :       case CALL_1:
; 2041 :         FDEREF(regs[1])

  015dc	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  015df	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  015e3	f6 c1 03	 test	 cl, 3
  015e6	74 04		 je	 SHORT $LN1606@bp
  015e8	8b c1		 mov	 eax, ecx
  015ea	eb 16		 jmp	 SHORT $LN690@bp
$LN1606@bp:
  015ec	8b 01		 mov	 eax, DWORD PTR [ecx]
  015ee	a8 03		 test	 al, 3
  015f0	75 10		 jne	 SHORT $LN690@bp
$LL691@bp:
  015f2	3b c8		 cmp	 ecx, eax
  015f4	74 0c		 je	 SHORT $LN690@bp
  015f6	8b c8		 mov	 ecx, eax
  015f8	8b 00		 mov	 eax, DWORD PTR [eax]
  015fa	89 4c 24 18	 mov	 DWORD PTR _xref$83215[esp+262196], ecx
  015fe	a8 03		 test	 al, 3
  01600	74 f0		 je	 SHORT $LL691@bp
$LN690@bp:

; 2042 :         ;
; 2043 :         fields = GETARITY(xval);
; 2044 :         P = GETPRED(PUTARITY(xval,++fields));

  01602	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104
  01608	8b f0		 mov	 esi, eax
  0160a	c1 ee 18	 shr	 esi, 24			; 00000018H
  0160d	46		 inc	 esi
  0160e	8b ce		 mov	 ecx, esi
  01610	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  01615	c1 e1 18	 shl	 ecx, 24			; 00000018H
  01618	0b c1		 or	 eax, ecx
  0161a	50		 push	 eax
  0161b	52		 push	 edx
  0161c	e8 00 00 00 00	 call	 _hget
  01621	8b d8		 mov	 ebx, eax
  01623	83 c4 08	 add	 esp, 8

; 2045 :         if (!P) {

  01626	85 db		 test	 ebx, ebx
  01628	75 0b		 jne	 SHORT $LN689@bp

; 2046 :           P = g.metacall;

  0162a	8b 1d 10 00 00
	00		 mov	 ebx, DWORD PTR _g+16

; 2047 :           continue;

  01630	e9 1e ea ff ff	 jmp	 $LL1041@bp
$LN689@bp:

; 2048 :           /* WARFUN(xval,"metacall to unknown predicate")*/
; 2049 :         }
; 2050 :         SETCELL(regs+fields--,regs[2]);

  01635	4e		 dec	 esi
  01636	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  01639	89 44 b7 04	 mov	 DWORD PTR [edi+esi*4+4], eax

; 2051 :         COPY_REGS()

  0163d	74 51		 je	 SHORT $LN688@bp
  0163f	8d 0c b5 fc ff
	ff ff		 lea	 ecx, DWORD PTR [esi*4-4]
  01646	85 c9		 test	 ecx, ecx
  01648	74 27		 je	 SHORT $LN1708@bp
  0164a	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  0164e	2b d7		 sub	 edx, edi
  01650	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  01653	89 54 24 24	 mov	 DWORD PTR tv7619[esp+262196], edx
  01657	eb 0b		 jmp	 SHORT $LN687@bp
  01659	8d a4 24 00 00
	00 00		 npad	 7
$LL1737@bp:
  01660	8b 54 24 24	 mov	 edx, DWORD PTR tv7619[esp+262196]
$LN687@bp:
  01664	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  01667	89 10		 mov	 DWORD PTR [eax], edx
  01669	83 e8 04	 sub	 eax, 4
  0166c	83 e9 04	 sub	 ecx, 4
  0166f	75 ef		 jne	 SHORT $LL1737@bp
$LN1708@bp:
  01671	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  01675	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  01678	8b 01		 mov	 eax, DWORD PTR [ecx]
  0167a	8b d0		 mov	 edx, eax
  0167c	83 e2 03	 and	 edx, 3
  0167f	80 fa 03	 cmp	 dl, 3
  01682	75 09		 jne	 SHORT $LN684@bp
  01684	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  01689	74 02		 je	 SHORT $LN684@bp
  0168b	8b c1		 mov	 eax, ecx
$LN684@bp:
  0168d	89 04 b7	 mov	 DWORD PTR [edi+esi*4], eax
$LN688@bp:

; 2052 :         CUT_AND_CHECK_HEAP()

  01690	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  01697	0f 85 3b f1 ff
	ff		 jne	 $LN1037@bp
  0169d	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  016a1	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  016a5	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  016a9	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  016ac	0f 82 a1 e9 ff
	ff		 jb	 $LL1041@bp
  016b2	56		 push	 esi
  016b3	53		 push	 ebx
  016b4	55		 push	 ebp
  016b5	57		 push	 edi
  016b6	50		 push	 eax
  016b7	e8 00 00 00 00	 call	 _trigger_gc
  016bc	83 c4 14	 add	 esp, 20			; 00000014H
  016bf	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  016c3	85 c0		 test	 eax, eax
  016c5	0f 85 88 e9 ff
	ff		 jne	 $LL1041@bp
$LN1620@bp:

; 1736 :         FAILURE()
; 1737 :         ;
; 1738 : 
; 1739 : #if JUMP_COMPRESS
; 1740 :       case EXEC_SWITCH:
; 1741 :         EXEC0()

  016cb	e8 00 00 00 00	 call	 _link_halt
  016d0	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  016d3	c7 40 18 fd ff
	ff ff		 mov	 DWORD PTR [eax+24], -3	; fffffffdH
  016da	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  016dd	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  016e4	89 6e 50	 mov	 DWORD PTR [esi+80], ebp
  016e7	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
  016ea	33 c0		 xor	 eax, eax
  016ec	e9 be 29 00 00	 jmp	 $LN1040@bp
$LN680@bp:

; 2053 :         ;
; 2054 :         continue;
; 2055 : 
; 2056 :       case APPLY:
; 2057 :         P = GETPRED((xval=GETFUN(P)));

  016f1	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  016f4	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  016f9	53		 push	 ebx
  016fa	50		 push	 eax
  016fb	89 5c 24 24	 mov	 DWORD PTR _xval$83216[esp+262204], ebx
  016ff	e8 00 00 00 00	 call	 _hget

; 2058 :         if (!P) /* setting up a metacall to bp_long. code */
; 2059 :         {
; 2060 :           H = apply(H, regs, xval, wam);

  01704	8b 74 24 18	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262204]
  01708	8b d8		 mov	 ebx, eax
  0170a	83 c4 08	 add	 esp, 8
  0170d	85 db		 test	 ebx, ebx
  0170f	75 20		 jne	 SHORT $LN1730@bp
  01711	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  01715	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  01719	56		 push	 esi
  0171a	51		 push	 ecx
  0171b	57		 push	 edi
  0171c	52		 push	 edx
  0171d	e8 00 00 00 00	 call	 _apply

; 2061 :           P = g.metacall;

  01722	8b 1d 10 00 00
	00		 mov	 ebx, DWORD PTR _g+16
  01728	83 c4 10	 add	 esp, 16			; 00000010H
  0172b	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  0172f	eb 04		 jmp	 SHORT $LN679@bp
$LN1730@bp:
  01731	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
$LN679@bp:

; 2062 :         }
; 2063 :         CUT_AND_CHECK_HEAP()

  01735	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  0173c	0f 85 96 f0 ff
	ff		 jne	 $LN1037@bp
  01742	89 6c 24 24	 mov	 DWORD PTR _cutB$[esp+262196], ebp
  01746	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  01749	0f 82 04 e9 ff
	ff		 jb	 $LL1041@bp
  0174f	56		 push	 esi
  01750	53		 push	 ebx
  01751	55		 push	 ebp
  01752	57		 push	 edi
  01753	50		 push	 eax
  01754	e8 00 00 00 00	 call	 _trigger_gc
  01759	83 c4 14	 add	 esp, 20			; 00000014H
  0175c	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  01760	85 c0		 test	 eax, eax
  01762	0f 85 eb e8 ff
	ff		 jne	 $LL1041@bp
$LN1622@bp:

; 1758 : #else
; 1759 :         continue;
; 1760 : #endif
; 1761 : 
; 1762 :         /* the OFFSETS optimization replaces H++=.. with H[i]=.. and H+=N..*/
; 1763 : 
; 1764 : #if JUMP_COMPRESS
; 1765 :       case EXEC_JUMP_IF:
; 1766 :         EXEC0()

  01768	e8 00 00 00 00	 call	 _link_halt
  0176d	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  01770	c7 42 18 fd ff
	ff ff		 mov	 DWORD PTR [edx+24], -3	; fffffffdH
  01777	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  0177a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  01781	89 6e 50	 mov	 DWORD PTR [esi+80], ebp
  01784	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  01787	33 c0		 xor	 eax, eax
  01789	e9 21 29 00 00	 jmp	 $LN1040@bp
$LN674@bp:

; 2064 :         ;
; 2065 :         continue;
; 2066 : 
; 2067 : #define BFAIL() FAILURE()
; 2068 : #define BEXIT(Mes) ABORT(Mes)
; 2069 : #define BCONTINUE() continue
; 2070 : 
; 2071 :         /* INLINE PREDICATES */
; 2072 : 
; 2073 :       case FAIL_0:
; 2074 :         BFAIL()
; 2075 : 
; 2076 :       case CWRITE_1:
; 2077 :         /* don't DEREF !!! ; regs may also be An */
; 2078 :         fout(TEMP(0), wam, g.tellfile);

  0178e	a1 34 01 00 00	 mov	 eax, DWORD PTR _g+308
  01793	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01797	8b 17		 mov	 edx, DWORD PTR [edi]
  01799	50		 push	 eax
  0179a	51		 push	 ecx
  0179b	52		 push	 edx
  0179c	e8 00 00 00 00	 call	 _fout
  017a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2079 :         BNEXT(1)

  017a4	83 c3 04	 add	 ebx, 4

; 2080 :         ;

  017a7	e9 a7 e8 ff ff	 jmp	 $LL1041@bp
$LN673@bp:

; 2081 : 
; 2082 :       case CNL_0:
; 2083 :         NEWLN()

  017ac	a1 34 01 00 00	 mov	 eax, DWORD PTR _g+308
  017b1	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  017b6	50		 push	 eax
  017b7	e8 00 00 00 00	 call	 _fprintf

; 2084 :         ;

  017bc	8b 0d 34 01 00
	00		 mov	 ecx, DWORD PTR _g+308
  017c2	51		 push	 ecx
  017c3	e8 00 00 00 00	 call	 _fflush
  017c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2085 :         BNEXT(1)

  017cb	83 c3 04	 add	 ebx, 4

; 2086 :         ;

  017ce	e9 80 e8 ff ff	 jmp	 $LL1041@bp
$LN672@bp:

; 2087 : 
; 2088 :       case VAR_1:
; 2089 :         FDEREF(TEMP(0))

  017d3	8b 0f		 mov	 ecx, DWORD PTR [edi]
  017d5	f6 c1 03	 test	 cl, 3
  017d8	74 04		 je	 SHORT $LN1608@bp
  017da	8b c1		 mov	 eax, ecx
  017dc	eb 16		 jmp	 SHORT $LN668@bp
$LN1608@bp:
  017de	8b 01		 mov	 eax, DWORD PTR [ecx]
  017e0	a8 03		 test	 al, 3
  017e2	0f 85 08 24 00
	00		 jne	 $LN1747@bp
$LL669@bp:
  017e8	3b c8		 cmp	 ecx, eax
  017ea	74 08		 je	 SHORT $LN668@bp
  017ec	8b c8		 mov	 ecx, eax
  017ee	8b 00		 mov	 eax, DWORD PTR [eax]
  017f0	a8 03		 test	 al, 3
  017f2	74 f4		 je	 SHORT $LL669@bp
$LN668@bp:

; 2090 :         ;
; 2091 :         if (NONVAR(xval))

  017f4	a8 03		 test	 al, 3
  017f6	0f 84 87 e8 ff
	ff		 je	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  017fc	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  017ff	e9 4f e8 ff ff	 jmp	 $LL1041@bp
$LN666@bp:

; 2092 :         BFAIL()
; 2093 :         BNEXT(1)
; 2094 :         ;
; 2095 : 
; 2096 :       case NONVAR_1:
; 2097 :         FDEREF(TEMP(0))

  01804	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01806	f6 c1 03	 test	 cl, 3
  01809	74 04		 je	 SHORT $LN1609@bp
  0180b	8b c1		 mov	 eax, ecx
  0180d	eb 1d		 jmp	 SHORT $LN662@bp
$LN1609@bp:
  0180f	8b 01		 mov	 eax, DWORD PTR [ecx]
  01811	a8 03		 test	 al, 3
  01813	0f 85 6a e8 ff
	ff		 jne	 $LN6@bp
  01819	8d a4 24 00 00
	00 00		 npad	 7
$LL663@bp:
  01820	3b c8		 cmp	 ecx, eax
  01822	74 08		 je	 SHORT $LN662@bp
  01824	8b c8		 mov	 ecx, eax
  01826	8b 00		 mov	 eax, DWORD PTR [eax]
  01828	a8 03		 test	 al, 3
  0182a	74 f4		 je	 SHORT $LL663@bp
$LN662@bp:

; 2098 :         ;
; 2099 :         if (VAR(xval))

  0182c	a8 03		 test	 al, 3
  0182e	0f 85 4f e8 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01834	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01837	e9 17 e8 ff ff	 jmp	 $LL1041@bp
$LN660@bp:

; 2100 :         BFAIL()
; 2101 :         BNEXT(1)
; 2102 :         ;
; 2103 : 
; 2104 :       case INTEGER_1:
; 2105 :         FDEREF(TEMP(0))

  0183c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0183e	f6 c1 03	 test	 cl, 3
  01841	74 04		 je	 SHORT $LN1610@bp
  01843	8b c1		 mov	 eax, ecx
  01845	eb 15		 jmp	 SHORT $LN656@bp
$LN1610@bp:
  01847	8b 01		 mov	 eax, DWORD PTR [ecx]
  01849	a8 03		 test	 al, 3
  0184b	75 0f		 jne	 SHORT $LN656@bp
  0184d	8d 49 00	 npad	 3
$LL657@bp:
  01850	3b c8		 cmp	 ecx, eax
  01852	74 08		 je	 SHORT $LN656@bp
  01854	8b c8		 mov	 ecx, eax
  01856	8b 00		 mov	 eax, DWORD PTR [eax]
  01858	a8 03		 test	 al, 3
  0185a	74 f4		 je	 SHORT $LL657@bp
$LN656@bp:

; 2106 :         ;
; 2107 :         if (INTEGER(xval)) {

  0185c	24 03		 and	 al, 3
  0185e	3c 01		 cmp	 al, 1
  01860	0f 85 7a 25 00
	00		 jne	 $LN1701@bp

; 2108 :           BNEXT(1)

  01866	83 c3 04	 add	 ebx, 4

; 2109 :           ;

  01869	e9 e5 e7 ff ff	 jmp	 $LL1041@bp
$LN654@bp:

; 2110 :         }
; 2111 :           else
; 2112 :           BFAIL()
; 2113 : 
; 2114 :       case ATOMIC_1:
; 2115 :         FDEREF(TEMP(0))

  0186e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01870	f6 c1 03	 test	 cl, 3
  01873	74 04		 je	 SHORT $LN1611@bp
  01875	8b c1		 mov	 eax, ecx
  01877	eb 13		 jmp	 SHORT $LN649@bp
$LN1611@bp:
  01879	8b 01		 mov	 eax, DWORD PTR [ecx]
  0187b	a8 03		 test	 al, 3
  0187d	75 0d		 jne	 SHORT $LN649@bp
  0187f	90		 npad	 1
$LL650@bp:
  01880	3b c8		 cmp	 ecx, eax
  01882	74 08		 je	 SHORT $LN649@bp
  01884	8b c8		 mov	 ecx, eax
  01886	8b 00		 mov	 eax, DWORD PTR [eax]
  01888	a8 03		 test	 al, 3
  0188a	74 f4		 je	 SHORT $LL650@bp
$LN649@bp:

; 2116 :         ;
; 2117 :         if (ATOMIC(xval)) {

  0188c	8b c8		 mov	 ecx, eax
  0188e	83 e1 03	 and	 ecx, 3
  01891	0f 84 49 25 00
	00		 je	 $LN1701@bp
  01897	83 f9 01	 cmp	 ecx, 1
  0189a	74 0b		 je	 SHORT $LN647@bp
  0189c	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  018a1	0f 85 39 25 00
	00		 jne	 $LN1701@bp
$LN647@bp:

; 2118 :           BNEXT(1)

  018a7	83 c3 04	 add	 ebx, 4

; 2119 :           ;

  018aa	e9 a4 e7 ff ff	 jmp	 $LL1041@bp
$LN646@bp:

; 2120 :         }
; 2121 :           else
; 2122 :           BFAIL()
; 2123 : 
; 2124 :       case IS_COMPILED_1:
; 2125 :         FDEREF(TEMP(0))

  018af	8b 0f		 mov	 ecx, DWORD PTR [edi]
  018b1	f6 c1 03	 test	 cl, 3
  018b4	74 04		 je	 SHORT $LN1612@bp
  018b6	8b c1		 mov	 eax, ecx
  018b8	eb 12		 jmp	 SHORT $LN641@bp
$LN1612@bp:
  018ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  018bc	a8 03		 test	 al, 3
  018be	75 0c		 jne	 SHORT $LN641@bp
$LL642@bp:
  018c0	3b c8		 cmp	 ecx, eax
  018c2	74 08		 je	 SHORT $LN641@bp
  018c4	8b c8		 mov	 ecx, eax
  018c6	8b 00		 mov	 eax, DWORD PTR [eax]
  018c8	a8 03		 test	 al, 3
  018ca	74 f4		 je	 SHORT $LL642@bp
$LN641@bp:

; 2126 :         ;
; 2127 :         xval = PUTARITY(xval,1+GETARITY(xval));

  018cc	8b d0		 mov	 edx, eax
  018ce	81 e2 00 00 00
	ff		 and	 edx, -16777216		; ff000000H
  018d4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  018d9	81 c2 00 00 00
	01		 add	 edx, 16777216		; 01000000H
  018df	0b d0		 or	 edx, eax

; 2128 :         if (GETPRED(xval)) {

  018e1	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  018e6	52		 push	 edx
  018e7	50		 push	 eax
  018e8	e8 00 00 00 00	 call	 _hget
  018ed	83 c4 08	 add	 esp, 8
  018f0	85 c0		 test	 eax, eax
  018f2	0f 84 e8 24 00
	00		 je	 $LN1701@bp

; 2129 :           BNEXT(1)

  018f8	83 c3 04	 add	 ebx, 4

; 2130 :           ;

  018fb	e9 53 e7 ff ff	 jmp	 $LL1041@bp
$LN639@bp:

; 2131 :         }
; 2132 :           else
; 2133 :           BFAIL()
; 2134 : 
; 2135 :         /* INLINE ARITH */
; 2136 : 
; 2137 :       case PLUS_3:
; 2138 :         COMPUTE(+)

  01900	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01903	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01906	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  0190a	83 e1 03	 and	 ecx, 3
  0190d	03 c9		 add	 ecx, ecx
  0190f	8b d0		 mov	 edx, eax
  01911	03 c9		 add	 ecx, ecx
  01913	83 e2 03	 and	 edx, 3
  01916	0b ca		 or	 ecx, edx
  01918	83 f9 05	 cmp	 ecx, 5
  0191b	74 1d		 je	 SHORT $LN637@bp
  0191d	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  01921	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  01925	52		 push	 edx
  01926	50		 push	 eax
  01927	56		 push	 esi
  01928	51		 push	 ecx
  01929	89 4c 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], ecx

; 2149 : 
; 2150 :       case DIV_3:
; 2151 :         COMPUTE_DIV(/)

  0192d	e8 00 00 00 00	 call	 _float_op
  01932	83 c4 10	 add	 esp, 16			; 00000010H
  01935	e9 0b 13 00 00	 jmp	 $LN1783@bp
$LN637@bp:

; 2131 :         }
; 2132 :           else
; 2133 :           BFAIL()
; 2134 : 
; 2135 :         /* INLINE ARITH */
; 2136 : 
; 2137 :       case PLUS_3:
; 2138 :         COMPUTE(+)

  0193a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  0193e	c1 f8 02	 sar	 eax, 2
  01941	c1 f9 02	 sar	 ecx, 2
  01944	03 c1		 add	 eax, ecx
  01946	03 c0		 add	 eax, eax
  01948	03 c0		 add	 eax, eax
  0194a	83 c8 01	 or	 eax, 1
  0194d	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01953	0f 84 d6 1a 00
	00		 je	 $LN32@bp
  01959	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0195d	55		 push	 ebp
  0195e	c1 ee 15	 shr	 esi, 21			; 00000015H
  01961	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01964	51		 push	 ecx
  01965	52		 push	 edx
  01966	e9 74 22 00 00	 jmp	 $LN1772@bp
$LN629@bp:

; 2139 :         ;
; 2140 :       case SUB_3:
; 2141 :         COMPUTE(-)

  0196b	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  0196e	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01971	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  01975	83 e1 03	 and	 ecx, 3
  01978	03 c9		 add	 ecx, ecx
  0197a	8b d0		 mov	 edx, eax
  0197c	03 c9		 add	 ecx, ecx
  0197e	83 e2 03	 and	 edx, 3
  01981	0b ca		 or	 ecx, edx
  01983	83 f9 05	 cmp	 ecx, 5
  01986	74 1d		 je	 SHORT $LN628@bp
  01988	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  0198c	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  01990	52		 push	 edx
  01991	50		 push	 eax
  01992	56		 push	 esi
  01993	51		 push	 ecx
  01994	89 4c 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], ecx

; 2149 : 
; 2150 :       case DIV_3:
; 2151 :         COMPUTE_DIV(/)

  01998	e8 00 00 00 00	 call	 _float_op
  0199d	83 c4 10	 add	 esp, 16			; 00000010H
  019a0	e9 a0 12 00 00	 jmp	 $LN1783@bp
$LN628@bp:

; 2139 :         ;
; 2140 :       case SUB_3:
; 2141 :         COMPUTE(-)

  019a5	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  019a9	c1 f8 02	 sar	 eax, 2
  019ac	c1 f9 02	 sar	 ecx, 2
  019af	2b c1		 sub	 eax, ecx
  019b1	03 c0		 add	 eax, eax
  019b3	03 c0		 add	 eax, eax
  019b5	83 c8 01	 or	 eax, 1
  019b8	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  019be	0f 84 6b 1a 00
	00		 je	 $LN32@bp
  019c4	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  019c8	55		 push	 ebp
  019c9	c1 ee 15	 shr	 esi, 21			; 00000015H
  019cc	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  019cf	51		 push	 ecx
  019d0	52		 push	 edx
  019d1	e9 09 22 00 00	 jmp	 $LN1772@bp
$LN620@bp:

; 2142 :         ;
; 2143 :       case MUL_3:
; 2144 :         COMPUTE(*)

  019d6	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  019d9	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  019dc	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  019e0	83 e1 03	 and	 ecx, 3
  019e3	03 c9		 add	 ecx, ecx
  019e5	8b d0		 mov	 edx, eax
  019e7	03 c9		 add	 ecx, ecx
  019e9	83 e2 03	 and	 edx, 3
  019ec	0b ca		 or	 ecx, edx
  019ee	83 f9 05	 cmp	 ecx, 5
  019f1	74 1d		 je	 SHORT $LN619@bp
  019f3	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  019f7	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  019fb	52		 push	 edx
  019fc	50		 push	 eax
  019fd	56		 push	 esi
  019fe	51		 push	 ecx
  019ff	89 4c 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], ecx

; 2149 : 
; 2150 :       case DIV_3:
; 2151 :         COMPUTE_DIV(/)

  01a03	e8 00 00 00 00	 call	 _float_op
  01a08	83 c4 10	 add	 esp, 16			; 00000010H
  01a0b	e9 35 12 00 00	 jmp	 $LN1783@bp
$LN619@bp:

; 2142 :         ;
; 2143 :       case MUL_3:
; 2144 :         COMPUTE(*)

  01a10	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  01a14	83 e0 fc	 and	 eax, -4			; fffffffcH
  01a17	c1 f9 02	 sar	 ecx, 2
  01a1a	0f af c1	 imul	 eax, ecx
  01a1d	83 c8 01	 or	 eax, 1
  01a20	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01a26	0f 84 03 1a 00
	00		 je	 $LN32@bp
  01a2c	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01a30	55		 push	 ebp
  01a31	c1 ee 15	 shr	 esi, 21			; 00000015H
  01a34	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01a37	51		 push	 ecx
  01a38	52		 push	 edx
  01a39	e9 a1 21 00 00	 jmp	 $LN1772@bp
$LN611@bp:

; 2145 :         ;
; 2146 :       case MOD_3:
; 2147 :         COMPUTE_MOD(%)

  01a3e	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01a41	8b c1		 mov	 eax, ecx
  01a43	24 03		 and	 al, 3
  01a45	3c 01		 cmp	 al, 1
  01a47	75 26		 jne	 SHORT $LN610@bp
  01a49	f7 c1 fc ff ff
	ff		 test	 ecx, -4			; fffffffcH
  01a4f	75 1e		 jne	 SHORT $LN610@bp
  01a51	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01a55	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  01a58	51		 push	 ecx
  01a59	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CBEJIEKE@mod?50?5invalid?$AA@
  01a5e	52		 push	 edx
  01a5f	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  01a64	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01a67	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a6a	e9 e4 e5 ff ff	 jmp	 $LL1041@bp
$LN610@bp:

; 2145 :         ;
; 2146 :       case MOD_3:
; 2147 :         COMPUTE_MOD(%)

  01a6f	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01a72	8b d1		 mov	 edx, ecx
  01a74	83 e2 03	 and	 edx, 3
  01a77	03 d2		 add	 edx, edx
  01a79	83 e0 03	 and	 eax, 3
  01a7c	03 d2		 add	 edx, edx
  01a7e	0b d0		 or	 edx, eax
  01a80	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01a83	83 fa 05	 cmp	 edx, 5
  01a86	0f 85 94 00 00
	00		 jne	 $LN1795@bp
  01a8c	c1 f8 02	 sar	 eax, 2
  01a8f	c1 f9 02	 sar	 ecx, 2
  01a92	99		 cdq
  01a93	f7 f9		 idiv	 ecx
  01a95	03 d2		 add	 edx, edx
  01a97	03 d2		 add	 edx, edx
  01a99	83 ca 01	 or	 edx, 1
  01a9c	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01aa2	74 22		 je	 SHORT $LN604@bp
  01aa4	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01aa8	55		 push	 ebp
  01aa9	51		 push	 ecx
  01aaa	c1 ee 15	 shr	 esi, 21			; 00000015H
  01aad	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  01ab0	50		 push	 eax
  01ab1	52		 push	 edx
  01ab2	e8 00 00 00 00	 call	 _unify
  01ab7	83 c4 10	 add	 esp, 16			; 00000010H
  01aba	85 c0		 test	 eax, eax
  01abc	75 0e		 jne	 SHORT $LN602@bp

; 3141 :         OUT_RESULT(xval);

  01abe	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01ac1	e9 8d e5 ff ff	 jmp	 $LL1041@bp
$LN604@bp:

; 2145 :         ;
; 2146 :       case MOD_3:
; 2147 :         COMPUTE_MOD(%)

  01ac6	c1 ee 15	 shr	 esi, 21			; 00000015H
  01ac9	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
$LN602@bp:
  01acc	83 c3 04	 add	 ebx, 4

; 2148 :         ;

  01acf	e9 7f e5 ff ff	 jmp	 $LL1041@bp
$LN601@bp:

; 2149 : 
; 2150 :       case DIV_3:
; 2151 :         COMPUTE_DIV(/)

  01ad4	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01ad7	8b d1		 mov	 edx, ecx
  01ad9	80 e2 03	 and	 dl, 3
  01adc	80 fa 01	 cmp	 dl, 1
  01adf	75 26		 jne	 SHORT $LN600@bp
  01ae1	f7 c1 fc ff ff
	ff		 test	 ecx, -4			; fffffffcH
  01ae7	75 1e		 jne	 SHORT $LN600@bp
  01ae9	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  01aed	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  01af0	50		 push	 eax
  01af1	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EDEAEALJ@divided?5by?50?$AA@
  01af6	51		 push	 ecx
  01af7	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  01afc	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01aff	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b02	e9 4c e5 ff ff	 jmp	 $LL1041@bp
$LN600@bp:

; 2149 : 
; 2150 :       case DIV_3:
; 2151 :         COMPUTE_DIV(/)

  01b07	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01b0a	8b d1		 mov	 edx, ecx
  01b0c	83 e2 03	 and	 edx, 3
  01b0f	03 d2		 add	 edx, edx
  01b11	83 e0 03	 and	 eax, 3
  01b14	03 d2		 add	 edx, edx
  01b16	0b d0		 or	 edx, eax
  01b18	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01b1b	83 fa 05	 cmp	 edx, 5
  01b1e	74 19		 je	 SHORT $LN599@bp
$LN1795@bp:
  01b20	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  01b24	51		 push	 ecx
  01b25	50		 push	 eax
  01b26	56		 push	 esi
  01b27	52		 push	 edx
  01b28	89 54 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], edx
  01b2c	e8 00 00 00 00	 call	 _float_op
  01b31	83 c4 10	 add	 esp, 16			; 00000010H
  01b34	e9 0c 11 00 00	 jmp	 $LN1783@bp
$LN599@bp:
  01b39	c1 f8 02	 sar	 eax, 2
  01b3c	99		 cdq
  01b3d	c1 f9 02	 sar	 ecx, 2
  01b40	f7 f9		 idiv	 ecx
  01b42	03 c0		 add	 eax, eax
  01b44	03 c0		 add	 eax, eax
  01b46	83 c8 01	 or	 eax, 1
  01b49	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01b4f	0f 84 da 18 00
	00		 je	 $LN32@bp
  01b55	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01b59	55		 push	 ebp
  01b5a	c1 ee 15	 shr	 esi, 21			; 00000015H
  01b5d	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01b60	51		 push	 ecx
  01b61	52		 push	 edx
  01b62	e9 78 20 00 00	 jmp	 $LN1772@bp
$LN591@bp:

; 2152 :         ;
; 2153 : 
; 2154 :       case FDIV_3:
; 2155 :         FLOAT_COMP(X(1),X(2))

  01b67	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01b6a	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  01b6d	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  01b71	51		 push	 ecx
  01b72	52		 push	 edx
  01b73	56		 push	 esi
  01b74	50		 push	 eax
  01b75	89 44 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], eax
  01b79	e8 00 00 00 00	 call	 _float_op
  01b7e	83 c4 10	 add	 esp, 16			; 00000010H
  01b81	e9 bf 10 00 00	 jmp	 $LN1783@bp
$LN586@bp:

; 2156 :         ;
; 2157 : 
; 2158 :       case RANDOM_1:
; 2159 :         OUT_RESULT(INPUT_INT(((bp_long)((no)rand()>>TAGBITS))))

  01b86	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01b8c	74 2d		 je	 SHORT $LN585@bp
  01b8e	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01b92	55		 push	 ebp
  01b93	c1 ee 15	 shr	 esi, 21			; 00000015H
  01b96	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01b99	51		 push	 ecx
  01b9a	52		 push	 edx
  01b9b	e8 00 00 00 00	 call	 _rand
  01ba0	83 e0 fd	 and	 eax, -3			; fffffffdH
  01ba3	83 c8 01	 or	 eax, 1
  01ba6	50		 push	 eax
  01ba7	e8 00 00 00 00	 call	 _unify
  01bac	83 c4 10	 add	 esp, 16			; 00000010H
  01baf	85 c0		 test	 eax, eax
  01bb1	75 19		 jne	 SHORT $LN583@bp

; 3141 :         OUT_RESULT(xval);

  01bb3	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01bb6	e9 98 e4 ff ff	 jmp	 $LL1041@bp
$LN585@bp:

; 2156 :         ;
; 2157 : 
; 2158 :       case RANDOM_1:
; 2159 :         OUT_RESULT(INPUT_INT(((bp_long)((no)rand()>>TAGBITS))))

  01bbb	e8 00 00 00 00	 call	 _rand
  01bc0	83 e0 fd	 and	 eax, -3			; fffffffdH
  01bc3	83 c8 01	 or	 eax, 1
  01bc6	c1 ee 15	 shr	 esi, 21			; 00000015H
  01bc9	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
$LN583@bp:
  01bcc	83 c3 04	 add	 ebx, 4

; 2160 :         ;

  01bcf	e9 7f e4 ff ff	 jmp	 $LL1041@bp
$LN582@bp:

; 2161 : 
; 2162 :       case GET0_1:
; 2163 :         if (feof(g.seefile)) {

  01bd4	a1 30 01 00 00	 mov	 eax, DWORD PTR _g+304
  01bd9	50		 push	 eax
  01bda	e8 00 00 00 00	 call	 _feof
  01bdf	83 c4 04	 add	 esp, 4
  01be2	85 c0		 test	 eax, eax
  01be4	74 18		 je	 SHORT $LN581@bp

; 2164 :           clearerr(g.seefile);

  01be6	8b 0d 30 01 00
	00		 mov	 ecx, DWORD PTR _g+304
  01bec	51		 push	 ecx
  01bed	e8 00 00 00 00	 call	 _clearerr
  01bf2	83 c4 04	 add	 esp, 4

; 2165 :           g.lineno = 0;

  01bf5	33 c0		 xor	 eax, eax
  01bf7	a3 40 01 00 00	 mov	 DWORD PTR _g+320, eax

; 2166 :           /* warnmes("Read past EOF"); */ires = 0;
; 2167 :         }
; 2168 :         else {

  01bfc	eb 28		 jmp	 SHORT $LN1709@bp
$LN581@bp:

; 2169 :           ires = (bp_long) getc(g.seefile);

  01bfe	8b 15 30 01 00
	00		 mov	 edx, DWORD PTR _g+304
  01c04	52		 push	 edx
  01c05	e8 00 00 00 00	 call	 _getc
  01c0a	83 c4 04	 add	 esp, 4

; 2170 : #ifdef VIVO
; 2171 :           if (QLEVEL() == 1111 && g.seefile != STD_in && ires > 0) ires
; 2172 :               = unobfuscate(ires);
; 2173 : #endif
; 2174 :           if ('\n' == ires && g.seefile != STD_in) g.lineno++;

  01c0d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01c10	75 14		 jne	 SHORT $LN1709@bp
  01c12	8b 0d 30 01 00
	00		 mov	 ecx, DWORD PTR _g+304
  01c18	3b 0d 38 01 00
	00		 cmp	 ecx, DWORD PTR _g+312
  01c1e	74 06		 je	 SHORT $LN1709@bp
  01c20	ff 05 40 01 00
	00		 inc	 DWORD PTR _g+320
$LN1709@bp:

; 2175 :         }
; 2176 :         OUT_RESULT(INPUT_INT(ires))

  01c26	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01c2c	0f 84 f6 17 00
	00		 je	 $LN135@bp
  01c32	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  01c36	55		 push	 ebp
  01c37	52		 push	 edx
  01c38	c1 ee 15	 shr	 esi, 21			; 00000015H
  01c3b	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  01c3e	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  01c45	51		 push	 ecx
  01c46	83 ca 01	 or	 edx, 1
  01c49	52		 push	 edx
  01c4a	e9 91 1f 00 00	 jmp	 $LN1746@bp
$LN575@bp:

; 2177 :         ;
; 2178 : 
; 2179 :       case PUT0_1:
; 2180 :         xval = X(1);

  01c4f	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2181 :         if (!INTEGER(xval))

  01c52	8b c8		 mov	 ecx, eax
  01c54	80 e1 03	 and	 cl, 3
  01c57	80 f9 01	 cmp	 cl, 1
  01c5a	74 1b		 je	 SHORT $LN574@bp

; 2182 :         BWARFUN(xval,"integer expected in put/1")

  01c5c	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  01c60	52		 push	 edx
  01c61	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DGBBHJGD@integer?5expected?5in?5put?11?$AA@
  01c66	50		 push	 eax
  01c67	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  01c6c	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01c6f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c72	e9 dc e3 ff ff	 jmp	 $LL1041@bp
$LN574@bp:

; 2183 :         ;
; 2184 :         putc(OUTPUT_INT(xval), g.tellfile);

  01c77	8b 0d 34 01 00
	00		 mov	 ecx, DWORD PTR _g+308
  01c7d	51		 push	 ecx
  01c7e	c1 f8 02	 sar	 eax, 2
  01c81	50		 push	 eax
  01c82	e8 00 00 00 00	 call	 _putc
  01c87	83 c4 08	 add	 esp, 8

; 2185 :         BNEXT(1)

  01c8a	83 c3 04	 add	 ebx, 4

; 2186 :         ;

  01c8d	e9 c1 e3 ff ff	 jmp	 $LL1041@bp
$LN573@bp:

; 2187 : 
; 2188 :       case LESS_2:
; 2189 :         MUST_BE(<)

  01c92	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  01c95	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01c98	83 e2 03	 and	 edx, 3
  01c9b	03 d2		 add	 edx, edx
  01c9d	8b c8		 mov	 ecx, eax
  01c9f	03 d2		 add	 edx, edx
  01ca1	83 e1 03	 and	 ecx, 3
  01ca4	0b d1		 or	 edx, ecx
  01ca6	83 fa 05	 cmp	 edx, 5
  01ca9	74 10		 je	 SHORT $LN572@bp
  01cab	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01cae	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  01cb2	51		 push	 ecx
  01cb3	50		 push	 eax
  01cb4	56		 push	 esi
  01cb5	52		 push	 edx
  01cb6	e9 69 01 00 00	 jmp	 $LN1788@bp
$LN572@bp:
  01cbb	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01cbe	0f 8c bf e3 ff
	ff		 jl	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01cc4	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01cc7	e9 87 e3 ff ff	 jmp	 $LL1041@bp
$LN569@bp:

; 2190 :         ;
; 2191 :       case GREATER_2:
; 2192 :         MUST_BE(>)

  01ccc	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01ccf	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01cd2	83 e1 03	 and	 ecx, 3
  01cd5	03 c9		 add	 ecx, ecx
  01cd7	8b d0		 mov	 edx, eax
  01cd9	03 c9		 add	 ecx, ecx
  01cdb	83 e2 03	 and	 edx, 3
  01cde	0b ca		 or	 ecx, edx
  01ce0	83 f9 05	 cmp	 ecx, 5
  01ce3	74 23		 je	 SHORT $LN568@bp
  01ce5	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01ce8	51		 push	 ecx
  01ce9	50		 push	 eax
  01cea	8b 44 24 1c	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262204]
  01cee	56		 push	 esi
  01cef	50		 push	 eax
  01cf0	e8 00 00 00 00	 call	 _float_op
  01cf5	83 c4 10	 add	 esp, 16			; 00000010H
  01cf8	85 c0		 test	 eax, eax
  01cfa	0f 85 83 e3 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01d00	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01d03	e9 4b e3 ff ff	 jmp	 $LL1041@bp
$LN568@bp:

; 2190 :         ;
; 2191 :       case GREATER_2:
; 2192 :         MUST_BE(>)

  01d08	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01d0b	0f 8f 72 e3 ff
	ff		 jg	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01d11	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01d14	e9 3a e3 ff ff	 jmp	 $LL1041@bp
$LN565@bp:

; 2193 :         ;
; 2194 :       case LESS_EQ_2:
; 2195 :         MUST_BE(<=)

  01d19	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01d1c	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01d1f	83 e1 03	 and	 ecx, 3
  01d22	03 c9		 add	 ecx, ecx
  01d24	8b d0		 mov	 edx, eax
  01d26	03 c9		 add	 ecx, ecx
  01d28	83 e2 03	 and	 edx, 3
  01d2b	0b ca		 or	 ecx, edx
  01d2d	83 f9 05	 cmp	 ecx, 5
  01d30	74 23		 je	 SHORT $LN564@bp
  01d32	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01d35	51		 push	 ecx
  01d36	50		 push	 eax
  01d37	8b 44 24 1c	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262204]
  01d3b	56		 push	 esi
  01d3c	50		 push	 eax
  01d3d	e8 00 00 00 00	 call	 _float_op
  01d42	83 c4 10	 add	 esp, 16			; 00000010H
  01d45	85 c0		 test	 eax, eax
  01d47	0f 85 36 e3 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01d4d	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01d50	e9 fe e2 ff ff	 jmp	 $LL1041@bp
$LN564@bp:

; 2193 :         ;
; 2194 :       case LESS_EQ_2:
; 2195 :         MUST_BE(<=)

  01d55	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01d58	0f 8e 25 e3 ff
	ff		 jle	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01d5e	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01d61	e9 ed e2 ff ff	 jmp	 $LL1041@bp
$LN561@bp:

; 2196 :         ;
; 2197 :       case GREATER_EQ_2:
; 2198 :         MUST_BE(>=)

  01d66	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01d69	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01d6c	83 e1 03	 and	 ecx, 3
  01d6f	03 c9		 add	 ecx, ecx
  01d71	8b d0		 mov	 edx, eax
  01d73	03 c9		 add	 ecx, ecx
  01d75	83 e2 03	 and	 edx, 3
  01d78	0b ca		 or	 ecx, edx
  01d7a	83 f9 05	 cmp	 ecx, 5
  01d7d	74 23		 je	 SHORT $LN560@bp
  01d7f	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01d82	51		 push	 ecx
  01d83	50		 push	 eax
  01d84	8b 44 24 1c	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262204]
  01d88	56		 push	 esi
  01d89	50		 push	 eax
  01d8a	e8 00 00 00 00	 call	 _float_op
  01d8f	83 c4 10	 add	 esp, 16			; 00000010H
  01d92	85 c0		 test	 eax, eax
  01d94	0f 85 e9 e2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01d9a	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01d9d	e9 b1 e2 ff ff	 jmp	 $LL1041@bp
$LN560@bp:

; 2196 :         ;
; 2197 :       case GREATER_EQ_2:
; 2198 :         MUST_BE(>=)

  01da2	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01da5	0f 8d d8 e2 ff
	ff		 jge	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01dab	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01dae	e9 a0 e2 ff ff	 jmp	 $LL1041@bp
$LN557@bp:

; 2199 :         ;
; 2200 :       case ARITH_EQ_2:
; 2201 :         MUST_BE(==)

  01db3	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01db6	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01db9	83 e1 03	 and	 ecx, 3
  01dbc	03 c9		 add	 ecx, ecx
  01dbe	8b d0		 mov	 edx, eax
  01dc0	03 c9		 add	 ecx, ecx
  01dc2	83 e2 03	 and	 edx, 3
  01dc5	0b ca		 or	 ecx, edx
  01dc7	83 f9 05	 cmp	 ecx, 5
  01dca	74 23		 je	 SHORT $LN556@bp
  01dcc	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01dcf	51		 push	 ecx
  01dd0	50		 push	 eax
  01dd1	8b 44 24 1c	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262204]
  01dd5	56		 push	 esi
  01dd6	50		 push	 eax
  01dd7	e8 00 00 00 00	 call	 _float_op
  01ddc	83 c4 10	 add	 esp, 16			; 00000010H
  01ddf	85 c0		 test	 eax, eax
  01de1	0f 85 9c e2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01de7	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01dea	e9 64 e2 ff ff	 jmp	 $LL1041@bp
$LN556@bp:

; 2199 :         ;
; 2200 :       case ARITH_EQ_2:
; 2201 :         MUST_BE(==)

  01def	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01df2	0f 84 8b e2 ff
	ff		 je	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01df8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01dfb	e9 53 e2 ff ff	 jmp	 $LL1041@bp
$LN553@bp:

; 2202 :         ;
; 2203 :       case ARITH_DIF_2:
; 2204 :         MUST_BE(!=)

  01e00	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01e03	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01e06	83 e1 03	 and	 ecx, 3
  01e09	03 c9		 add	 ecx, ecx
  01e0b	8b d0		 mov	 edx, eax
  01e0d	03 c9		 add	 ecx, ecx
  01e0f	83 e2 03	 and	 edx, 3
  01e12	0b ca		 or	 ecx, edx
  01e14	83 f9 05	 cmp	 ecx, 5
  01e17	74 23		 je	 SHORT $LN552@bp
  01e19	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01e1c	51		 push	 ecx
  01e1d	50		 push	 eax
  01e1e	8b 44 24 1c	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262204]
  01e22	56		 push	 esi
  01e23	50		 push	 eax
$LN1788@bp:
  01e24	e8 00 00 00 00	 call	 _float_op
$LN1789@bp:
  01e29	83 c4 10	 add	 esp, 16			; 00000010H
  01e2c	85 c0		 test	 eax, eax
  01e2e	0f 85 4f e2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01e34	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01e37	e9 17 e2 ff ff	 jmp	 $LL1041@bp
$LN552@bp:

; 2202 :         ;
; 2203 :       case ARITH_DIF_2:
; 2204 :         MUST_BE(!=)

  01e3c	3b 47 f8	 cmp	 eax, DWORD PTR [edi-8]
  01e3f	0f 85 3e e2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  01e45	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01e48	e9 06 e2 ff ff	 jmp	 $LL1041@bp
$LN549@bp:

; 2205 :         ;
; 2206 : 
; 2207 :       case LSHIFT_3:
; 2208 :       INT_ONLY(<<)

  01e4d	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01e50	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01e53	83 e1 03	 and	 ecx, 3
  01e56	03 c9		 add	 ecx, ecx
  01e58	8b d0		 mov	 edx, eax
  01e5a	03 c9		 add	 ecx, ecx
  01e5c	83 e2 03	 and	 edx, 3
  01e5f	0b ca		 or	 ecx, edx
  01e61	83 f9 05	 cmp	 ecx, 5
  01e64	0f 85 86 1d 00
	00		 jne	 $LN1747@bp
  01e6a	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01e6d	c1 f8 02	 sar	 eax, 2
  01e70	c1 f9 02	 sar	 ecx, 2
  01e73	d3 e0		 shl	 eax, cl
  01e75	03 c0		 add	 eax, eax
  01e77	03 c0		 add	 eax, eax
  01e79	83 c8 01	 or	 eax, 1
  01e7c	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01e82	0f 84 a7 15 00
	00		 je	 $LN32@bp
  01e88	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01e8c	55		 push	 ebp
  01e8d	c1 ee 15	 shr	 esi, 21			; 00000015H
  01e90	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01e93	51		 push	 ecx
  01e94	52		 push	 edx
  01e95	e9 45 1d 00 00	 jmp	 $LN1772@bp
$LN544@bp:

; 2209 :         ;
; 2210 :       case RSHIFT_3:
; 2211 :       INT_ONLY(>>)

  01e9a	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01e9d	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  01ea0	83 e1 03	 and	 ecx, 3
  01ea3	03 c9		 add	 ecx, ecx
  01ea5	8b d0		 mov	 edx, eax
  01ea7	03 c9		 add	 ecx, ecx
  01ea9	83 e2 03	 and	 edx, 3
  01eac	0b ca		 or	 ecx, edx
  01eae	83 f9 05	 cmp	 ecx, 5
  01eb1	0f 85 39 1d 00
	00		 jne	 $LN1747@bp
  01eb7	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  01eba	c1 f8 02	 sar	 eax, 2
  01ebd	c1 f9 02	 sar	 ecx, 2
  01ec0	d3 f8		 sar	 eax, cl
  01ec2	03 c0		 add	 eax, eax
  01ec4	03 c0		 add	 eax, eax
  01ec6	83 c8 01	 or	 eax, 1
  01ec9	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01ecf	0f 84 5a 15 00
	00		 je	 $LN32@bp
  01ed5	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01ed9	55		 push	 ebp
  01eda	c1 ee 15	 shr	 esi, 21			; 00000015H
  01edd	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01ee0	51		 push	 ecx
  01ee1	52		 push	 edx
  01ee2	e9 f8 1c 00 00	 jmp	 $LN1772@bp
$LN539@bp:

; 2212 :         ;
; 2213 :       case L_AND_3:
; 2214 :       INT_ONLY(&)

  01ee7	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  01eea	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  01eed	8b d0		 mov	 edx, eax
  01eef	83 e2 03	 and	 edx, 3
  01ef2	03 d2		 add	 edx, edx
  01ef4	03 d2		 add	 edx, edx
  01ef6	83 e1 03	 and	 ecx, 3
  01ef9	0b d1		 or	 edx, ecx
  01efb	83 fa 05	 cmp	 edx, 5
  01efe	0f 85 ec 1c 00
	00		 jne	 $LN1747@bp
  01f04	23 47 fc	 and	 eax, DWORD PTR [edi-4]
$LN1779@bp:
  01f07	83 e0 fd	 and	 eax, -3			; fffffffdH
$LN1781@bp:
  01f0a	83 c8 01	 or	 eax, 1
$LN1780@bp:
  01f0d	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  01f13	0f 84 16 15 00
	00		 je	 $LN32@bp
  01f19	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01f1d	55		 push	 ebp
  01f1e	c1 ee 15	 shr	 esi, 21			; 00000015H
  01f21	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  01f24	51		 push	 ecx
  01f25	52		 push	 edx
  01f26	e9 b4 1c 00 00	 jmp	 $LN1772@bp
$LN534@bp:

; 2215 :         ;
; 2216 :       case L_OR_3:
; 2217 :       INT_ONLY(|)

  01f2b	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  01f2e	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  01f31	8b d0		 mov	 edx, eax
  01f33	83 e2 03	 and	 edx, 3
  01f36	03 d2		 add	 edx, edx
  01f38	03 d2		 add	 edx, edx
  01f3a	83 e1 03	 and	 ecx, 3
  01f3d	0b d1		 or	 edx, ecx
  01f3f	83 fa 05	 cmp	 edx, 5
  01f42	0f 85 a8 1c 00
	00		 jne	 $LN1747@bp
  01f48	0b 47 fc	 or	 eax, DWORD PTR [edi-4]
  01f4b	eb ba		 jmp	 SHORT $LN1779@bp
$LN529@bp:

; 2218 :         ;
; 2219 :       case L_XOR_3:
; 2220 :       INT_ONLY(^)

  01f4d	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  01f50	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  01f53	8b d0		 mov	 edx, eax
  01f55	83 e2 03	 and	 edx, 3
  01f58	03 d2		 add	 edx, edx
  01f5a	03 d2		 add	 edx, edx
  01f5c	83 e1 03	 and	 ecx, 3
  01f5f	0b d1		 or	 edx, ecx
  01f61	83 fa 05	 cmp	 edx, 5
  01f64	0f 85 86 1c 00
	00		 jne	 $LN1747@bp
  01f6a	33 47 fc	 xor	 eax, DWORD PTR [edi-4]
  01f6d	eb 98		 jmp	 SHORT $LN1779@bp
$LN524@bp:

; 2221 :         ;
; 2222 : 
; 2223 :       case L_NEG_3:
; 2224 :         IF_NOT_INTEGER_OP()

  01f6f	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  01f72	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  01f75	8b d0		 mov	 edx, eax
  01f77	83 e2 03	 and	 edx, 3
  01f7a	03 d2		 add	 edx, edx
  01f7c	03 d2		 add	 edx, edx
  01f7e	83 e1 03	 and	 ecx, 3
  01f81	0b d1		 or	 edx, ecx
  01f83	83 fa 05	 cmp	 edx, 5

; 2225 :         BFAIL()

  01f86	0f 85 64 1c 00
	00		 jne	 $LN1747@bp

; 2226 :         xval = INPUT_INT(~OUTPUT_INT(X(2)));

  01f8c	c1 f8 02	 sar	 eax, 2
  01f8f	f7 d0		 not	 eax
  01f91	03 c0		 add	 eax, eax
  01f93	03 c0		 add	 eax, eax

; 2227 :         INT_COMP(|,X(1),xval)

  01f95	0b 47 fc	 or	 eax, DWORD PTR [edi-4]
  01f98	e9 6a ff ff ff	 jmp	 $LN1779@bp
$LN519@bp:

; 2228 :         ;
; 2229 : 
; 2230 :       case COMPARE0_3:
; 2231 :         ires = compare(&X(1), &X(2));

  01f9d	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  01fa0	50		 push	 eax
  01fa1	8d 4f fc	 lea	 ecx, DWORD PTR [edi-4]
  01fa4	51		 push	 ecx
  01fa5	e8 00 00 00 00	 call	 _compare

; 2232 :         xval = g.compare_vals[ires + 1];

  01faa	8b 04 85 08 01
	00 00		 mov	 eax, DWORD PTR _g[eax*4+264]
  01fb1	83 c4 08	 add	 esp, 8

; 2233 :         OUT_RESULT(xval)

  01fb4	e9 0d 1c 00 00	 jmp	 $LN1774@bp
$LN515@bp:

; 2234 :         ;
; 2235 : 
; 2236 :       case ARG_3:
; 2237 :         xval = X(1);

  01fb9	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2238 :         if (!INTEGER(xval))

  01fbc	8b d0		 mov	 edx, eax
  01fbe	80 e2 03	 and	 dl, 3
  01fc1	80 fa 01	 cmp	 dl, 1
  01fc4	74 1b		 je	 SHORT $LN514@bp

; 2239 :         BWARFUN(xval,"arg/3's 1st arg must be integer")

  01fc6	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  01fca	51		 push	 ecx
  01fcb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFCHOHFJ@arg?13?8s?51st?5arg?5must?5be?5integer?$AA@
  01fd0	50		 push	 eax
  01fd1	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  01fd6	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  01fd9	83 c4 0c	 add	 esp, 12			; 0000000cH
  01fdc	e9 72 e0 ff ff	 jmp	 $LL1041@bp
$LN514@bp:

; 2240 :         ;
; 2241 :         ires = OUTPUT_INT(xval);
; 2242 : 
; 2243 :         xref = C2T(X(2));

  01fe1	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  01fe4	c1 f8 02	 sar	 eax, 2

; 2244 :         if (ATOMIC(T2C(xref)))

  01fe7	8b ca		 mov	 ecx, edx
  01fe9	83 e1 03	 and	 ecx, 3
  01fec	89 44 24 1c	 mov	 DWORD PTR _ires$83218[esp+262196], eax
  01ff0	74 15		 je	 SHORT $LN513@bp
  01ff2	83 f9 01	 cmp	 ecx, 1
  01ff5	0f 84 f5 1b 00
	00		 je	 $LN1747@bp
  01ffb	f7 c2 00 00 00
	ff		 test	 edx, -16777216		; ff000000H

; 2245 :         BFAIL()

  02001	0f 84 e9 1b 00
	00		 je	 $LN1747@bp
$LN513@bp:

; 2246 :         ASSERT2(VAR(T2C(xref)),xref);
; 2247 :         xval = GETREF(xref);

  02007	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 2248 :         if (VAR(xval))

  02009	f6 c1 03	 test	 cl, 3
  0200c	75 1b		 jne	 SHORT $LN511@bp

; 2249 :         BWARFUN(xval,"arg/3's 2nd arg must be nonvar")

  0200e	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02012	52		 push	 edx
  02013	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PIJIHPDP@arg?13?8s?52nd?5arg?5must?5be?5nonvar?$AA@
  02018	51		 push	 ecx
  02019	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  0201e	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02021	83 c4 0c	 add	 esp, 12			; 0000000cH
  02024	e9 2a e0 ff ff	 jmp	 $LL1041@bp
$LN511@bp:

; 2250 :         ;
; 2251 :         if (ires <= 0 || (no) ires > GETARITY(xval))

  02029	85 c0		 test	 eax, eax
  0202b	7e 17		 jle	 SHORT $LN509@bp
  0202d	8b c1		 mov	 eax, ecx
  0202f	c1 e8 18	 shr	 eax, 24			; 00000018H
  02032	39 44 24 1c	 cmp	 DWORD PTR _ires$83218[esp+262196], eax
  02036	77 0c		 ja	 SHORT $LN509@bp

; 2253 :         ;
; 2254 :         xref += ires;

  02038	8b 4c 24 1c	 mov	 ecx, DWORD PTR _ires$83218[esp+262196]
  0203c	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 2255 :         OUT_RESULT(xref)

  0203f	e9 82 1b 00 00	 jmp	 $LN1774@bp
$LN509@bp:

; 2252 :         BWARFUN(xval,"arg/3's 1st arg must be in 1..arity")

  02044	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02048	52		 push	 edx
  02049	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DEDAKFBO@arg?13?8s?51st?5arg?5must?5be?5in?51?4?4ar@
  0204e	51		 push	 ecx
  0204f	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  02054	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0205a	e9 f4 df ff ff	 jmp	 $LL1041@bp
$LN505@bp:

; 2256 :         ;
; 2257 : 
; 2258 :       case SETARG_3:
; 2259 :         BUG("setarg/3 called");
; 2260 :         if (!setarg(regs, wam, A))

  0205f	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02063	55		 push	 ebp
  02064	50		 push	 eax
  02065	57		 push	 edi
  02066	e8 00 00 00 00	 call	 _setarg
  0206b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0206e	85 c0		 test	 eax, eax
  02070	0f 85 0d e0 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02076	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02079	e9 d5 df ff ff	 jmp	 $LL1041@bp
$LN503@bp:

; 2261 :         BFAIL()
; 2262 :         BNEXT(1)
; 2263 :         ;
; 2264 : 
; 2265 :         /* BEXIT("%%unimplemented: setarg/3"); */
; 2266 : 
; 2267 :       case CHANGE_ARG_3:
; 2268 :         if (!change_arg(regs, wam, A))

  0207e	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02082	55		 push	 ebp
  02083	51		 push	 ecx
  02084	57		 push	 edi
  02085	e8 00 00 00 00	 call	 _change_arg
  0208a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0208d	85 c0		 test	 eax, eax
  0208f	0f 85 ee df ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02095	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02098	e9 b6 df ff ff	 jmp	 $LL1041@bp
$LN501@bp:

; 2269 :         BFAIL()
; 2270 :         BNEXT(1)
; 2271 :         ;
; 2272 : 
; 2273 :       case DEF_3:
; 2274 :         if (!def(regs, wam, BBOARDTIME))

  0209d	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  020a1	6a 03		 push	 3
  020a3	52		 push	 edx
  020a4	57		 push	 edi
  020a5	e8 00 00 00 00	 call	 _def
  020aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  020ad	85 c0		 test	 eax, eax
  020af	0f 85 ce df ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  020b5	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  020b8	e9 96 df ff ff	 jmp	 $LL1041@bp
$LN499@bp:

; 2275 :         BFAIL()
; 2276 :         BNEXT(1)
; 2277 :         ;
; 2278 : 
; 2279 :       case RM_2:
; 2280 :         X(3) = g.empty;

  020bd	a1 38 00 00 00	 mov	 eax, DWORD PTR _g+56
  020c2	89 47 f4	 mov	 DWORD PTR [edi-12], eax
$LN498@bp:

; 2281 :       case SET_3:
; 2282 :         if (!set(regs, wam, BBOARDTIME))

  020c5	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  020c9	6a 03		 push	 3
  020cb	51		 push	 ecx
  020cc	57		 push	 edi
  020cd	e8 00 00 00 00	 call	 _set
  020d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  020d5	85 c0		 test	 eax, eax
  020d7	0f 85 a6 df ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  020dd	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  020e0	e9 6e df ff ff	 jmp	 $LL1041@bp
$LN496@bp:

; 2283 :         BFAIL()
; 2284 :         BNEXT(1)
; 2285 :         ;
; 2286 : 
; 2287 :       case VAL_3:
; 2288 :         ATOMIZE(X(1));

  020e5	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  020e8	8b c8		 mov	 ecx, eax
  020ea	83 e1 03	 and	 ecx, 3
  020ed	74 0c		 je	 SHORT $LN1710@bp
  020ef	83 f9 01	 cmp	 ecx, 1
  020f2	74 0c		 je	 SHORT $LN1731@bp
  020f4	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  020f9	74 05		 je	 SHORT $LN1731@bp
$LN1710@bp:
  020fb	8b 10		 mov	 edx, DWORD PTR [eax]
  020fd	89 57 fc	 mov	 DWORD PTR [edi-4], edx
$LN1731@bp:

; 2289 :         ATOMIZE(X(2));

  02100	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  02103	8b c8		 mov	 ecx, eax
  02105	83 e1 03	 and	 ecx, 3
  02108	74 0c		 je	 SHORT $LN492@bp
  0210a	83 f9 01	 cmp	 ecx, 1
  0210d	74 0c		 je	 SHORT $LN493@bp
  0210f	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  02114	74 05		 je	 SHORT $LN493@bp
$LN492@bp:
  02116	8b 00		 mov	 eax, DWORD PTR [eax]
  02118	89 47 f8	 mov	 DWORD PTR [edi-8], eax
$LN493@bp:

; 2290 :         xval = hget(X(1), X(2));

  0211b	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  0211e	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  02121	51		 push	 ecx
  02122	52		 push	 edx
  02123	e8 00 00 00 00	 call	 _hget
  02128	83 c4 08	 add	 esp, 8

; 2291 :         if ((0 == xval) || (g.empty == xval))

  0212b	85 c0		 test	 eax, eax
  0212d	0f 84 ad 1c 00
	00		 je	 $LN1701@bp
  02133	39 05 38 00 00
	00		 cmp	 DWORD PTR _g+56, eax
  02139	0f 84 a1 1c 00
	00		 je	 $LN1701@bp

; 2292 :         BFAIL()
; 2293 :         /*fprintf(STD_err,"VAL_3: %ld$$$\n\n",xval);*/
; 2294 :         SAFE_OUT(xval)

  0213f	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02145	0f 84 e4 12 00
	00		 je	 $LN32@bp
  0214b	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0214f	55		 push	 ebp
  02150	c1 ee 15	 shr	 esi, 21			; 00000015H
  02153	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02156	51		 push	 ecx
  02157	52		 push	 edx
  02158	50		 push	 eax
  02159	e8 00 00 00 00	 call	 _unify_to
  0215e	e9 82 1a 00 00	 jmp	 $LN1775@bp
$LN486@bp:

; 2295 :         ;
; 2296 : 
; 2297 :       case LVAL_3: /* now checks with SAFE_HASH_OP */
; 2298 :         BUG("lval called");
; 2299 :         if (!(xval = lval(regs, wam, VARTIME)))

  02163	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02167	6a 04		 push	 4
  02169	50		 push	 eax
  0216a	57		 push	 edi
  0216b	e8 00 00 00 00	 call	 _lval
  02170	83 c4 0c	 add	 esp, 12			; 0000000cH
  02173	85 c0		 test	 eax, eax

; 2300 :         BFAIL()

  02175	0f 84 75 1a 00
	00		 je	 $LN1747@bp

; 2301 :         SAFE_OUT(xval)

  0217b	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02181	0f 84 a8 12 00
	00		 je	 $LN32@bp
  02187	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0218b	55		 push	 ebp
  0218c	c1 ee 15	 shr	 esi, 21			; 00000015H
  0218f	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02192	51		 push	 ecx
  02193	52		 push	 edx
  02194	50		 push	 eax
  02195	e8 00 00 00 00	 call	 _unify_to
  0219a	e9 46 1a 00 00	 jmp	 $LN1775@bp
$LN481@bp:

; 2302 :         ;
; 2303 : 
; 2304 :       case SYMCAT_3:
; 2305 :         xval = symcat(regs, wam);

  0219f	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  021a3	50		 push	 eax
  021a4	57		 push	 edi
  021a5	e8 00 00 00 00	 call	 _symcat
  021aa	83 c4 08	 add	 esp, 8

; 2306 :         if (!xval)

  021ad	85 c0		 test	 eax, eax

; 2307 :         BFAIL()

  021af	0f 84 3b 1a 00
	00		 je	 $LN1747@bp

; 2308 :         OUT_RESULT(xval)

  021b5	e9 53 fd ff ff	 jmp	 $LN1780@bp
$LN476@bp:

; 2309 :         ;
; 2310 : 
; 2311 :         /* C-ification of builtins ends here. To be continued... */
; 2312 : 
; 2313 :       case NAMECAT_4:
; 2314 :         xval = namecat(regs, wam);

  021ba	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  021be	50		 push	 eax
  021bf	57		 push	 edi
  021c0	e8 00 00 00 00	 call	 _namecat
  021c5	83 c4 08	 add	 esp, 8

; 2315 :         if (!xval)

  021c8	85 c0		 test	 eax, eax

; 2316 :         BFAIL()

  021ca	0f 84 20 1a 00
	00		 je	 $LN1747@bp

; 2317 :         OUT_RESULT(xval)

  021d0	e9 38 fd ff ff	 jmp	 $LN1780@bp
$LN471@bp:

; 2318 :         ;
; 2319 : 
; 2320 :       case DEEP_HASH_4: {
; 2321 :         xval = X(2);

  021d5	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]

; 2322 :         ATOMIZE(xval);

  021d8	8b c8		 mov	 ecx, eax
  021da	83 e1 03	 and	 ecx, 3
  021dd	74 0c		 je	 SHORT $LN1711@bp
  021df	83 f9 01	 cmp	 ecx, 1
  021e2	74 09		 je	 SHORT $LN1732@bp
  021e4	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  021e9	74 02		 je	 SHORT $LN1732@bp
$LN1711@bp:
  021eb	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1732@bp:

; 2323 :         if (!INTEGER(xval))

  021ed	8b c8		 mov	 ecx, eax
  021ef	80 e1 03	 and	 cl, 3
  021f2	80 f9 01	 cmp	 cl, 1
  021f5	74 1b		 je	 SHORT $LN468@bp

; 2324 :         BWARFUN(xval,"deep_hash's 2nd arg (rec. level) must be integer");

  021f7	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  021fb	52		 push	 edx
  021fc	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KKPNJCHL@deep_hash?8s?52nd?5arg?5?$CIrec?4?5level?$CJ@
  02201	50		 push	 eax
  02202	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  02207	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0220a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0220d	e9 41 de ff ff	 jmp	 $LL1041@bp
$LN468@bp:

; 2325 :         ires = OUTPUT_INT(xval);
; 2326 : 
; 2327 :         xval = X(3);

  02212	8b 4f f4	 mov	 ecx, DWORD PTR [edi-12]

; 2328 :         ATOMIZE(xval);

  02215	8b d1		 mov	 edx, ecx
  02217	c1 f8 02	 sar	 eax, 2
  0221a	83 e2 03	 and	 edx, 3
  0221d	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  02221	74 0d		 je	 SHORT $LN466@bp
  02223	83 fa 01	 cmp	 edx, 1
  02226	74 0e		 je	 SHORT $LN467@bp
  02228	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  0222e	74 06		 je	 SHORT $LN467@bp
$LN466@bp:
  02230	8b 09		 mov	 ecx, DWORD PTR [ecx]
  02232	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
$LN467@bp:

; 2329 :         if (!INTEGER(xval))

  02236	80 e1 03	 and	 cl, 3
  02239	80 f9 01	 cmp	 cl, 1
  0223c	74 1f		 je	 SHORT $LN465@bp

; 2330 :         BWARFUN(xval,"deep_hash's 3nd arg (mod) must be integer");

  0223e	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02242	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  02246	50		 push	 eax
  02247	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IANFFGNM@deep_hash?8s?53nd?5arg?5?$CImod?$CJ?5must?5b@
  0224c	51		 push	 ecx
  0224d	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  02252	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02255	83 c4 0c	 add	 esp, 12			; 0000000cH
  02258	e9 f6 dd ff ff	 jmp	 $LL1041@bp
$LN465@bp:

; 2331 :         ires = deep_hash(X(1), ires, OUTPUT_INT(xval)); /* do not atomize X(1)! */

  0225d	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  02261	c1 fa 02	 sar	 edx, 2
  02264	52		 push	 edx
  02265	50		 push	 eax
  02266	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02269	50		 push	 eax
  0226a	e8 00 00 00 00	 call	 _deep_hash
  0226f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2332 :         /* key, max recursion, mod */
; 2333 :       }
; 2334 :         if (-2 == ires)

  02272	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  02275	75 1f		 jne	 SHORT $LN464@bp

; 2335 :         BWARFUN(xval,"large or cyclic 1st arg in deep_hash: recursion depth error")

  02277	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0227b	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  0227f	51		 push	 ecx
  02280	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EAAFBHNF@large?5or?5cyclic?51st?5arg?5in?5deep_@
  02285	52		 push	 edx
  02286	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  0228b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0228e	83 c4 0c	 add	 esp, 12			; 0000000cH
  02291	e9 bd dd ff ff	 jmp	 $LL1041@bp
$LN464@bp:

; 2336 :         ;
; 2337 :         if (ires < 0)

  02296	85 c0		 test	 eax, eax

; 2338 :         BFAIL()

  02298	0f 88 52 19 00
	00		 js	 $LN1747@bp

; 2339 :         xval = INPUT_INT(ires);

  0229e	03 c0		 add	 eax, eax
  022a0	03 c0		 add	 eax, eax

; 2340 :         OUT_RESULT(xval)

  022a2	e9 63 fc ff ff	 jmp	 $LN1781@bp
$LN459@bp:

; 2341 :         ;
; 2342 : 
; 2343 :       case GVAL_2:
; 2344 :         xref = H;
; 2345 :         H = tval(H, X(1), 0); /* var or fun->name/0 */

  022a7	6a 00		 push	 0

; 2346 :         OUT_RESULT(xref)

  022a9	eb 02		 jmp	 SHORT $LN1792@bp
$LN455@bp:

; 2351 :         H = tval(H, X(1), 1); /* fun->symno/arity */

  022ab	6a 01		 push	 1
$LN1792@bp:
  022ad	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  022b0	8b 44 24 18	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262200]
  022b4	51		 push	 ecx
  022b5	50		 push	 eax
  022b6	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  022ba	e8 00 00 00 00	 call	 _tval
  022bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  022c2	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2352 :         OUT_RESULT(xref)

  022c6	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  022cc	0f 84 89 0f 00
	00		 je	 $LN154@bp
  022d2	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  022d6	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  022da	55		 push	 ebp
  022db	52		 push	 edx
  022dc	c1 ee 15	 shr	 esi, 21			; 00000015H
  022df	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  022e2	50		 push	 eax
  022e3	51		 push	 ecx
  022e4	e8 00 00 00 00	 call	 _unify
  022e9	83 c4 10	 add	 esp, 16			; 00000010H
  022ec	85 c0		 test	 eax, eax
  022ee	0f 85 71 0f 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  022f4	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  022f7	e9 57 dd ff ff	 jmp	 $LL1041@bp
$LN451@bp:

; 2353 :         ;
; 2354 : 
; 2355 :       case TVAL_3:
; 2356 :         ATOMIZE(X(1));

  022fc	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  022ff	8b c8		 mov	 ecx, eax
  02301	83 e1 03	 and	 ecx, 3
  02304	74 0c		 je	 SHORT $LN1712@bp
  02306	83 f9 01	 cmp	 ecx, 1
  02309	74 0c		 je	 SHORT $LN1733@bp
  0230b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  02310	74 05		 je	 SHORT $LN1733@bp
$LN1712@bp:
  02312	8b 00		 mov	 eax, DWORD PTR [eax]
  02314	89 47 fc	 mov	 DWORD PTR [edi-4], eax
$LN1733@bp:

; 2357 :         ATOMIZE(X(2));

  02317	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0231a	8b c8		 mov	 ecx, eax
  0231c	83 e1 03	 and	 ecx, 3
  0231f	74 0c		 je	 SHORT $LN447@bp
  02321	83 f9 01	 cmp	 ecx, 1
  02324	74 0c		 je	 SHORT $LN448@bp
  02326	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0232b	74 05		 je	 SHORT $LN448@bp
$LN447@bp:
  0232d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0232f	89 4f f8	 mov	 DWORD PTR [edi-8], ecx
$LN448@bp:

; 2358 :         xval = hget(X(1), X(2));

  02332	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  02335	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02338	52		 push	 edx
  02339	50		 push	 eax
  0233a	e8 00 00 00 00	 call	 _hget
  0233f	83 c4 08	 add	 esp, 8

; 2359 :         if (!xval)

  02342	85 c0		 test	 eax, eax

; 2360 :         BFAIL()

  02344	0f 84 a6 18 00
	00		 je	 $LN1747@bp

; 2361 :         H = tval((xref = H), xval, 0); /* OK! 0=> F/N *???*/
; 2362 :         OUT_RESULT(xref)

  0234a	e9 a7 00 00 00	 jmp	 $LN1786@bp
$LN442@bp:

; 2363 :         ;
; 2364 : 
; 2365 :       case TLET_3:
; 2366 :         if (!tlet(regs))

  0234f	57		 push	 edi
  02350	e8 00 00 00 00	 call	 _tlet
  02355	83 c4 04	 add	 esp, 4
  02358	85 c0		 test	 eax, eax
  0235a	0f 85 23 dd ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02360	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02363	e9 eb dc ff ff	 jmp	 $LL1041@bp
$LN440@bp:

; 2367 :         BFAIL()
; 2368 :         BNEXT(1)
; 2369 :         ;
; 2370 : 
; 2371 :       case GET_ASSERTED_2:
; 2372 :         if (!(xval = get_asserted(regs, wam)))

  02368	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  0236c	52		 push	 edx
  0236d	57		 push	 edi
  0236e	e8 00 00 00 00	 call	 _get_asserted
  02373	83 c4 08	 add	 esp, 8
  02376	85 c0		 test	 eax, eax

; 2373 :         BFAIL()

  02378	0f 84 72 18 00
	00		 je	 $LN1747@bp

; 2374 :         SAFE_OUT(xval)

  0237e	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02384	0f 84 a5 10 00
	00		 je	 $LN32@bp
  0238a	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0238e	55		 push	 ebp
  0238f	c1 ee 15	 shr	 esi, 21			; 00000015H
  02392	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02395	51		 push	 ecx
  02396	52		 push	 edx
  02397	50		 push	 eax
  02398	e8 00 00 00 00	 call	 _unify_to
  0239d	e9 43 18 00 00	 jmp	 $LN1775@bp
$LN435@bp:

; 2375 :         ;
; 2376 : 
; 2377 :       case ARRAY_SET_3:
; 2378 :         if (!(xref = array_ref(X(1), X(2), wam)))

  023a2	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  023a6	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  023a9	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  023ac	50		 push	 eax
  023ad	51		 push	 ecx
  023ae	52		 push	 edx
  023af	e8 00 00 00 00	 call	 _array_ref
  023b4	8b f0		 mov	 esi, eax
  023b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  023b9	85 f6		 test	 esi, esi

; 2379 :         BFAIL()

  023bb	0f 84 2f 18 00
	00		 je	 $LN1747@bp

; 2380 :         xval = untval(C2T(X(3)));

  023c1	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  023c4	50		 push	 eax
  023c5	e8 00 00 00 00	 call	 _untval
  023ca	83 c4 04	 add	 esp, 4

; 2381 :         SETREF(xref,xval);

  023cd	89 06		 mov	 DWORD PTR [esi], eax

; 2382 :         BNEXT(1)

  023cf	83 c3 04	 add	 ebx, 4

; 2383 :         ;

  023d2	e9 7c dc ff ff	 jmp	 $LL1041@bp
$LN433@bp:

; 2384 : 
; 2385 :       case ARRAY_GET0_3:
; 2386 :         if (!(xref = array_ref(X(1), X(2), wam)))

  023d7	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  023db	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  023de	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  023e1	51		 push	 ecx
  023e2	52		 push	 edx
  023e3	50		 push	 eax
  023e4	e8 00 00 00 00	 call	 _array_ref
  023e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  023ec	85 c0		 test	 eax, eax

; 2387 :         BFAIL()

  023ee	0f 84 fc 17 00
	00		 je	 $LN1747@bp

; 2388 :         xval = GETREF(xref);

  023f4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1786@bp:

; 2389 :         H = tval((xref = H), xval, 0);

  023f6	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  023fa	6a 00		 push	 0
  023fc	50		 push	 eax
  023fd	51		 push	 ecx
  023fe	89 4c 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], ecx
  02402	e8 00 00 00 00	 call	 _tval
  02407	83 c4 0c	 add	 esp, 12			; 0000000cH
  0240a	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2390 :         OUT_RESULT(xref)

  0240e	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02414	0f 84 02 08 00
	00		 je	 $LN281@bp
  0241a	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0241e	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  02422	55		 push	 ebp
  02423	51		 push	 ecx
  02424	c1 ee 15	 shr	 esi, 21			; 00000015H
  02427	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  0242a	52		 push	 edx
  0242b	50		 push	 eax
  0242c	e8 00 00 00 00	 call	 _unify
  02431	83 c4 10	 add	 esp, 16			; 00000010H
  02434	85 c0		 test	 eax, eax
  02436	0f 85 ea 07 00
	00		 jne	 $LN279@bp

; 3141 :         OUT_RESULT(xval);

  0243c	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0243f	e9 0f dc ff ff	 jmp	 $LL1041@bp
$LN428@bp:

; 2391 :         ;
; 2392 : 
; 2393 :       case ARRAY_GET_3:
; 2394 :         if (!(xref = array_ref(X(1), X(2), wam)))

  02444	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02448	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0244b	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  0244e	52		 push	 edx
  0244f	50		 push	 eax
  02450	51		 push	 ecx
  02451	e8 00 00 00 00	 call	 _array_ref
  02456	83 c4 0c	 add	 esp, 12			; 0000000cH
  02459	85 c0		 test	 eax, eax

; 2395 :         BFAIL()

  0245b	0f 84 8f 17 00
	00		 je	 $LN1747@bp

; 2396 :         xval = GETREF(xref);
; 2397 :         DEREF1(xval)

  02461	8b 08		 mov	 ecx, DWORD PTR [eax]
  02463	f6 c1 03	 test	 cl, 3
  02466	75 25		 jne	 SHORT $LN1793@bp
  02468	8b 01		 mov	 eax, DWORD PTR [ecx]
  0246a	a8 03		 test	 al, 3
  0246c	75 0e		 jne	 SHORT $LN423@bp
  0246e	8b ff		 npad	 2
$LL424@bp:
  02470	3b c8		 cmp	 ecx, eax
  02472	74 08		 je	 SHORT $LN423@bp
  02474	8b c8		 mov	 ecx, eax
  02476	8b 00		 mov	 eax, DWORD PTR [eax]
  02478	a8 03		 test	 al, 3
  0247a	74 f4		 je	 SHORT $LL424@bp
$LN423@bp:
  0247c	8b d0		 mov	 edx, eax
  0247e	83 e2 03	 and	 edx, 3
  02481	80 fa 03	 cmp	 dl, 3
  02484	75 09		 jne	 SHORT $LN1052@bp
  02486	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0248b	74 02		 je	 SHORT $LN1052@bp
$LN1793@bp:
  0248d	8b c1		 mov	 eax, ecx
$LN1052@bp:

; 2398 :         ;
; 2399 :         H = tval((xref = H), xval, 0);

  0248f	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  02493	6a 00		 push	 0
  02495	50		 push	 eax
  02496	51		 push	 ecx
  02497	89 4c 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], ecx
  0249b	e8 00 00 00 00	 call	 _tval
  024a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  024a3	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2400 :         OUT_RESULT(xref)

  024a7	e9 a5 07 00 00	 jmp	 $LN1785@bp
$LN419@bp:

; 2401 :         ;
; 2402 : 
; 2403 :       case MAKE_ARRAY_2:
; 2404 :         xval = X(1);

  024ac	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2405 :         if (!INTEGER(xval))

  024af	8b c8		 mov	 ecx, eax
  024b1	80 e1 03	 and	 cl, 3
  024b4	80 f9 01	 cmp	 cl, 1

; 2406 :         BFAIL()

  024b7	0f 85 33 17 00
	00		 jne	 $LN1747@bp

; 2407 :         if (!(xref = make_var_array(xval)))

  024bd	50		 push	 eax
  024be	e8 00 00 00 00	 call	 _make_var_array
  024c3	83 c4 04	 add	 esp, 4
  024c6	85 c0		 test	 eax, eax

; 2408 :         BFAIL()

  024c8	0f 84 22 17 00
	00		 je	 $LN1747@bp

; 2409 :         xval = PTR2INT(xref);

  024ce	40		 inc	 eax

; 2410 :         OUT_RESULT(xval)

  024cf	e9 f2 16 00 00	 jmp	 $LN1774@bp
$LN413@bp:

; 2411 :         ;
; 2412 : 
; 2413 :       case DESTROY_ARRAY_1:
; 2414 :         xval = X(1);

  024d4	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2415 :         if (!INTEGER(xval))

  024d7	8b d0		 mov	 edx, eax
  024d9	80 e2 03	 and	 dl, 3
  024dc	80 fa 01	 cmp	 dl, 1

; 2416 :         BFAIL()

  024df	0f 85 0b 17 00
	00		 jne	 $LN1747@bp

; 2417 :         xref = (term) INT2PTR(xval);

  024e5	48		 dec	 eax

; 2418 :         XFREE(xref);

  024e6	50		 push	 eax
  024e7	e8 00 00 00 00	 call	 _free
  024ec	83 c4 04	 add	 esp, 4

; 2419 :         BNEXT(1)

  024ef	83 c3 04	 add	 ebx, 4

; 2420 :         ;

  024f2	e9 5c db ff ff	 jmp	 $LL1041@bp
$LN411@bp:

; 2421 : 
; 2422 :       case VGET_INT0_2:
; 2423 :         if (!(xref = array_ref(X(1), INPUT_INT(0), wam)))

  024f7	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  024fb	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  024fe	50		 push	 eax
  024ff	6a 01		 push	 1
  02501	51		 push	 ecx
  02502	e8 00 00 00 00	 call	 _array_ref
  02507	83 c4 0c	 add	 esp, 12			; 0000000cH
  0250a	85 c0		 test	 eax, eax

; 2424 :         BFAIL()

  0250c	0f 84 de 16 00
	00		 je	 $LN1747@bp

; 2425 :         xval = INPUT_INT(xref[0]);

  02512	8b 00		 mov	 eax, DWORD PTR [eax]
  02514	03 c0		 add	 eax, eax
  02516	03 c0		 add	 eax, eax
  02518	83 c8 01	 or	 eax, 1

; 2426 :         OUT_RESULT(xval)

  0251b	e9 a6 16 00 00	 jmp	 $LN1774@bp
$LN406@bp:

; 2427 :         ;
; 2428 : 
; 2429 :       case VSET_INT0_2:
; 2430 :         xval = X(2);

  02520	8b 77 f8	 mov	 esi, DWORD PTR [edi-8]

; 2431 :         if (!INTEGER(xval))

  02523	8b d6		 mov	 edx, esi
  02525	80 e2 03	 and	 dl, 3
  02528	80 fa 01	 cmp	 dl, 1

; 2432 :         BFAIL()

  0252b	0f 85 bf 16 00
	00		 jne	 $LN1747@bp

; 2433 :         if (!(xref = array_ref(X(1), INPUT_INT(0), wam)))

  02531	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02535	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  02538	50		 push	 eax
  02539	6a 01		 push	 1
  0253b	51		 push	 ecx
  0253c	e8 00 00 00 00	 call	 _array_ref
  02541	83 c4 0c	 add	 esp, 12			; 0000000cH
  02544	85 c0		 test	 eax, eax

; 2434 :         BFAIL()

  02546	0f 84 a4 16 00
	00		 je	 $LN1747@bp

; 2435 :         xref[0] = OUTPUT_INT(xval);

  0254c	c1 fe 02	 sar	 esi, 2
  0254f	89 30		 mov	 DWORD PTR [eax], esi

; 2436 :         BNEXT(1)

  02551	83 c3 04	 add	 ebx, 4

; 2437 :         ;

  02554	e9 fa da ff ff	 jmp	 $LL1041@bp
$LN403@bp:

; 2438 : 
; 2439 :       case ADDQ0_2:
; 2440 :         if (!addq0(wam, RX(1), X(2)))

  02559	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  0255c	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  0255f	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02563	52		 push	 edx
  02564	50		 push	 eax
  02565	51		 push	 ecx
  02566	e8 00 00 00 00	 call	 _addq0
  0256b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0256e	85 c0		 test	 eax, eax
  02570	0f 85 0d db ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02576	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02579	e9 d5 da ff ff	 jmp	 $LL1041@bp
$LN401@bp:

; 2441 :         BFAIL()
; 2442 :         BNEXT(1)
; 2443 :         ;
; 2444 : 
; 2445 :       case PUSHQ0_2:
; 2446 :         if (!pushq0(wam, RX(1), X(2)))

  0257e	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  02581	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02584	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02588	52		 push	 edx
  02589	50		 push	 eax
  0258a	51		 push	 ecx
  0258b	e8 00 00 00 00	 call	 _pushq0
  02590	83 c4 0c	 add	 esp, 12			; 0000000cH
  02593	85 c0		 test	 eax, eax
  02595	0f 85 e8 da ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  0259b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0259e	e9 b0 da ff ff	 jmp	 $LL1041@bp
$LN399@bp:

; 2447 :         BFAIL()
; 2448 :         BNEXT(1)
; 2449 :         ;
; 2450 : 
; 2451 :       case POPQ0_2:
; 2452 :         wam[HeapStk].top = (term*) H;

  025a3	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  025a7	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  025ab	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2453 :         xref = popq0(HeapStk, wam, RX(1));

  025ae	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  025b1	51		 push	 ecx
  025b2	50		 push	 eax
  025b3	6a 00		 push	 0
  025b5	e8 00 00 00 00	 call	 _popq0
  025ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2454 :         if (!xref)

  025bd	85 c0		 test	 eax, eax

; 2455 :         BFAIL()

  025bf	0f 84 2b 16 00
	00		 je	 $LN1747@bp

; 2456 :         H = (term) wam[HeapStk].top;

  025c5	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  025c9	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  025cc	89 4c 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], ecx

; 2457 :         SAFE_OUT(xref)

  025d0	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  025d6	0f 84 53 0e 00
	00		 je	 $LN32@bp
  025dc	55		 push	 ebp
  025dd	c1 ee 15	 shr	 esi, 21			; 00000015H
  025e0	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  025e3	52		 push	 edx
  025e4	51		 push	 ecx
  025e5	50		 push	 eax
  025e6	e8 00 00 00 00	 call	 _unify_to
  025eb	e9 f5 15 00 00	 jmp	 $LN1775@bp
$LN394@bp:

; 2458 :         ;
; 2459 : 
; 2460 :       case DCG_CONNECT_1:
; 2461 :         if (!(H = dcg_connect(H, regs, wam, A)))

  025f0	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  025f4	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  025f8	55		 push	 ebp
  025f9	52		 push	 edx
  025fa	57		 push	 edi
  025fb	50		 push	 eax
  025fc	e8 00 00 00 00	 call	 _dcg_connect
  02601	83 c4 10	 add	 esp, 16			; 00000010H
  02604	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02608	85 c0		 test	 eax, eax

; 2462 :         BFAIL()

  0260a	0f 84 e0 15 00
	00		 je	 $LN1747@bp

; 2463 :         OUT_RESULT(X(0))

  02610	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02616	74 24		 je	 SHORT $LN392@bp
  02618	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0261c	8b 07		 mov	 eax, DWORD PTR [edi]
  0261e	55		 push	 ebp
  0261f	51		 push	 ecx
  02620	c1 ee 15	 shr	 esi, 21			; 00000015H
  02623	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02626	52		 push	 edx
  02627	50		 push	 eax
  02628	e8 00 00 00 00	 call	 _unify
  0262d	83 c4 10	 add	 esp, 16			; 00000010H
  02630	85 c0		 test	 eax, eax
  02632	75 10		 jne	 SHORT $LN390@bp

; 3141 :         OUT_RESULT(xval);

  02634	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02637	e9 17 da ff ff	 jmp	 $LL1041@bp
$LN392@bp:

; 2463 :         OUT_RESULT(X(0))

  0263c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0263e	c1 ee 15	 shr	 esi, 21			; 00000015H
  02641	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
$LN390@bp:
  02644	83 c3 04	 add	 ebx, 4

; 2464 :         ;

  02647	e9 07 da ff ff	 jmp	 $LL1041@bp
$LN389@bp:

; 2465 : 
; 2466 :       case LIST2TERM_2:
; 2467 :         xref = H;
; 2468 :         if (!(H = list2term(H, regs, wam)))

  0264c	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02650	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  02654	52		 push	 edx
  02655	57		 push	 edi
  02656	50		 push	 eax
  02657	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  0265b	e8 00 00 00 00	 call	 _list2term

; 2469 :         BFAIL()
; 2470 :         OUT_RESULT(xref)

  02660	e9 dd 05 00 00	 jmp	 $LN1784@bp
$LN384@bp:

; 2471 :         ;
; 2472 : 
; 2473 :       case TERM2LIST_4:
; 2474 :         xref = H;
; 2475 :         if (!(H = term2list(H, regs, wam)))

  02665	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02669	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  0266d	51		 push	 ecx
  0266e	57		 push	 edi
  0266f	50		 push	 eax
  02670	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02674	e8 00 00 00 00	 call	 _term2list
  02679	83 c4 0c	 add	 esp, 12			; 0000000cH
  0267c	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02680	85 c0		 test	 eax, eax

; 2476 :         BFAIL()

  02682	0f 84 68 15 00
	00		 je	 $LN1747@bp

; 2477 :         OUT_RESULT(xref)

  02688	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  0268e	0f 84 c7 0b 00
	00		 je	 $LN154@bp
  02694	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02698	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  0269c	55		 push	 ebp
  0269d	52		 push	 edx
  0269e	c1 ee 15	 shr	 esi, 21			; 00000015H
  026a1	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  026a4	50		 push	 eax
  026a5	51		 push	 ecx
  026a6	e8 00 00 00 00	 call	 _unify
  026ab	83 c4 10	 add	 esp, 16			; 00000010H
  026ae	85 c0		 test	 eax, eax
  026b0	0f 85 af 0b 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  026b6	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  026b9	e9 95 d9 ff ff	 jmp	 $LL1041@bp
$LN379@bp:

; 2478 :         ;
; 2479 : #if 0
; 2480 :         case SELF_INFO_1:
; 2481 :         BEXIT("unexpected SELF_INFO");
; 2482 :         xval=INPUT_INT(LEFTFIELD);
; 2483 :         /* return the arity of the (lexically speaking)
; 2484 :          `current predicate' */
; 2485 :         OUT_RESULT(xval);
; 2486 : #endif
; 2487 :       case CALL_EXTERNAL_3:
; 2488 :         xref = H;
; 2489 :         H = call_external(H, regs, wam);

  026be	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  026c2	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  026c6	51		 push	 ecx
  026c7	57		 push	 edi
  026c8	50		 push	 eax
  026c9	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  026cd	e8 00 00 00 00	 call	 _call_external
  026d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  026d5	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2490 :         if (NULL == H) {

  026d9	85 c0		 test	 eax, eax

; 2491 :           /*BEXIT("failed external C function call");*/
; 2492 :           BFAIL()

  026db	0f 84 0f 15 00
	00		 je	 $LN1747@bp

; 2493 :         }
; 2494 :         OUT_RESULT(xref)

  026e1	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  026e7	0f 84 6e 0b 00
	00		 je	 $LN154@bp
  026ed	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  026f1	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  026f5	55		 push	 ebp
  026f6	52		 push	 edx
  026f7	c1 ee 15	 shr	 esi, 21			; 00000015H
  026fa	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  026fd	50		 push	 eax
  026fe	51		 push	 ecx
  026ff	e8 00 00 00 00	 call	 _unify
  02704	83 c4 10	 add	 esp, 16			; 00000010H
  02707	85 c0		 test	 eax, eax
  02709	0f 85 56 0b 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  0270f	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02712	e9 3c d9 ff ff	 jmp	 $LL1041@bp
$LN374@bp:

; 2495 :         ;
; 2496 : 
; 2497 :       case ADD_INSTR_4:
; 2498 :         if (!add_instr(regs, wam))

  02717	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  0271b	50		 push	 eax
  0271c	57		 push	 edi
  0271d	e8 00 00 00 00	 call	 _add_instr
  02722	83 c4 08	 add	 esp, 8
  02725	85 c0		 test	 eax, eax
  02727	0f 85 56 d9 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  0272d	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02730	e9 1e d9 ff ff	 jmp	 $LL1041@bp
$LN372@bp:

; 2499 :         BFAIL()
; 2500 :         BNEXT(1)
; 2501 :         ;
; 2502 : 
; 2503 :       case OLDER_FILE_2:
; 2504 :         if (!older_file(regs, wam))

  02735	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02739	51		 push	 ecx
  0273a	57		 push	 edi
  0273b	e8 00 00 00 00	 call	 _older_file
  02740	83 c4 08	 add	 esp, 8
  02743	85 c0		 test	 eax, eax
  02745	0f 85 38 d9 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  0274b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0274e	e9 00 d9 ff ff	 jmp	 $LL1041@bp
$LN370@bp:

; 2505 :         BFAIL()
; 2506 :         BNEXT(1)
; 2507 :         ;
; 2508 : 
; 2509 :       case SEEING_TELLING_2:
; 2510 :         xval = (!OUTPUT_INT(X(1))) ? g.seefunc : g.tellfunc;

  02753	f7 47 fc fc ff
	ff ff		 test	 DWORD PTR [edi-4], -4	; fffffffcH
  0275a	a1 8c 00 00 00	 mov	 eax, DWORD PTR _g+140
  0275f	0f 84 61 14 00
	00		 je	 $LN1774@bp
  02765	a1 90 00 00 00	 mov	 eax, DWORD PTR _g+144

; 2511 :         OUT_RESULT(xval)

  0276a	e9 57 14 00 00	 jmp	 $LN1774@bp
$LN366@bp:

; 2512 :         ;
; 2513 : 
; 2514 :       case SEE_TELL_2:
; 2515 :         if (!see_tell(regs, wam))

  0276f	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02773	52		 push	 edx
  02774	57		 push	 edi
  02775	e8 00 00 00 00	 call	 _see_tell
  0277a	83 c4 08	 add	 esp, 8
  0277d	85 c0		 test	 eax, eax
  0277f	0f 85 fe d8 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02785	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02788	e9 c6 d8 ff ff	 jmp	 $LL1041@bp
$LN364@bp:

; 2516 :         BFAIL()
; 2517 :         BNEXT(1)
; 2518 :         ;
; 2519 : 
; 2520 :       case SEEN_TOLD_1:
; 2521 :         seen_told((byte) OUTPUT_INT(X(1)));

  0278d	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02790	c1 f8 02	 sar	 eax, 2
  02793	50		 push	 eax
  02794	e8 00 00 00 00	 call	 _seen_told
  02799	83 c4 04	 add	 esp, 4

; 2522 :         /*used also in restart*/
; 2523 :         BNEXT(1)

  0279c	83 c3 04	 add	 ebx, 4

; 2524 :         ;

  0279f	e9 af d8 ff ff	 jmp	 $LL1041@bp
$LN363@bp:

; 2525 : 
; 2526 :       case SEE_TELL_AT_2:
; 2527 :         if (!see_tell_at(regs, wam))

  027a4	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  027a8	51		 push	 ecx
  027a9	57		 push	 edi
  027aa	e8 00 00 00 00	 call	 _see_tell_at
  027af	83 c4 08	 add	 esp, 8
  027b2	85 c0		 test	 eax, eax
  027b4	0f 85 c9 d8 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  027ba	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  027bd	e9 91 d8 ff ff	 jmp	 $LL1041@bp
$LN361@bp:

; 2528 :         BFAIL()
; 2529 :         BNEXT(1)
; 2530 :         ;
; 2531 : 
; 2532 :       case SEEING_TELLING_AT_2:
; 2533 :         xval = seeing_telling_at(regs);

  027c2	57		 push	 edi
  027c3	e8 00 00 00 00	 call	 _seeing_telling_at
  027c8	83 c4 04	 add	 esp, 4

; 2534 :         OUT_RESULT(xval)

  027cb	e9 f6 13 00 00	 jmp	 $LN1774@bp
$LN357@bp:

; 2535 :         ;
; 2536 : 
; 2537 :       case STRING_OP_3:
; 2538 :         ires = OUTPUT_INT(X(1));

  027d0	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  027d3	c1 f8 02	 sar	 eax, 2

; 2539 :         if (0 == ires) {

  027d6	85 c0		 test	 eax, eax
  027d8	0f 84 cb 16 00
	00		 je	 $LN1632@bp

; 2548 : #endif
; 2549 :         }
; 2550 :         else if (1 == ires) { /*plain*/

  027de	83 f8 01	 cmp	 eax, 1
  027e1	75 16		 jne	 SHORT $LN354@bp

; 2551 :           xval = sout(X(2), wam);

  027e3	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  027e7	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  027ea	52		 push	 edx
  027eb	50		 push	 eax
  027ec	e8 00 00 00 00	 call	 _sout
  027f1	83 c4 08	 add	 esp, 8
  027f4	e9 14 f7 ff ff	 jmp	 $LN1780@bp
$LN354@bp:

; 2552 :         }
; 2553 :         else if (2 == ires) {

  027f9	83 f8 02	 cmp	 eax, 2
  027fc	75 44		 jne	 SHORT $LN352@bp

; 2554 :           /*warnmes("entering STRING_OP(2,..");*/
; 2555 :           if (g.query == g.empty)

  027fe	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR _g+56
  02804	39 0d e4 00 00
	00		 cmp	 DWORD PTR _g+228, ecx

; 2556 :           BFAIL()

  0280a	0f 84 e0 13 00
	00		 je	 $LN1747@bp

; 2557 :           { /*string to chars built on the heap*/
; 2558 :             /*string s=INT2PTR(X(2));*/
; 2559 :             string s = INT2PTR(g.query);

  02810	a1 e4 00 00 00	 mov	 eax, DWORD PTR _g+228

; 2560 :             xref = H;
; 2561 :             H = string2list(xref, s, wam);

  02815	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02819	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0281d	52		 push	 edx
  0281e	48		 dec	 eax
  0281f	50		 push	 eax
  02820	51		 push	 ecx
  02821	89 4c 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], ecx
  02825	e8 00 00 00 00	 call	 _string2list
  0282a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0282d	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2562 :             if (!H) BEXIT("fatal error in STRING_OP(2,...)");

  02831	85 c0		 test	 eax, eax
  02833	0f 84 86 16 00
	00		 je	 $LN1633@bp

; 2563 :             xval = T2C(xref);

  02839	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  0283d	e9 cb f6 ff ff	 jmp	 $LN1780@bp
$LN352@bp:

; 2564 :           }
; 2565 :         }
; 2566 :         else if (3 == ires) { /*quoted for read back, returns list of chars*/

  02842	83 f8 03	 cmp	 eax, 3
  02845	75 3a		 jne	 SHORT $LN348@bp

; 2567 :           string s = qsout(X(2), wam); /* s==g.sbuf */

  02847	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  0284b	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  0284e	50		 push	 eax
  0284f	51		 push	 ecx
  02850	e8 00 00 00 00	 call	 _qsout

; 2568 :           xref = H;
; 2569 :           H = string2list(xref, s, wam);

  02855	8b 54 24 18	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262204]
  02859	8b 4c 24 1c	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262204]
  0285d	52		 push	 edx
  0285e	50		 push	 eax
  0285f	51		 push	 ecx
  02860	89 4c 24 2c	 mov	 DWORD PTR _xref$83215[esp+262216], ecx
  02864	e8 00 00 00 00	 call	 _string2list
  02869	83 c4 14	 add	 esp, 20			; 00000014H
  0286c	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2570 :           if (!H) BEXIT("fatal error in STRING_OP(3,...)");

  02870	85 c0		 test	 eax, eax
  02872	0f 84 5a 16 00
	00		 je	 $LN1634@bp

; 2571 :           xval = T2C(xref);

  02878	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  0287c	e9 8c f6 ff ff	 jmp	 $LN1780@bp
$LN348@bp:

; 2572 :         }
; 2573 :         else if (4 == ires) { /*puts a list of chars directly into a C string, without internalizing it*/

  02881	83 f8 04	 cmp	 eax, 4
  02884	0f 85 65 16 00
	00		 jne	 $LN345@bp

; 2574 :           /* string s=INT2PTR(X(2)); ignore for now */
; 2575 :           /*warnmes("entering STRING_OP(4,..");*/
; 2576 :           FDEREF(X(2));

  0288a	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  0288d	f6 c1 03	 test	 cl, 3
  02890	74 04		 je	 SHORT $LN1614@bp
  02892	8b c1		 mov	 eax, ecx
  02894	eb 16		 jmp	 SHORT $LN341@bp
$LN1614@bp:
  02896	8b 01		 mov	 eax, DWORD PTR [ecx]
  02898	a8 03		 test	 al, 3
  0289a	75 10		 jne	 SHORT $LN341@bp
  0289c	8d 64 24 00	 npad	 4
$LL342@bp:
  028a0	3b c8		 cmp	 ecx, eax
  028a2	74 08		 je	 SHORT $LN341@bp
  028a4	8b c8		 mov	 ecx, eax
  028a6	8b 00		 mov	 eax, DWORD PTR [eax]
  028a8	a8 03		 test	 al, 3
  028aa	74 f4		 je	 SHORT $LL342@bp
$LN341@bp:

; 2577 :           if (g.NIL == xval) g.answer = g.empty;

  028ac	39 05 20 00 00
	00		 cmp	 DWORD PTR _g+32, eax
  028b2	75 11		 jne	 SHORT $LN340@bp
  028b4	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR _g+56
  028ba	89 0d e8 00 00
	00		 mov	 DWORD PTR _g+232, ecx

; 2578 :           else {

  028c0	e9 48 f6 ff ff	 jmp	 $LN1780@bp
$LN340@bp:

; 2579 :             if (!list2buf(xref, xval, sbuf, MAXSBUF)) BEXIT("fatal error in STRING_OP(4,..)");

  028c5	68 00 00 04 00	 push	 262144			; 00040000H
  028ca	8d 54 24 34	 lea	 edx, DWORD PTR _sbuf$[esp+262200]
  028ce	52		 push	 edx
  028cf	50		 push	 eax
  028d0	51		 push	 ecx
  028d1	e8 00 00 00 00	 call	 _list2buf
  028d6	83 c4 10	 add	 esp, 16			; 00000010H
  028d9	85 c0		 test	 eax, eax
  028db	0f 84 04 16 00
	00		 je	 $LN1635@bp

; 2580 :             /*g.answer=INPUT_STRING(g.sbuf);*/
; 2581 :             g.answer = PTR2INT(sbuf);

  028e1	8d 44 24 31	 lea	 eax, DWORD PTR _sbuf$[esp+262197]
  028e5	a3 e8 00 00 00	 mov	 DWORD PTR _g+232, eax

; 2582 :             xval = INPUT_INT(0);

  028ea	b8 01 00 00 00	 mov	 eax, 1

; 2586 :         OUT_RESULT(xval);

  028ef	e9 19 f6 ff ff	 jmp	 $LN1780@bp
$LN333@bp:

; 2587 : 
; 2588 :         case OP0_3:
; 2589 :         if(!op0(regs,wam)) BFAIL()

  028f4	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  028f8	50		 push	 eax
  028f9	57		 push	 edi
  028fa	e8 00 00 00 00	 call	 _op0
  028ff	83 c4 08	 add	 esp, 8
  02902	85 c0		 test	 eax, eax
  02904	0f 85 79 d7 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  0290a	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0290d	e9 41 d7 ff ff	 jmp	 $LL1041@bp
$LN331@bp:

; 2590 :         BNEXT(1);
; 2591 : 
; 2592 :         case DET_APPEND0_3:
; 2593 :         xref=H;
; 2594 :         if(!(H=det_append0(H,regs,wam))) BFAIL()

  02912	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02916	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  0291a	51		 push	 ecx
  0291b	57		 push	 edi
  0291c	50		 push	 eax
  0291d	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02921	e8 00 00 00 00	 call	 _det_append0
  02926	83 c4 0c	 add	 esp, 12			; 0000000cH
  02929	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  0292d	85 c0		 test	 eax, eax
  0292f	0f 84 bb 12 00
	00		 je	 $LN1747@bp

; 2595 :         OUT_RESULT(xref);

  02935	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  0293b	0f 84 1a 09 00
	00		 je	 $LN154@bp
  02941	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02945	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  02949	55		 push	 ebp
  0294a	52		 push	 edx
  0294b	c1 ee 15	 shr	 esi, 21			; 00000015H
  0294e	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  02951	50		 push	 eax
  02952	51		 push	 ecx
  02953	e8 00 00 00 00	 call	 _unify
  02958	83 c4 10	 add	 esp, 16			; 00000010H
  0295b	85 c0		 test	 eax, eax
  0295d	0f 85 02 09 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  02963	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02966	e9 e8 d6 ff ff	 jmp	 $LL1041@bp
$LN326@bp:

; 2596 : 
; 2597 :         case COPY_TERM_3:
; 2598 :         xval=X(2); /* the term to be copied */

  0296b	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]

; 2599 :         if(!ATOMIC(xval)) {

  0296e	8b c1		 mov	 eax, ecx
  02970	83 e0 03	 and	 eax, 3
  02973	74 0d		 je	 SHORT $LN324@bp
  02975	83 f8 01	 cmp	 eax, 1
  02978	74 63		 je	 SHORT $LN321@bp
  0297a	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  02980	74 5b		 je	 SHORT $LN321@bp
$LN324@bp:

; 2600 :           if(!OUTPUT_INT(X(1))) {

  02982	f7 47 fc fc ff
	ff ff		 test	 DWORD PTR [edi-4], -4	; fffffffcH

; 2601 :             COPY_TERM(
; 2602 :                 H, /* from */
; 2603 :                 wam[HeapStk].margin, /* to */
; 2604 :                 BEXIT("heap_overflow in copy_term/2"));

  02989	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  0298d	50		 push	 eax
  0298e	75 24		 jne	 SHORT $LN323@bp
  02990	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  02993	8b 54 24 18	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262200]
  02997	50		 push	 eax
  02998	52		 push	 edx
  02999	51		 push	 ecx
  0299a	e8 00 00 00 00	 call	 _copy_term
  0299f	8b 4c 24 24	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262212]
  029a3	83 c4 10	 add	 esp, 16			; 00000010H
  029a6	85 c0		 test	 eax, eax
  029a8	0f 84 57 15 00
	00		 je	 $LN1636@bp
  029ae	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2605 :           }
; 2606 :           else {

  029b2	eb 29		 jmp	 SHORT $LN321@bp
$LN323@bp:

; 2607 :             COPY_TERM(
; 2608 :                 g.shared[BBoardStk].top, /* from */
; 2609 :                 g.shared[BBoardStk].margin, /* to */
; 2610 :                 BFAIL() );

  029b4	8b 15 ac 01 00
	00		 mov	 edx, DWORD PTR _g+428
  029ba	a1 a0 01 00 00	 mov	 eax, DWORD PTR _g+416
  029bf	52		 push	 edx
  029c0	50		 push	 eax
  029c1	51		 push	 ecx
  029c2	e8 00 00 00 00	 call	 _copy_term
  029c7	83 c4 10	 add	 esp, 16			; 00000010H
  029ca	85 c0		 test	 eax, eax
  029cc	0f 84 1e 12 00
	00		 je	 $LN1747@bp
  029d2	8b 0d a0 01 00
	00		 mov	 ecx, DWORD PTR _g+416
  029d8	a3 a0 01 00 00	 mov	 DWORD PTR _g+416, eax
$LN321@bp:

; 2611 :           }
; 2612 :         }
; 2613 :         /* else, if atomic, do nothing - return original X(2) */
; 2614 :         SAFE_OUT(xval);

  029dd	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  029e3	0f 84 0f 09 00
	00		 je	 $LN319@bp
  029e9	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  029ed	55		 push	 ebp
  029ee	52		 push	 edx
  029ef	c1 ee 15	 shr	 esi, 21			; 00000015H
  029f2	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  029f5	50		 push	 eax
  029f6	51		 push	 ecx
  029f7	e8 00 00 00 00	 call	 _unify_to
  029fc	83 c4 10	 add	 esp, 16			; 00000010H
  029ff	85 c0		 test	 eax, eax
  02a01	0f 85 f7 08 00
	00		 jne	 $LN145@bp

; 3141 :         OUT_RESULT(xval);

  02a07	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02a0a	e9 44 d6 ff ff	 jmp	 $LL1041@bp
$LN316@bp:

; 2615 : 
; 2616 :         case UNIFY_TO_2:
; 2617 :         xval=X(1);

  02a0f	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2618 :         SAFE_OUT(xval);

  02a12	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02a18	0f 84 11 0a 00
	00		 je	 $LN32@bp
  02a1e	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02a22	55		 push	 ebp
  02a23	c1 ee 15	 shr	 esi, 21			; 00000015H
  02a26	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02a29	51		 push	 ecx
  02a2a	52		 push	 edx
  02a2b	50		 push	 eax
  02a2c	e8 00 00 00 00	 call	 _unify_to
  02a31	e9 af 11 00 00	 jmp	 $LN1775@bp
$LN312@bp:

; 2619 : 
; 2620 :         case TERM_APPEND_3:
; 2621 :         xref=H;
; 2622 :         if(!(H=term_append(H,regs,wam))) BFAIL()

  02a36	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02a3a	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  02a3e	51		 push	 ecx
  02a3f	57		 push	 edi
  02a40	50		 push	 eax
  02a41	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02a45	e8 00 00 00 00	 call	 _term_append
  02a4a	83 c4 0c	 add	 esp, 12			; 0000000cH
  02a4d	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02a51	85 c0		 test	 eax, eax
  02a53	0f 84 97 11 00
	00		 je	 $LN1747@bp

; 2623 :         OUT_RESULT(xref);

  02a59	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02a5f	0f 84 f6 07 00
	00		 je	 $LN154@bp
  02a65	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02a69	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  02a6d	55		 push	 ebp
  02a6e	52		 push	 edx
  02a6f	c1 ee 15	 shr	 esi, 21			; 00000015H
  02a72	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  02a75	50		 push	 eax
  02a76	51		 push	 ecx
  02a77	e8 00 00 00 00	 call	 _unify
  02a7c	83 c4 10	 add	 esp, 16			; 00000010H
  02a7f	85 c0		 test	 eax, eax
  02a81	0f 85 de 07 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  02a87	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02a8a	e9 c4 d5 ff ff	 jmp	 $LL1041@bp
$LN307@bp:

; 2624 : 
; 2625 :         case STRIP_CONT0_2:
; 2626 :         xref=H;
; 2627 :         if(!(H=strip_cont0(H,regs,wam))) BFAIL()

  02a8f	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02a93	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  02a97	51		 push	 ecx
  02a98	57		 push	 edi
  02a99	50		 push	 eax
  02a9a	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02a9e	e8 00 00 00 00	 call	 _strip_cont0
  02aa3	83 c4 0c	 add	 esp, 12			; 0000000cH
  02aa6	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02aaa	85 c0		 test	 eax, eax
  02aac	0f 84 3e 11 00
	00		 je	 $LN1747@bp

; 2628 :         OUT_RESULT(xref);

  02ab2	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02ab8	0f 84 9d 07 00
	00		 je	 $LN154@bp
  02abe	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02ac2	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  02ac6	55		 push	 ebp
  02ac7	52		 push	 edx
  02ac8	c1 ee 15	 shr	 esi, 21			; 00000015H
  02acb	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  02ace	50		 push	 eax
  02acf	51		 push	 ecx
  02ad0	e8 00 00 00 00	 call	 _unify
  02ad5	83 c4 10	 add	 esp, 16			; 00000010H
  02ad8	85 c0		 test	 eax, eax
  02ada	0f 85 85 07 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  02ae0	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02ae3	e9 6b d5 ff ff	 jmp	 $LL1041@bp
$LN302@bp:

; 2629 : 
; 2630 :         case DCG_VAL_1:
; 2631 :         DCG_TRACE();
; 2632 :         xref=DCGSTART();
; 2633 :         xval=GETCELL(GETREF(xref));

  02ae8	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02aec	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02aef	8b 91 20 1c 00
	00		 mov	 edx, DWORD PTR [ecx+7200]
  02af5	8b 02		 mov	 eax, DWORD PTR [edx]

; 2634 :         OUT_RESULT(xval);

  02af7	e9 11 f4 ff ff	 jmp	 $LN1780@bp
$LN298@bp:

; 2635 : 
; 2636 :         case DCG_DEF_1:
; 2637 :         DCG_TRACE();
; 2638 :         xref=DCGSTART();
; 2639 :         xref=C2T(GETREF(xref));

  02afc	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02b00	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  02b03	8b b1 20 1c 00
	00		 mov	 esi, DWORD PTR [ecx+7200]

; 2640 :         ASSERT2(VAR(xref),"VAR expected in dcg_def/1");
; 2641 : #if defined(NO_VALUE_TRAIL)
; 2642 :         TRAIL_IF(xref);
; 2643 : #else
; 2644 :         xval=GETCELL(xref);
; 2645 :         SMART_VTRAIL_IF(xref,xval);

  02b09	8b 55 f8	 mov	 edx, DWORD PTR [ebp-8]
  02b0c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  02b0e	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx
  02b12	3b f2		 cmp	 esi, edx
  02b14	73 43		 jae	 SHORT $LN297@bp
  02b16	f6 c1 03	 test	 cl, 3
  02b19	75 04		 jne	 SHORT $LN296@bp
  02b1b	3b ca		 cmp	 ecx, edx
  02b1d	73 3a		 jae	 SHORT $LN297@bp
$LN296@bp:
  02b1f	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  02b22	3b 50 38	 cmp	 edx, DWORD PTR [eax+56]
  02b25	72 20		 jb	 SHORT $LN295@bp
  02b27	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  02b2c	50		 push	 eax
  02b2d	6a 01		 push	 1
  02b2f	52		 push	 edx
  02b30	e8 00 00 00 00	 call	 _overflow_by
  02b35	6a 0e		 push	 14			; 0000000eH
  02b37	e8 00 00 00 00	 call	 _bp_halt
  02b3c	8b 4c 24 30	 mov	 ecx, DWORD PTR _xval$83216[esp+262216]
  02b40	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  02b44	83 c4 14	 add	 esp, 20			; 00000014H
$LN295@bp:
  02b47	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  02b4a	89 0a		 mov	 DWORD PTR [edx], ecx
  02b4c	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  02b4f	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  02b52	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  02b55	83 40 2c 08	 add	 DWORD PTR [eax+44], 8
$LN297@bp:

; 2646 : #endif
; 2647 :         SETREF(xref,X(1));

  02b59	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02b5c	89 06		 mov	 DWORD PTR [esi], eax

; 2648 :         BNEXT(1);

  02b5e	83 c3 04	 add	 ebx, 4
  02b61	e9 ed d4 ff ff	 jmp	 $LL1041@bp
$LN294@bp:

; 2649 : 
; 2650 :         case DCG_TELL_1:
; 2651 :         DCG_TRACE();
; 2652 :         if(!dcg_tell(regs,wam,A)) BFAIL()

  02b66	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02b6a	55		 push	 ebp
  02b6b	51		 push	 ecx
  02b6c	57		 push	 edi
  02b6d	e8 00 00 00 00	 call	 _dcg_tell
  02b72	83 c4 0c	 add	 esp, 12			; 0000000cH
  02b75	85 c0		 test	 eax, eax
  02b77	0f 85 06 d5 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02b7d	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02b80	e9 ce d4 ff ff	 jmp	 $LL1041@bp
$LN292@bp:

; 2653 :         BNEXT(1);
; 2654 : 
; 2655 :         case DCG_TELLING_1:
; 2656 :         DCG_TRACE();
; 2657 :         { term g_connect=DCGSTART();

  02b85	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02b89	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]

; 2658 :           xref=C2T(GETREF(g_connect));
; 2659 :           xval=INPUT_INT(xref-(term)g_connect);

  02b8c	8b 81 20 1c 00
	00		 mov	 eax, DWORD PTR [ecx+7200]
  02b92	81 c1 20 1c 00
	00		 add	 ecx, 7200		; 00001c20H
  02b98	2b c1		 sub	 eax, ecx
  02b9a	83 e0 fd	 and	 eax, -3			; fffffffdH
  02b9d	83 c8 01	 or	 eax, 1

; 2660 :         }
; 2661 :         OUT_RESULT(xval);

  02ba0	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02ba6	0f 84 83 08 00
	00		 je	 $LN32@bp
  02bac	8b ca		 mov	 ecx, edx
  02bae	55		 push	 ebp
  02baf	c1 ee 15	 shr	 esi, 21			; 00000015H
  02bb2	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02bb5	51		 push	 ecx
  02bb6	52		 push	 edx
  02bb7	e9 23 10 00 00	 jmp	 $LN1772@bp
$LN288@bp:

; 2662 : 
; 2663 :         case FLOAT_FUN_3:
; 2664 :         xref=H;

  02bbc	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 2665 :         if(!(H=float_fun(H, regs )))

  02bc0	57		 push	 edi
  02bc1	50		 push	 eax
  02bc2	89 44 24 20	 mov	 DWORD PTR _xref$83215[esp+262204], eax
  02bc6	e8 00 00 00 00	 call	 _float_fun
  02bcb	83 c4 08	 add	 esp, 8

; 2666 :         BFAIL()
; 2667 :         OUT_RESULT(xref);

  02bce	eb 75		 jmp	 SHORT $LN1783@bp
$LN283@bp:

; 2668 : 
; 2669 :         case FLOAT_FUN2_4:
; 2670 :         xref=H;

  02bd0	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 2671 :         if(!(H=float_fun2(H,regs))) BFAIL()

  02bd4	57		 push	 edi
  02bd5	50		 push	 eax
  02bd6	89 44 24 20	 mov	 DWORD PTR _xref$83215[esp+262204], eax
  02bda	e8 00 00 00 00	 call	 _float_fun2
  02bdf	83 c4 08	 add	 esp, 8
  02be2	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02be6	85 c0		 test	 eax, eax
  02be8	0f 84 02 10 00
	00		 je	 $LN1747@bp

; 2672 :         OUT_RESULT(xref);

  02bee	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02bf4	74 26		 je	 SHORT $LN281@bp
  02bf6	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02bfa	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  02bfe	55		 push	 ebp
  02bff	51		 push	 ecx
  02c00	c1 ee 15	 shr	 esi, 21			; 00000015H
  02c03	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02c06	52		 push	 edx
  02c07	50		 push	 eax
  02c08	e8 00 00 00 00	 call	 _unify
  02c0d	83 c4 10	 add	 esp, 16			; 00000010H
  02c10	85 c0		 test	 eax, eax
  02c12	75 12		 jne	 SHORT $LN279@bp

; 3141 :         OUT_RESULT(xval);

  02c14	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02c17	e9 37 d4 ff ff	 jmp	 $LL1041@bp
$LN281@bp:

; 2672 :         OUT_RESULT(xref);

  02c1c	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  02c20	c1 ee 15	 shr	 esi, 21			; 00000015H
  02c23	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
$LN279@bp:
  02c26	83 c3 04	 add	 ebx, 4
  02c29	e9 25 d4 ff ff	 jmp	 $LL1041@bp
$LN278@bp:

; 2673 : 
; 2674 :         case INPUT_FLOAT_4:
; 2675 :         xref=H;
; 2676 :         if(!(H=input_float(H,regs,wam))) BFAIL()

  02c2e	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02c32	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  02c36	52		 push	 edx
  02c37	57		 push	 edi
  02c38	50		 push	 eax
  02c39	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02c3d	e8 00 00 00 00	 call	 _input_float
$LN1784@bp:
  02c42	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1783@bp:
  02c45	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  02c49	85 c0		 test	 eax, eax
  02c4b	0f 84 9f 0f 00
	00		 je	 $LN1747@bp
$LN1785@bp:

; 2677 :         OUT_RESULT(xref);

  02c51	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02c57	0f 84 91 0b 00
	00		 je	 $LN79@bp
  02c5d	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02c61	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  02c65	55		 push	 ebp
  02c66	50		 push	 eax
  02c67	c1 ee 15	 shr	 esi, 21			; 00000015H
  02c6a	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  02c6d	51		 push	 ecx
  02c6e	52		 push	 edx
  02c6f	e8 00 00 00 00	 call	 _unify
  02c74	83 c4 10	 add	 esp, 16			; 00000010H
  02c77	85 c0		 test	 eax, eax
  02c79	0f 85 79 0b 00
	00		 jne	 $LN77@bp

; 3141 :         OUT_RESULT(xval);

  02c7f	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02c82	e9 cc d3 ff ff	 jmp	 $LL1041@bp
$LN273@bp:

; 2678 : 
; 2679 :         case BB_LIST0_3:
; 2680 :         xref=H;
; 2681 :         H=hlist(H,regs,wam);

  02c87	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02c8b	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  02c8f	51		 push	 ecx
  02c90	57		 push	 edi
  02c91	50		 push	 eax
  02c92	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  02c96	e8 00 00 00 00	 call	 _hlist
  02c9b	83 c4 0c	 add	 esp, 12			; 0000000cH
  02c9e	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2682 :         if(!H) BEXIT("error in bb_list/2");

  02ca2	85 c0		 test	 eax, eax
  02ca4	0f 84 6d 12 00
	00		 je	 $LN1637@bp

; 2683 :         OUT_RESULT(xref);

  02caa	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02cb0	0f 84 a5 05 00
	00		 je	 $LN154@bp
  02cb6	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02cba	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  02cbe	55		 push	 ebp
  02cbf	52		 push	 edx
  02cc0	c1 ee 15	 shr	 esi, 21			; 00000015H
  02cc3	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  02cc6	50		 push	 eax
  02cc7	51		 push	 ecx
  02cc8	e8 00 00 00 00	 call	 _unify
  02ccd	83 c4 10	 add	 esp, 16			; 00000010H
  02cd0	85 c0		 test	 eax, eax
  02cd2	0f 85 8d 05 00
	00		 jne	 $LN152@bp

; 3141 :         OUT_RESULT(xval);

  02cd8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02cdb	e9 73 d3 ff ff	 jmp	 $LL1041@bp
$LN268@bp:

; 2684 : 
; 2685 :         case UNIX_ARGC_1:
; 2686 :         xval=INPUT_INT(g.argc);

  02ce0	a1 44 01 00 00	 mov	 eax, DWORD PTR _g+324
  02ce5	03 c0		 add	 eax, eax
  02ce7	03 c0		 add	 eax, eax

; 2687 :         OUT_RESULT(xval);

  02ce9	e9 1c f2 ff ff	 jmp	 $LN1781@bp
$LN264@bp:

; 2688 : 
; 2689 :         case UNIX_ARGV_2:
; 2690 :         if(!(xval=unix_argv(regs,wam))) BFAIL()

  02cee	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02cf2	50		 push	 eax
  02cf3	57		 push	 edi
  02cf4	e8 00 00 00 00	 call	 _unix_argv
  02cf9	83 c4 08	 add	 esp, 8
  02cfc	85 c0		 test	 eax, eax
  02cfe	0f 84 ec 0e 00
	00		 je	 $LN1747@bp

; 2691 :         OUT_RESULT(xval);

  02d04	e9 04 f2 ff ff	 jmp	 $LN1780@bp
$LN259@bp:

; 2692 : 
; 2693 :         case UNIX_GETENV_2:
; 2694 :         if(!(xval=unix_getenv(regs,wam))) BFAIL()

  02d09	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02d0d	50		 push	 eax
  02d0e	57		 push	 edi
  02d0f	e8 00 00 00 00	 call	 _unix_getenv
  02d14	83 c4 08	 add	 esp, 8
  02d17	85 c0		 test	 eax, eax
  02d19	0f 84 d1 0e 00
	00		 je	 $LN1747@bp

; 2695 :         OUT_RESULT(xval);

  02d1f	e9 e9 f1 ff ff	 jmp	 $LN1780@bp
$LN254@bp:

; 2696 : 
; 2697 :         case UNIX_ACCESS_2:
; 2698 :         if(!unix_access(regs,wam)) BFAIL()

  02d24	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02d28	50		 push	 eax
  02d29	57		 push	 edi
  02d2a	e8 00 00 00 00	 call	 _unix_access
  02d2f	83 c4 08	 add	 esp, 8
  02d32	85 c0		 test	 eax, eax
  02d34	0f 85 49 d3 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02d3a	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02d3d	e9 11 d3 ff ff	 jmp	 $LL1041@bp
$LN252@bp:

; 2699 :         BNEXT(1);
; 2700 : 
; 2701 :         case UNIX_CD_1:
; 2702 :         if(!unix_cd(regs,wam)) BFAIL()

  02d42	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02d46	51		 push	 ecx
  02d47	57		 push	 edi
  02d48	e8 00 00 00 00	 call	 _unix_cd
  02d4d	83 c4 08	 add	 esp, 8
  02d50	85 c0		 test	 eax, eax
  02d52	0f 85 2b d3 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02d58	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02d5b	e9 f3 d2 ff ff	 jmp	 $LL1041@bp
$LN250@bp:

; 2703 :         BNEXT(1);
; 2704 : 
; 2705 :         case UNIX_FORK_1:
; 2706 :         ires=unix_fork();

  02d60	e8 00 00 00 00	 call	 _unix_fork

; 2707 :         if(ires<0)

  02d65	85 c0		 test	 eax, eax
  02d67	0f 88 bd 11 00
	00		 js	 $LN1638@bp

; 2709 :         xval=INPUT_INT(ires);

  02d6d	03 c0		 add	 eax, eax
  02d6f	03 c0		 add	 eax, eax
  02d71	83 c8 01	 or	 eax, 1

; 2710 :         OUT_RESULT(xval);

  02d74	e9 4d 0e 00 00	 jmp	 $LN1774@bp
$LN245@bp:

; 2711 : 
; 2712 :         case UNIX_PID_1:
; 2713 :         ires=unix_pid();

  02d79	e8 00 00 00 00	 call	 _unix_pid

; 2714 :         if(ires<0)

  02d7e	85 c0		 test	 eax, eax
  02d80	0f 88 ba 11 00
	00		 js	 $LN1639@bp

; 2716 :         xval=INPUT_INT(ires);

  02d86	03 c0		 add	 eax, eax
  02d88	03 c0		 add	 eax, eax
  02d8a	83 c8 01	 or	 eax, 1

; 2717 :         OUT_RESULT(xval);

  02d8d	e9 34 0e 00 00	 jmp	 $LN1774@bp
$LN240@bp:

; 2718 : 
; 2719 :         case UNIX_KILL_2:
; 2720 :         if(!unix_kill(regs,wam)) BFAIL()

  02d92	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02d96	52		 push	 edx
  02d97	57		 push	 edi
  02d98	e8 00 00 00 00	 call	 _unix_kill
  02d9d	83 c4 08	 add	 esp, 8
  02da0	85 c0		 test	 eax, eax
  02da2	0f 85 db d2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02da8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02dab	e9 a3 d2 ff ff	 jmp	 $LL1041@bp
$LN238@bp:

; 2721 :         BNEXT(1);
; 2722 : 
; 2723 :         case CREATE_ENGINE_4:
; 2724 :         xval=(cell)create_engine(wam,
; 2725 :             OUTPUT_INT(X(1)),
; 2726 :             OUTPUT_INT(X(2)),
; 2727 :             OUTPUT_INT(X(3))
; 2728 :         );

  02db0	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  02db3	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  02db6	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  02db9	c1 f8 02	 sar	 eax, 2
  02dbc	50		 push	 eax
  02dbd	8b 44 24 14	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262200]
  02dc1	c1 f9 02	 sar	 ecx, 2
  02dc4	51		 push	 ecx
  02dc5	c1 fa 02	 sar	 edx, 2
  02dc8	52		 push	 edx
  02dc9	50		 push	 eax
  02dca	e8 00 00 00 00	 call	 _create_engine
  02dcf	83 c4 10	 add	 esp, 16			; 00000010H

; 2729 : #if TRACE>1
; 2730 :         fprintf(STD_err,"CREATE_ENGINE: %ld\n",xval);
; 2731 : #endif
; 2732 :         if(!xval) BFAIL()

  02dd2	85 c0		 test	 eax, eax
  02dd4	0f 84 16 0e 00
	00		 je	 $LN1747@bp

; 2733 : 
; 2734 :         xval=PTR2INT(xval);

  02dda	40		 inc	 eax

; 2735 :         OUT_RESULT(xval);

  02ddb	e9 2d f1 ff ff	 jmp	 $LN1780@bp
$LN233@bp:

; 2736 : 
; 2737 :         case DESTROY_ENGINE_1:
; 2738 : #if TRACE>1
; 2739 :         fprintf(STD_err,"DESTROY_ENGINE: %ld\n",INT2PTR(X(1)));
; 2740 : #endif
; 2741 :         xval=X(1);
; 2742 :         if(xval==PTR2INT(wam) ||
; 2743 :             !destroy_engine(INT2PTR(xval))) /* do not cast! */

  02de0	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02de4	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02de7	41		 inc	 ecx
  02de8	3b c1		 cmp	 eax, ecx
  02dea	0f 84 f0 0f 00
	00		 je	 $LN1701@bp
  02df0	48		 dec	 eax
  02df1	50		 push	 eax
  02df2	e8 00 00 00 00	 call	 _destroy_engine
  02df7	83 c4 04	 add	 esp, 4
  02dfa	85 c0		 test	 eax, eax
  02dfc	0f 84 de 0f 00
	00		 je	 $LN1701@bp

; 2744 :         BFAIL()
; 2745 :         BNEXT(1);

  02e02	83 c3 04	 add	 ebx, 4
  02e05	e9 49 d2 ff ff	 jmp	 $LL1041@bp
$LN230@bp:

; 2746 : 
; 2747 :         case LOAD_ENGINE_3:
; 2748 :         if(!load_engine0(regs)) BFAIL()

  02e0a	57		 push	 edi
  02e0b	e8 00 00 00 00	 call	 _load_engine0
  02e10	83 c4 04	 add	 esp, 4
  02e13	85 c0		 test	 eax, eax
  02e15	0f 85 68 d2 ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02e1b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02e1e	e9 30 d2 ff ff	 jmp	 $LL1041@bp
$LN228@bp:

; 2749 :         BNEXT(1);
; 2750 : 
; 2751 :         case ASK_ENGINE_2:
; 2752 :         xval=X(1);

  02e23	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2753 :         if(!INTEGER(xval))

  02e26	8b d0		 mov	 edx, eax
  02e28	80 e2 03	 and	 dl, 3
  02e2b	80 fa 01	 cmp	 dl, 1
  02e2e	0f 85 16 11 00
	00		 jne	 $LN1640@bp

; 2755 : 
; 2756 :         xref=INT2PTR(xval);

  02e34	48		 dec	 eax

; 2757 :         xref=ask_engine((stack)xref);

  02e35	50		 push	 eax
  02e36	e8 00 00 00 00	 call	 _ask_engine
  02e3b	83 c4 04	 add	 esp, 4

; 2758 : 
; 2759 :         if(xref)

  02e3e	85 c0		 test	 eax, eax
  02e40	0f 84 9a 0f 00
	00		 je	 $LN1701@bp

; 2760 :         {
; 2761 :           wam[HeapStk].top=(term*)H;

  02e46	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02e4a	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]

; 2762 :           xref=copy_to_engine(wam,xref);

  02e4e	50		 push	 eax
  02e4f	51		 push	 ecx
  02e50	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  02e53	e8 00 00 00 00	 call	 _copy_to_engine
  02e58	83 c4 08	 add	 esp, 8

; 2763 :           if(xref) H=(term)wam[HeapStk].top;

  02e5b	85 c0		 test	 eax, eax
  02e5d	0f 84 7d 0f 00
	00		 je	 $LN1701@bp
  02e63	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02e67	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  02e6a	89 54 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], edx

; 2764 :         }
; 2765 : 
; 2766 :         if(!xref) BFAIL()
; 2767 :         OUT_RESULT(xref);

  02e6e	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02e74	0f 84 b5 05 00
	00		 je	 $LN32@bp

; 2212 :         ;
; 2213 :       case L_AND_3:
; 2214 :       INT_ONLY(&)

  02e7a	55		 push	 ebp
  02e7b	c1 ee 15	 shr	 esi, 21			; 00000015H
  02e7e	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02e81	51		 push	 ecx
  02e82	52		 push	 edx
  02e83	e9 57 0d 00 00	 jmp	 $LN1772@bp
$LN220@bp:

; 2768 : 
; 2769 : #if THREADS>0
; 2770 :         case ASK_THREAD_2:
; 2771 : 
; 2772 :         xval=X(1);

  02e88	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2773 :         if(!INTEGER(xval))

  02e8b	8b c8		 mov	 ecx, eax
  02e8d	80 e1 03	 and	 cl, 3
  02e90	80 f9 01	 cmp	 cl, 1
  02e93	0f 85 c7 10 00
	00		 jne	 $LN1641@bp

; 2775 : 
; 2776 :         xref=INT2PTR(xval);

  02e99	48		 dec	 eax

; 2777 :         ires=tcreate(ask_thread,xref);

  02e9a	50		 push	 eax
  02e9b	68 00 00 00 00	 push	 OFFSET _ask_thread@4
  02ea0	e8 00 00 00 00	 call	 _tcreate

; 2778 :         set_engine_prop(X(1),ENGINE_TYPE,INPUT_INT(RUNNING_ENGINE));

  02ea5	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  02ea8	6a 15		 push	 21			; 00000015H
  02eaa	6a 00		 push	 0
  02eac	52		 push	 edx
  02ead	89 44 24 30	 mov	 DWORD PTR _ires$83218[esp+262216], eax
  02eb1	e8 00 00 00 00	 call	 _set_engine_prop

; 2779 :         xval=INPUT_INT(ires);

  02eb6	8b 44 24 30	 mov	 eax, DWORD PTR _ires$83218[esp+262216]
  02eba	03 c0		 add	 eax, eax
  02ebc	03 c0		 add	 eax, eax
  02ebe	83 c8 01	 or	 eax, 1

; 2780 :         set_engine_prop(X(1),ENGINE_THREAD,xval);

  02ec1	50		 push	 eax
  02ec2	89 44 24 34	 mov	 DWORD PTR _xval$83216[esp+262220], eax
  02ec6	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  02ec9	6a 05		 push	 5
  02ecb	50		 push	 eax
  02ecc	e8 00 00 00 00	 call	 _set_engine_prop
  02ed1	83 c4 20	 add	 esp, 32			; 00000020H

; 2781 : 
; 2782 :         OUT_RESULT(xval);

  02ed4	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02eda	74 26		 je	 SHORT $LN218@bp
  02edc	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  02ee0	8b 44 24 1c	 mov	 eax, DWORD PTR _xval$83216[esp+262196]
  02ee4	55		 push	 ebp
  02ee5	51		 push	 ecx
  02ee6	c1 ee 15	 shr	 esi, 21			; 00000015H
  02ee9	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  02eec	52		 push	 edx
  02eed	50		 push	 eax
  02eee	e8 00 00 00 00	 call	 _unify
  02ef3	83 c4 10	 add	 esp, 16			; 00000010H
  02ef6	85 c0		 test	 eax, eax
  02ef8	75 12		 jne	 SHORT $LN216@bp

; 3141 :         OUT_RESULT(xval);

  02efa	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02efd	e9 51 d1 ff ff	 jmp	 $LL1041@bp
$LN218@bp:

; 2781 : 
; 2782 :         OUT_RESULT(xval);

  02f02	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  02f06	c1 ee 15	 shr	 esi, 21			; 00000015H
  02f09	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
$LN216@bp:
  02f0c	83 c3 04	 add	 ebx, 4
  02f0f	e9 3f d1 ff ff	 jmp	 $LL1041@bp
$LN215@bp:

; 2783 : 
; 2784 :         case THREAD_EXIT_1: /* arg ignored */
; 2785 :         thread_exit(wam);

  02f14	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02f18	52		 push	 edx
  02f19	e8 00 00 00 00	 call	 _thread_exit
  02f1e	83 c4 04	 add	 esp, 4

; 2786 :         BNEXT(1);

  02f21	83 c3 04	 add	 ebx, 4
  02f24	e9 2a d1 ff ff	 jmp	 $LL1041@bp
$LN214@bp:

; 2787 : 
; 2788 :         case THREAD_JOIN_1:
; 2789 :         xval=X(1);

  02f29	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2790 :         if( !INTEGER(xval) )

  02f2c	8b c8		 mov	 ecx, eax
  02f2e	80 e1 03	 and	 cl, 3
  02f31	80 f9 01	 cmp	 cl, 1
  02f34	0f 85 3c 10 00
	00		 jne	 $LN1642@bp

; 2792 :         thread_join( OUTPUT_INT(xval) );

  02f3a	c1 f8 02	 sar	 eax, 2
  02f3d	50		 push	 eax
  02f3e	e8 00 00 00 00	 call	 _thread_join
  02f43	83 c4 04	 add	 esp, 4

; 2793 :         BNEXT(1);

  02f46	83 c3 04	 add	 ebx, 4
  02f49	e9 05 d1 ff ff	 jmp	 $LL1041@bp
$LN212@bp:

; 2794 : 
; 2795 :         case CURRENT_THREAD_1:
; 2796 :         ires=current_thread(wam);

  02f4e	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  02f52	52		 push	 edx
  02f53	e8 00 00 00 00	 call	 _get_engine_thread

; 2797 :         xval=INPUT_INT(ires);

  02f58	03 c0		 add	 eax, eax
  02f5a	83 c4 04	 add	 esp, 4
  02f5d	03 c0		 add	 eax, eax

; 2798 :         OUT_RESULT(xval);

  02f5f	e9 a6 ef ff ff	 jmp	 $LN1781@bp
$LN208@bp:

; 2799 : 
; 2800 :         case TSYNC_OP_3:
; 2801 :         ires=0;
; 2802 :         if(INTEGER(X(1)) && INTEGER(X(2)) && INTEGER(X(3)) ) {

  02f64	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  02f67	8b c1		 mov	 eax, ecx
  02f69	24 03		 and	 al, 3
  02f6b	3c 01		 cmp	 al, 1
  02f6d	0f 85 23 10 00
	00		 jne	 $LN207@bp
  02f73	8b 77 f8	 mov	 esi, DWORD PTR [edi-8]
  02f76	8b d6		 mov	 edx, esi
  02f78	80 e2 03	 and	 dl, 3
  02f7b	3a d0		 cmp	 dl, al
  02f7d	0f 85 13 10 00
	00		 jne	 $LN207@bp
  02f83	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  02f86	8b d0		 mov	 edx, eax
  02f88	80 e2 03	 and	 dl, 3
  02f8b	80 fa 01	 cmp	 dl, 1
  02f8e	0f 85 02 10 00
	00		 jne	 $LN207@bp

; 2803 :           ires=tsync_op(
; 2804 :               OUTPUT_INT(X(1)), OUTPUT_INT(X(2)),
; 2805 :               OUTPUT_INT(X(3))
; 2806 :           );

  02f94	c1 f8 02	 sar	 eax, 2
  02f97	50		 push	 eax
  02f98	c1 fe 02	 sar	 esi, 2
  02f9b	c1 f9 02	 sar	 ecx, 2
  02f9e	56		 push	 esi
  02f9f	51		 push	 ecx
  02fa0	e8 00 00 00 00	 call	 _tsync_op
  02fa5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2807 :           if(0==ires) BEXIT("error in tsync_op/3");

  02fa8	85 c0		 test	 eax, eax
  02faa	0f 84 d0 0f 00
	00		 je	 $LN1643@bp

; 2808 :           if(ires>1) BFAIL();

  02fb0	83 f8 01	 cmp	 eax, 1
  02fb3	0f 8e ca d0 ff
	ff		 jle	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  02fb9	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  02fbc	e9 92 d0 ff ff	 jmp	 $LL1041@bp
$LN203@bp:

; 2816 :         }
; 2817 :         BNEXT(1);
; 2818 : #else
; 2819 :         case ASK_THREAD_2:
; 2820 :         case THREAD_EXIT_1:
; 2821 :         case THREAD_JOIN_1:
; 2822 :         case CURRENT_THREAD_1:
; 2823 :         case TSYNC_OP_3:
; 2824 :         fprintf(STD_err,"unimplemented thread operation: %ld\n",GETOPCODE());
; 2825 :         /*BEXIT("error in thread operation: no threads implemented");*/
; 2826 :         BFAIL();
; 2827 : #endif
; 2828 :         case LIST_ENGINES_1:
; 2829 :         xref=H;

  02fc1	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]

; 2830 :         H=list_engines(H);

  02fc5	50		 push	 eax
  02fc6	89 44 24 1c	 mov	 DWORD PTR _xref$83215[esp+262200], eax
  02fca	e8 00 00 00 00	 call	 _list_engines
  02fcf	83 c4 04	 add	 esp, 4
  02fd2	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 2831 :         if(!H) BEXIT("error in list_engines/1");

  02fd6	85 c0		 test	 eax, eax
  02fd8	0f 84 fe 0f 00
	00		 je	 $LN1644@bp
$LN165@bp:

; 2832 :         OUT_RESULT(xref);

  02fde	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  02fe4	0f 84 04 08 00
	00		 je	 $LN79@bp
  02fea	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  02fee	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  02ff2	55		 push	 ebp
  02ff3	50		 push	 eax
  02ff4	c1 ee 15	 shr	 esi, 21			; 00000015H
  02ff7	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  02ffa	51		 push	 ecx
  02ffb	52		 push	 edx
  02ffc	e8 00 00 00 00	 call	 _unify
  03001	83 c4 10	 add	 esp, 16			; 00000010H
  03004	85 c0		 test	 eax, eax
  03006	0f 85 ec 07 00
	00		 jne	 $LN77@bp

; 3141 :         OUT_RESULT(xval);

  0300c	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0300f	e9 3f d0 ff ff	 jmp	 $LL1041@bp
$LN198@bp:

; 2833 : 
; 2834 :         case CURRENT_ENGINE_ADDR_1:
; 2835 :         xval=PTR2INT(wam);

  03014	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03018	40		 inc	 eax

; 2836 :         OUT_RESULT(xval);

  03019	e9 ef ee ff ff	 jmp	 $LN1780@bp
$LN194@bp:

; 2837 : 
; 2838 :         case GET_ENGINE_PROP_3:
; 2839 : 
; 2840 :         if(!INTEGER(X(1)) || !INTEGER(X(2))) {

  0301e	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  03021	8b c1		 mov	 eax, ecx
  03023	24 03		 and	 al, 3
  03025	3c 01		 cmp	 al, 1
  03027	0f 85 c2 0f 00
	00		 jne	 $LN1645@bp
  0302d	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  03030	8b d0		 mov	 edx, eax
  03032	80 e2 03	 and	 dl, 3
  03035	80 fa 01	 cmp	 dl, 1
  03038	0f 85 b1 0f 00
	00		 jne	 $LN1645@bp

; 2842 :           /* xval=INPUT_INT(0);*/
; 2843 :         }
; 2844 :         else {
; 2845 :           xval=get_engine_prop(X(1),OUTPUT_INT(X(2)));

  0303e	c1 f8 02	 sar	 eax, 2
  03041	50		 push	 eax
  03042	51		 push	 ecx
  03043	e8 00 00 00 00	 call	 _get_engine_prop
  03048	83 c4 08	 add	 esp, 8

; 2846 :         }
; 2847 :         OUT_RESULT(xval);

  0304b	e9 bd ee ff ff	 jmp	 $LN1780@bp
$LN187@bp:

; 2848 : 
; 2849 :         case UNTRAIL_TO_1:
; 2850 :         xval=X(1);

  03050	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2851 :         if(!INTEGER(xval))

  03053	8b c8		 mov	 ecx, eax
  03055	80 e1 03	 and	 cl, 3
  03058	80 f9 01	 cmp	 cl, 1
  0305b	0f 85 a4 0f 00
	00		 jne	 $LN1646@bp

; 2853 :         xval=INT2CUT(xval);
; 2854 :         A=(term*)xval;
; 2855 :         TR_TOP=unwind_trail(TR_TOP,(term*)SAVED_TR);

  03061	8b 50 fb	 mov	 edx, DWORD PTR [eax-5]
  03064	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  03068	8d 68 ff	 lea	 ebp, DWORD PTR [eax-1]
  0306b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0306e	52		 push	 edx
  0306f	50		 push	 eax
  03070	e8 00 00 00 00	 call	 _unwind_trail
  03075	83 c4 08	 add	 esp, 8
  03078	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 2856 :         BNEXT(1);

  0307b	83 c3 04	 add	 ebx, 4
  0307e	e9 d0 cf ff ff	 jmp	 $LL1041@bp
$LN185@bp:

; 2857 : 
; 2858 :         case GET_NECK_CUT_1:
; 2859 :         xval=CUT2INT(cutB);

  03083	8b 44 24 24	 mov	 eax, DWORD PTR _cutB$[esp+262196]
  03087	40		 inc	 eax

; 2860 :         OUT_RESULT(xval);

  03088	e9 80 ee ff ff	 jmp	 $LN1780@bp
$LN181@bp:

; 2861 : 
; 2862 :         case OVERRIDE_3:
; 2863 : #if HAS_OVERRIDE
; 2864 :         BUG("override/2 clled");
; 2865 :         if(!override(regs,wam))

  0308d	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03091	50		 push	 eax
  03092	57		 push	 edi
  03093	e8 00 00 00 00	 call	 _override
  03098	83 c4 08	 add	 esp, 8
  0309b	85 c0		 test	 eax, eax
  0309d	0f 85 e0 cf ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  030a3	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  030a6	e9 a8 cf ff ff	 jmp	 $LL1041@bp
$LN179@bp:

; 2866 :         BFAIL();
; 2867 :         BNEXT(1);
; 2868 : #else
; 2869 :         BEXIT("OVERRIDE_2 not implemented");
; 2870 : #endif
; 2871 : 
; 2872 :         case RANDOM_SEED_1:
; 2873 :         xval=X(1);

  030ab	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2874 :         if(!INTEGER(xval)) BFAIL()

  030ae	8b c8		 mov	 ecx, eax
  030b0	80 e1 03	 and	 cl, 3
  030b3	80 f9 01	 cmp	 cl, 1
  030b6	0f 85 34 0b 00
	00		 jne	 $LN1747@bp

; 2875 :         init_random(OUTPUT_INT(xval));

  030bc	c1 f8 02	 sar	 eax, 2
  030bf	50		 push	 eax
  030c0	e8 00 00 00 00	 call	 _init_random
  030c5	83 c4 04	 add	 esp, 4

; 2876 :         BNEXT(1);

  030c8	83 c3 04	 add	 ebx, 4
  030cb	e9 83 cf ff ff	 jmp	 $LL1041@bp
$LN177@bp:

; 2877 : 
; 2878 :         case MEMBER_SCAN_3:
; 2879 :         if(!(xref=member_scan(X(1),X(2),wam,A))) BFAIL()

  030d0	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  030d4	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  030d7	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  030da	55		 push	 ebp
  030db	52		 push	 edx
  030dc	50		 push	 eax
  030dd	51		 push	 ecx
  030de	e8 00 00 00 00	 call	 _member_scan
  030e3	83 c4 10	 add	 esp, 16			; 00000010H
  030e6	85 c0		 test	 eax, eax
  030e8	0f 84 02 0b 00
	00		 je	 $LN1747@bp

; 2880 :         SAFE_OUT(xref);

  030ee	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  030f4	0f 84 35 03 00
	00		 je	 $LN32@bp
  030fa	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  030fe	55		 push	 ebp
  030ff	c1 ee 15	 shr	 esi, 21			; 00000015H
  03102	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  03105	52		 push	 edx
  03106	51		 push	 ecx
  03107	50		 push	 eax
  03108	e8 00 00 00 00	 call	 _unify_to
  0310d	e9 d3 0a 00 00	 jmp	 $LN1775@bp
$LN172@bp:

; 2881 : 
; 2882 :         case CMEMBER_SCAN_3:
; 2883 :         { no ok=TRUE;
; 2884 :           xref=H;
; 2885 :           if(!(H=cmember_scan(H,X(1),X(2),wam,A,&ok)))

  03112	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03116	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  0311a	8d 54 24 28	 lea	 edx, DWORD PTR _ok$89911[esp+262196]
  0311e	52		 push	 edx
  0311f	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  03122	55		 push	 ebp
  03123	51		 push	 ecx
  03124	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  03127	52		 push	 edx
  03128	51		 push	 ecx
  03129	50		 push	 eax
  0312a	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR _ok$89911[esp+262220], 1
  03132	89 44 24 30	 mov	 DWORD PTR _xref$83215[esp+262220], eax
  03136	e8 00 00 00 00	 call	 _cmember_scan
  0313b	83 c4 18	 add	 esp, 24			; 00000018H
  0313e	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03142	85 c0		 test	 eax, eax
  03144	0f 85 e3 00 00
	00		 jne	 $LN171@bp

; 2886 :           { if(ok) BFAIL()

  0314a	39 44 24 28	 cmp	 DWORD PTR _ok$89911[esp+262196], eax
  0314e	0f 85 9c 0a 00
	00		 jne	 $LN1747@bp

; 2887 :             BEXIT("bad data or heap_overflow in cmember_scan/3");

  03154	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03158	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NBICNKMK@bad?5data?5or?5heap_overflow?5in?5cme@
  0315d	51		 push	 ecx
  0315e	55		 push	 ebp
  0315f	53		 push	 ebx
  03160	50		 push	 eax
  03161	e9 41 0f 00 00	 jmp	 $LN1791@bp
$LN166@bp:

; 2888 :           }
; 2889 :         }
; 2890 :         OUT_RESULT(xref);
; 2891 : 
; 2892 :         case CDEL_SCAN_3:
; 2893 :         { no ok=TRUE;
; 2894 :           xref=H;
; 2895 :           if(!(H=cdel_scan(H,X(1),X(2),wam,A,&ok)))

  03166	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  0316a	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  0316e	8d 4c 24 2c	 lea	 ecx, DWORD PTR _ok$89934[esp+262196]
  03172	51		 push	 ecx
  03173	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  03176	55		 push	 ebp
  03177	52		 push	 edx
  03178	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  0317b	51		 push	 ecx
  0317c	52		 push	 edx
  0317d	50		 push	 eax
  0317e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR _ok$89934[esp+262220], 1
  03186	89 44 24 30	 mov	 DWORD PTR _xref$83215[esp+262220], eax
  0318a	e8 00 00 00 00	 call	 _cdel_scan
  0318f	83 c4 18	 add	 esp, 24			; 00000018H
  03192	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03196	85 c0		 test	 eax, eax
  03198	0f 85 40 fe ff
	ff		 jne	 $LN165@bp

; 2896 :           { if(ok) BFAIL()

  0319e	39 44 24 2c	 cmp	 DWORD PTR _ok$89934[esp+262196], eax
  031a2	0f 85 48 0a 00
	00		 jne	 $LN1747@bp

; 2897 :             BEXIT("bad data or heap_overflow in cdel_scan/3");

  031a8	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  031ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NKGJFKHF@bad?5data?5or?5heap_overflow?5in?5cde@
  031b1	52		 push	 edx
  031b2	55		 push	 ebp
  031b3	53		 push	 ebx
  031b4	50		 push	 eax
  031b5	e9 ed 0e 00 00	 jmp	 $LN1791@bp
$LN160@bp:

; 2898 :           }
; 2899 :         }
; 2900 :         OUT_RESULT(xref);
; 2901 : 
; 2902 :         case PUSH_CODE_1:
; 2903 :         xval=PTR2INT(ctop);

  031ba	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  031c0	41		 inc	 ecx
  031c1	89 4c 24 1c	 mov	 DWORD PTR _xval$83216[esp+262196], ecx

; 2904 :         push_code(wam);

  031c5	e8 00 00 00 00	 call	 _push_code

; 2905 :         OUT_RESULT(xval);

  031ca	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  031d0	74 26		 je	 SHORT $LN159@bp
  031d2	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  031d6	8b 4c 24 1c	 mov	 ecx, DWORD PTR _xval$83216[esp+262196]
  031da	55		 push	 ebp
  031db	52		 push	 edx
  031dc	c1 ee 15	 shr	 esi, 21			; 00000015H
  031df	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  031e2	50		 push	 eax
  031e3	51		 push	 ecx
  031e4	e8 00 00 00 00	 call	 _unify
  031e9	83 c4 10	 add	 esp, 16			; 00000010H
  031ec	85 c0		 test	 eax, eax
  031ee	75 12		 jne	 SHORT $LN157@bp

; 3141 :         OUT_RESULT(xval);

  031f0	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  031f3	e9 5b ce ff ff	 jmp	 $LL1041@bp
$LN159@bp:

; 2905 :         OUT_RESULT(xval);

  031f8	8b 54 24 1c	 mov	 edx, DWORD PTR _xval$83216[esp+262196]
  031fc	c1 ee 15	 shr	 esi, 21			; 00000015H
  031ff	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
$LN157@bp:
  03202	83 c3 04	 add	 ebx, 4
  03205	e9 49 ce ff ff	 jmp	 $LL1041@bp
$LN156@bp:

; 2906 : 
; 2907 :         case OPEN_STREAM_4:
; 2908 :         xref=H;
; 2909 :         if(!(H=open_stream(H,regs,wam))) BFAIL()

  0320a	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0320e	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  03212	51		 push	 ecx
  03213	57		 push	 edi
  03214	50		 push	 eax
  03215	89 44 24 24	 mov	 DWORD PTR _xref$83215[esp+262208], eax
  03219	e8 00 00 00 00	 call	 _open_stream
  0321e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03221	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03225	85 c0		 test	 eax, eax
  03227	0f 84 c3 09 00
	00		 je	 $LN1747@bp
$LN171@bp:

; 2910 :         OUT_RESULT(xref);

  0322d	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03233	74 26		 je	 SHORT $LN154@bp
  03235	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03239	8b 4c 24 18	 mov	 ecx, DWORD PTR _xref$83215[esp+262196]
  0323d	55		 push	 ebp
  0323e	52		 push	 edx
  0323f	c1 ee 15	 shr	 esi, 21			; 00000015H
  03242	8b 04 3e	 mov	 eax, DWORD PTR [esi+edi]
  03245	50		 push	 eax
  03246	51		 push	 ecx
  03247	e8 00 00 00 00	 call	 _unify
  0324c	83 c4 10	 add	 esp, 16			; 00000010H
  0324f	85 c0		 test	 eax, eax
  03251	75 12		 jne	 SHORT $LN152@bp

; 3141 :         OUT_RESULT(xval);

  03253	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03256	e9 f8 cd ff ff	 jmp	 $LL1041@bp
$LN154@bp:

; 2910 :         OUT_RESULT(xref);

  0325b	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  0325f	c1 ee 15	 shr	 esi, 21			; 00000015H
  03262	89 14 3e	 mov	 DWORD PTR [esi+edi], edx
$LN152@bp:
  03265	83 c3 04	 add	 ebx, 4
  03268	e9 e6 cd ff ff	 jmp	 $LL1041@bp
$LN151@bp:

; 2911 : 
; 2912 :         case CLOSE_STREAM_2:
; 2913 :         if(!close_stream(regs,wam)) BFAIL()

  0326d	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03271	50		 push	 eax
  03272	57		 push	 edi
  03273	e8 00 00 00 00	 call	 _close_stream
  03278	83 c4 08	 add	 esp, 8
  0327b	85 c0		 test	 eax, eax
  0327d	0f 85 00 ce ff
	ff		 jne	 $LN6@bp

; 3141 :         OUT_RESULT(xval);

  03283	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03286	e9 c8 cd ff ff	 jmp	 $LL1041@bp
$LN149@bp:

; 2914 :         BNEXT(1);
; 2915 : 
; 2916 :         case FGETC_2:
; 2917 :         xval=X(1);

  0328b	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2918 :         if(!INTEGER(xval))

  0328e	8b c8		 mov	 ecx, eax
  03290	80 e1 03	 and	 cl, 3
  03293	80 f9 01	 cmp	 cl, 1
  03296	74 1b		 je	 SHORT $LN148@bp

; 2919 :         BWARFUN(xval,"bad first arg in fgetc/2")

  03298	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  0329c	52		 push	 edx
  0329d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DABCLHAC@bad?5first?5arg?5in?5fgetc?12?$AA@
  032a2	50		 push	 eax
  032a3	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  032a8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  032ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  032ae	e9 a0 cd ff ff	 jmp	 $LL1041@bp
$LN148@bp:

; 2920 :         xref=INT2PTR(xval);

  032b3	48		 dec	 eax

; 2921 :         ires=(bp_long)getc((FILE *)xref);

  032b4	50		 push	 eax
  032b5	e8 00 00 00 00	 call	 _getc
  032ba	83 c4 04	 add	 esp, 4

; 2922 :         OUT_RESULT(INPUT_INT(ires));

  032bd	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  032c3	74 29		 je	 SHORT $LN147@bp
  032c5	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  032c9	55		 push	 ebp
  032ca	03 c0		 add	 eax, eax
  032cc	51		 push	 ecx
  032cd	c1 ee 15	 shr	 esi, 21			; 00000015H
  032d0	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  032d3	03 c0		 add	 eax, eax
  032d5	52		 push	 edx
  032d6	83 c8 01	 or	 eax, 1
  032d9	50		 push	 eax
  032da	e8 00 00 00 00	 call	 _unify
  032df	83 c4 10	 add	 esp, 16			; 00000010H
  032e2	85 c0		 test	 eax, eax
  032e4	75 18		 jne	 SHORT $LN145@bp

; 3141 :         OUT_RESULT(xval);

  032e6	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  032e9	e9 65 cd ff ff	 jmp	 $LL1041@bp
$LN147@bp:

; 2922 :         OUT_RESULT(INPUT_INT(ires));

  032ee	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  032f5	83 c9 01	 or	 ecx, 1
$LN319@bp:
  032f8	c1 ee 15	 shr	 esi, 21			; 00000015H
  032fb	89 0c 3e	 mov	 DWORD PTR [esi+edi], ecx
$LN145@bp:
  032fe	83 c3 04	 add	 ebx, 4
  03301	e9 4d cd ff ff	 jmp	 $LL1041@bp
$LN144@bp:

; 2923 : 
; 2924 :         case FPUTC_2:
; 2925 :         if(!INTEGER(X(1)))

  03306	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  03309	8b d0		 mov	 edx, eax
  0330b	80 e2 03	 and	 dl, 3
  0330e	80 fa 01	 cmp	 dl, 1
  03311	74 1b		 je	 SHORT $LN143@bp

; 2926 :         BWARFUN(X(1),"bad first arg in fputc/2")

  03313	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03317	51		 push	 ecx
  03318	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JBLNBHNJ@bad?5first?5arg?5in?5fputc?12?$AA@
  0331d	50		 push	 eax
  0331e	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  03323	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03326	83 c4 0c	 add	 esp, 12			; 0000000cH
  03329	e9 25 cd ff ff	 jmp	 $LL1041@bp
$LN143@bp:

; 2927 :         xval=X(2);

  0332e	8b 77 f8	 mov	 esi, DWORD PTR [edi-8]

; 2928 :         if(!(INTEGER(xval) &&
; 2929 :                 0<=(ires=OUTPUT_INT(xval)) && ires<256))

  03331	8b d6		 mov	 edx, esi
  03333	80 e2 03	 and	 dl, 3
  03336	80 fa 01	 cmp	 dl, 1
  03339	75 41		 jne	 SHORT $LN141@bp
  0333b	8b ce		 mov	 ecx, esi
  0333d	c1 f9 02	 sar	 ecx, 2
  03340	89 4c 24 1c	 mov	 DWORD PTR _ires$83218[esp+262196], ecx
  03344	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0334a	77 30		 ja	 SHORT $LN141@bp

; 2931 :         xref=INT2PTR(X(1));

  0334c	48		 dec	 eax

; 2932 :         if(ires!=putc(ires,(FILE*)xref))

  0334d	50		 push	 eax
  0334e	51		 push	 ecx
  0334f	e8 00 00 00 00	 call	 _putc
  03354	83 c4 08	 add	 esp, 8
  03357	39 44 24 1c	 cmp	 DWORD PTR _ires$83218[esp+262196], eax
  0335b	0f 84 22 cd ff
	ff		 je	 $LN6@bp

; 2933 :         BWARFUN(xval,"file error in fputc/1");

  03361	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03365	50		 push	 eax
  03366	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DEMKKJAC@file?5error?5in?5fputc?11?$AA@
  0336b	56		 push	 esi
  0336c	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  03371	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03374	83 c4 0c	 add	 esp, 12			; 0000000cH
  03377	e9 d7 cc ff ff	 jmp	 $LL1041@bp
$LN141@bp:

; 2930 :         BWARFUN(xval,"byte in 0..255 expected in fputc/1");

  0337c	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03380	51		 push	 ecx
  03381	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GOEKJLMG@byte?5in?50?4?4255?5expected?5in?5fputc@
  03386	56		 push	 esi
  03387	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  0338c	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0338f	83 c4 0c	 add	 esp, 12			; 0000000cH
  03392	e9 bc cc ff ff	 jmp	 $LL1041@bp
$LN139@bp:

; 2934 :         BNEXT(1);
; 2935 : 
; 2936 :         case FFLUSH_1:
; 2937 :         xval=X(1);

  03397	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2938 :         if(!INTEGER(xval))

  0339a	8b d0		 mov	 edx, eax
  0339c	80 e2 03	 and	 dl, 3
  0339f	80 fa 01	 cmp	 dl, 1
  033a2	74 1b		 je	 SHORT $LN138@bp

; 2939 :         BWARFUN(xval,"bad first arg in fflush/1")

  033a4	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  033a8	51		 push	 ecx
  033a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MINACFOE@bad?5first?5arg?5in?5fflush?11?$AA@
  033ae	50		 push	 eax
  033af	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  033b4	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  033b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  033ba	e9 94 cc ff ff	 jmp	 $LL1041@bp
$LN138@bp:

; 2940 :         xref=INT2PTR(xval);

  033bf	48		 dec	 eax

; 2941 :         fflush((FILE *)xref);

  033c0	50		 push	 eax
  033c1	e8 00 00 00 00	 call	 _fflush
  033c6	83 c4 04	 add	 esp, 4

; 2942 :         BNEXT(1);

  033c9	83 c3 04	 add	 ebx, 4
  033cc	e9 82 cc ff ff	 jmp	 $LL1041@bp
$LN137@bp:

; 2943 : 
; 2944 :         case FSIZE_2:
; 2945 :         xval=X(1);

  033d1	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2946 :         if(!INTEGER(xval))

  033d4	8b d0		 mov	 edx, eax
  033d6	80 e2 03	 and	 dl, 3
  033d9	80 fa 01	 cmp	 dl, 1
  033dc	74 1b		 je	 SHORT $LN136@bp

; 2947 :         BWARFUN(xval,"bad first arg in fsize/1")

  033de	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  033e2	51		 push	 ecx
  033e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GFDHHNNK@bad?5first?5arg?5in?5fsize?11?$AA@
  033e8	50		 push	 eax
  033e9	e8 00 00 00 00	 call	 _local_error

; 3141 :         OUT_RESULT(xval);

  033ee	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  033f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  033f4	e9 5a cc ff ff	 jmp	 $LL1041@bp
$LN136@bp:

; 2948 :         xref=INT2PTR(xval);

  033f9	48		 dec	 eax

; 2949 :         ires=(bp_long)fsize((FILE *)xref);

  033fa	50		 push	 eax
  033fb	e8 00 00 00 00	 call	 _fsize
  03400	83 c4 04	 add	 esp, 4

; 2950 :         OUT_RESULT(INPUT_INT(ires));

  03403	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03409	74 1d		 je	 SHORT $LN135@bp
  0340b	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  0340f	55		 push	 ebp
  03410	52		 push	 edx
  03411	c1 ee 15	 shr	 esi, 21			; 00000015H
  03414	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  03417	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0341e	51		 push	 ecx
  0341f	83 ca 01	 or	 edx, 1
  03422	52		 push	 edx
  03423	e9 b8 07 00 00	 jmp	 $LN1746@bp
$LN135@bp:
  03428	03 c0		 add	 eax, eax
  0342a	03 c0		 add	 eax, eax
  0342c	83 c8 01	 or	 eax, 1
$LN32@bp:
  0342f	c1 ee 15	 shr	 esi, 21			; 00000015H
  03432	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
$LN133@bp:
  03435	83 c3 04	 add	 ebx, 4
  03438	e9 16 cc ff ff	 jmp	 $LL1041@bp
$LN132@bp:

; 2951 : 
; 2952 :         case SYSTEM0_2:
; 2953 :         xval=system0(regs,wam);

  0343d	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03441	51		 push	 ecx
  03442	57		 push	 edi
  03443	e8 00 00 00 00	 call	 _system0
  03448	83 c4 08	 add	 esp, 8

; 2954 :         OUT_RESULT(xval);

  0344b	e9 58 02 00 00	 jmp	 $LN1777@bp
$LN128@bp:

; 2955 : 
; 2956 :         case NEW_NAME_2:
; 2957 :         if(!(xval=new_name(X(1),wam))) BFAIL()

  03450	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03454	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  03457	52		 push	 edx
  03458	50		 push	 eax
  03459	e8 00 00 00 00	 call	 _new_name
  0345e	83 c4 08	 add	 esp, 8
  03461	85 c0		 test	 eax, eax
  03463	0f 85 03 07 00
	00		 jne	 $LN127@bp

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03469	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0346c	e9 e2 cb ff ff	 jmp	 $LL1041@bp
$LN123@bp:

; 2958 :         OUT_RESULT(xval);
; 2959 : 
; 2960 :         /* socket operations for client/server crafting */
; 2961 : 
; 2962 :         case NEW_CLIENT_3: {
; 2963 :           string host;
; 2964 :           if(!SYMCONST(X(1)))

  03471	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  03474	8b c8		 mov	 ecx, eax
  03476	83 e1 03	 and	 ecx, 3
  03479	80 f9 03	 cmp	 cl, 3
  0347c	75 7a		 jne	 SHORT $LN121@bp
  0347e	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  03483	75 73		 jne	 SHORT $LN121@bp

; 2966 :           host=NAME(X(1));

  03485	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable

; 2967 :           if(!INTEGER(X(2)))

  0348b	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  0348e	c1 e8 02	 shr	 eax, 2
  03491	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  03496	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  03499	8b d1		 mov	 edx, ecx
  0349b	80 e2 03	 and	 dl, 3
  0349e	80 fa 01	 cmp	 dl, 1
  034a1	74 1b		 je	 SHORT $LN120@bp

; 2968 :           BWARFUN(X(2),"bad second arg in new_client/3")

  034a3	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  034a7	50		 push	 eax
  034a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GFLJDAK@bad?5second?5arg?5in?5new_client?13?$AA@
  034ad	51		 push	 ecx

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  034ae	e8 00 00 00 00	 call	 _local_error
  034b3	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  034b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  034b9	e9 95 cb ff ff	 jmp	 $LL1041@bp
$LN120@bp:

; 2969 :           ires=OUTPUT_INT(X(2));

  034be	c1 f9 02	 sar	 ecx, 2

; 2970 :           if((ires=new_client(host,ires))<=0) BFAIL()

  034c1	51		 push	 ecx
  034c2	50		 push	 eax
  034c3	e8 00 00 00 00	 call	 _new_client
  034c8	83 c4 08	 add	 esp, 8
  034cb	85 c0		 test	 eax, eax
  034cd	0f 8e 75 02 00
	00		 jle	 $LN1750@bp

; 2971 :           xval=INPUT_INT(ires);

  034d3	03 c0		 add	 eax, eax
  034d5	03 c0		 add	 eax, eax
  034d7	83 c8 01	 or	 eax, 1

; 2972 :         }
; 2973 :         OUT_RESULT(xval);

  034da	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  034e0	0f 84 49 ff ff
	ff		 je	 $LN32@bp
  034e6	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  034ea	55		 push	 ebp
  034eb	c1 ee 15	 shr	 esi, 21			; 00000015H
  034ee	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  034f1	51		 push	 ecx
  034f2	52		 push	 edx
  034f3	e9 c9 01 00 00	 jmp	 $LN1776@bp
$LN121@bp:

; 2965 :           BWARFUN(X(1),"bad host name in arg 1 of new_server/2")

  034f8	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  034fc	51		 push	 ecx
  034fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JLKFDJNK@bad?5host?5name?5in?5arg?51?5of?5new_se@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03502	50		 push	 eax
  03503	e8 00 00 00 00	 call	 _local_error
  03508	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0350b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0350e	e9 40 cb ff ff	 jmp	 $LL1041@bp
$LN115@bp:

; 2974 : 
; 2975 :         case NEW_SERVER_2:
; 2976 :         if(!INTEGER(X(1)))

  03513	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  03516	8b d0		 mov	 edx, eax
  03518	80 e2 03	 and	 dl, 3
  0351b	80 fa 01	 cmp	 dl, 1
  0351e	74 1b		 je	 SHORT $LN114@bp

; 2977 :         BWARFUN(X(1),"bad first arg in new_server/2")

  03520	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03524	51		 push	 ecx
  03525	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OPGGOAG@bad?5first?5arg?5in?5new_server?12?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  0352a	50		 push	 eax
  0352b	e8 00 00 00 00	 call	 _local_error
  03530	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03533	83 c4 0c	 add	 esp, 12			; 0000000cH
  03536	e9 18 cb ff ff	 jmp	 $LL1041@bp
$LN114@bp:

; 2978 :         ires=OUTPUT_INT(X(1));

  0353b	c1 f8 02	 sar	 eax, 2

; 2979 :         if((ires=new_server(ires))<=0) BFAIL()

  0353e	50		 push	 eax
  0353f	e8 00 00 00 00	 call	 _new_server
  03544	83 c4 04	 add	 esp, 4

; 2980 :         xval=INPUT_INT(ires);
; 2981 :         OUT_RESULT(xval);

  03547	eb 62		 jmp	 SHORT $LN1778@bp
$LN109@bp:

; 2982 : 
; 2983 :         case NEW_SERVICE_3: {
; 2984 :           bp_long timeout;
; 2985 :           if(!INTEGER(X(1)))

  03549	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  0354c	8b d0		 mov	 edx, eax
  0354e	80 e2 03	 and	 dl, 3
  03551	80 fa 01	 cmp	 dl, 1
  03554	74 1b		 je	 SHORT $LN108@bp

; 2986 :           BWARFUN(X(1),"bad first arg in new_service/3")

  03556	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0355a	51		 push	 ecx
  0355b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@NHBDMAFI@bad?5first?5arg?5in?5new_service?13?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03560	50		 push	 eax
  03561	e8 00 00 00 00	 call	 _local_error
  03566	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03569	83 c4 0c	 add	 esp, 12			; 0000000cH
  0356c	e9 e2 ca ff ff	 jmp	 $LL1041@bp
$LN108@bp:

; 2987 :           ires=OUTPUT_INT(X(1));

  03571	c1 f8 02	 sar	 eax, 2
  03574	8b c8		 mov	 ecx, eax

; 2988 :           if(!INTEGER(X(2)))

  03576	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  03579	8b d0		 mov	 edx, eax
  0357b	80 e2 03	 and	 dl, 3
  0357e	80 fa 01	 cmp	 dl, 1
  03581	74 1b		 je	 SHORT $LN107@bp

; 2989 :           BWARFUN(X(2),"bad second arg in new_service/3")

  03583	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03587	51		 push	 ecx
  03588	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MGACNCEH@bad?5second?5arg?5in?5new_service?13?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  0358d	50		 push	 eax
  0358e	e8 00 00 00 00	 call	 _local_error
  03593	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03596	83 c4 0c	 add	 esp, 12			; 0000000cH
  03599	e9 b5 ca ff ff	 jmp	 $LL1041@bp
$LN107@bp:

; 2990 :           timeout=OUTPUT_INT(X(2));

  0359e	c1 f8 02	 sar	 eax, 2

; 2991 :           if((ires=new_service(ires,timeout))<=0) BFAIL()

  035a1	50		 push	 eax
  035a2	51		 push	 ecx
  035a3	e8 00 00 00 00	 call	 _new_service
  035a8	83 c4 08	 add	 esp, 8
$LN1778@bp:
  035ab	85 c0		 test	 eax, eax
  035ad	0f 8e 95 01 00
	00		 jle	 $LN1750@bp

; 2992 :           xval=INPUT_INT(ires);

  035b3	03 c0		 add	 eax, eax
  035b5	03 c0		 add	 eax, eax
  035b7	83 c8 01	 or	 eax, 1

; 2993 :         }
; 2994 :         OUT_RESULT(xval);

  035ba	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  035c0	0f 84 69 fe ff
	ff		 je	 $LN32@bp
  035c6	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  035ca	55		 push	 ebp
  035cb	52		 push	 edx
  035cc	c1 ee 15	 shr	 esi, 21			; 00000015H
  035cf	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  035d2	51		 push	 ecx
  035d3	50		 push	 eax
  035d4	e8 00 00 00 00	 call	 _unify
  035d9	83 c4 10	 add	 esp, 16			; 00000010H
  035dc	85 c0		 test	 eax, eax
  035de	0f 85 51 fe ff
	ff		 jne	 $LN133@bp

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  035e4	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  035e7	e9 67 ca ff ff	 jmp	 $LL1041@bp
$LN102@bp:

; 2995 : 
; 2996 :         case PEER_ADDR_2:
; 2997 :         xval=X(1);

  035ec	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 2998 :         if(!INTEGER(xval))

  035ef	8b d0		 mov	 edx, eax
  035f1	80 e2 03	 and	 dl, 3
  035f4	80 fa 01	 cmp	 dl, 1
  035f7	74 1b		 je	 SHORT $LN101@bp

; 2999 :         BWARFUN(xval,"bad first arg in peer_addr/2")

  035f9	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  035fd	51		 push	 ecx
  035fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JDACKHPM@bad?5first?5arg?5in?5peer_addr?12?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03603	50		 push	 eax
  03604	e8 00 00 00 00	 call	 _local_error
  03609	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0360c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0360f	e9 3f ca ff ff	 jmp	 $LL1041@bp
$LN101@bp:

; 3000 :         ires=OUTPUT_INT(xval);

  03614	c1 f8 02	 sar	 eax, 2

; 3001 :         { string s;
; 3002 :           if(!(s=peer_addr(ires))) BFAIL()

  03617	50		 push	 eax
  03618	e8 00 00 00 00	 call	 _peer_addr
  0361d	83 c4 04	 add	 esp, 4
  03620	85 c0		 test	 eax, eax
  03622	0f 84 20 01 00
	00		 je	 $LN1750@bp

; 3003 :           xval=INPUT_STRING(s);

  03628	6a 00		 push	 0
  0362a	50		 push	 eax
  0362b	e8 00 00 00 00	 call	 _new_func
  03630	83 c4 08	 add	 esp, 8

; 3004 :         }
; 3005 :         OUT_RESULT(xval);

  03633	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03639	0f 84 f0 fd ff
	ff		 je	 $LN32@bp
  0363f	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03643	55		 push	 ebp
  03644	52		 push	 edx
  03645	c1 ee 15	 shr	 esi, 21			; 00000015H
  03648	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  0364b	51		 push	 ecx
  0364c	50		 push	 eax
  0364d	e8 00 00 00 00	 call	 _unify
  03652	83 c4 10	 add	 esp, 16			; 00000010H
  03655	85 c0		 test	 eax, eax
  03657	0f 85 d8 fd ff
	ff		 jne	 $LN133@bp

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  0365d	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03660	e9 ee c9 ff ff	 jmp	 $LL1041@bp
$LN96@bp:

; 3006 : 
; 3007 :         case PEER_PORT_2:
; 3008 :         xval=X(1);

  03665	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3009 :         if(!INTEGER(xval))

  03668	8b d0		 mov	 edx, eax
  0366a	80 e2 03	 and	 dl, 3
  0366d	80 fa 01	 cmp	 dl, 1
  03670	74 1b		 je	 SHORT $LN95@bp

; 3010 :         BWARFUN(xval,"bad first arg in peer_port/2")

  03672	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03676	51		 push	 ecx
  03677	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PCKHPNLL@bad?5first?5arg?5in?5peer_port?12?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  0367c	50		 push	 eax
  0367d	e8 00 00 00 00	 call	 _local_error
  03682	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03685	83 c4 0c	 add	 esp, 12			; 0000000cH
  03688	e9 c6 c9 ff ff	 jmp	 $LL1041@bp
$LN95@bp:

; 3011 :         ires=OUTPUT_INT(xval);

  0368d	c1 f8 02	 sar	 eax, 2

; 3012 :         if((ires=peer_port(ires))<0) BFAIL()

  03690	50		 push	 eax
  03691	e8 00 00 00 00	 call	 _peer_port
  03696	83 c4 04	 add	 esp, 4
  03699	85 c0		 test	 eax, eax
  0369b	0f 88 a7 00 00
	00		 js	 $LN1750@bp

; 3013 :         xval=INPUT_INT(ires);

  036a1	03 c0		 add	 eax, eax
  036a3	03 c0		 add	 eax, eax
  036a5	83 c8 01	 or	 eax, 1
$LN1777@bp:

; 3014 :         OUT_RESULT(xval);

  036a8	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  036ae	0f 84 7b fd ff
	ff		 je	 $LN32@bp
  036b4	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  036b8	55		 push	 ebp
  036b9	c1 ee 15	 shr	 esi, 21			; 00000015H
  036bc	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  036bf	52		 push	 edx
  036c0	51		 push	 ecx
$LN1776@bp:
  036c1	50		 push	 eax
  036c2	e8 00 00 00 00	 call	 _unify
  036c7	83 c4 10	 add	 esp, 16			; 00000010H
  036ca	85 c0		 test	 eax, eax
  036cc	0f 85 63 fd ff
	ff		 jne	 $LN133@bp

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  036d2	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  036d5	e9 79 c9 ff ff	 jmp	 $LL1041@bp
$LN90@bp:

; 3015 : 
; 3016 :         case CLOSE_SOCKET_1:
; 3017 :         xval=X(1);

  036da	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3018 :         if(!INTEGER(xval))

  036dd	8b d0		 mov	 edx, eax
  036df	80 e2 03	 and	 dl, 3
  036e2	80 fa 01	 cmp	 dl, 1
  036e5	74 1b		 je	 SHORT $LN89@bp

; 3019 :         BWARFUN(xval,"bad first arg in close_socket/1")

  036e7	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  036eb	51		 push	 ecx
  036ec	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OFDIOJI@bad?5first?5arg?5in?5close_socket?11?$AA@

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  036f1	50		 push	 eax
  036f2	e8 00 00 00 00	 call	 _local_error
  036f7	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  036fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  036fd	e9 51 c9 ff ff	 jmp	 $LL1041@bp
$LN89@bp:

; 3020 :         ires=OUTPUT_INT(xval);

  03702	c1 f8 02	 sar	 eax, 2

; 3021 :         close_socket(ires);

  03705	50		 push	 eax
  03706	e8 00 00 00 00	 call	 _close_socket
  0370b	83 c4 04	 add	 esp, 4

; 3022 :         BNEXT(1);

  0370e	83 c3 04	 add	 ebx, 4
  03711	e9 3d c9 ff ff	 jmp	 $LL1041@bp
$LN88@bp:

; 3023 : 
; 3024 :         case SOCK_READ_3: case SOCK_READLN_3:
; 3025 :         xval=X(1);

  03716	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3026 :         if(!INTEGER(xval))

  03719	8b d0		 mov	 edx, eax
  0371b	80 e2 03	 and	 dl, 3
  0371e	80 fa 01	 cmp	 dl, 1

; 3027 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03721	75 12		 jne	 SHORT $LN1748@bp

; 3028 :         ires=OUTPUT_INT(xval);

  03723	c1 f8 02	 sar	 eax, 2
  03726	8b c8		 mov	 ecx, eax

; 3029 : 
; 3030 :         xval=X(2);

  03728	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]

; 3031 :         if(!INTEGER(xval))

  0372b	8b d0		 mov	 edx, eax
  0372d	80 e2 03	 and	 dl, 3
  03730	80 fa 01	 cmp	 dl, 1
  03733	74 1b		 je	 SHORT $LN86@bp
$LN1748@bp:

; 3032 :         BWARFUN(xval,"bad first arg in sock_read(ln)/2")

  03735	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03739	51		 push	 ecx
  0373a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DAMPPDMM@bad?5first?5arg?5in?5sock_read?$CIln?$CJ?12@
  0373f	50		 push	 eax
  03740	e8 00 00 00 00	 call	 _local_error
  03745	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1750@bp:
  03748	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0374b	e9 03 c9 ff ff	 jmp	 $LL1041@bp
$LN86@bp:

; 3033 :         { bp_long max=OUTPUT_INT(xval);
; 3034 :           bp_long count=0;
; 3035 :           /* warnmes("blocking sock_read");*/
; 3036 :           if(SOCK_READ_3==GETOPCODE()) {

  03750	8b d6		 mov	 edx, esi
  03752	c1 f8 02	 sar	 eax, 2
  03755	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH

; 3037 :             if((count=sock_read(ires,sbuf,max))<=0) BFAIL();

  0375b	50		 push	 eax
  0375c	81 fa c0 00 00
	00		 cmp	 edx, 192		; 000000c0H
  03762	75 1a		 jne	 SHORT $LN85@bp
  03764	8d 44 24 34	 lea	 eax, DWORD PTR _sbuf$[esp+262200]
  03768	50		 push	 eax
  03769	51		 push	 ecx
  0376a	e8 00 00 00 00	 call	 _sock_read
  0376f	83 c4 0c	 add	 esp, 12			; 0000000cH
  03772	85 c0		 test	 eax, eax
  03774	7f 22		 jg	 SHORT $LN82@bp
  03776	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03779	e9 d5 c8 ff ff	 jmp	 $LL1041@bp
$LN85@bp:

; 3038 :           }
; 3039 :           else { /* SOCK_READLN_3 */
; 3040 :             if((count=sock_readln(ires,sbuf,max))<=0) BFAIL();

  0377e	8d 54 24 34	 lea	 edx, DWORD PTR _sbuf$[esp+262200]
  03782	52		 push	 edx
  03783	51		 push	 ecx
  03784	e8 00 00 00 00	 call	 _sock_readln
  03789	83 c4 0c	 add	 esp, 12			; 0000000cH
  0378c	85 c0		 test	 eax, eax
  0378e	7f 08		 jg	 SHORT $LN82@bp
  03790	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03793	e9 bb c8 ff ff	 jmp	 $LL1041@bp
$LN82@bp:

; 3041 :           }
; 3042 :           /* warnmes("unblocked sock_read"); */
; 3043 :           xref=H;

  03798	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]

; 3044 :           if(!(H=string2list_with_length(H,sbuf,wam,count)))

  0379c	50		 push	 eax
  0379d	8b 44 24 14	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262200]
  037a1	50		 push	 eax
  037a2	8d 54 24 38	 lea	 edx, DWORD PTR _sbuf$[esp+262204]
  037a6	52		 push	 edx
  037a7	51		 push	 ecx
  037a8	89 4c 24 28	 mov	 DWORD PTR _xref$83215[esp+262212], ecx
  037ac	e8 00 00 00 00	 call	 _string2list_with_length
  037b1	83 c4 10	 add	 esp, 16			; 00000010H
  037b4	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  037b8	85 c0		 test	 eax, eax
  037ba	0f 84 4f 08 00
	00		 je	 $LN1647@bp

; 3046 :           /* was: BFAIL() */
; 3047 :         }
; 3048 :         OUT_RESULT(xref);

  037c0	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  037c6	74 26		 je	 SHORT $LN79@bp
  037c8	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  037cc	8b 54 24 18	 mov	 edx, DWORD PTR _xref$83215[esp+262196]
  037d0	55		 push	 ebp
  037d1	50		 push	 eax
  037d2	c1 ee 15	 shr	 esi, 21			; 00000015H
  037d5	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  037d8	51		 push	 ecx
  037d9	52		 push	 edx
  037da	e8 00 00 00 00	 call	 _unify
  037df	83 c4 10	 add	 esp, 16			; 00000010H
  037e2	85 c0		 test	 eax, eax
  037e4	75 12		 jne	 SHORT $LN77@bp
  037e6	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  037e9	e9 65 c8 ff ff	 jmp	 $LL1041@bp
$LN79@bp:
  037ee	8b 44 24 18	 mov	 eax, DWORD PTR _xref$83215[esp+262196]
  037f2	c1 ee 15	 shr	 esi, 21			; 00000015H
  037f5	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
$LN77@bp:
  037f8	83 c3 04	 add	 ebx, 4
  037fb	e9 53 c8 ff ff	 jmp	 $LL1041@bp
$LN76@bp:

; 3049 : 
; 3050 :         case SOCK_WRITE_3: case SOCK_WRITELN_3:
; 3051 :         if(!INTEGER(X(3)))

  03800	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  03803	8b c8		 mov	 ecx, eax
  03805	80 e1 03	 and	 cl, 3
  03808	80 f9 01	 cmp	 cl, 1
  0380b	74 1b		 je	 SHORT $LN75@bp

; 3052 :         BWARFUN(X(3),"integer 3-rd arg expected in sock_write(ln)/2")

  0380d	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03811	52		 push	 edx
  03812	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GPDIIDMM@integer?53?9rd?5arg?5expected?5in?5soc@
  03817	50		 push	 eax
  03818	e8 00 00 00 00	 call	 _local_error
  0381d	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03820	83 c4 0c	 add	 esp, 12			; 0000000cH
  03823	e9 2b c8 ff ff	 jmp	 $LL1041@bp
$LN75@bp:

; 3053 : 
; 3054 :         xval=X(1);

  03828	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3055 :         if(!INTEGER(xval))

  0382b	8b c8		 mov	 ecx, eax
  0382d	80 e1 03	 and	 cl, 3
  03830	80 f9 01	 cmp	 cl, 1
  03833	74 1b		 je	 SHORT $LN74@bp

; 3056 :         BWARFUN(xval,"integer first arg expected in sock_write(ln)/2")

  03835	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03839	52		 push	 edx
  0383a	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@EHMGJDOH@integer?5first?5arg?5expected?5in?5so@
  0383f	50		 push	 eax
  03840	e8 00 00 00 00	 call	 _local_error
  03845	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03848	83 c4 0c	 add	 esp, 12			; 0000000cH
  0384b	e9 03 c8 ff ff	 jmp	 $LL1041@bp
$LN74@bp:

; 3057 :         ires=OUTPUT_INT(xval);
; 3058 : 
; 3059 :         xref=RX(2);
; 3060 :         if((cell)xref==g.NIL)

  03850	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR _g+32
  03856	c1 f8 02	 sar	 eax, 2
  03859	8b f0		 mov	 esi, eax
  0385b	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0385e	3b c1		 cmp	 eax, ecx

; 3061 :         xval=g.NIL;

  03860	74 21		 je	 SHORT $LN70@bp

; 3062 :         else if(NONVAR(xref)) /* a ptr to a list of chars */

  03862	a8 03		 test	 al, 3
  03864	74 1b		 je	 SHORT $LN71@bp

; 3063 :         BWARFUN(X(2),"unexpected arg 2 in sock_write(ln)/2")

  03866	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  0386a	51		 push	 ecx
  0386b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MOPLBJIL@unexpected?5arg?52?5in?5sock_write?$CIl@
  03870	50		 push	 eax
  03871	e8 00 00 00 00	 call	 _local_error
  03876	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03879	83 c4 0c	 add	 esp, 12			; 0000000cH
  0387c	e9 d2 c7 ff ff	 jmp	 $LL1041@bp
$LN71@bp:

; 3064 :         else
; 3065 :         xval=GETCELL(xref);

  03881	8b 08		 mov	 ecx, DWORD PTR [eax]
$LN70@bp:

; 3066 : 
; 3067 :         {
; 3068 :           if(!list2buf(xref,xval,sbuf,MAXSBUF))

  03883	68 00 00 04 00	 push	 262144			; 00040000H
  03888	8d 54 24 34	 lea	 edx, DWORD PTR _sbuf$[esp+262200]
  0388c	52		 push	 edx
  0388d	51		 push	 ecx
  0388e	50		 push	 eax
  0388f	e8 00 00 00 00	 call	 _list2buf
  03894	83 c4 10	 add	 esp, 16			; 00000010H
  03897	85 c0		 test	 eax, eax
  03899	75 1e		 jne	 SHORT $LN69@bp

; 3069 :           BWARFUN(X(2),"bad non-list arg 2 in sock_write(ln)/2");

  0389b	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  0389f	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  038a2	50		 push	 eax
  038a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GICKHGDB@bad?5non?9list?5arg?52?5in?5sock_write@
  038a8	51		 push	 ecx
  038a9	e8 00 00 00 00	 call	 _local_error
  038ae	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  038b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  038b4	e9 9a c7 ff ff	 jmp	 $LL1041@bp
$LN69@bp:

; 3070 : 
; 3071 :           if(SOCK_WRITE_3==GETOPCODE()) {

  038b9	8b 13		 mov	 edx, DWORD PTR [ebx]
  038bb	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  038c1	81 fa c1 00 00
	00		 cmp	 edx, 193		; 000000c1H
  038c7	75 25		 jne	 SHORT $LN68@bp

; 3072 : 
; 3073 :             if((sock_write(ires,sbuf,OUTPUT_INT(X(3))))<=0) BFAIL();

  038c9	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  038cc	c1 f8 02	 sar	 eax, 2
  038cf	50		 push	 eax
  038d0	8d 4c 24 34	 lea	 ecx, DWORD PTR _sbuf$[esp+262200]
  038d4	51		 push	 ecx
  038d5	56		 push	 esi
  038d6	e8 00 00 00 00	 call	 _sock_write
  038db	83 c4 0c	 add	 esp, 12			; 0000000cH
  038de	85 c0		 test	 eax, eax
  038e0	0f 8f 9d c7 ff
	ff		 jg	 $LN6@bp
  038e6	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  038e9	e9 65 c7 ff ff	 jmp	 $LL1041@bp
$LN68@bp:

; 3074 :           }
; 3075 :           else {
; 3076 :             if((sock_writeln(ires,sbuf,OUTPUT_INT(X(3))))<=0) BFAIL();

  038ee	8b 57 f4	 mov	 edx, DWORD PTR [edi-12]
  038f1	c1 fa 02	 sar	 edx, 2
  038f4	52		 push	 edx
  038f5	8d 44 24 34	 lea	 eax, DWORD PTR _sbuf$[esp+262200]
  038f9	50		 push	 eax
  038fa	56		 push	 esi
  038fb	e8 00 00 00 00	 call	 _sock_writeln
  03900	83 c4 0c	 add	 esp, 12			; 0000000cH
  03903	85 c0		 test	 eax, eax
  03905	0f 8f 78 c7 ff
	ff		 jg	 $LN6@bp
  0390b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0390e	e9 40 c7 ff ff	 jmp	 $LL1041@bp
$LN64@bp:

; 3077 :           }
; 3078 :         }
; 3079 :         BNEXT(1);
; 3080 : 
; 3081 :         case FILE2SOCK_2:
; 3082 :         ATOMIZE(X(1)); ATOMIZE(X(2));

  03913	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  03916	8b c8		 mov	 ecx, eax
  03918	83 e1 03	 and	 ecx, 3
  0391b	74 0c		 je	 SHORT $LN1713@bp
  0391d	83 f9 01	 cmp	 ecx, 1
  03920	74 0c		 je	 SHORT $LN1735@bp
  03922	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  03927	74 05		 je	 SHORT $LN1735@bp
$LN1713@bp:
  03929	8b 08		 mov	 ecx, DWORD PTR [eax]
  0392b	89 4f fc	 mov	 DWORD PTR [edi-4], ecx
$LN1735@bp:
  0392e	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  03931	8b c8		 mov	 ecx, eax
  03933	83 e1 03	 and	 ecx, 3
  03936	74 0c		 je	 SHORT $LN60@bp
  03938	83 f9 01	 cmp	 ecx, 1
  0393b	74 0c		 je	 SHORT $LN61@bp
  0393d	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  03942	74 05		 je	 SHORT $LN61@bp
$LN60@bp:
  03944	8b 10		 mov	 edx, DWORD PTR [eax]
  03946	89 57 f8	 mov	 DWORD PTR [edi-8], edx
$LN61@bp:

; 3083 :         if(!INTEGER(X(1)))

  03949	8b 77 fc	 mov	 esi, DWORD PTR [edi-4]
  0394c	8b c6		 mov	 eax, esi
  0394e	24 03		 and	 al, 3
  03950	3c 01		 cmp	 al, 1
  03952	74 1b		 je	 SHORT $LN59@bp

; 3084 :         BWARFUN(X(1),"bad first arg in file2sock/2")

  03954	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03958	51		 push	 ecx
  03959	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NAHFBO@bad?5first?5arg?5in?5file2sock?12?$AA@
  0395e	56		 push	 esi
  0395f	e8 00 00 00 00	 call	 _local_error
  03964	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03967	83 c4 0c	 add	 esp, 12			; 0000000cH
  0396a	e9 e4 c6 ff ff	 jmp	 $LL1041@bp
$LN59@bp:

; 3085 :         if(!INTEGER(X(2)))

  0396f	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  03972	8b d0		 mov	 edx, eax
  03974	80 e2 03	 and	 dl, 3
  03977	80 fa 01	 cmp	 dl, 1
  0397a	74 1b		 je	 SHORT $LN58@bp

; 3086 :         BWARFUN(X(2),"bad first arg in file2sock/2")

  0397c	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03980	51		 push	 ecx
  03981	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NAHFBO@bad?5first?5arg?5in?5file2sock?12?$AA@
  03986	50		 push	 eax
  03987	e8 00 00 00 00	 call	 _local_error
  0398c	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  0398f	83 c4 0c	 add	 esp, 12			; 0000000cH
  03992	e9 bc c6 ff ff	 jmp	 $LL1041@bp
$LN58@bp:

; 3087 :         xref=INT2PTR(X(1));
; 3088 :         ires=OUTPUT_INT(X(2));
; 3089 :         /*fprintf(STD_err,"file2sock: ires=%d\n",ires);*/
; 3090 :         {
; 3091 :           if(file2sock((FILE *)xref,ires,sbuf)<=0) BFAIL()

  03997	8d 54 24 30	 lea	 edx, DWORD PTR _sbuf$[esp+262196]
  0399b	52		 push	 edx
  0399c	c1 f8 02	 sar	 eax, 2
  0399f	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  039a2	50		 push	 eax
  039a3	51		 push	 ecx
  039a4	e8 00 00 00 00	 call	 _file2sock
  039a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  039ac	85 c0		 test	 eax, eax
  039ae	0f 8f cf c6 ff
	ff		 jg	 $LN6@bp
  039b4	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  039b7	e9 97 c6 ff ff	 jmp	 $LL1041@bp
$LN56@bp:

; 3092 :         }
; 3093 :         BNEXT(1);
; 3094 : 
; 3095 :         case SOCK2FILE_2:
; 3096 :         ATOMIZE(X(1)); ATOMIZE(X(2));

  039bc	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  039bf	8b c8		 mov	 ecx, eax
  039c1	83 e1 03	 and	 ecx, 3
  039c4	74 0c		 je	 SHORT $LN1714@bp
  039c6	83 f9 01	 cmp	 ecx, 1
  039c9	74 0c		 je	 SHORT $LN1736@bp
  039cb	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  039d0	74 05		 je	 SHORT $LN1736@bp
$LN1714@bp:
  039d2	8b 00		 mov	 eax, DWORD PTR [eax]
  039d4	89 47 fc	 mov	 DWORD PTR [edi-4], eax
$LN1736@bp:
  039d7	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  039da	8b c8		 mov	 ecx, eax
  039dc	83 e1 03	 and	 ecx, 3
  039df	74 0c		 je	 SHORT $LN52@bp
  039e1	83 f9 01	 cmp	 ecx, 1
  039e4	74 0c		 je	 SHORT $LN53@bp
  039e6	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  039eb	74 05		 je	 SHORT $LN53@bp
$LN52@bp:
  039ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  039ef	89 4f f8	 mov	 DWORD PTR [edi-8], ecx
$LN53@bp:

; 3097 :         if(!INTEGER(X(1)))

  039f2	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  039f5	8b d0		 mov	 edx, eax
  039f7	80 e2 03	 and	 dl, 3
  039fa	80 fa 01	 cmp	 dl, 1
  039fd	74 1b		 je	 SHORT $LN51@bp

; 3098 :         BWARFUN(X(1),"bad first arg in sock2file/2")

  039ff	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03a03	51		 push	 ecx
  03a04	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MECHBFDI@bad?5first?5arg?5in?5sock2file?12?$AA@
  03a09	50		 push	 eax
  03a0a	e8 00 00 00 00	 call	 _local_error
  03a0f	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03a12	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a15	e9 39 c6 ff ff	 jmp	 $LL1041@bp
$LN51@bp:

; 3099 :         if(!INTEGER(X(2)))

  03a1a	8b 77 f8	 mov	 esi, DWORD PTR [edi-8]
  03a1d	8b d6		 mov	 edx, esi
  03a1f	80 e2 03	 and	 dl, 3
  03a22	80 fa 01	 cmp	 dl, 1
  03a25	74 1b		 je	 SHORT $LN50@bp

; 3100 :         BWARFUN(X(2),"bad arg 2 in sock2file/2")

  03a27	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03a2b	50		 push	 eax
  03a2c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BOCIIDNN@bad?5arg?52?5in?5sock2file?12?$AA@
  03a31	56		 push	 esi
  03a32	e8 00 00 00 00	 call	 _local_error
  03a37	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03a3a	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a3d	e9 11 c6 ff ff	 jmp	 $LL1041@bp
$LN50@bp:

; 3101 :         ires=OUTPUT_INT(X(1));
; 3102 :         xref=INT2PTR(X(2));
; 3103 :         /*fprintf(STD_err,"sock2file: ires=%d\n",ires);*/
; 3104 :         {
; 3105 :           if(sock2file(ires,(FILE *)xref,sbuf)<=0) BFAIL()

  03a42	8d 54 24 30	 lea	 edx, DWORD PTR _sbuf$[esp+262196]
  03a46	52		 push	 edx
  03a47	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  03a4a	c1 f8 02	 sar	 eax, 2
  03a4d	51		 push	 ecx
  03a4e	50		 push	 eax
  03a4f	e8 00 00 00 00	 call	 _sock2file
  03a54	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a57	85 c0		 test	 eax, eax
  03a59	0f 8f 24 c6 ff
	ff		 jg	 $LN6@bp
  03a5f	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03a62	e9 ec c5 ff ff	 jmp	 $LL1041@bp
$LN48@bp:

; 3106 :         }
; 3107 :         BNEXT(1);
; 3108 : 
; 3109 :         case SLEEP_1:
; 3110 :         xval=X(1);

  03a67	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3111 :         if(!INTEGER(xval))

  03a6a	8b c8		 mov	 ecx, eax
  03a6c	80 e1 03	 and	 cl, 3
  03a6f	80 f9 01	 cmp	 cl, 1
  03a72	74 1b		 je	 SHORT $LN47@bp

; 3112 :         BWARFUN(xval,"bad first arg in sleep/1")

  03a74	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03a78	52		 push	 edx
  03a79	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DCEPMJDH@bad?5first?5arg?5in?5sleep?11?$AA@
  03a7e	50		 push	 eax
  03a7f	e8 00 00 00 00	 call	 _local_error
  03a84	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03a87	83 c4 0c	 add	 esp, 12			; 0000000cH
  03a8a	e9 c4 c5 ff ff	 jmp	 $LL1041@bp
$LN47@bp:

; 3113 :         ires=OUTPUT_INT(xval);

  03a8f	c1 f8 02	 sar	 eax, 2

; 3114 :         unix_sleep(ires);

  03a92	50		 push	 eax
  03a93	e8 00 00 00 00	 call	 _unix_sleep
  03a98	83 c4 04	 add	 esp, 4

; 3115 :         BNEXT(1);

  03a9b	83 c3 04	 add	 ebx, 4
  03a9e	e9 b0 c5 ff ff	 jmp	 $LL1041@bp
$LN46@bp:

; 3116 : 
; 3117 :         case HOST2IP_2:
; 3118 :         xval=X(1);

  03aa3	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 3119 :         if(!SYMCONST(xval))

  03aa6	8b c8		 mov	 ecx, eax
  03aa8	83 e1 03	 and	 ecx, 3
  03aab	80 f9 03	 cmp	 cl, 3
  03aae	75 5b		 jne	 SHORT $LN44@bp
  03ab0	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  03ab5	75 54		 jne	 SHORT $LN44@bp

; 3121 :         { string s=NAME(xval);

  03ab7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  03abd	c1 e8 02	 shr	 eax, 2
  03ac0	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  03ac5	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]

; 3122 :           s=host2ip(s);

  03ac8	50		 push	 eax
  03ac9	e8 00 00 00 00	 call	 _host2ip

; 3123 :           xval=INPUT_STRING(s);

  03ace	6a 00		 push	 0
  03ad0	50		 push	 eax
  03ad1	e8 00 00 00 00	 call	 _new_func
  03ad6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3124 :         }
; 3125 :         OUT_RESULT(xval);

  03ad9	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03adf	0f 84 4a f9 ff
	ff		 je	 $LN32@bp
  03ae5	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03ae9	55		 push	 ebp
  03aea	51		 push	 ecx
  03aeb	c1 ee 15	 shr	 esi, 21			; 00000015H
  03aee	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  03af1	52		 push	 edx
  03af2	50		 push	 eax
  03af3	e8 00 00 00 00	 call	 _unify
  03af8	83 c4 10	 add	 esp, 16			; 00000010H
  03afb	85 c0		 test	 eax, eax
  03afd	0f 85 32 f9 ff
	ff		 jne	 $LN133@bp
  03b03	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03b06	e9 48 c5 ff ff	 jmp	 $LL1041@bp
$LN44@bp:

; 3120 :         BWARFUN(xval,"bad first arg in host2ip/2")

  03b0b	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03b0f	51		 push	 ecx
  03b10	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IHOLGNBJ@bad?5first?5arg?5in?5host2ip?12?$AA@
  03b15	50		 push	 eax
  03b16	e8 00 00 00 00	 call	 _local_error
  03b1b	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03b1e	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b21	e9 2d c5 ff ff	 jmp	 $LL1041@bp
$LN40@bp:

; 3126 : 
; 3127 :         case QPRINT_1:
; 3128 :         xval=X(1);
; 3129 :         /* don't DEREF !!! ; regs may also be An */
; 3130 :         qprint(xval,wam,g.tellfile);

  03b26	8b 15 34 01 00
	00		 mov	 edx, DWORD PTR _g+308
  03b2c	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03b30	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  03b33	52		 push	 edx
  03b34	50		 push	 eax
  03b35	51		 push	 ecx
  03b36	e8 00 00 00 00	 call	 _qprint
  03b3b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3131 :         BNEXT(1);

  03b3e	83 c3 04	 add	 ebx, 4
  03b41	e9 0d c5 ff ff	 jmp	 $LL1041@bp
$LN39@bp:

; 3132 : 
; 3133 :         case TERM_STORE_OP_4:
; 3134 :         if(!(H=term_store_op(H,regs,wam))) BFAIL()

  03b46	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03b4a	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  03b4e	52		 push	 edx
  03b4f	57		 push	 edi
  03b50	50		 push	 eax
  03b51	e8 00 00 00 00	 call	 _term_store_op
  03b56	83 c4 0c	 add	 esp, 12			; 0000000cH
  03b59	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03b5d	85 c0		 test	 eax, eax
  03b5f	75 08		 jne	 SHORT $LN38@bp
  03b61	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03b64	e9 ea c4 ff ff	 jmp	 $LL1041@bp
$LN38@bp:

; 3135 :         xval=X(4);

  03b69	8b 47 f0	 mov	 eax, DWORD PTR [edi-16]
$LN127@bp:

; 3136 :         OUT_RESULT(xval);

  03b6c	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03b72	0f 84 b7 f8 ff
	ff		 je	 $LN32@bp
  03b78	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03b7c	55		 push	 ebp
  03b7d	51		 push	 ecx
  03b7e	c1 ee 15	 shr	 esi, 21			; 00000015H
  03b81	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  03b84	52		 push	 edx
  03b85	50		 push	 eax
  03b86	e8 00 00 00 00	 call	 _unify
  03b8b	83 c4 10	 add	 esp, 16			; 00000010H
  03b8e	85 c0		 test	 eax, eax
  03b90	0f 85 9f f8 ff
	ff		 jne	 $LN133@bp
  03b96	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03b99	e9 b5 c4 ff ff	 jmp	 $LL1041@bp
$LN34@bp:

; 3137 : 
; 3138 :         case NEW_BUILTIN_3:
; 3139 :         if(!(H=new_builtin(H,regs,A,P,wam))) BFAIL()

  03b9e	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03ba2	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03ba6	50		 push	 eax
  03ba7	53		 push	 ebx
  03ba8	55		 push	 ebp
  03ba9	57		 push	 edi
  03baa	51		 push	 ecx
  03bab	e8 00 00 00 00	 call	 _new_builtin
  03bb0	83 c4 14	 add	 esp, 20			; 00000014H
  03bb3	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03bb7	85 c0		 test	 eax, eax
  03bb9	75 08		 jne	 SHORT $LN33@bp
  03bbb	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03bbe	e9 90 c4 ff ff	 jmp	 $LL1041@bp
$LN33@bp:

; 3140 :         xval=X(3);

  03bc3	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
$LN1774@bp:

; 3141 :         OUT_RESULT(xval);

  03bc6	f7 c6 00 f0 1f
	00		 test	 esi, 2093056		; 001ff000H
  03bcc	0f 84 5d f8 ff
	ff		 je	 $LN32@bp
  03bd2	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03bd6	55		 push	 ebp
  03bd7	c1 ee 15	 shr	 esi, 21			; 00000015H
  03bda	8b 0c 3e	 mov	 ecx, DWORD PTR [esi+edi]
  03bdd	52		 push	 edx
  03bde	51		 push	 ecx
$LN1772@bp:
  03bdf	50		 push	 eax
$LN1746@bp:
  03be0	e8 00 00 00 00	 call	 _unify
$LN1775@bp:
  03be5	83 c4 10	 add	 esp, 16			; 00000010H
  03be8	85 c0		 test	 eax, eax
  03bea	0f 85 45 f8 ff
	ff		 jne	 $LN133@bp
$LN1747@bp:
  03bf0	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03bf3	e9 5b c4 ff ff	 jmp	 $LL1041@bp
$LN28@bp:

; 3146 :         break;
; 3147 : 
; 3148 :         case RESTART0_0:
; 3149 :         restart_orig(wam);

  03bf8	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03bfc	52		 push	 edx
  03bfd	e8 00 00 00 00	 call	 _restart_orig
  03c02	83 c4 04	 add	 esp, 4

; 3150 :         NEXT(1);

  03c05	83 c3 04	 add	 ebx, 4
  03c08	e9 46 c4 ff ff	 jmp	 $LL1041@bp
$LN26@bp:

; 3156 : 
; 3157 :         case BEGIN_C_CHUNK:
; 3158 : 
; 3159 :         C_CHUNK_TRACE("BEGIN_C_CHUNK");
; 3160 : 
; 3161 :         xval=GETFUN(P);
; 3162 : 
; 3163 :         H = FUNCALL(xval,(H,regs,P+2,cutB,A,wam));

  03c0d	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  03c11	8b 4c 24 24	 mov	 ecx, DWORD PTR _cutB$[esp+262196]
  03c15	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  03c18	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03c1c	56		 push	 esi
  03c1d	55		 push	 ebp
  03c1e	51		 push	 ecx
  03c1f	83 c3 08	 add	 ebx, 8
  03c22	53		 push	 ebx
  03c23	57		 push	 edi
  03c24	52		 push	 edx
  03c25	ff d0		 call	 eax

; 3164 : #if TRACE>0 || PROF
; 3165 :         if(g.inC)
; 3166 :         {
; 3167 :           if(wam[ChoiceStk].top>A
; 3168 :               || wam[ChoiceStk].top<wam[ChoiceStk].base)
; 3169 :           ABORT("unexpected A after C_CHUNK");
; 3170 :         }
; 3171 :         else
; 3172 :         ABORT("unexpected BEGIN_C_CHUNK");
; 3173 : #endif
; 3174 :         A=wam[ChoiceStk].top; /* SAVED_P depends on A */

  03c27	8b 6e 50	 mov	 ebp, DWORD PTR [esi+80]
  03c2a	83 c4 18	 add	 esp, 24			; 00000018H
  03c2d	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 3175 :         if(!H) FAILURE();

  03c31	85 c0		 test	 eax, eax
  03c33	75 08		 jne	 SHORT $LN25@bp
  03c35	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03c38	e9 16 c4 ff ff	 jmp	 $LL1041@bp
$LN25@bp:

; 3176 :         P=(instr)wam[ChoiceStk].oldtop;

  03c3d	8b 5e 54	 mov	 ebx, DWORD PTR [esi+84]

; 3177 :         continue;

  03c40	e9 0e c4 ff ff	 jmp	 $LL1041@bp
$LN24@bp:

; 3178 : 
; 3179 :         case END_C_CHUNK:
; 3180 :         C_CHUNK_TRACE("END_C_CHUNK");
; 3181 :         warnmes("END_C_CHUNK should never be executed");

  03c45	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NHKCDLMJ@END_C_CHUNK?5should?5never?5be?5exec@
  03c4a	e8 00 00 00 00	 call	 _warnmes
  03c4f	83 c4 04	 add	 esp, 4

; 3182 :         NEXT(1);

  03c52	83 c3 04	 add	 ebx, 4
  03c55	e9 f9 c3 ff ff	 jmp	 $LL1041@bp
$LN23@bp:

; 3183 : 
; 3184 :         case FUNCTOR_3:
; 3185 :         if(!(H=functor(H,regs+1,wam,A))) FAILURE()

  03c5a	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03c5e	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03c62	55		 push	 ebp
  03c63	50		 push	 eax
  03c64	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  03c67	56		 push	 esi
  03c68	51		 push	 ecx
  03c69	e8 00 00 00 00	 call	 _functor
  03c6e	83 c4 10	 add	 esp, 16			; 00000010H
  03c71	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03c75	85 c0		 test	 eax, eax
  03c77	75 08		 jne	 SHORT $LN22@bp
  03c79	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03c7c	e9 d2 c3 ff ff	 jmp	 $LL1041@bp
$LN22@bp:

; 3186 :         CONT(4);

  03c81	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  03c84	89 16		 mov	 DWORD PTR [esi], edx
  03c86	83 c3 04	 add	 ebx, 4
  03c89	e9 c5 c3 ff ff	 jmp	 $LL1041@bp
$LN21@bp:

; 3187 : 
; 3188 :         case NAME_2:
; 3189 :         if(!(H=name2list(H,regs+1,regs+2,wam,A))) FAILURE()

  03c8e	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03c92	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03c96	55		 push	 ebp
  03c97	50		 push	 eax
  03c98	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  03c9b	51		 push	 ecx
  03c9c	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  03c9f	56		 push	 esi
  03ca0	52		 push	 edx
  03ca1	e8 00 00 00 00	 call	 _name2list
  03ca6	83 c4 14	 add	 esp, 20			; 00000014H
  03ca9	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03cad	85 c0		 test	 eax, eax
  03caf	75 08		 jne	 SHORT $LN20@bp
  03cb1	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03cb4	e9 9a c3 ff ff	 jmp	 $LL1041@bp
$LN20@bp:

; 3190 :         CONT(3);

  03cb9	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  03cbc	89 06		 mov	 DWORD PTR [esi], eax
  03cbe	83 c3 04	 add	 ebx, 4
  03cc1	e9 8d c3 ff ff	 jmp	 $LL1041@bp
$LN19@bp:

; 3191 : 
; 3192 :         case LOAD0_1: if(!load_1(regs,wam)) FAILURE();

  03cc6	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03cca	51		 push	 ecx
  03ccb	57		 push	 edi
  03ccc	e8 00 00 00 00	 call	 _load_1
  03cd1	83 c4 08	 add	 esp, 8
  03cd4	85 c0		 test	 eax, eax
  03cd6	75 5e		 jne	 SHORT $LN13@bp
  03cd8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03cdb	e9 73 c3 ff ff	 jmp	 $LL1041@bp
$LN17@bp:

; 3193 :         CONT(2);
; 3194 : 
; 3195 :         case STAT0_3:
; 3196 :         if(!stats0(H,regs,wam,A)) FAILURE()

  03ce0	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03ce4	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03ce8	55		 push	 ebp
  03ce9	50		 push	 eax
  03cea	57		 push	 edi
  03ceb	51		 push	 ecx
  03cec	e8 00 00 00 00	 call	 _stats0
  03cf1	83 c4 10	 add	 esp, 16			; 00000010H
  03cf4	85 c0		 test	 eax, eax
  03cf6	75 08		 jne	 SHORT $LN16@bp
  03cf8	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03cfb	e9 53 c3 ff ff	 jmp	 $LL1041@bp
$LN16@bp:

; 3197 :         CONT(4);

  03d00	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  03d03	89 57 04	 mov	 DWORD PTR [edi+4], edx
  03d06	83 c3 04	 add	 ebx, 4
  03d09	e9 45 c3 ff ff	 jmp	 $LL1041@bp
$LN15@bp:

; 3198 : 
; 3199 :         case LIST_ASM_3:
; 3200 : #if TRACE>0 || PROF
; 3201 :         if(!list_asm(regs[1],regs[2],regs[3],wam)) FAILURE()
; 3202 : #endif
; 3203 :         CONT(4);

  03d0e	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  03d11	89 47 04	 mov	 DWORD PTR [edi+4], eax
  03d14	83 c3 04	 add	 ebx, 4
  03d17	e9 37 c3 ff ff	 jmp	 $LL1041@bp
$LN14@bp:

; 3204 : 
; 3205 :         case BB_RESET_1:
; 3206 :         if(!bb_reset(regs,wam)) FAILURE()

  03d1c	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03d20	51		 push	 ecx
  03d21	57		 push	 edi
  03d22	e8 00 00 00 00	 call	 _bb_reset
  03d27	83 c4 08	 add	 esp, 8
  03d2a	85 c0		 test	 eax, eax
  03d2c	75 08		 jne	 SHORT $LN13@bp
  03d2e	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03d31	e9 1d c3 ff ff	 jmp	 $LL1041@bp
$LN13@bp:

; 3207 :         CONT(2);

  03d36	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  03d39	89 57 04	 mov	 DWORD PTR [edi+4], edx
  03d3c	83 c3 04	 add	 ebx, 4
  03d3f	e9 0f c3 ff ff	 jmp	 $LL1041@bp
$LN12@bp:

; 3208 : 
; 3209 :         case GARBAGE_COLLECT_0:
; 3210 : #if GC>0
; 3211 :         if(!(H=trigger_gc(H, regs, A, P, wam)))

  03d44	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  03d48	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  03d4c	56		 push	 esi
  03d4d	53		 push	 ebx
  03d4e	55		 push	 ebp
  03d4f	57		 push	 edi
  03d50	50		 push	 eax
  03d51	e8 00 00 00 00	 call	 _trigger_gc
  03d56	83 c4 14	 add	 esp, 20			; 00000014H
  03d59	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03d5d	85 c0		 test	 eax, eax
  03d5f	0f 84 54 ca ff
	ff		 je	 $LN1617@bp

; 3212 :         {
; 3213 :           RECOVER();
; 3214 :         }
; 3215 :         CONT(1);

  03d65	83 c3 04	 add	 ebx, 4
  03d68	e9 e6 c2 ff ff	 jmp	 $LL1041@bp
$LN9@bp:

; 3216 : #else
; 3217 :         ABORT("garbage_collect/0 not implemented");
; 3218 : #endif
; 3219 : 
; 3220 :         case PROFILE_0:
; 3221 : #if TRACE>1 || PROF
; 3222 :         profiler(2,P,A,H,wam);
; 3223 : #endif
; 3224 : #if TRACE_EXEC>0
; 3225 :         show_ucount();
; 3226 : #endif
; 3227 :         CONT(1);
; 3228 : 
; 3229 : #ifdef BUILTIN_MEMBER
; 3230 :         case MEMBER_ENTRY_2:
; 3231 :         H=member_entry(H,regs,wam,A);

  03d6d	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  03d71	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03d75	55		 push	 ebp
  03d76	56		 push	 esi
  03d77	57		 push	 edi
  03d78	51		 push	 ecx
  03d79	e8 00 00 00 00	 call	 _member_entry
  03d7e	83 c4 10	 add	 esp, 16			; 00000010H
  03d81	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 3232 :         if(!H) {A=wam[ChoiceStk].top; FAILURE()}

  03d85	85 c0		 test	 eax, eax
  03d87	0f 85 f6 c2 ff
	ff		 jne	 $LN6@bp
  03d8d	8b 6e 50	 mov	 ebp, DWORD PTR [esi+80]
  03d90	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03d93	e9 bb c2 ff ff	 jmp	 $LL1041@bp
$LN7@bp:

; 3233 :         NEXT(1);
; 3234 : 
; 3235 :         case FOR_ENTRY_3:
; 3236 :         H=for_entry(H,regs,wam,A);

  03d98	8b 74 24 10	 mov	 esi, DWORD PTR _wam$GSCopy$[esp+262196]
  03d9c	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03da0	55		 push	 ebp
  03da1	56		 push	 esi
  03da2	57		 push	 edi
  03da3	52		 push	 edx
  03da4	e8 00 00 00 00	 call	 _for_entry
  03da9	83 c4 10	 add	 esp, 16			; 00000010H
  03dac	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax

; 3237 :         if(!H) {A=wam[ChoiceStk].top; FAILURE()}

  03db0	85 c0		 test	 eax, eax
  03db2	0f 85 cb c2 ff
	ff		 jne	 $LN6@bp
  03db8	8b 6e 50	 mov	 ebp, DWORD PTR [esi+80]
  03dbb	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03dbe	e9 90 c2 ff ff	 jmp	 $LL1041@bp
$LN3@bp:

; 3257 : 
; 3258 :         case IF0_3:
; 3259 :         if(!(H=if0(regs,H,P,A,wam))) FAILURE();

  03dc3	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03dc7	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03dcb	50		 push	 eax
  03dcc	55		 push	 ebp
  03dcd	53		 push	 ebx
  03dce	51		 push	 ecx
  03dcf	57		 push	 edi
  03dd0	e8 00 00 00 00	 call	 _if0
  03dd5	83 c4 14	 add	 esp, 20			; 00000014H
  03dd8	89 44 24 14	 mov	 DWORD PTR _H$GSCopy$[esp+262196], eax
  03ddc	85 c0		 test	 eax, eax
  03dde	75 08		 jne	 SHORT $LN2@bp
$LN1701@bp:
  03de0	8b 5d 00	 mov	 ebx, DWORD PTR [ebp]
  03de3	e9 6b c2 ff ff	 jmp	 $LL1041@bp
$LN2@bp:

; 3260 :         P=g.call;

  03de8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _g

; 3261 :         continue;

  03dee	e9 60 c2 ff ff	 jmp	 $LL1041@bp
$LN1@bp:

; 3262 : 
; 3263 :         default: /* xval=fields; makes gcc reg allocator happy */
; 3264 :         bad_instr(P);

  03df3	81 e6 ff 03 00
	00		 and	 esi, 1023		; 000003ffH
  03df9	56		 push	 esi
  03dfa	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MGKEAMMC@?$CK?$CK?$CK?5bad?5instruction?3?5?$FL?$CFlu?$FN?5?$CK?$CK?$CK?6?$AA@
  03dff	e8 00 00 00 00	 call	 ___iob_func
  03e04	83 c0 40	 add	 eax, 64			; 00000040H
  03e07	50		 push	 eax
  03e08	e8 00 00 00 00	 call	 _fprintf
  03e0d	6a 08		 push	 8
  03e0f	e8 00 00 00 00	 call	 _bp_halt
  03e14	83 c4 10	 add	 esp, 16			; 00000010H

; 3265 : 
; 3266 :       } /* switch */
; 3267 :     } /* for    */

  03e17	e9 37 c2 ff ff	 jmp	 $LL1041@bp
$LN925@bp:

; 1688 : 
; 1689 :       case PUSH_VARIABLE:
; 1690 :         ABORT("unexpected push_variable");

  03e1c	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LAEMLNBC@unexpected?5push_variable?$AA@
  03e21	e9 75 02 00 00	 jmp	 $LN1790@bp
$LN1624@bp:

; 1915 : #endif
; 1916 : 
; 1917 : #if JUMP_COMPRESS
; 1918 :       case EXEC_TRY:
; 1919 :         EXEC0()

  03e26	e8 00 00 00 00	 call	 _link_halt
  03e2b	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03e2f	8b 48 7c	 mov	 ecx, DWORD PTR [eax+124]
  03e32	c7 41 18 fd ff
	ff ff		 mov	 DWORD PTR [ecx+24], -3	; fffffffdH
  03e39	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  03e3c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  03e43	89 68 50	 mov	 DWORD PTR [eax+80], ebp
  03e46	89 5a 08	 mov	 DWORD PTR [edx+8], ebx
  03e49	33 c0		 xor	 eax, eax
  03e4b	e9 5f 02 00 00	 jmp	 $LN1040@bp
$LN1625@bp:

; 1922 : #endif
; 1923 : 
; 1924 :       case TRY_ME_ELSE:
; 1925 :         xval = REGFIELD;
; 1926 :         IF_OVER("TRY_ME_ELSE",A,ChoiceStk,RECOVER())

  03e50	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IIDJDDPG@TRY_ME_ELSE?$AA@
  03e55	8b f1		 mov	 esi, ecx
  03e57	56		 push	 esi
  03e58	6a 02		 push	 2
  03e5a	55		 push	 ebp
  03e5b	e8 00 00 00 00	 call	 _overflow_by
  03e60	83 c4 10	 add	 esp, 16			; 00000010H
  03e63	e8 00 00 00 00	 call	 _link_halt
  03e68	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  03e6b	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03e6f	c7 40 18 fd ff
	ff ff		 mov	 DWORD PTR [eax+24], -3	; fffffffdH
  03e76	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  03e79	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  03e7c	89 6e 50	 mov	 DWORD PTR [esi+80], ebp
  03e7f	89 5a 08	 mov	 DWORD PTR [edx+8], ebx
  03e82	33 c0		 xor	 eax, eax
  03e84	e9 26 02 00 00	 jmp	 $LN1040@bp
$LN736@bp:

; 1948 : 
; 1949 :       case TRY_ME_ONLY: /* nop */
; 1950 : #if 1
; 1951 :         ABORT("unexpected TRY_ME_ONLY");

  03e89	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03e8d	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03e91	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DPJLIEHM@unexpected?5TRY_ME_ONLY?$AA@
  03e96	50		 push	 eax
  03e97	55		 push	 ebp
  03e98	53		 push	 ebx
  03e99	51		 push	 ecx
  03e9a	e9 08 02 00 00	 jmp	 $LN1791@bp
$LN735@bp:

; 1952 : #else
; 1953 :         NEXT(2);
; 1954 : 
; 1955 : #endif
; 1956 :       case NONDET:
; 1957 : #if 1
; 1958 :         ABORT("unexpected NONDET");

  03e9f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JLMAFMNA@unexpected?5NONDET?$AA@
  03ea4	e9 f2 01 00 00	 jmp	 $LN1790@bp
$LN1632@bp:

; 2540 : #ifdef OLD_SREAD
; 2541 :           xval=X(2);
; 2542 :           if(!SYMCONST(xval)) BFAIL()
; 2543 :           xval=sread(H,xval);
; 2544 :           if(!xval) BFAIL()
; 2545 :           H=(term)(xval)+1;
; 2546 : #else
; 2547 :           BEXIT("old sread not supported anymore");

  03ea9	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03ead	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03eb1	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LNHJFFBE@old?5sread?5not?5supported?5anymore?$AA@
  03eb6	51		 push	 ecx
  03eb7	55		 push	 ebp
  03eb8	53		 push	 ebx
  03eb9	52		 push	 edx
  03eba	e9 e8 01 00 00	 jmp	 $LN1791@bp
$LN1633@bp:

; 2562 :             if (!H) BEXIT("fatal error in STRING_OP(2,...)");

  03ebf	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03ec3	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MIPHDEIL@fatal?5error?5in?5STRING_OP?$CI2?0?4?4?4?$CJ?$AA@
  03ec8	50		 push	 eax
  03ec9	55		 push	 ebp
  03eca	53		 push	 ebx
  03ecb	6a 00		 push	 0
  03ecd	e9 d5 01 00 00	 jmp	 $LN1791@bp
$LN1634@bp:

; 2570 :           if (!H) BEXIT("fatal error in STRING_OP(3,...)");

  03ed2	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03ed6	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GOIADPDP@fatal?5error?5in?5STRING_OP?$CI3?0?4?4?4?$CJ?$AA@
  03edb	51		 push	 ecx
  03edc	55		 push	 ebp
  03edd	53		 push	 ebx
  03ede	6a 00		 push	 0
  03ee0	e9 c2 01 00 00	 jmp	 $LN1791@bp
$LN1635@bp:

; 2579 :             if (!list2buf(xref, xval, sbuf, MAXSBUF)) BEXIT("fatal error in STRING_OP(4,..)");

  03ee5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PLMPOGIE@fatal?5error?5in?5STRING_OP?$CI4?0?4?4?$CJ?$AA@
  03eea	e9 ac 01 00 00	 jmp	 $LN1790@bp
$LN345@bp:

; 2583 :           }
; 2584 :         }
; 2585 : else        BEXIT("bad string op");

  03eef	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03ef3	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03ef7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KIFKLKPM@bad?5string?5op?$AA@
  03efc	51		 push	 ecx
  03efd	55		 push	 ebp
  03efe	53		 push	 ebx
  03eff	52		 push	 edx
  03f00	e9 a2 01 00 00	 jmp	 $LN1791@bp
$LN1636@bp:

; 2601 :             COPY_TERM(
; 2602 :                 H, /* from */
; 2603 :                 wam[HeapStk].margin, /* to */
; 2604 :                 BEXIT("heap_overflow in copy_term/2"));

  03f05	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03f09	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OPJCLFFO@heap_overflow?5in?5copy_term?12?$AA@
  03f0e	50		 push	 eax
  03f0f	55		 push	 ebp
  03f10	53		 push	 ebx
  03f11	51		 push	 ecx
  03f12	e9 90 01 00 00	 jmp	 $LN1791@bp
$LN1637@bp:

; 2682 :         if(!H) BEXIT("error in bb_list/2");

  03f17	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03f1b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NKGLIFDI@error?5in?5bb_list?12?$AA@
  03f20	52		 push	 edx
  03f21	55		 push	 ebp
  03f22	53		 push	 ebx
  03f23	6a 00		 push	 0
  03f25	e9 7d 01 00 00	 jmp	 $LN1791@bp
$LN1638@bp:

; 2708 :         BEXIT("error in unix_fork/1");

  03f2a	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03f2e	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03f32	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PAIJDAHP@error?5in?5unix_fork?11?$AA@
  03f37	50		 push	 eax
  03f38	55		 push	 ebp
  03f39	53		 push	 ebx
  03f3a	51		 push	 ecx
  03f3b	e9 67 01 00 00	 jmp	 $LN1791@bp
$LN1639@bp:

; 2715 :         BEXIT("error in unix_pid/1");

  03f40	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FLBCDNAM@error?5in?5unix_pid?11?$AA@
  03f45	e9 51 01 00 00	 jmp	 $LN1790@bp
$LN1640@bp:

; 2754 :         BEXIT("bad engine in ask_engine/2");

  03f4a	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03f4e	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03f52	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OFHHPKJP@bad?5engine?5in?5ask_engine?12?$AA@
  03f57	51		 push	 ecx
  03f58	55		 push	 ebp
  03f59	53		 push	 ebx
  03f5a	52		 push	 edx
  03f5b	e9 47 01 00 00	 jmp	 $LN1791@bp
$LN1641@bp:

; 2774 :         BEXIT("bad engine in ask_thread/2");

  03f60	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03f64	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03f68	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OAGLCGIM@bad?5engine?5in?5ask_thread?12?$AA@
  03f6d	50		 push	 eax
  03f6e	55		 push	 ebp
  03f6f	53		 push	 ebx
  03f70	51		 push	 ecx
  03f71	e9 31 01 00 00	 jmp	 $LN1791@bp
$LN1642@bp:

; 2791 :         BEXIT("integer arg expected in join_thread/1");

  03f76	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IAJGJMEG@integer?5arg?5expected?5in?5join_thr@
  03f7b	e9 1b 01 00 00	 jmp	 $LN1790@bp
$LN1643@bp:

; 2807 :           if(0==ires) BEXIT("error in tsync_op/3");

  03f80	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  03f84	8b 54 24 14	 mov	 edx, DWORD PTR _H$GSCopy$[esp+262196]
  03f88	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KFOMLNGG@error?5in?5tsync_op?13?$AA@
  03f8d	51		 push	 ecx
  03f8e	55		 push	 ebp
  03f8f	53		 push	 ebx
  03f90	52		 push	 edx
  03f91	e9 11 01 00 00	 jmp	 $LN1791@bp
$LN207@bp:

; 2809 :         }
; 2810 :         else {
; 2811 :           fprintf(STD_err, "ARGS: %ld %ld %ld\n",
; 2812 :               OUTPUT_INT(X(1)), OUTPUT_INT(X(2)),
; 2813 :               OUTPUT_INT(X(3))
; 2814 :           );

  03f96	8b 47 f4	 mov	 eax, DWORD PTR [edi-12]
  03f99	8b 4f f8	 mov	 ecx, DWORD PTR [edi-8]
  03f9c	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  03f9f	c1 f8 02	 sar	 eax, 2
  03fa2	50		 push	 eax
  03fa3	c1 f9 02	 sar	 ecx, 2
  03fa6	51		 push	 ecx
  03fa7	c1 fa 02	 sar	 edx, 2
  03faa	52		 push	 edx
  03fab	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CKAJPEJ@ARGS?3?5?$CFld?5?$CFld?5?$CFld?6?$AA@
  03fb0	e8 00 00 00 00	 call	 ___iob_func
  03fb5	83 c0 40	 add	 eax, 64			; 00000040H
  03fb8	50		 push	 eax
  03fb9	e8 00 00 00 00	 call	 _fprintf

; 2815 :           BEXIT("bad input in tsync_op/3");

  03fbe	8b 44 24 24	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262216]
  03fc2	8b 4c 24 28	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262216]
  03fc6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EOKIIOGO@bad?5input?5in?5tsync_op?13?$AA@
  03fcb	50		 push	 eax
  03fcc	55		 push	 ebp
  03fcd	53		 push	 ebx
  03fce	51		 push	 ecx
  03fcf	e8 00 00 00 00	 call	 _bp_abort
  03fd4	83 c4 28	 add	 esp, 40			; 00000028H
  03fd7	e9 d3 00 00 00	 jmp	 $LN1040@bp
$LN1644@bp:

; 2831 :         if(!H) BEXIT("error in list_engines/1");

  03fdc	8b 54 24 10	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262196]
  03fe0	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BCNJLFIO@error?5in?5list_engines?11?$AA@
  03fe5	52		 push	 edx
  03fe6	55		 push	 ebp
  03fe7	53		 push	 ebx
  03fe8	6a 00		 push	 0
  03fea	e9 b8 00 00 00	 jmp	 $LN1791@bp
$LN1645@bp:

; 2841 :           BEXIT("bad args in get_engine_prop(No,Attr,Val)");

  03fef	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  03ff3	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  03ff7	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KMFIFFAF@bad?5args?5in?5get_engine_prop?$CINo?0A@
  03ffc	50		 push	 eax
  03ffd	55		 push	 ebp
  03ffe	53		 push	 ebx
  03fff	51		 push	 ecx
  04000	e9 a2 00 00 00	 jmp	 $LN1791@bp
$LN1646@bp:

; 2852 :         BEXIT("arg 1 of untrail_to/1 should be integer");

  04005	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EPDMONLP@arg?51?5of?5untrail_to?11?5should?5be?5@
  0400a	e9 8c 00 00 00	 jmp	 $LN1790@bp
$LN1647@bp:

; 3045 :           if(!H) BEXIT("fatal error string2list in SOCK_READ(...)");

  0400f	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  04013	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@MIJFHGF@fatal?5error?5string2list?5in?5SOCK_@
  04018	50		 push	 eax
  04019	55		 push	 ebp
  0401a	53		 push	 ebx
  0401b	6a 00		 push	 0
  0401d	e9 85 00 00 00	 jmp	 $LN1791@bp
$LN29@bp:

; 3142 : 
; 3143 :         case HALT_1:
; 3144 :         SAVE_HAP();

  04022	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  04026	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0402a	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]

; 3145 :         return heap_or_bp_halt(H,regs,wam);

  0402d	50		 push	 eax
  0402e	57		 push	 edi
  0402f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  04032	89 68 50	 mov	 DWORD PTR [eax+80], ebp
  04035	51		 push	 ecx
  04036	89 5a 08	 mov	 DWORD PTR [edx+8], ebx
  04039	e8 00 00 00 00	 call	 _heap_or_bp_halt
  0403e	83 c4 0c	 add	 esp, 12			; 0000000cH
  04041	eb 6c		 jmp	 SHORT $LN1040@bp
$LN27@bp:

; 3151 : 
; 3152 :         case ABORT0_0:
; 3153 :         SAVE_HAP();

  04043	8b 44 24 10	 mov	 eax, DWORD PTR _wam$GSCopy$[esp+262196]
  04047	8b 50 7c	 mov	 edx, DWORD PTR [eax+124]
  0404a	8b 4c 24 14	 mov	 ecx, DWORD PTR _H$GSCopy$[esp+262196]
  0404e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  04051	89 68 50	 mov	 DWORD PTR [eax+80], ebp
  04054	89 5a 08	 mov	 DWORD PTR [edx+8], ebx

; 3154 :         SET_ENGINE_ERROR(ENGINE_ABORT);

  04057	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0405a	c7 40 18 fd ff
	ff ff		 mov	 DWORD PTR [eax+24], -3	; fffffffdH

; 3155 :         return NULL;

  04061	33 c0		 xor	 eax, eax
  04063	eb 4a		 jmp	 SHORT $LN1040@bp
$LN5@bp:

; 3238 :         NEXT(1);
; 3239 : 
; 3240 : #else
; 3241 :         case MEMBER_ENTRY_2:
; 3242 :         ABORT("member_entry/2 builtin not implemented");
; 3243 :         case FOR_ENTRY_3:
; 3244 :         ABORT("for_entry/3 builtin not implemented");
; 3245 : #endif
; 3246 : 
; 3247 :         case RETURN0_1:
; 3248 :         xval=INPUT_INT(1);
; 3249 :         SET_ENGINE_TYPE(SUSPENDED_ENGINE);

  04065	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$GSCopy$[esp+262196]
  04069	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  0406c	c7 00 19 00 00
	00		 mov	 DWORD PTR [eax], 25	; 00000019H

; 3250 :         SET_ENGINE(ENGINE_RETURN,regs[1]);

  04072	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  04075	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  04078	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 3251 :         regs[1]=regs[2]; P++;

  0407b	8b 57 08	 mov	 edx, DWORD PTR [edi+8]

; 3252 :         SAVE_HAP();

  0407e	8b 44 24 14	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262196]
  04082	89 57 04	 mov	 DWORD PTR [edi+4], edx
  04085	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  04088	89 69 50	 mov	 DWORD PTR [ecx+80], ebp
  0408b	8b 49 7c	 mov	 ecx, DWORD PTR [ecx+124]
  0408e	83 c3 04	 add	 ebx, 4
  04091	89 59 08	 mov	 DWORD PTR [ecx+8], ebx

; 3253 :         return H;

  04094	eb 19		 jmp	 SHORT $LN1040@bp
$LN4@bp:

; 3254 : 
; 3255 :         case FCALL_3:
; 3256 :         ABORT("fcall/3 builtin not implemented");

  04096	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LGCBDFFN@fcall?13?5builtin?5not?5implemented?$AA@
$LN1790@bp:
  0409b	8b 54 24 14	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+262200]
  0409f	8b 44 24 18	 mov	 eax, DWORD PTR _H$GSCopy$[esp+262200]
  040a3	52		 push	 edx
  040a4	55		 push	 ebp
  040a5	53		 push	 ebx
  040a6	50		 push	 eax
$LN1791@bp:
  040a7	e8 00 00 00 00	 call	 _bp_abort
  040ac	83 c4 14	 add	 esp, 20			; 00000014H
$LN1040@bp:

; 3268 :   } /* bp0     */

  040af	8b 8c 24 30 00
	04 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+262196]
  040b6	5f		 pop	 edi
  040b7	5e		 pop	 esi
  040b8	5d		 pop	 ebp
  040b9	5b		 pop	 ebx
  040ba	33 cc		 xor	 ecx, esp
  040bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  040c1	81 c4 24 00 04
	00		 add	 esp, 262180		; 00040024H
  040c7	c3		 ret	 0
$LN1798@bp:
  040c8	00 00 00 00	 DD	 $LN1037@bp
  040cc	00 00 00 00	 DD	 $LN1036@bp
  040d0	00 00 00 00	 DD	 $LN1035@bp
  040d4	00 00 00 00	 DD	 $LN1033@bp
  040d8	00 00 00 00	 DD	 $LN1024@bp
  040dc	00 00 00 00	 DD	 $LN938@bp
  040e0	00 00 00 00	 DD	 $LN1718@bp
  040e4	00 00 00 00	 DD	 $LN924@bp
  040e8	00 00 00 00	 DD	 $LN1017@bp
  040ec	00 00 00 00	 DD	 $LN914@bp
  040f0	00 00 00 00	 DD	 $LN1008@bp
  040f4	00 00 00 00	 DD	 $LN1007@bp
  040f8	00 00 00 00	 DD	 $LN1006@bp
  040fc	00 00 00 00	 DD	 $LN1005@bp
  04100	00 00 00 00	 DD	 $LN913@bp
  04104	00 00 00 00	 DD	 $LN912@bp
  04108	00 00 00 00	 DD	 $LN911@bp
  0410c	00 00 00 00	 DD	 $LN906@bp
  04110	00 00 00 00	 DD	 $LN901@bp
  04114	00 00 00 00	 DD	 $LN749@bp
  04118	00 00 00 00	 DD	 $LN744@bp
  0411c	00 00 00 00	 DD	 $LN740@bp
  04120	00 00 00 00	 DD	 $LN736@bp
  04124	00 00 00 00	 DD	 $LN735@bp
  04128	00 00 00 00	 DD	 $LN899@bp
  0412c	00 00 00 00	 DD	 $LN896@bp
  04130	00 00 00 00	 DD	 $LN888@bp
  04134	00 00 00 00	 DD	 $LN885@bp
  04138	00 00 00 00	 DD	 $LN729@bp
  0413c	00 00 00 00	 DD	 $LN714@bp
  04140	00 00 00 00	 DD	 $LN838@bp
  04144	00 00 00 00	 DD	 $LN1002@bp
  04148	00 00 00 00	 DD	 $LN813@bp
  0414c	00 00 00 00	 DD	 $LN1001@bp
  04150	00 00 00 00	 DD	 $LN861@bp
  04154	00 00 00 00	 DD	 $LN983@bp
  04158	00 00 00 00	 DD	 $LN805@bp
  0415c	00 00 00 00	 DD	 $LN967@bp
  04160	00 00 00 00	 DD	 $LN829@bp
  04164	00 00 00 00	 DD	 $LN954@bp
  04168	00 00 00 00	 DD	 $LN792@bp
  0416c	00 00 00 00	 DD	 $LN945@bp
  04170	00 00 00 00	 DD	 $LN877@bp
  04174	00 00 00 00	 DD	 $LN999@bp
  04178	00 00 00 00	 DD	 $LN812@bp
  0417c	00 00 00 00	 DD	 $LN990@bp
  04180	00 00 00 00	 DD	 $LN1003@bp
  04184	00 00 00 00	 DD	 $LN723@bp
  04188	00 00 00 00	 DD	 $LN728@bp
  0418c	00 00 00 00	 DD	 $LN753@bp
  04190	00 00 00 00	 DD	 $LN709@bp
  04194	00 00 00 00	 DD	 $LN927@bp
  04198	00 00 00 00	 DD	 $LN925@bp
  0419c	00 00 00 00	 DD	 $LN785@bp
  041a0	00 00 00 00	 DD	 $LN1722@bp
  041a4	00 00 00 00	 DD	 $LN783@bp
  041a8	00 00 00 00	 DD	 $LN1723@bp
  041ac	00 00 00 00	 DD	 $LN775@bp
  041b0	00 00 00 00	 DD	 $LN1724@bp
  041b4	00 00 00 00	 DD	 $LN761@bp
  041b8	00 00 00 00	 DD	 $LN1726@bp
  041bc	00 00 00 00	 DD	 $LN734@bp
  041c0	00 00 00 00	 DD	 $LN1727@bp
  041c4	00 00 00 00	 DD	 $LN26@bp
  041c8	00 00 00 00	 DD	 $LN24@bp
  041cc	00 00 00 00	 DD	 $LN680@bp
  041d0	00 00 00 00	 DD	 $LN1701@bp
  041d4	00 00 00 00	 DD	 $LN674@bp
  041d8	00 00 00 00	 DD	 $LN673@bp
  041dc	00 00 00 00	 DD	 $LN672@bp
  041e0	00 00 00 00	 DD	 $LN666@bp
  041e4	00 00 00 00	 DD	 $LN660@bp
  041e8	00 00 00 00	 DD	 $LN654@bp
  041ec	00 00 00 00	 DD	 $LN646@bp
  041f0	00 00 00 00	 DD	 $LN639@bp
  041f4	00 00 00 00	 DD	 $LN629@bp
  041f8	00 00 00 00	 DD	 $LN620@bp
  041fc	00 00 00 00	 DD	 $LN611@bp
  04200	00 00 00 00	 DD	 $LN601@bp
  04204	00 00 00 00	 DD	 $LN591@bp
  04208	00 00 00 00	 DD	 $LN586@bp
  0420c	00 00 00 00	 DD	 $LN582@bp
  04210	00 00 00 00	 DD	 $LN575@bp
  04214	00 00 00 00	 DD	 $LN573@bp
  04218	00 00 00 00	 DD	 $LN569@bp
  0421c	00 00 00 00	 DD	 $LN565@bp
  04220	00 00 00 00	 DD	 $LN561@bp
  04224	00 00 00 00	 DD	 $LN557@bp
  04228	00 00 00 00	 DD	 $LN553@bp
  0422c	00 00 00 00	 DD	 $LN549@bp
  04230	00 00 00 00	 DD	 $LN544@bp
  04234	00 00 00 00	 DD	 $LN539@bp
  04238	00 00 00 00	 DD	 $LN534@bp
  0423c	00 00 00 00	 DD	 $LN529@bp
  04240	00 00 00 00	 DD	 $LN524@bp
  04244	00 00 00 00	 DD	 $LN519@bp
  04248	00 00 00 00	 DD	 $LN515@bp
  0424c	00 00 00 00	 DD	 $LN505@bp
  04250	00 00 00 00	 DD	 $LN503@bp
  04254	00 00 00 00	 DD	 $LN501@bp
  04258	00 00 00 00	 DD	 $LN499@bp
  0425c	00 00 00 00	 DD	 $LN498@bp
  04260	00 00 00 00	 DD	 $LN496@bp
  04264	00 00 00 00	 DD	 $LN486@bp
  04268	00 00 00 00	 DD	 $LN481@bp
  0426c	00 00 00 00	 DD	 $LN476@bp
  04270	00 00 00 00	 DD	 $LN471@bp
  04274	00 00 00 00	 DD	 $LN459@bp
  04278	00 00 00 00	 DD	 $LN455@bp
  0427c	00 00 00 00	 DD	 $LN451@bp
  04280	00 00 00 00	 DD	 $LN442@bp
  04284	00 00 00 00	 DD	 $LN440@bp
  04288	00 00 00 00	 DD	 $LN435@bp
  0428c	00 00 00 00	 DD	 $LN433@bp
  04290	00 00 00 00	 DD	 $LN428@bp
  04294	00 00 00 00	 DD	 $LN419@bp
  04298	00 00 00 00	 DD	 $LN413@bp
  0429c	00 00 00 00	 DD	 $LN411@bp
  042a0	00 00 00 00	 DD	 $LN406@bp
  042a4	00 00 00 00	 DD	 $LN403@bp
  042a8	00 00 00 00	 DD	 $LN401@bp
  042ac	00 00 00 00	 DD	 $LN399@bp
  042b0	00 00 00 00	 DD	 $LN394@bp
  042b4	00 00 00 00	 DD	 $LN389@bp
  042b8	00 00 00 00	 DD	 $LN384@bp
  042bc	00 00 00 00	 DD	 $LN379@bp
  042c0	00 00 00 00	 DD	 $LN374@bp
  042c4	00 00 00 00	 DD	 $LN331@bp
  042c8	00 00 00 00	 DD	 $LN326@bp
  042cc	00 00 00 00	 DD	 $LN316@bp
  042d0	00 00 00 00	 DD	 $LN273@bp
  042d4	00 00 00 00	 DD	 $LN372@bp
  042d8	00 00 00 00	 DD	 $LN370@bp
  042dc	00 00 00 00	 DD	 $LN366@bp
  042e0	00 00 00 00	 DD	 $LN364@bp
  042e4	00 00 00 00	 DD	 $LN361@bp
  042e8	00 00 00 00	 DD	 $LN363@bp
  042ec	00 00 00 00	 DD	 $LN357@bp
  042f0	00 00 00 00	 DD	 $LN333@bp
  042f4	00 00 00 00	 DD	 $LN312@bp
  042f8	00 00 00 00	 DD	 $LN283@bp
  042fc	00 00 00 00	 DD	 $LN288@bp
  04300	00 00 00 00	 DD	 $LN278@bp
  04304	00 00 00 00	 DD	 $LN307@bp
  04308	00 00 00 00	 DD	 $LN298@bp
  0430c	00 00 00 00	 DD	 $LN302@bp
  04310	00 00 00 00	 DD	 $LN294@bp
  04314	00 00 00 00	 DD	 $LN292@bp
  04318	00 00 00 00	 DD	 $LN156@bp
  0431c	00 00 00 00	 DD	 $LN151@bp
  04320	00 00 00 00	 DD	 $LN149@bp
  04324	00 00 00 00	 DD	 $LN144@bp
  04328	00 00 00 00	 DD	 $LN139@bp
  0432c	00 00 00 00	 DD	 $LN137@bp
  04330	00 00 00 00	 DD	 $LN268@bp
  04334	00 00 00 00	 DD	 $LN264@bp
  04338	00 00 00 00	 DD	 $LN259@bp
  0433c	00 00 00 00	 DD	 $LN254@bp
  04340	00 00 00 00	 DD	 $LN252@bp
  04344	00 00 00 00	 DD	 $LN250@bp
  04348	00 00 00 00	 DD	 $LN245@bp
  0434c	00 00 00 00	 DD	 $LN240@bp
  04350	00 00 00 00	 DD	 $LN238@bp
  04354	00 00 00 00	 DD	 $LN233@bp
  04358	00 00 00 00	 DD	 $LN230@bp
  0435c	00 00 00 00	 DD	 $LN228@bp
  04360	00 00 00 00	 DD	 $LN203@bp
  04364	00 00 00 00	 DD	 $LN198@bp
  04368	00 00 00 00	 DD	 $LN194@bp
  0436c	00 00 00 00	 DD	 $LN220@bp
  04370	00 00 00 00	 DD	 $LN208@bp
  04374	00 00 00 00	 DD	 $LN215@bp
  04378	00 00 00 00	 DD	 $LN214@bp
  0437c	00 00 00 00	 DD	 $LN212@bp
  04380	00 00 00 00	 DD	 $LN187@bp
  04384	00 00 00 00	 DD	 $LN185@bp
  04388	00 00 00 00	 DD	 $LN181@bp
  0438c	00 00 00 00	 DD	 $LN179@bp
  04390	00 00 00 00	 DD	 $LN177@bp
  04394	00 00 00 00	 DD	 $LN172@bp
  04398	00 00 00 00	 DD	 $LN166@bp
  0439c	00 00 00 00	 DD	 $LN160@bp
  043a0	00 00 00 00	 DD	 $LN132@bp
  043a4	00 00 00 00	 DD	 $LN128@bp
  043a8	00 00 00 00	 DD	 $LN123@bp
  043ac	00 00 00 00	 DD	 $LN115@bp
  043b0	00 00 00 00	 DD	 $LN109@bp
  043b4	00 00 00 00	 DD	 $LN102@bp
  043b8	00 00 00 00	 DD	 $LN96@bp
  043bc	00 00 00 00	 DD	 $LN90@bp
  043c0	00 00 00 00	 DD	 $LN88@bp
  043c4	00 00 00 00	 DD	 $LN76@bp
  043c8	00 00 00 00	 DD	 $LN88@bp
  043cc	00 00 00 00	 DD	 $LN76@bp
  043d0	00 00 00 00	 DD	 $LN56@bp
  043d4	00 00 00 00	 DD	 $LN64@bp
  043d8	00 00 00 00	 DD	 $LN48@bp
  043dc	00 00 00 00	 DD	 $LN46@bp
  043e0	00 00 00 00	 DD	 $LN40@bp
  043e4	00 00 00 00	 DD	 $LN39@bp
  043e8	00 00 00 00	 DD	 $LN34@bp
  043ec	00 00 00 00	 DD	 $LN29@bp
  043f0	00 00 00 00	 DD	 $LN708@bp
  043f4	00 00 00 00	 DD	 $LN694@bp
  043f8	00 00 00 00	 DD	 $LN27@bp
  043fc	00 00 00 00	 DD	 $LN28@bp
  04400	00 00 00 00	 DD	 $LN23@bp
  04404	00 00 00 00	 DD	 $LN21@bp
  04408	00 00 00 00	 DD	 $LN19@bp
  0440c	00 00 00 00	 DD	 $LN17@bp
  04410	00 00 00 00	 DD	 $LN15@bp
  04414	00 00 00 00	 DD	 $LN14@bp
  04418	00 00 00 00	 DD	 $LN12@bp
  0441c	00 00 00 00	 DD	 $LN6@bp
  04420	00 00 00 00	 DD	 $LN9@bp
  04424	00 00 00 00	 DD	 $LN7@bp
  04428	00 00 00 00	 DD	 $LN5@bp
  0442c	00 00 00 00	 DD	 $LN4@bp
  04430	00 00 00 00	 DD	 $LN3@bp
_bp	ENDP
_TEXT	ENDS
PUBLIC	_interp_from
; Function compile flags: /Ogtpy
;	COMDAT _interp_from
_TEXT	SEGMENT
_P$ = 8							; size = 4
tv265 = 12						; size = 4
_g_connect$91218 = 12					; size = 4
_wam$ = 12						; size = 4
_interp_from PROC					; COMDAT

; 3270 : term interp_from(instr P, register stack wam) {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 3271 : 
; 3272 :   register term regs;
; 3273 :   register term H;
; 3274 :   register term *A;
; 3275 : 
; 3276 :   START_INTERP();

  00003	8b 74 24 14	 mov	 esi, DWORD PTR _wam$[esp+8]
  00007	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0000a	8b 6e 58	 mov	 ebp, DWORD PTR [esi+88]
  0000d	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00010	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00013	57		 push	 edi
  00014	8d 58 20	 lea	 ebx, DWORD PTR [eax+32]
  00017	05 20 1c 00 00	 add	 eax, 7200		; 00001c20H
  0001c	68 ff 00 00 00	 push	 255			; 000000ffH
  00021	50		 push	 eax
  00022	8d bb fc 1f 00
	00		 lea	 edi, DWORD PTR [ebx+8188]
  00028	89 44 24 20	 mov	 DWORD PTR _g_connect$91218[esp+20], eax
  0002c	e8 00 00 00 00	 call	 _init_var_array
  00031	8b 4c 24 20	 mov	 ecx, DWORD PTR _g_connect$91218[esp+20]
  00035	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _engine_unique_id
  00040	89 00		 mov	 DWORD PTR [eax], eax
  00042	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00049	83 c8 01	 or	 eax, 1
  0004c	41		 inc	 ecx
  0004d	50		 push	 eax
  0004e	89 0d 00 00 00
	00		 mov	 DWORD PTR _engine_unique_id, ecx
  00054	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  00057	6a 07		 push	 7
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _set_engine_prop
  0005f	89 3f		 mov	 DWORD PTR [edi], edi
  00061	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00064	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR _g+100
  0006a	8b cb		 mov	 ecx, ebx
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	83 c7 04	 add	 edi, 4
  00072	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  00075	8d 45 08	 lea	 eax, DWORD PTR [ebp+8]
  00078	2b cd		 sub	 ecx, ebp
  0007a	c7 44 24 18 02
	00 00 00	 mov	 DWORD PTR tv265[esp+12], 2
$LL3@interp_fro:
  00082	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00085	89 10		 mov	 DWORD PTR [eax], edx
  00087	83 e8 04	 sub	 eax, 4
  0008a	ff 4c 24 18	 dec	 DWORD PTR tv265[esp+12]
  0008e	75 f2		 jne	 SHORT $LL3@interp_fro

; 3277 :   return bp(regs, H, P, A, wam); /* ret H to become exit code 0 */

  00090	8b 54 24 14	 mov	 edx, DWORD PTR _P$[esp+12]
  00094	83 c5 14	 add	 ebp, 20			; 00000014H
  00097	56		 push	 esi
  00098	55		 push	 ebp
  00099	89 7d f8	 mov	 DWORD PTR [ebp-8], edi
  0009c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0009f	52		 push	 edx
  000a0	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  000a3	8b 0d 84 01 00
	00		 mov	 ecx, DWORD PTR _g+388
  000a9	57		 push	 edi
  000aa	53		 push	 ebx
  000ab	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  000ae	e8 00 00 00 00	 call	 _bp
  000b3	83 c4 14	 add	 esp, 20			; 00000014H
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5d		 pop	 ebp
  000b9	5b		 pop	 ebx

; 3278 : }

  000ba	c3		 ret	 0
_interp_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@		; `string'
PUBLIC	??_C@_0CH@LLJIOCAK@unexpected?5engine?5error?5in?5inter@ ; `string'
PUBLIC	_entry$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_interp
EXTRN	_sprintf:PROC
;	COMDAT ??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@
CONST	SEGMENT
??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@ DB '%s: %ld', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LLJIOCAK@unexpected?5engine?5error?5in?5inter@
CONST	SEGMENT
??_C@_0CH@LLJIOCAK@unexpected?5engine?5error?5in?5inter@ DB 'unexpected e'
	DB	'ngine error in interp(wam)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _interp
_TEXT	SEGMENT
tv190 = -92						; size = 4
_g_connect$92378 = -92					; size = 4
_entry$GSCopy$ = -88					; size = 4
_mes$91317 = -84					; size = 80
__$ArrayPad$ = -4					; size = 4
_wam$ = 8						; size = 4
_entry$ = 12						; size = 4
_interp	PROC						; COMDAT

; 3280 : bp_long interp(register stack wam, instr entry) {

  00000	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 58	 mov	 DWORD PTR __$ArrayPad$[esp+92], eax
  0000e	8b 44 24 64	 mov	 eax, DWORD PTR _entry$[esp+88]
  00012	53		 push	 ebx
  00013	55		 push	 ebp
  00014	56		 push	 esi
  00015	8b 74 24 6c	 mov	 esi, DWORD PTR _wam$[esp+100]
  00019	57		 push	 edi

; 3285 :     H = interp_from(entry, wam); /* ignoring returned H */

  0001a	89 44 24 14	 mov	 DWORD PTR _entry$GSCopy$[esp+108], eax
  0001e	8b ff		 npad	 2
$LL10@interp:

; 3281 :   register term H;
; 3282 :   for (;;) {
; 3283 :     g.stopper = 0;
; 3284 :     SET_ENGINE_ERROR(ENGINE_OK);

  00020	c7 05 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+444, 0
  0002a	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  0002d	c7 41 18 01 00
	00 00		 mov	 DWORD PTR [ecx+24], 1

; 3285 :     H = interp_from(entry, wam); /* ignoring returned H */

  00034	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00037	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0003a	8b 6e 58	 mov	 ebp, DWORD PTR [esi+88]
  0003d	8d 58 20	 lea	 ebx, DWORD PTR [eax+32]
  00040	05 20 1c 00 00	 add	 eax, 7200		; 00001c20H
  00045	68 ff 00 00 00	 push	 255			; 000000ffH
  0004a	50		 push	 eax
  0004b	89 56 2c	 mov	 DWORD PTR [esi+44], edx
  0004e	8d bb fc 1f 00
	00		 lea	 edi, DWORD PTR [ebx+8188]
  00054	89 44 24 18	 mov	 DWORD PTR _g_connect$92378[esp+116], eax
  00058	e8 00 00 00 00	 call	 _init_var_array
  0005d	8b 4c 24 18	 mov	 ecx, DWORD PTR _g_connect$92378[esp+116]
  00061	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00064	89 01		 mov	 DWORD PTR [ecx], eax
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _engine_unique_id
  0006c	89 00		 mov	 DWORD PTR [eax], eax
  0006e	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00075	83 c8 01	 or	 eax, 1
  00078	50		 push	 eax
  00079	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0007c	41		 inc	 ecx
  0007d	6a 07		 push	 7
  0007f	50		 push	 eax
  00080	89 0d 00 00 00
	00		 mov	 DWORD PTR _engine_unique_id, ecx
  00086	e8 00 00 00 00	 call	 _set_engine_prop
  0008b	89 3f		 mov	 DWORD PTR [edi], edi
  0008d	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00090	a1 64 00 00 00	 mov	 eax, DWORD PTR _g+100
  00095	8b cb		 mov	 ecx, ebx
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	83 c7 04	 add	 edi, 4
  0009d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  000a0	8d 45 08	 lea	 eax, DWORD PTR [ebp+8]
  000a3	2b cd		 sub	 ecx, ebp
  000a5	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR tv190[esp+108], 2
  000ad	8d 49 00	 npad	 3
$LL15@interp:
  000b0	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  000b3	89 10		 mov	 DWORD PTR [eax], edx
  000b5	83 e8 04	 sub	 eax, 4
  000b8	ff 4c 24 10	 dec	 DWORD PTR tv190[esp+108]
  000bc	75 f2		 jne	 SHORT $LL15@interp
  000be	8b 54 24 14	 mov	 edx, DWORD PTR _entry$GSCopy$[esp+108]
  000c2	83 c5 14	 add	 ebp, 20			; 00000014H
  000c5	56		 push	 esi
  000c6	55		 push	 ebp
  000c7	89 7d f8	 mov	 DWORD PTR [ebp-8], edi
  000ca	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000cd	52		 push	 edx
  000ce	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  000d1	8b 0d 84 01 00
	00		 mov	 ecx, DWORD PTR _g+388
  000d7	57		 push	 edi
  000d8	53		 push	 ebx
  000d9	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  000dc	e8 00 00 00 00	 call	 _bp

; 3286 :     /*fprintf(STD_err,"$$ <<ENGINE_ERROR: %d g.stopper=%d,H=%ld\n",
; 3287 :      GET_ENGINE_ERROR(),g.stopper,H);
; 3288 :      */
; 3289 :     switch (GET_ENGINE_ERROR()) {

  000e1	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  000e4	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000e7	c1 f8 02	 sar	 eax, 2
  000ea	83 c4 14	 add	 esp, 20			; 00000014H
  000ed	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  000f0	74 42		 je	 SHORT $LN3@interp
  000f2	83 f8 ff	 cmp	 eax, -1
  000f5	74 2e		 je	 SHORT $LN6@interp
  000f7	85 c0		 test	 eax, eax
  000f9	74 5c		 je	 SHORT $LN4@interp

; 3302 :       break;
; 3303 : 
; 3304 :       default: {
; 3305 :         char mes[80];
; 3306 :         sprintf(mes,"%s: %ld",
; 3307 :             "unexpected engine error in interp(wam)",
; 3308 :             GET_ENGINE_ERROR()
; 3309 :         );

  000fb	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000fe	c1 f8 02	 sar	 eax, 2
  00101	50		 push	 eax
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LLJIOCAK@unexpected?5engine?5error?5in?5inter@
  00107	8d 4c 24 20	 lea	 ecx, DWORD PTR _mes$91317[esp+116]
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_07EFFLEODG@?$CFs?3?5?$CFld?$AA@
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _sprintf

; 3310 :         warnmes(mes);

  00116	8d 54 24 28	 lea	 edx, DWORD PTR _mes$91317[esp+124]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _warnmes
  00120	83 c4 14	 add	 esp, 20			; 00000014H
  00123	eb 23		 jmp	 SHORT $LN7@interp
$LN6@interp:

; 3290 :       case ENGINE_ABORT:
; 3291 :         hbak(BBOARDTIME);

  00125	6a 03		 push	 3
  00127	e8 00 00 00 00	 call	 _hbak
  0012c	83 c4 04	 add	 esp, 4

; 3292 :         if (0 == g.stopper) continue;
; 3293 :       break;

  0012f	e9 ec fe ff ff	 jmp	 $LL10@interp
$LN3@interp:

; 3297 :       break;
; 3298 : 
; 3299 :       case ENGINE_FORCE_HALT:
; 3300 :         g.stopper = 0;
; 3301 :         bp_halt(0);

  00134	6a 00		 push	 0
  00136	c7 05 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+444, 0
  00140	e8 00 00 00 00	 call	 _bp_halt
  00145	83 c4 04	 add	 esp, 4
$LN7@interp:

; 3311 :       }
; 3312 :     }
; 3313 :     if (0 == g.stopper) break;

  00148	83 3d bc 01 00
	00 00		 cmp	 DWORD PTR _g+444, 0
  0014f	0f 85 cb fe ff
	ff		 jne	 $LL10@interp
  00155	eb 0a		 jmp	 SHORT $LN24@interp
$LN4@interp:

; 3294 : 
; 3295 :       case ENGINE_OK:
; 3296 :         g.stopper = 0;

  00157	c7 05 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+444, 0
$LN24@interp:

; 3314 :   }
; 3315 :   /* fprintf(STD_err,"$$ >>EXITING interp: %d\n",GET_ENGINE_ERROR());*/
; 3316 :   return GET_ENGINE_ERROR();

  00161	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]

; 3317 : }

  00164	8b 4c 24 68	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+108]
  00168	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5d		 pop	 ebp
  0016e	5b		 pop	 ebx
  0016f	33 cc		 xor	 ecx, esp
  00171	c1 f8 02	 sar	 eax, 2
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	83 c4 5c	 add	 esp, 92			; 0000005cH
  0017c	c3		 ret	 0
_interp	ENDP
_TEXT	ENDS
PUBLIC	_bp_prolog_call
; Function compile flags: /Ogtpy
;	COMDAT _bp_prolog_call
_TEXT	SEGMENT
_goal$ = 8						; size = 4
_regs$ = 12						; size = 4
_H$ = 16						; size = 4
_P$ = 20						; size = 4
_A$ = 24						; size = 4
_wam$ = 28						; size = 4
_bp_prolog_call PROC					; COMDAT

; 584  :   PREP_CALL(goal);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _goal$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	8b 74 24 14	 mov	 esi, DWORD PTR _regs$[esp+8]
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR _g+100
  00014	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00017	8b 4c 24 20	 mov	 ecx, DWORD PTR _A$[esp+8]
  0001b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _g
  00021	8b d6		 mov	 edx, esi
  00023	57		 push	 edi
  00024	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00027	2b d1		 sub	 edx, ecx
  00029	bf 02 00 00 00	 mov	 edi, 2
  0002e	8b ff		 npad	 2
$LL3@bp_prolog_:
  00030	8b 2c 02	 mov	 ebp, DWORD PTR [edx+eax]
  00033	89 28		 mov	 DWORD PTR [eax], ebp
  00035	83 e8 04	 sub	 eax, 4
  00038	4f		 dec	 edi
  00039	75 f5		 jne	 SHORT $LL3@bp_prolog_
  0003b	8b 54 24 28	 mov	 edx, DWORD PTR _wam$[esp+12]
  0003f	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+12]
  00043	83 c1 14	 add	 ecx, 20			; 00000014H

; 585  :   return bp(regs, H, P, A, wam);

  00046	52		 push	 edx
  00047	51		 push	 ecx
  00048	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  0004b	8b 7a 2c	 mov	 edi, DWORD PTR [edx+44]
  0004e	53		 push	 ebx
  0004f	89 79 fc	 mov	 DWORD PTR [ecx-4], edi
  00052	8b 3d 84 01 00
	00		 mov	 edi, DWORD PTR _g+388
  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	89 39		 mov	 DWORD PTR [ecx], edi
  0005c	e8 00 00 00 00	 call	 _bp
  00061	83 c4 14	 add	 esp, 20			; 00000014H
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5d		 pop	 ebp
  00067	5b		 pop	 ebx

; 586  : }

  00068	c3		 ret	 0
_bp_prolog_call ENDP
_TEXT	ENDS
END
