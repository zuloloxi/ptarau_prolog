; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\load.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_instr_len:DWORD
_DATA	ENDS
PUBLIC	_init_instr_len
EXTRN	_make_byte_array:PROC
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\load.c
;	COMDAT _init_instr_len
_TEXT	SEGMENT
_init_instr_len PROC					; COMDAT

; 27   : 
; 28   :     instr_len=make_byte_array(MAXOP);

  00000	68 00 01 00 00	 push	 256			; 00000100H
  00005	e8 00 00 00 00	 call	 _make_byte_array
  0000a	83 c4 04	 add	 esp, 4
  0000d	a3 00 00 00 00	 mov	 DWORD PTR _instr_len, eax

; 29   : 
; 30   :     for(i=0; i<MAXOP; i++) instr_len[i]=1;

  00012	33 c0		 xor	 eax, eax
$LN3@init_instr:
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0001a	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
  0001e	40		 inc	 eax
  0001f	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00024	7c ee		 jl	 SHORT $LN3@init_instr

; 31   : 
; 32   :     instr_len[BEGIN_C_CHUNK]        =2;

  00026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0002c	b0 02		 mov	 al, 2
  0002e	88 42 3f	 mov	 BYTE PTR [edx+63], al

; 33   : 
; 34   :     instr_len[GET_STRUCTURE]        =2;

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00037	88 41 08	 mov	 BYTE PTR [ecx+8], al

; 35   :     instr_len[PUT_STRUCTURE]        =2;

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00040	88 42 0a	 mov	 BYTE PTR [edx+10], al

; 36   :     instr_len[PUSH_STRUCTURE]       =2;

  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00049	88 41 33	 mov	 BYTE PTR [ecx+51], al

; 37   : 
; 38   :     instr_len[UNIFY_CONSTANT]       =2;

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00052	88 42 05	 mov	 BYTE PTR [edx+5], al

; 39   : 
; 40   :     instr_len[WRITE_CONSTANT]       =2;

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0005b	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 41   : 
; 42   :     instr_len[GET_CONSTANT]          =2;

  0005e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00064	88 42 07	 mov	 BYTE PTR [edx+7], al

; 43   :     instr_len[PUT_CONSTANT]          =2;

  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0006d	88 41 09	 mov	 BYTE PTR [ecx+9], al

; 44   :     instr_len[LOAD_CONSTANT]        =2;

  00070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00076	88 42 1c	 mov	 BYTE PTR [edx+28], al

; 45   : 
; 46   :     instr_len[EXECUTE]               =2;

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0007f	88 41 11	 mov	 BYTE PTR [ecx+17], al

; 47   :     instr_len[APPLY]                 =2;

  00082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00088	88 42 41	 mov	 BYTE PTR [edx+65], al

; 48   : 
; 49   :     instr_len[PROCEED]               =2;

  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00091	88 41 12	 mov	 BYTE PTR [ecx+18], al

; 50   :     instr_len[END]                  =2;

  00094	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0009a	88 02		 mov	 BYTE PTR [edx], al

; 51   : 
; 52   :     instr_len[TRY_ME_ELSE]          =2;

  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000a2	88 41 13	 mov	 BYTE PTR [ecx+19], al

; 53   :     instr_len[RETRY_ME_ELSE]        =2;

  000a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  000ab	88 42 14	 mov	 BYTE PTR [edx+20], al

; 54   :     instr_len[TRUST_ME_ELSE]        =2;

  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000b4	88 41 15	 mov	 BYTE PTR [ecx+21], al

; 55   :     instr_len[TRY_ME_ONLY]          =2;

  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  000bd	88 42 16	 mov	 BYTE PTR [edx+22], al

; 56   : 
; 57   :     instr_len[SWITCH]               =2;

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000c6	88 41 19	 mov	 BYTE PTR [ecx+25], al

; 58   :     instr_len[JUMP_IF]              =2;

  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  000cf	88 42 1b	 mov	 BYTE PTR [edx+27], al

; 59   :     instr_len[NONDET]               =2;

  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000d8	88 41 17	 mov	 BYTE PTR [ecx+23], al

; 60   : 
; 61   : #if JUMP_COMPRESS
; 62   :     instr_len[EXEC_TRY]             =2;

  000db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  000e1	88 42 31	 mov	 BYTE PTR [edx+49], al

; 63   :     instr_len[EXEC_SWITCH]          =2;

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000ea	88 41 18	 mov	 BYTE PTR [ecx+24], al

; 64   :     instr_len[EXEC_JUMP_IF]         =2;

  000ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  000f3	88 42 1a	 mov	 BYTE PTR [edx+26], al

; 65   : #endif
; 66   : 
; 67   : #if STRUCT_COMPRESS
; 68   :     instr_len[GET_UNIFY_VAR_VAR]    =2;

  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  000fc	88 41 1e	 mov	 BYTE PTR [ecx+30], al

; 69   :     instr_len[GET_UNIFY_VAL_VAL]    =2;

  000ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00105	88 42 22	 mov	 BYTE PTR [edx+34], al

; 70   :     instr_len[GET_UNIFY_VAR_VAL]    =2;

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0010e	88 41 26	 mov	 BYTE PTR [ecx+38], al

; 71   :     instr_len[GET_UNIFY_VAL_VAR]    =2;

  00111	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00117	88 42 2a	 mov	 BYTE PTR [edx+42], al

; 72   : 
; 73   :     instr_len[PUT_WRITE_VAR_VAR]    =2;

  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00120	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 74   :     instr_len[PUT_WRITE_VAL_VAL]    =2;

  00123	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00129	88 42 24	 mov	 BYTE PTR [edx+36], al

; 75   :     instr_len[PUT_WRITE_VAR_VAL]    =2;

  0012c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00132	88 41 28	 mov	 BYTE PTR [ecx+40], al

; 76   :     instr_len[PUT_WRITE_VAL_VAR]    =2;

  00135	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0013b	88 42 2c	 mov	 BYTE PTR [edx+44], al

; 77   : 
; 78   :     instr_len[PUSH_VAR_VAR]    =2;

  0013e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00144	88 41 35	 mov	 BYTE PTR [ecx+53], al

; 79   :     instr_len[CONSTANT_VAR_VAR]    =2;

  00147	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0014d	88 42 36	 mov	 BYTE PTR [edx+54], al

; 80   :     instr_len[PUSH_VAL_VAR]    =2;

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00156	88 41 37	 mov	 BYTE PTR [ecx+55], al

; 81   :     instr_len[CONSTANT_VAL_VAR]    =2;

  00159	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0015f	88 42 38	 mov	 BYTE PTR [edx+56], al

; 82   : 
; 83   :     instr_len[PUSH_VAL_VAL]    =2;

  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00168	88 41 39	 mov	 BYTE PTR [ecx+57], al

; 84   :     instr_len[CONSTANT_VAL_VAL]    =2;

  0016b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00171	88 42 3a	 mov	 BYTE PTR [edx+58], al

; 85   :     instr_len[PUSH_VAR_VAL]    =2;

  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  0017a	88 41 3b	 mov	 BYTE PTR [ecx+59], al

; 86   :     instr_len[CONSTANT_VAR_VAL]    =2;

  0017d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00183	88 42 3c	 mov	 BYTE PTR [edx+60], al

; 87   : #endif
; 88   : 
; 89   : }

  00186	c3		 ret	 0
_init_instr_len ENDP
_TEXT	ENDS
EXTRN	_isdigit:PROC
; Function compile flags: /Ogtpy
;	COMDAT _get_one_int
_TEXT	SEGMENT
_neg$ = 8						; size = 4
_name$ = 8						; size = 4
_ip$ = 12						; size = 4
_get_one_int PROC					; COMDAT

; 92   : { register bp_long val=0;

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _name$[esp+4]

; 93   :   register char c=*name;

  00006	8a 5d 00	 mov	 bl, BYTE PTR [ebp]

; 94   :   no neg;
; 95   :   if((neg=('-'==c))) c= *++name;

  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi
  0000c	33 f6		 xor	 esi, esi
  0000e	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00011	0f 94 c0	 sete	 al
  00014	89 44 24 10	 mov	 DWORD PTR _neg$[esp+8], eax
  00018	85 c0		 test	 eax, eax
  0001a	74 04		 je	 SHORT $LN5@get_one_in
  0001c	8a 5d 01	 mov	 bl, BYTE PTR [ebp+1]
  0001f	45		 inc	 ebp
$LN5@get_one_in:

; 96   :   if(!c) return 0;

  00020	84 db		 test	 bl, bl
  00022	75 06		 jne	 SHORT $LN4@get_one_in
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	33 c0		 xor	 eax, eax
  00028	5b		 pop	 ebx

; 102  : }

  00029	c3		 ret	 0
$LN4@get_one_in:
  0002a	57		 push	 edi

; 97   :   for( ; isdigit(c); c= *++name)

  0002b	0f be fb	 movsx	 edi, bl
  0002e	57		 push	 edi
  0002f	e8 00 00 00 00	 call	 _isdigit
  00034	83 c4 04	 add	 esp, 4
  00037	85 c0		 test	 eax, eax
  00039	74 20		 je	 SHORT $LN1@get_one_in
  0003b	eb 03 8d 49 00	 npad	 5
$LL3@get_one_in:
  00040	8a 5d 01	 mov	 bl, BYTE PTR [ebp+1]

; 98   :     val=(val<<3)+(val<<1)+(c-'0'); /* efficient val*10 */

  00043	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00046	45		 inc	 ebp
  00047	8d 74 47 d0	 lea	 esi, DWORD PTR [edi+eax*2-48]
  0004b	0f be fb	 movsx	 edi, bl
  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 _isdigit
  00054	83 c4 04	 add	 esp, 4
  00057	85 c0		 test	 eax, eax
  00059	75 e5		 jne	 SHORT $LL3@get_one_in
$LN1@get_one_in:

; 99   :   *ip=(neg)?(-val):val;

  0005b	83 7c 24 14 00	 cmp	 DWORD PTR _neg$[esp+12], 0
  00060	5f		 pop	 edi
  00061	74 02		 je	 SHORT $LN8@get_one_in
  00063	f7 de		 neg	 esi
$LN8@get_one_in:
  00065	8b 4c 24 14	 mov	 ecx, DWORD PTR _ip$[esp+8]
  00069	89 31		 mov	 DWORD PTR [ecx], esi
  0006b	5e		 pop	 esi

; 100  :   /* if(c && neg) fprintf(STD_err,"NEG: %ld\n",*ip); */
; 101  :   return !c;

  0006c	33 c0		 xor	 eax, eax
  0006e	84 db		 test	 bl, bl
  00070	5d		 pop	 ebp
  00071	0f 94 c0	 sete	 al
  00074	5b		 pop	 ebx

; 102  : }

  00075	c3		 ret	 0
_get_one_int ENDP
_TEXT	ENDS
PUBLIC	_input_fun
EXTRN	_new_func:PROC
; Function compile flags: /Ogtpy
;	COMDAT _input_fun
_TEXT	SEGMENT
_val$ = -4						; size = 4
_name$ = 8						; size = 4
_arity$ = 12						; size = 4
_input_fun PROC						; COMDAT

; 106  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 107  :   bp_long val; cell f;
; 108  :   if(get_one_int(name,&val))

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _name$[esp+4]
  00006	8d 44 24 04	 lea	 eax, DWORD PTR _val$[esp+8]
  0000a	50		 push	 eax
  0000b	56		 push	 esi
  0000c	e8 00 00 00 00	 call	 _get_one_int
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 0e		 je	 SHORT $LN2@input_fun

; 109  :      f=INPUT_INT(val);

  00018	8b 44 24 04	 mov	 eax, DWORD PTR _val$[esp+8]
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	83 c8 01	 or	 eax, 1
  00023	5e		 pop	 esi

; 112  :   return f;
; 113  : }

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN2@input_fun:

; 110  :   else
; 111  :     f=new_func(name,arity);

  00026	8b 4c 24 10	 mov	 ecx, DWORD PTR _arity$[esp+4]
  0002a	51		 push	 ecx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 _new_func
  00031	83 c4 08	 add	 esp, 8
  00034	5e		 pop	 esi

; 112  :   return f;
; 113  : }

  00035	59		 pop	 ecx
  00036	c3		 ret	 0
_input_fun ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _link_switch
_TEXT	SEGMENT
_doit$ = 8						; size = 4
_link_switch PROC					; COMDAT
; _p$ = edx

; 122  : {   instr label=GETLABEL(p+2);

  00000	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00003	56		 push	 esi

; 123  :     instr jlabel=label;
; 124  :     if(label && TRUST_ME_ELSE==GETOP(label) &&
; 125  :       MAGIC==GETOP(label+2))

  00004	85 c0		 test	 eax, eax
  00006	74 37		 je	 SHORT $LN2@link_switc
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00010	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00013	75 2a		 jne	 SHORT $LN2@link_switc
  00015	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00018	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001b	81 e6 ff 03 00
	00		 and	 esi, 1023		; 000003ffH
  00021	83 fe 1e	 cmp	 esi, 30			; 0000001eH
  00024	75 19		 jne	 SHORT $LN2@link_switc

; 126  :       {
; 127  :         if(doit)

  00026	83 7c 24 08 00	 cmp	 DWORD PTR _doit$[esp], 0
  0002b	74 14		 je	 SHORT $LN3@link_switc

; 128  :           {
; 129  :             SETOP(p,JUMP_IF); label+=2; SETLABEL(p,label);

  0002d	8b 32		 mov	 esi, DWORD PTR [edx]
  0002f	81 e6 1b fc ff
	ff		 and	 esi, -997		; fffffc1bH
  00035	83 ce 1b	 or	 esi, 27			; 0000001bH
  00038	89 32		 mov	 DWORD PTR [edx], esi
  0003a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003d	5e		 pop	 esi

; 134  : }

  0003e	c3		 ret	 0
$LN2@link_switc:

; 130  :           }
; 131  :         return jlabel;
; 132  :       }
; 133  :     return NULL;

  0003f	33 c0		 xor	 eax, eax
$LN3@link_switc:
  00041	5e		 pop	 esi

; 134  : }

  00042	c3		 ret	 0
_link_switch ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OMFAIDPG@call?$AA@			; `string'
PUBLIC	_is_call
;	COMDAT ??_C@_04OMFAIDPG@call?$AA@
CONST	SEGMENT
??_C@_04OMFAIDPG@call?$AA@ DB 'call', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _is_call
_TEXT	SEGMENT
_fun$ = 8						; size = 4
_is_call PROC						; COMDAT

; 139  : {

  00000	56		 push	 esi

; 140  :   return GETARITY(fun)>(MAX_FAST_CALL_ARGS+1)
; 141  :       && PUTARITY(fun,0)==new_func("call",0);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _fun$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0000c	3d 00 00 00 07	 cmp	 eax, 117440512		; 07000000H
  00011	76 20		 jbe	 SHORT $LN3@is_call
  00013	6a 00		 push	 0
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_04OMFAIDPG@call?$AA@
  0001a	e8 00 00 00 00	 call	 _new_func
  0001f	81 e6 ff ff ff
	00		 and	 esi, 16777215		; 00ffffffH
  00025	83 c4 08	 add	 esp, 8
  00028	3b f0		 cmp	 esi, eax
  0002a	75 07		 jne	 SHORT $LN3@is_call
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	5e		 pop	 esi

; 142  : }

  00032	c3		 ret	 0
$LN3@is_call:

; 140  :   return GETARITY(fun)>(MAX_FAST_CALL_ARGS+1)
; 141  :       && PUTARITY(fun,0)==new_func("call",0);

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 142  : }

  00036	c3		 ret	 0
_is_call ENDP
_TEXT	ENDS
PUBLIC	_is_dynamic
EXTRN	_hget:PROC
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _is_dynamic
_TEXT	SEGMENT
_f_plus$ = 8						; size = 4
_is_dynamic PROC					; COMDAT

; 145  : { cell f=PUTARITY(f_plus, GETARITY(f_plus)-1);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _f_plus$[esp-4]
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax
  00007	c1 ee 18	 shr	 esi, 24			; 00000018H
  0000a	4e		 dec	 esi
  0000b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00010	c1 e6 18	 shl	 esi, 24			; 00000018H
  00013	0b f0		 or	 esi, eax

; 146  :   cell v;
; 147  :   no ok=
; 148  :   ((v=hget(g.current_db,f)) && g.empty!=v)
; 149  :   /* || NONVAR(hget(g.assumed,f)) #RISKY */
; 150  :   || is_call(f)
; 151  :   || hget(g.bp_virtual,f);

  00015	a1 bc 00 00 00	 mov	 eax, DWORD PTR _g+188
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _hget
  00021	83 c4 08	 add	 esp, 8
  00024	85 c0		 test	 eax, eax
  00026	74 08		 je	 SHORT $LN3@is_dynamic
  00028	39 05 38 00 00
	00		 cmp	 DWORD PTR _g+56, eax
  0002e	75 40		 jne	 SHORT $LN4@is_dynamic
$LN3@is_dynamic:
  00030	8b ce		 mov	 ecx, esi
  00032	81 e1 00 00 00
	ff		 and	 ecx, -16777216		; ff000000H
  00038	81 f9 00 00 00
	07		 cmp	 ecx, 117440512		; 07000000H
  0003e	76 1b		 jbe	 SHORT $LN8@is_dynamic
  00040	6a 00		 push	 0
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_04OMFAIDPG@call?$AA@
  00047	e8 00 00 00 00	 call	 _new_func
  0004c	8b d6		 mov	 edx, esi
  0004e	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00054	83 c4 08	 add	 esp, 8
  00057	3b d0		 cmp	 edx, eax
  00059	74 15		 je	 SHORT $LN4@is_dynamic
$LN8@is_dynamic:
  0005b	a1 dc 00 00 00	 mov	 eax, DWORD PTR _g+220
  00060	56		 push	 esi
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _hget
  00067	83 c4 08	 add	 esp, 8
  0006a	85 c0		 test	 eax, eax
  0006c	75 02		 jne	 SHORT $LN4@is_dynamic
  0006e	5e		 pop	 esi

; 152  : #if TRACE>3
; 153  :   if(ok) fprintf(STD_err,"!!! dynamic %s/%ld\n",NAME(f),GETARITY(f));
; 154  : #endif
; 155  :   return ok;
; 156  : }

  0006f	c3		 ret	 0
$LN4@is_dynamic:

; 146  :   cell v;
; 147  :   no ok=
; 148  :   ((v=hget(g.current_db,f)) && g.empty!=v)
; 149  :   /* || NONVAR(hget(g.assumed,f)) #RISKY */
; 150  :   || is_call(f)
; 151  :   || hget(g.bp_virtual,f);

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	5e		 pop	 esi

; 152  : #if TRACE>3
; 153  :   if(ok) fprintf(STD_err,"!!! dynamic %s/%ld\n",NAME(f),GETARITY(f));
; 154  : #endif
; 155  :   return ok;
; 156  : }

  00076	c3		 ret	 0
_is_dynamic ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@KJFIEHGO@has?5no?5compiled?5definition?3?5left@ ; `string'
PUBLIC	??_C@_0BP@JPFOKBMD@?$CBinC?3?5unexpected?5BEGIN_C_CHUNK?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0N@KGDDEECA@opcode?$DP?$DN?$CFld?6?$AA@	; `string'
PUBLIC	??_C@_0BI@KEIGGJLA@unexpected?5integer?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_07MNNBFCEI@?$CFs?1?$CFld?6?$AA@		; `string'
PUBLIC	??_C@_0BG@INJFAOFD@expected?5END_OF_CHUNK?$AA@	; `string'
EXTRN	_hset:PROC
EXTRN	_hdef:PROC
EXTRN	_max:BYTE
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_atomtable:DWORD
EXTRN	_local_error:PROC
;	COMDAT ??_C@_0CK@KJFIEHGO@has?5no?5compiled?5definition?3?5left@
CONST	SEGMENT
??_C@_0CK@KJFIEHGO@has?5no?5compiled?5definition?3?5left@ DB 'has no comp'
	DB	'iled definition: left unlinked', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JPFOKBMD@?$CBinC?3?5unexpected?5BEGIN_C_CHUNK?$AA@
CONST	SEGMENT
??_C@_0BP@JPFOKBMD@?$CBinC?3?5unexpected?5BEGIN_C_CHUNK?$AA@ DB '!inC: un'
	DB	'expected BEGIN_C_CHUNK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGDDEECA@opcode?$DP?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0N@KGDDEECA@opcode?$DP?$DN?$CFld?6?$AA@ DB 'opcode?=%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KEIGGJLA@unexpected?5integer?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BI@KEIGGJLA@unexpected?5integer?$DN?$CFld?6?$AA@ DB 'unexpected in'
	DB	'teger=%ld', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNNBFCEI@?$CFs?1?$CFld?6?$AA@
CONST	SEGMENT
??_C@_07MNNBFCEI@?$CFs?1?$CFld?6?$AA@ DB '%s/%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@INJFAOFD@expected?5END_OF_CHUNK?$AA@
CONST	SEGMENT
??_C@_0BG@INJFAOFD@expected?5END_OF_CHUNK?$AA@ DB 'expected END_OF_CHUNK', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _link_code
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_link_code PROC						; COMDAT
; _p$ = eax

; 160  : { register instr label; register cell f; register bp_long l=1;

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 161  :   for(; p<(instr)ctop; p+=l)

  00003	3b 35 7c 01 00
	00		 cmp	 esi, DWORD PTR _g+380
  00009	0f 83 73 04 00
	00		 jae	 $LN65@link_code
  0000f	53		 push	 ebx
  00010	55		 push	 ebp
  00011	57		 push	 edi
$LL46@link_code:

; 162  :     { l=INSTR_LEN(p);

  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  0001a	8b c8		 mov	 ecx, eax
  0001c	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00022	0f b6 1c 11	 movzx	 ebx, BYTE PTR [ecx+edx]

; 163  :       switch(GETOP(p))

  00026	83 c1 ef	 add	 ecx, -17		; ffffffefH
  00029	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  0002c	0f 87 35 04 00
	00		 ja	 $LN2@link_code
  00032	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN63@link_code[ecx]
  00039	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN68@link_code[ecx*4]
$LN41@link_code:

; 164  :         {
; 165  : 
; 166  :           case BEGIN_C_CHUNK:
; 167  :           if(g.inC)

  00040	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  00047	0f 84 00 01 00
	00		 je	 $LN40@link_code

; 168  :            {
; 169  :             if(LOADTIME==g.timestamp && g.self) /* i.e. only for C-code */

  0004d	80 3d 70 01 00
	00 01		 cmp	 BYTE PTR _g+368, 1
  00054	0f 85 16 04 00
	00		 jne	 $LN45@link_code
  0005a	83 3d f0 00 00
	00 00		 cmp	 DWORD PTR _g+240, 0
  00061	0f 84 09 04 00
	00		 je	 $LN45@link_code

; 170  :              {
; 171  :                 while( END_C_CHUNK!=GETOP(p+l) && (IDENTIFIER(p[l]))
; 172  :                      ) l++;

  00067	8b 04 9e	 mov	 eax, DWORD PTR [esi+ebx*4]
  0006a	8b d0		 mov	 edx, eax
  0006c	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00072	83 fa 40	 cmp	 edx, 64			; 00000040H
  00075	74 19		 je	 SHORT $LN37@link_code
$LL38@link_code:
  00077	83 e0 03	 and	 eax, 3
  0007a	3c 03		 cmp	 al, 3
  0007c	75 12		 jne	 SHORT $LN37@link_code
  0007e	8b 44 9e 04	 mov	 eax, DWORD PTR [esi+ebx*4+4]
  00082	43		 inc	 ebx
  00083	8b c8		 mov	 ecx, eax
  00085	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0008b	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0008e	75 e7		 jne	 SHORT $LL38@link_code
$LN37@link_code:

; 173  :               if(END_C_CHUNK!=GETOP(p+l))

  00090	8b 14 9e	 mov	 edx, DWORD PTR [esi+ebx*4]
  00093	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]
  00096	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0009c	83 fa 40	 cmp	 edx, 64			; 00000040H
  0009f	0f 84 cb 03 00
	00		 je	 $LN45@link_code

; 174  :               {  int i;
; 175  :                  (void)LOCAL_ERR(T2C(p+l),"expected END_OF_CHUNK");

  000a5	8b 4c 24 14	 mov	 ecx, DWORD PTR _wam$[esp+12]
  000a9	51		 push	 ecx
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@INJFAOFD@expected?5END_OF_CHUNK?$AA@
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _local_error

; 176  : 
; 177  :                  for(i=2;i<=l+4;i++)

  000b5	bf 02 00 00 00	 mov	 edi, 2
  000ba	8d 6b 04	 lea	 ebp, DWORD PTR [ebx+4]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	3b ef		 cmp	 ebp, edi
  000c2	7c 6e		 jl	 SHORT $LN33@link_code
$LL35@link_code:

; 178  :                    if(IDENTIFIER(p[i]))

  000c4	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]
  000c7	8b c8		 mov	 ecx, eax
  000c9	83 e1 03	 and	 ecx, 3
  000cc	83 f9 03	 cmp	 ecx, 3
  000cf	75 30		 jne	 SHORT $LN32@link_code

; 179  :                         fprintf(STD_err,"%s/%ld\n",
; 180  :                           NAME(p[i]),GETARITY(p[i]));

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  000d7	8b d0		 mov	 edx, eax
  000d9	c1 ea 18	 shr	 edx, 24			; 00000018H
  000dc	c1 e8 02	 shr	 eax, 2
  000df	52		 push	 edx
  000e0	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  000e5	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000e8	52		 push	 edx
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_07MNNBFCEI@?$CFs?1?$CFld?6?$AA@
  000ee	e8 00 00 00 00	 call	 ___iob_func
  000f3	83 c0 40	 add	 eax, 64			; 00000040H
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _fprintf
  000fc	83 c4 10	 add	 esp, 16			; 00000010H
  000ff	eb 2c		 jmp	 SHORT $LN34@link_code
$LN32@link_code:

; 181  :                    else if(INTEGER(p[i]))

  00101	83 f9 01	 cmp	 ecx, 1
  00104	75 0b		 jne	 SHORT $LN30@link_code

; 182  :                       fprintf(STD_err,"unexpected integer=%ld\n",
; 183  :                               OUTPUT_INT(p[i]));

  00106	c1 f8 02	 sar	 eax, 2
  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KEIGGJLA@unexpected?5integer?$DN?$CFld?6?$AA@

; 184  :                    else

  0010f	eb 0b		 jmp	 SHORT $LN67@link_code
$LN30@link_code:

; 185  :                       fprintf(STD_err,"opcode?=%ld\n",
; 186  :                              GETOP(p+i));

  00111	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KGDDEECA@opcode?$DP?$DN?$CFld?6?$AA@
$LN67@link_code:
  0011c	e8 00 00 00 00	 call	 ___iob_func
  00121	83 c0 40	 add	 eax, 64			; 00000040H
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _fprintf
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@link_code:

; 176  : 
; 177  :                  for(i=2;i<=l+4;i++)

  0012d	47		 inc	 edi
  0012e	3b fd		 cmp	 edi, ebp
  00130	7e 92		 jle	 SHORT $LL35@link_code
$LN33@link_code:

; 187  :                  fprintf(STD_err,"\n");

  00132	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00137	e8 00 00 00 00	 call	 ___iob_func
  0013c	83 c0 40	 add	 eax, 64			; 00000040H
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 _fprintf
  00145	83 c4 08	 add	 esp, 8

; 188  :               }
; 189  :               ASSERT2(END_C_CHUNK==GETOP(p+l),p[l]);
; 190  :              }
; 191  :             }
; 192  :            else

  00148	e9 23 03 00 00	 jmp	 $LN45@link_code
$LN40@link_code:

; 193  :              {
; 194  :                (void)LOCAL_ERR(T2C(p),"!inC: unexpected BEGIN_C_CHUNK");

  0014d	8b 44 24 14	 mov	 eax, DWORD PTR _wam$[esp+12]
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JPFOKBMD@?$CBinC?3?5unexpected?5BEGIN_C_CHUNK?$AA@
  00157	56		 push	 esi
  00158	e8 00 00 00 00	 call	 _local_error
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  :               }
; 196  :           break;

  00160	e9 0b 03 00 00	 jmp	 $LN45@link_code
$LN27@link_code:

; 197  :           case EXECUTE: /* we look to what's next ## */
; 198  :           {
; 199  :             f=GETFUN(p);

  00165	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 200  : 
; 201  :             if(is_dynamic(f))

  00168	57		 push	 edi
  00169	e8 00 00 00 00	 call	 _is_dynamic
  0016e	83 c4 04	 add	 esp, 4
  00171	85 c0		 test	 eax, eax
  00173	74 12		 je	 SHORT $LN26@link_code

; 202  :               {SETOP(p,APPLY);}

  00175	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00177	81 e1 41 fc ff
	ff		 and	 ecx, -959		; fffffc41H
  0017d	83 c9 41	 or	 ecx, 65			; 00000041H
  00180	89 0e		 mov	 DWORD PTR [esi], ecx
  00182	e9 e9 02 00 00	 jmp	 $LN45@link_code
$LN26@link_code:

; 203  :             else if(!(label=GETPRED(f))) {

  00187	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104
  0018d	57		 push	 edi
  0018e	52		 push	 edx
  0018f	e8 00 00 00 00	 call	 _hget
  00194	8b e8		 mov	 ebp, eax
  00196	83 c4 08	 add	 esp, 8
  00199	85 ed		 test	 ebp, ebp
  0019b	75 47		 jne	 SHORT $LN24@link_code

; 204  :                SETOP(p,APPLY);

  0019d	8b 06		 mov	 eax, DWORD PTR [esi]
  0019f	25 41 fc ff ff	 and	 eax, -959		; fffffc41H
  001a4	83 c8 41	 or	 eax, 65			; 00000041H
  001a7	89 06		 mov	 DWORD PTR [esi], eax

; 205  :                if(QLEVEL()<1)

  001a9	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  001af	83 e1 fc	 and	 ecx, -4			; fffffffcH
  001b2	83 f9 04	 cmp	 ecx, 4
  001b5	0f 8d b5 02 00
	00		 jge	 $LN45@link_code

; 206  :                  (void)LOCAL_ERR((PUTARITY(f, GETARITY(f)-1)),
; 207  :                    "has no compiled definition: left unlinked");

  001bb	8b 54 24 14	 mov	 edx, DWORD PTR _wam$[esp+12]
  001bf	8b c7		 mov	 eax, edi
  001c1	c1 e8 18	 shr	 eax, 24			; 00000018H
  001c4	48		 dec	 eax
  001c5	52		 push	 edx
  001c6	c1 e0 18	 shl	 eax, 24			; 00000018H
  001c9	81 e7 ff ff ff
	00		 and	 edi, 16777215		; 00ffffffH
  001cf	0b c7		 or	 eax, edi
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KJFIEHGO@has?5no?5compiled?5definition?3?5left@
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _local_error
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  :               }
; 209  :             else

  001df	e9 8c 02 00 00	 jmp	 $LN45@link_code
$LN24@link_code:

; 210  :              {
; 211  :                switch(GETOP(label))

  001e4	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  001e7	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001ec	83 c0 ed	 add	 eax, -19		; ffffffedH
  001ef	3d b8 00 00 00	 cmp	 eax, 184		; 000000b8H
  001f4	0f 87 ec 00 00
	00		 ja	 $LN14@link_code
  001fa	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN64@link_code[eax]
  00201	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN69@link_code[ecx*4]
$LN19@link_code:

; 212  :                  {
; 213  :                   case TRUE_0:
; 214  :                     SETOP(p,TRUE_0); SETREG(p,1);

  00208	8b 16		 mov	 edx, DWORD PTR [esi]
  0020a	81 e2 00 fc 1f
	00		 and	 edx, 2096128		; 001ffc00H
  00210	81 ca ca 00 80
	00		 or	 edx, 8388810		; 008000caH
  00216	89 16		 mov	 DWORD PTR [esi], edx

; 215  :                     SETOP(p+instr_len[TRUE_0],NOP);

  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  0021d	0f b6 88 ca 00
	00 00		 movzx	 ecx, BYTE PTR [eax+202]
  00224	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  00227	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]
  0022a	81 e2 db fc ff
	ff		 and	 edx, -805		; fffffcdbH
  00230	81 ca db 00 00
	00		 or	 edx, 219		; 000000dbH
  00236	89 10		 mov	 DWORD PTR [eax], edx

; 216  :                     SETREG(p+instr_len[TRUE_0],0);

  00238	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  0023d	0f b6 88 ca 00
	00 00		 movzx	 ecx, BYTE PTR [eax+202]
  00244	81 24 8e ff ff
	1f 00		 and	 DWORD PTR [esi+ecx*4], 2097151 ; 001fffffH
  0024b	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 217  :                   break;

  0024e	e9 1d 02 00 00	 jmp	 $LN45@link_code
$LN18@link_code:

; 218  : 
; 219  :                   case CALL_1:
; 220  :                     SETOP(p,CALL_1); SETREG(p,1);

  00253	8b 16		 mov	 edx, DWORD PTR [esi]
  00255	81 e2 00 fc 1f
	00		 and	 edx, 2096128		; 001ffc00H
  0025b	81 ca cb 00 80
	00		 or	 edx, 8388811		; 008000cbH
  00261	89 16		 mov	 DWORD PTR [esi], edx

; 221  :                     SETOP(p+instr_len[CALL_1],NOP);

  00263	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  00268	0f b6 88 cb 00
	00 00		 movzx	 ecx, BYTE PTR [eax+203]
  0026f	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  00272	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]
  00275	81 e2 db fc ff
	ff		 and	 edx, -805		; fffffcdbH
  0027b	81 ca db 00 00
	00		 or	 edx, 219		; 000000dbH
  00281	89 10		 mov	 DWORD PTR [eax], edx

; 222  :                     SETREG(p+instr_len[CALL_1],0);

  00283	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  00288	0f b6 88 cb 00
	00 00		 movzx	 ecx, BYTE PTR [eax+203]
  0028f	81 24 8e ff ff
	1f 00		 and	 DWORD PTR [esi+ecx*4], 2097151 ; 001fffffH
  00296	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]

; 223  :                   break;

  00299	e9 d2 01 00 00	 jmp	 $LN45@link_code
$LN17@link_code:

; 224  : 
; 225  :                   case NONDET:
; 226  : #if JUMP_COMPRESS
; 227  :                    if(!is_dynamic(f))

  0029e	57		 push	 edi
  0029f	e8 00 00 00 00	 call	 _is_dynamic
  002a4	83 c4 04	 add	 esp, 4
  002a7	85 c0		 test	 eax, eax
  002a9	75 0d		 jne	 SHORT $LN16@link_code

; 228  :                    {
; 229  :                       /* MARK_JCOMPRESSED(f); */
; 230  :                       SETOP(p,EXEC_TRY);

  002ab	8b 16		 mov	 edx, DWORD PTR [esi]
  002ad	81 e2 31 fc ff
	ff		 and	 edx, -975		; fffffc31H
  002b3	83 ca 31	 or	 edx, 49			; 00000031H
  002b6	89 16		 mov	 DWORD PTR [esi], edx
$LN16@link_code:

; 231  :                    }
; 232  : #endif
; 233  :                     SETLABEL(p,label+instr_len[NONDET]);

  002b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  002bd	0f b6 48 17	 movzx	 ecx, BYTE PTR [eax+23]
  002c1	8d 54 8d 00	 lea	 edx, DWORD PTR [ebp+ecx*4]
  002c5	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 234  :                   break;

  002c8	e9 a3 01 00 00	 jmp	 $LN45@link_code
$LN15@link_code:

; 235  : 
; 236  : #if JUMP_COMPRESS
; 237  :                   case TRY_ME_ELSE:
; 238  :                    if(!is_dynamic(f))

  002cd	57		 push	 edi
  002ce	e8 00 00 00 00	 call	 _is_dynamic
  002d3	83 c4 04	 add	 esp, 4
  002d6	85 c0		 test	 eax, eax
  002d8	75 0c		 jne	 SHORT $LN14@link_code

; 239  :                    {
; 240  :                     /* MARK_JCOMPRESSED(f); */
; 241  :                        SETOP(p,EXEC_TRY);

  002da	8b 06		 mov	 eax, DWORD PTR [esi]
  002dc	25 31 fc ff ff	 and	 eax, -975		; fffffc31H
  002e1	83 c8 31	 or	 eax, 49			; 00000031H
  002e4	89 06		 mov	 DWORD PTR [esi], eax
$LN14@link_code:

; 242  :                     }
; 243  :                     SETLABEL(p,label);

  002e6	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 244  :                   break;

  002e9	e9 82 01 00 00	 jmp	 $LN45@link_code
$LN13@link_code:

; 245  : 
; 246  :                   case JUMP_IF:
; 247  :                    if(!is_dynamic(f))

  002ee	57		 push	 edi
  002ef	e8 00 00 00 00	 call	 _is_dynamic
  002f4	83 c4 04	 add	 esp, 4
  002f7	85 c0		 test	 eax, eax
  002f9	75 39		 jne	 SHORT $LN12@link_code

; 248  :                    {
; 249  :                      MARK_JCOMPRESSED(f);

  002fb	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR _g+128
  00301	57		 push	 edi
  00302	51		 push	 ecx
  00303	e8 00 00 00 00	 call	 _hget
  00308	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR _g+128
  0030e	83 c4 08	 add	 esp, 8
  00311	3b c8		 cmp	 ecx, eax
  00313	74 13		 je	 SHORT $LN11@link_code
  00315	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0031c	52		 push	 edx
  0031d	51		 push	 ecx
  0031e	57		 push	 edi
  0031f	51		 push	 ecx
  00320	e8 00 00 00 00	 call	 _hdef
  00325	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@link_code:

; 250  :                      SETOP(p,EXEC_JUMP_IF);

  00328	8b 06		 mov	 eax, DWORD PTR [esi]
  0032a	25 1a fc ff ff	 and	 eax, -998		; fffffc1aH
  0032f	83 c8 1a	 or	 eax, 26			; 0000001aH
  00332	89 06		 mov	 DWORD PTR [esi], eax
$LN12@link_code:

; 251  :                     }
; 252  :                     SETLABEL(p,label);

  00334	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 253  :                   break;

  00337	e9 34 01 00 00	 jmp	 $LN45@link_code
$LN10@link_code:

; 254  : 
; 255  :                   case SWITCH:
; 256  :                    if(!is_dynamic(f))

  0033c	57		 push	 edi
  0033d	e8 00 00 00 00	 call	 _is_dynamic
  00342	83 c4 04	 add	 esp, 4
  00345	85 c0		 test	 eax, eax
  00347	75 70		 jne	 SHORT $LN6@link_code

; 257  :                    {
; 258  :                      MARK_JCOMPRESSED(f);

  00349	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR _g+128
  0034f	57		 push	 edi
  00350	51		 push	 ecx
  00351	e8 00 00 00 00	 call	 _hget
  00356	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR _g+128
  0035c	83 c4 08	 add	 esp, 8
  0035f	3b c8		 cmp	 ecx, eax
  00361	74 13		 je	 SHORT $LN8@link_code
  00363	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0036a	52		 push	 edx
  0036b	51		 push	 ecx
  0036c	57		 push	 edi
  0036d	51		 push	 ecx
  0036e	e8 00 00 00 00	 call	 _hdef
  00373	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@link_code:

; 259  :                      if(link_switch(label,FALSE))

  00376	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  00379	85 c0		 test	 eax, eax
  0037b	74 2f		 je	 SHORT $LN7@link_code
  0037d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037f	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00385	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00388	75 22		 jne	 SHORT $LN7@link_code
  0038a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0038d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00393	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  00396	75 14		 jne	 SHORT $LN7@link_code

; 260  :                        { SETOP(p,EXEC_JUMP_IF);}

  00398	8b 06		 mov	 eax, DWORD PTR [esi]
  0039a	25 1a fc ff ff	 and	 eax, -998		; fffffc1aH
  0039f	83 c8 1a	 or	 eax, 26			; 0000001aH
  003a2	89 06		 mov	 DWORD PTR [esi], eax

; 263  :                     }
; 264  :                     SETLABEL(p,label);

  003a4	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 265  :                   break;

  003a7	e9 c4 00 00 00	 jmp	 $LN45@link_code
$LN7@link_code:

; 261  :                      else
; 262  :                        { SETOP(p,EXEC_SWITCH);}

  003ac	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003ae	81 e1 18 fc ff
	ff		 and	 ecx, -1000		; fffffc18H
  003b4	83 c9 18	 or	 ecx, 24			; 00000018H
  003b7	89 0e		 mov	 DWORD PTR [esi], ecx
$LN6@link_code:

; 263  :                     }
; 264  :                     SETLABEL(p,label);

  003b9	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 265  :                   break;

  003bc	e9 af 00 00 00	 jmp	 $LN45@link_code
$LN4@link_code:

; 266  : #endif
; 267  :                   default: SETLABEL(p,label);
; 268  :                  }   /* switch GETOP(label) */
; 269  :                } /* else */
; 270  :          }
; 271  :          break;
; 272  : 
; 273  :          case SWITCH: (void)link_switch(p,TRUE);

  003c1	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  003c4	85 c9		 test	 ecx, ecx
  003c6	0f 84 a4 00 00
	00		 je	 $LN45@link_code
  003cc	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ce	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  003d4	83 fa 15	 cmp	 edx, 21			; 00000015H
  003d7	0f 85 93 00 00
	00		 jne	 $LN45@link_code
  003dd	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003e0	83 c1 08	 add	 ecx, 8
  003e3	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  003e9	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  003ec	0f 85 7e 00 00
	00		 jne	 $LN45@link_code
  003f2	25 1b fc ff ff	 and	 eax, -997		; fffffc1bH
  003f7	83 c8 1b	 or	 eax, 27			; 0000001bH
  003fa	89 06		 mov	 DWORD PTR [esi], eax
  003fc	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 274  :          break;

  003ff	eb 6f		 jmp	 SHORT $LN45@link_code
$LN3@link_code:

; 275  : 
; 276  :          case NONDET:
; 277  :            label=GETPRED(GETFUN(p));

  00401	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00404	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  0040a	50		 push	 eax
  0040b	51		 push	 ecx
  0040c	e8 00 00 00 00	 call	 _hget

; 278  :            SETPRED(GETFUN(p),(no)(label+instr_len[NONDET]));

  00411	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len
  00417	8b f8		 mov	 edi, eax
  00419	0f b6 42 17	 movzx	 eax, BYTE PTR [edx+23]
  0041d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00420	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]
  00423	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  00428	51		 push	 ecx
  00429	52		 push	 edx
  0042a	50		 push	 eax
  0042b	e8 00 00 00 00	 call	 _hset
  00430	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  00437	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0043a	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  0043f	51		 push	 ecx
  00440	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _instr_len
  00446	52		 push	 edx
  00447	0f b6 51 17	 movzx	 edx, BYTE PTR [ecx+23]
  0044b	50		 push	 eax
  0044c	8d 04 97	 lea	 eax, DWORD PTR [edi+edx*4]
  0044f	50		 push	 eax
  00450	e8 00 00 00 00	 call	 _hdef

; 279  :            SETOP(label,TRY_ME_ONLY);

  00455	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00457	81 e1 16 fc ff
	ff		 and	 ecx, -1002		; fffffc16H
  0045d	83 c4 24	 add	 esp, 36			; 00000024H
  00460	83 c9 16	 or	 ecx, 22			; 00000016H
  00463	89 0f		 mov	 DWORD PTR [edi], ecx

; 280  :          break;

  00465	eb 09		 jmp	 SHORT $LN45@link_code
$LN2@link_code:

; 281  : 
; 282  :          default: if(0==l) l=1;

  00467	85 db		 test	 ebx, ebx
  00469	75 05		 jne	 SHORT $LN45@link_code
  0046b	bb 01 00 00 00	 mov	 ebx, 1
$LN45@link_code:

; 161  :   for(; p<(instr)ctop; p+=l)

  00470	8d 34 9e	 lea	 esi, DWORD PTR [esi+ebx*4]
  00473	3b 35 7c 01 00
	00		 cmp	 esi, DWORD PTR _g+380
  00479	0f 82 93 fb ff
	ff		 jb	 $LL46@link_code
  0047f	5f		 pop	 edi
  00480	5d		 pop	 ebp
  00481	5b		 pop	 ebx
$LN65@link_code:

; 283  :       } /* switch GETOP(P) */
; 284  :     } /* for */
; 285  :   return TRUE;

  00482	b8 01 00 00 00	 mov	 eax, 1
  00487	5e		 pop	 esi

; 286  : }

  00488	c3		 ret	 0
  00489	8d 49 00	 npad	 3
$LN68@link_code:
  0048c	00 00 00 00	 DD	 $LN27@link_code
  00490	00 00 00 00	 DD	 $LN3@link_code
  00494	00 00 00 00	 DD	 $LN4@link_code
  00498	00 00 00 00	 DD	 $LN41@link_code
  0049c	00 00 00 00	 DD	 $LN2@link_code
$LN63@link_code:
  004a0	00		 DB	 0
  004a1	04		 DB	 4
  004a2	04		 DB	 4
  004a3	04		 DB	 4
  004a4	04		 DB	 4
  004a5	04		 DB	 4
  004a6	01		 DB	 1
  004a7	04		 DB	 4
  004a8	02		 DB	 2
  004a9	04		 DB	 4
  004aa	04		 DB	 4
  004ab	04		 DB	 4
  004ac	04		 DB	 4
  004ad	04		 DB	 4
  004ae	04		 DB	 4
  004af	04		 DB	 4
  004b0	04		 DB	 4
  004b1	04		 DB	 4
  004b2	04		 DB	 4
  004b3	04		 DB	 4
  004b4	04		 DB	 4
  004b5	04		 DB	 4
  004b6	04		 DB	 4
  004b7	04		 DB	 4
  004b8	04		 DB	 4
  004b9	04		 DB	 4
  004ba	04		 DB	 4
  004bb	04		 DB	 4
  004bc	04		 DB	 4
  004bd	04		 DB	 4
  004be	04		 DB	 4
  004bf	04		 DB	 4
  004c0	04		 DB	 4
  004c1	04		 DB	 4
  004c2	04		 DB	 4
  004c3	04		 DB	 4
  004c4	04		 DB	 4
  004c5	04		 DB	 4
  004c6	04		 DB	 4
  004c7	04		 DB	 4
  004c8	04		 DB	 4
  004c9	04		 DB	 4
  004ca	04		 DB	 4
  004cb	04		 DB	 4
  004cc	04		 DB	 4
  004cd	04		 DB	 4
  004ce	03		 DB	 3
  004cf	90		 npad	 1
$LN69@link_code:
  004d0	00 00 00 00	 DD	 $LN15@link_code
  004d4	00 00 00 00	 DD	 $LN17@link_code
  004d8	00 00 00 00	 DD	 $LN10@link_code
  004dc	00 00 00 00	 DD	 $LN13@link_code
  004e0	00 00 00 00	 DD	 $LN19@link_code
  004e4	00 00 00 00	 DD	 $LN18@link_code
  004e8	00 00 00 00	 DD	 $LN14@link_code
$LN64@link_code:
  004ec	00		 DB	 0
  004ed	06		 DB	 6
  004ee	06		 DB	 6
  004ef	06		 DB	 6
  004f0	01		 DB	 1
  004f1	06		 DB	 6
  004f2	02		 DB	 2
  004f3	06		 DB	 6
  004f4	03		 DB	 3
  004f5	06		 DB	 6
  004f6	06		 DB	 6
  004f7	06		 DB	 6
  004f8	06		 DB	 6
  004f9	06		 DB	 6
  004fa	06		 DB	 6
  004fb	06		 DB	 6
  004fc	06		 DB	 6
  004fd	06		 DB	 6
  004fe	06		 DB	 6
  004ff	06		 DB	 6
  00500	06		 DB	 6
  00501	06		 DB	 6
  00502	06		 DB	 6
  00503	06		 DB	 6
  00504	06		 DB	 6
  00505	06		 DB	 6
  00506	06		 DB	 6
  00507	06		 DB	 6
  00508	06		 DB	 6
  00509	06		 DB	 6
  0050a	06		 DB	 6
  0050b	06		 DB	 6
  0050c	06		 DB	 6
  0050d	06		 DB	 6
  0050e	06		 DB	 6
  0050f	06		 DB	 6
  00510	06		 DB	 6
  00511	06		 DB	 6
  00512	06		 DB	 6
  00513	06		 DB	 6
  00514	06		 DB	 6
  00515	06		 DB	 6
  00516	06		 DB	 6
  00517	06		 DB	 6
  00518	06		 DB	 6
  00519	06		 DB	 6
  0051a	06		 DB	 6
  0051b	06		 DB	 6
  0051c	06		 DB	 6
  0051d	06		 DB	 6
  0051e	06		 DB	 6
  0051f	06		 DB	 6
  00520	06		 DB	 6
  00521	06		 DB	 6
  00522	06		 DB	 6
  00523	06		 DB	 6
  00524	06		 DB	 6
  00525	06		 DB	 6
  00526	06		 DB	 6
  00527	06		 DB	 6
  00528	06		 DB	 6
  00529	06		 DB	 6
  0052a	06		 DB	 6
  0052b	06		 DB	 6
  0052c	06		 DB	 6
  0052d	06		 DB	 6
  0052e	06		 DB	 6
  0052f	06		 DB	 6
  00530	06		 DB	 6
  00531	06		 DB	 6
  00532	06		 DB	 6
  00533	06		 DB	 6
  00534	06		 DB	 6
  00535	06		 DB	 6
  00536	06		 DB	 6
  00537	06		 DB	 6
  00538	06		 DB	 6
  00539	06		 DB	 6
  0053a	06		 DB	 6
  0053b	06		 DB	 6
  0053c	06		 DB	 6
  0053d	06		 DB	 6
  0053e	06		 DB	 6
  0053f	06		 DB	 6
  00540	06		 DB	 6
  00541	06		 DB	 6
  00542	06		 DB	 6
  00543	06		 DB	 6
  00544	06		 DB	 6
  00545	06		 DB	 6
  00546	06		 DB	 6
  00547	06		 DB	 6
  00548	06		 DB	 6
  00549	06		 DB	 6
  0054a	06		 DB	 6
  0054b	06		 DB	 6
  0054c	06		 DB	 6
  0054d	06		 DB	 6
  0054e	06		 DB	 6
  0054f	06		 DB	 6
  00550	06		 DB	 6
  00551	06		 DB	 6
  00552	06		 DB	 6
  00553	06		 DB	 6
  00554	06		 DB	 6
  00555	06		 DB	 6
  00556	06		 DB	 6
  00557	06		 DB	 6
  00558	06		 DB	 6
  00559	06		 DB	 6
  0055a	06		 DB	 6
  0055b	06		 DB	 6
  0055c	06		 DB	 6
  0055d	06		 DB	 6
  0055e	06		 DB	 6
  0055f	06		 DB	 6
  00560	06		 DB	 6
  00561	06		 DB	 6
  00562	06		 DB	 6
  00563	06		 DB	 6
  00564	06		 DB	 6
  00565	06		 DB	 6
  00566	06		 DB	 6
  00567	06		 DB	 6
  00568	06		 DB	 6
  00569	06		 DB	 6
  0056a	06		 DB	 6
  0056b	06		 DB	 6
  0056c	06		 DB	 6
  0056d	06		 DB	 6
  0056e	06		 DB	 6
  0056f	06		 DB	 6
  00570	06		 DB	 6
  00571	06		 DB	 6
  00572	06		 DB	 6
  00573	06		 DB	 6
  00574	06		 DB	 6
  00575	06		 DB	 6
  00576	06		 DB	 6
  00577	06		 DB	 6
  00578	06		 DB	 6
  00579	06		 DB	 6
  0057a	06		 DB	 6
  0057b	06		 DB	 6
  0057c	06		 DB	 6
  0057d	06		 DB	 6
  0057e	06		 DB	 6
  0057f	06		 DB	 6
  00580	06		 DB	 6
  00581	06		 DB	 6
  00582	06		 DB	 6
  00583	06		 DB	 6
  00584	06		 DB	 6
  00585	06		 DB	 6
  00586	06		 DB	 6
  00587	06		 DB	 6
  00588	06		 DB	 6
  00589	06		 DB	 6
  0058a	06		 DB	 6
  0058b	06		 DB	 6
  0058c	06		 DB	 6
  0058d	06		 DB	 6
  0058e	06		 DB	 6
  0058f	06		 DB	 6
  00590	06		 DB	 6
  00591	06		 DB	 6
  00592	06		 DB	 6
  00593	06		 DB	 6
  00594	06		 DB	 6
  00595	06		 DB	 6
  00596	06		 DB	 6
  00597	06		 DB	 6
  00598	06		 DB	 6
  00599	06		 DB	 6
  0059a	06		 DB	 6
  0059b	06		 DB	 6
  0059c	06		 DB	 6
  0059d	06		 DB	 6
  0059e	06		 DB	 6
  0059f	06		 DB	 6
  005a0	06		 DB	 6
  005a1	06		 DB	 6
  005a2	06		 DB	 6
  005a3	04		 DB	 4
  005a4	05		 DB	 5
_link_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OLBFBHOO@insert_op?$AA@			; `string'
PUBLIC	??_C@_0BH@DCOCMCNK@unexpected?5END_C_CHUNK?$AA@	; `string'
PUBLIC	??_C@_0BJ@GJGDFOIO@unexpected?5BEGIN_C_CHUNK?$AA@ ; `string'
PUBLIC	??_C@_0BF@FCOFIBGK@not?5enough?5registers?$AA@	; `string'
PUBLIC	??_C@_0DO@HGDNFGEH@declare?5it?5multifile?5or?5disconti@ ; `string'
PUBLIC	??_C@_0EA@HKLJGOJE@?$FL?$CFlu?$FN?5?$CFs?1?$CFlu?5?$DM?$DNpredicate?5leads?5o@ ; `string'
PUBLIC	??_C@_0BJ@PJAKLANF@bad?5code?5in?5backpatching?$AA@ ; `string'
PUBLIC	_insert_op
EXTRN	_overflow_by:PROC
EXTRN	_fatal_error:PROC
EXTRN	_warnmes:PROC
_BSS	SEGMENT
_prev_prev_len DD 01H DUP (?)
_prev_len DD	01H DUP (?)
_badcode DD	01H DUP (?)
_last	DD	01H DUP (?)
_currpred DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09OLBFBHOO@insert_op?$AA@
CONST	SEGMENT
??_C@_09OLBFBHOO@insert_op?$AA@ DB 'insert_op', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DCOCMCNK@unexpected?5END_C_CHUNK?$AA@
CONST	SEGMENT
??_C@_0BH@DCOCMCNK@unexpected?5END_C_CHUNK?$AA@ DB 'unexpected END_C_CHUN'
	DB	'K', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GJGDFOIO@unexpected?5BEGIN_C_CHUNK?$AA@
CONST	SEGMENT
??_C@_0BJ@GJGDFOIO@unexpected?5BEGIN_C_CHUNK?$AA@ DB 'unexpected BEGIN_C_'
	DB	'CHUNK', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FCOFIBGK@not?5enough?5registers?$AA@
CONST	SEGMENT
??_C@_0BF@FCOFIBGK@not?5enough?5registers?$AA@ DB 'not enough registers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@HGDNFGEH@declare?5it?5multifile?5or?5disconti@
CONST	SEGMENT
??_C@_0DO@HGDNFGEH@declare?5it?5multifile?5or?5disconti@ DB 'declare it m'
	DB	'ultifile or discontiguous if that''s what you want', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HKLJGOJE@?$FL?$CFlu?$FN?5?$CFs?1?$CFlu?5?$DM?$DNpredicate?5leads?5o@
CONST	SEGMENT
??_C@_0EA@HKLJGOJE@?$FL?$CFlu?$FN?5?$CFs?1?$CFlu?5?$DM?$DNpredicate?5leads?5o@ DB '['
	DB	'%lu] %s/%lu <=predicate leads other group of clauses: IGNORED'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PJAKLANF@bad?5code?5in?5backpatching?$AA@
CONST	SEGMENT
??_C@_0BJ@PJAKLANF@bad?5code?5in?5backpatching?$AA@ DB 'bad code in backp'
	DB	'atching', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _insert_op
_TEXT	SEGMENT
_opcode$ = 8						; size = 4
_reg$ = 12						; size = 4
_name$ = 16						; size = 4
_arity$ = 20						; size = 4
_wam$ = 24						; size = 4
_insert_op PROC						; COMDAT

; 323  :   SETOP(ctop,opcode);

  00000	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00005	53		 push	 ebx
  00006	8b 5c 24 08	 mov	 ebx, DWORD PTR _opcode$[esp]
  0000a	c7 05 f4 00 00
	00 05 00 00 00	 mov	 DWORD PTR _g+244, 5
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	55		 push	 ebp
  00017	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  0001d	56		 push	 esi
  0001e	0b cb		 or	 ecx, ebx

; 324  :   switch(opcode)

  00020	bd 01 00 00 00	 mov	 ebp, 1
  00025	57		 push	 edi
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8d 7d 03	 lea	 edi, DWORD PTR [ebp+3]
  0002b	81 fb dd 00 00
	00		 cmp	 ebx, 221		; 000000ddH
  00031	0f 87 c2 0b 00
	00		 ja	 $LN3@insert_op
  00037	0f b6 83 00 00
	00 00		 movzx	 eax, BYTE PTR $LN118@insert_op[ebx]
  0003e	8d 55 01	 lea	 edx, DWORD PTR [ebp+1]
  00041	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN131@insert_op[eax*4]
$LN99@insert_op:

; 325  :   {
; 326  :     case CLAUSE:
; 327  :       {   cell pred=input_fun(name,arity);

  00048	8b 74 24 20	 mov	 esi, DWORD PTR _arity$[esp+12]
  0004c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _name$[esp+12]
  00050	56		 push	 esi
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 _input_fun

; 328  :         no ok=DEFPRED(pred,(no)ctop);

  00057	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0005e	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  00064	8b f8		 mov	 edi, eax
  00066	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0006b	52		 push	 edx
  0006c	50		 push	 eax
  0006d	57		 push	 edi
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _hdef
  00074	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0007b	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00081	52		 push	 edx
  00082	8b e8		 mov	 ebp, eax
  00084	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  00089	57		 push	 edi
  0008a	50		 push	 eax
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _hdef

; 329  : #if (TRACE>2)
; 330  : 	fprintf(STD_err,"inserting clause for %s/%ld\n",name,arity);
; 331  : #endif
; 332  :         if(currpred!=g.true) SETLABEL(last,(instr)ctop);

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR _currpred
  00096	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _last
  0009c	83 c4 28	 add	 esp, 40			; 00000028H
  0009f	3b 05 64 00 00
	00		 cmp	 eax, DWORD PTR _g+100
  000a5	74 09		 je	 SHORT $LN98@insert_op
  000a7	8b 15 7c 01 00
	00		 mov	 edx, DWORD PTR _g+380
  000ad	89 53 04	 mov	 DWORD PTR [ebx+4], edx
$LN98@insert_op:

; 333  :         reg++;
; 334  :         if(ok)

  000b0	85 ed		 test	 ebp, ebp
  000b2	0f 84 db 00 00
	00		 je	 $LN97@insert_op

; 335  :           { badcode=FALSE;
; 336  :             if(currpred!=g.true && GETOP(ctop-2)!=END)

  000b8	3b 05 64 00 00
	00		 cmp	 eax, DWORD PTR _g+100
  000be	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  000c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _badcode, 0
  000cd	0f 84 79 00 00
	00		 je	 $LN87@insert_op
  000d3	f7 40 f8 ff 03
	00 00		 test	 DWORD PTR [eax-8], 1023	; 000003ffH
  000da	74 70		 je	 SHORT $LN87@insert_op

; 337  :               {
; 338  :                 switch(GETOP(last))

  000dc	8b 13		 mov	 edx, DWORD PTR [ebx]
  000de	8b ca		 mov	 ecx, edx
  000e0	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  000e6	83 e9 13	 sub	 ecx, 19			; 00000013H
  000e9	74 2e		 je	 SHORT $LN93@insert_op
  000eb	49		 dec	 ecx
  000ec	74 1e		 je	 SHORT $LN89@insert_op

; 352  : 
; 353  :                     default: badcode=TRUE;
; 354  :                       ERREXIT("bad code in backpatching")

  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PJAKLANF@bad?5code?5in?5backpatching?$AA@
  000f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _badcode, 1
  000fd	e8 00 00 00 00	 call	 _warnmes
  00102	83 c4 04	 add	 esp, 4
$LN129@insert_op:
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5d		 pop	 ebp
  00108	33 c0		 xor	 eax, eax
  0010a	5b		 pop	 ebx

; 586  : }

  0010b	c3		 ret	 0
$LN89@insert_op:

; 347  :                     break;
; 348  : 
; 349  :                     case RETRY_ME_ELSE:
; 350  :                       SETOP(last,TRUST_ME_ELSE);

  0010c	81 e2 15 fc ff
	ff		 and	 edx, -1003		; fffffc15H
  00112	83 ca 15	 or	 edx, 21			; 00000015H
  00115	89 13		 mov	 DWORD PTR [ebx], edx

; 351  :                     break;

  00117	eb 2e		 jmp	 SHORT $LN130@insert_op
$LN93@insert_op:

; 339  :                   {
; 340  :                     case TRY_ME_ELSE: /* begin of single cls */
; 341  :                       { instr p;
; 342  :                           for(p=last-2; p<=(instr)ctop-4; p++)

  00119	8d 4b f8	 lea	 ecx, DWORD PTR [ebx-8]
  0011c	8d 50 f0	 lea	 edx, DWORD PTR [eax-16]
  0011f	3b ca		 cmp	 ecx, edx
  00121	77 14		 ja	 SHORT $LN90@insert_op
$LL92@insert_op:

; 343  :                           *p = *(p+4);

  00123	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00126	89 01		 mov	 DWORD PTR [ecx], eax
  00128	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0012d	83 c1 04	 add	 ecx, 4
  00130	8d 50 f0	 lea	 edx, DWORD PTR [eax-16]
  00133	3b ca		 cmp	 ecx, edx
  00135	76 ec		 jbe	 SHORT $LL92@insert_op
$LN90@insert_op:

; 344  :                       }
; 345  :                       SETOP(ctop-4,END);

  00137	b9 00 fc ff ff	 mov	 ecx, -1024		; fffffc00H
  0013c	21 48 f0	 and	 DWORD PTR [eax-16], ecx

; 346  :                       SETOP(ctop-2,END);

  0013f	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00144	21 48 f8	 and	 DWORD PTR [eax-8], ecx
$LN130@insert_op:
  00147	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
$LN87@insert_op:

; 355  :                   }
; 356  :               }
; 357  :             SKIPBAD();
; 358  :             currpred=pred;
; 359  :             SETOP(ctop,SWITCH);

  0014c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014e	81 e1 19 fc ff
	ff		 and	 ecx, -999		; fffffc19H
  00154	83 c9 19	 or	 ecx, 25			; 00000019H
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 360  :             SETREG(ctop,0);

  00159	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0015e	81 20 ff ff 1f
	00		 and	 DWORD PTR [eax], 2097151 ; 001fffffH

; 361  :             SETFUN(ctop,pred);

  00164	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00169	83 c0 04	 add	 eax, 4
  0016c	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  00171	89 38		 mov	 DWORD PTR [eax], edi

; 362  :             ctop++;

  00173	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00178	83 c0 04	 add	 eax, 4
  0017b	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax

; 363  : 
; 364  :             SETOP(ctop,TRY_ME_ELSE); /* reg = how far is fun=nextcls */

  00180	8b 10		 mov	 edx, DWORD PTR [eax]
  00182	81 e2 13 fc ff
	ff		 and	 edx, -1005		; fffffc13H
  00188	89 3d 00 00 00
	00		 mov	 DWORD PTR _currpred, edi
  0018e	83 ca 13	 or	 edx, 19			; 00000013H

; 365  :             SETREG(ctop,arity);   /* arity is here, not on the stack */

  00191	eb 21		 jmp	 SHORT $LN124@insert_op
$LN97@insert_op:

; 366  :           }
; 367  :         else if(currpred==pred)

  00193	3b c7		 cmp	 eax, edi
  00195	75 56		 jne	 SHORT $LN85@insert_op

; 368  :           { SKIPBAD();

  00197	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  0019e	0f 85 61 ff ff
	ff		 jne	 $LN129@insert_op

; 369  :             SETOP(ctop,RETRY_ME_ELSE);

  001a4	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  001a9	8b 10		 mov	 edx, DWORD PTR [eax]
  001ab	81 e2 14 fc ff
	ff		 and	 edx, -1004		; fffffc14H
  001b1	83 ca 14	 or	 edx, 20			; 00000014H
$LN124@insert_op:

; 380  :           }
; 381  :         last=(instr)(ctop++);
; 382  :       }
; 383  :     break;

  001b4	8b 5c 24 14	 mov	 ebx, DWORD PTR _opcode$[esp+12]
  001b8	89 10		 mov	 DWORD PTR [eax], edx
  001ba	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  001bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c1	c1 e6 17	 shl	 esi, 23			; 00000017H
  001c4	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  001ca	0b ce		 or	 ecx, esi
  001cc	89 08		 mov	 DWORD PTR [eax], ecx
  001ce	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  001d3	a3 00 00 00 00	 mov	 DWORD PTR _last, eax
  001d8	83 c0 04	 add	 eax, 4
  001db	bd 01 00 00 00	 mov	 ebp, 1
  001e0	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  001e5	8d 7d 03	 lea	 edi, DWORD PTR [ebp+3]
  001e8	e9 31 0a 00 00	 jmp	 $LN122@insert_op
$LN85@insert_op:

; 370  :             SETREG(ctop,arity);
; 371  :           }
; 372  :         else
; 373  :           { badcode=TRUE;
; 374  :             fprintf(STD_err,
; 375  :     "[%lu] %s/%lu <=predicate leads other group of clauses: IGNORED\n",
; 376  :             ctop-cbase,name,arity);

  001ed	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  001f2	2b 05 84 01 00
	00		 sub	 eax, DWORD PTR _g+388
  001f8	8b 54 24 1c	 mov	 edx, DWORD PTR _name$[esp+12]
  001fc	56		 push	 esi
  001fd	52		 push	 edx
  001fe	c1 f8 02	 sar	 eax, 2
  00201	50		 push	 eax
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HKLJGOJE@?$FL?$CFlu?$FN?5?$CFs?1?$CFlu?5?$DM?$DNpredicate?5leads?5o@
  00207	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _badcode, 1
  00211	e8 00 00 00 00	 call	 ___iob_func
  00216	83 c0 40	 add	 eax, 64			; 00000040H
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 _fprintf

; 377  :             ERREXIT(
; 378  :             "declare it multifile or discontiguous if that's what you want"
; 379  :             )

  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@HGDNFGEH@declare?5it?5multifile?5or?5disconti@
  00224	e8 00 00 00 00	 call	 _warnmes
  00229	83 c4 18	 add	 esp, 24			; 00000018H
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	5d		 pop	 ebp
  0022f	33 c0		 xor	 eax, eax
  00231	5b		 pop	 ebx

; 586  : }

  00232	c3		 ret	 0
$LN82@insert_op:

; 384  : 
; 385  :     case FIRSTARG: /* MaxReg-FunFirstarg/Arity */
; 386  :       SKIPBAD();

  00233	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  0023a	0f 85 c5 fe ff
	ff		 jne	 $LN129@insert_op

; 387  :       if(reg>=MAXREG) ERREXIT("not enough registers")

  00240	81 7c 24 18 ff
	07 00 00	 cmp	 DWORD PTR _reg$[esp+12], 2047 ; 000007ffH
  00248	72 14		 jb	 SHORT $LN80@insert_op
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FCOFIBGK@not?5enough?5registers?$AA@
  0024f	e8 00 00 00 00	 call	 _warnmes
  00254	83 c4 04	 add	 esp, 4
  00257	5f		 pop	 edi
  00258	5e		 pop	 esi
  00259	5d		 pop	 ebp
  0025a	33 c0		 xor	 eax, eax
  0025c	5b		 pop	 ebx

; 586  : }

  0025d	c3		 ret	 0
$LN80@insert_op:

; 388  :         { no funval=(no)input_fun(name,arity);

  0025e	8b 4c 24 20	 mov	 ecx, DWORD PTR _arity$[esp+12]
  00262	8b 74 24 1c	 mov	 esi, DWORD PTR _name$[esp+12]
  00266	51		 push	 ecx
  00267	56		 push	 esi
  00268	e8 00 00 00 00	 call	 _input_fun
  0026d	83 c4 08	 add	 esp, 8

; 389  :           if('_'==*name || !hdef(currpred,funval,(no)ctop,g.timestamp))

  00270	80 3e 5f	 cmp	 BYTE PTR [esi], 95	; 0000005fH
  00273	74 23		 je	 SHORT $LN78@insert_op
  00275	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0027c	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00282	52		 push	 edx
  00283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _currpred
  00289	51		 push	 ecx
  0028a	50		 push	 eax
  0028b	52		 push	 edx
  0028c	e8 00 00 00 00	 call	 _hdef
  00291	83 c4 10	 add	 esp, 16			; 00000010H
  00294	85 c0		 test	 eax, eax
  00296	75 22		 jne	 SHORT $LN79@insert_op
$LN78@insert_op:

; 390  :             { instr label=GETPRED(currpred);

  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR _currpred
  0029d	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  002a3	50		 push	 eax
  002a4	51		 push	 ecx
  002a5	e8 00 00 00 00	 call	 _hget

; 391  :               SETOP(label,NONDET);

  002aa	8b 10		 mov	 edx, DWORD PTR [eax]
  002ac	81 e2 17 fc ff
	ff		 and	 edx, -1001		; fffffc17H
  002b2	83 c4 08	 add	 esp, 8
  002b5	83 ca 17	 or	 edx, 23			; 00000017H
  002b8	89 10		 mov	 DWORD PTR [eax], edx
$LN79@insert_op:

; 392  :             }
; 393  :         }
; 394  :       ctop--; /* null effect, as we do ctop++ later */

  002ba	29 3d 7c 01 00
	00		 sub	 DWORD PTR _g+380, edi

; 395  :     break;

  002c0	e9 59 09 00 00	 jmp	 $LN122@insert_op
$LN77@insert_op:

; 396  : 
; 397  :     case EXECUTE: SKIPBAD();

  002c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  002cc	0f 84 8f 07 00
	00		 je	 $LN76@insert_op
  002d2	5f		 pop	 edi
  002d3	5e		 pop	 esi
  002d4	5d		 pop	 ebp
  002d5	33 c0		 xor	 eax, eax
  002d7	5b		 pop	 ebx

; 586  : }

  002d8	c3		 ret	 0
$LN75@insert_op:

; 398  :       SETFUN(ctop,input_fun(name,arity));
; 399  :     break;
; 400  : 
; 401  :     case LOAD_VARIABLE:
; 402  :     case PUT_VARIABLE:
; 403  :     case GET_VALUE: SKIPBAD();

  002d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  002e0	0f 85 1f fe ff
	ff		 jne	 $LN129@insert_op

; 404  :   	SETREG(ctop,reg);

  002e6	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  002eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ed	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  002f1	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  002f7	c1 e2 17	 shl	 edx, 23			; 00000017H
  002fa	0b ca		 or	 ecx, edx
  002fc	89 08		 mov	 DWORD PTR [eax], ecx
$LN127@insert_op:

; 405  :   	SETLEFT(ctop,arity);

  002fe	8b 4c 24 20	 mov	 ecx, DWORD PTR _arity$[esp+12]
$LN128@insert_op:
  00302	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00307	8b 10		 mov	 edx, DWORD PTR [eax]
  00309	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  0030f	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00312	81 e2 ff 03 e0
	ff		 and	 edx, -2096129		; ffe003ffH

; 406  :     break;

  00318	e9 fd 08 00 00	 jmp	 $LN125@insert_op
$LN73@insert_op:

; 407  : 
; 408  :     case GET_STRUCTURE:
; 409  :     case PUT_STRUCTURE:
; 410  :     case PUSH_STRUCTURE:
; 411  :       SKIPBAD();

  0031d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00324	0f 84 1f 07 00
	00		 je	 $LN19@insert_op
  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	5d		 pop	 ebp
  0032d	33 c0		 xor	 eax, eax
  0032f	5b		 pop	 ebx

; 586  : }

  00330	c3		 ret	 0
$LN71@insert_op:

; 412  :       SETREG(ctop,reg);
; 413  :       SETFUN(ctop,input_fun(name,arity));
; 414  :     break;
; 415  : 
; 416  :     case UNIFY_VARIABLE: SKIPBAD();

  00331	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00338	0f 85 c7 fd ff
	ff		 jne	 $LN129@insert_op

; 417  : #if STRUCT_COMPRESS
; 418  :       OCOMPRESS(UNIFY_VALUE,UNIFY_VAL_VAR,GET_STRUCTURE,
; 419  :         GET_UNIFY_VAL_VAR)

  0033e	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00343	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  00349	0f 85 bc 08 00
	00		 jne	 $LN67@insert_op
  0034f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00352	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00358	83 f9 03	 cmp	 ecx, 3
  0035b	75 6c		 jne	 SHORT $LN106@insert_op
  0035d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00360	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00364	81 e1 2b fc ff
	ff		 and	 ecx, -981		; fffffc2bH
  0036a	83 c9 2b	 or	 ecx, 43			; 0000002bH
  0036d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  00370	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00375	2b c7		 sub	 eax, edi
  00377	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  0037c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037e	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00384	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00387	81 e1 ff 03 e0
	ff		 and	 ecx, -2096129		; ffe003ffH
  0038d	0b d1		 or	 edx, ecx
  0038f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _prev_prev_len, 2
  00396	89 10		 mov	 DWORD PTR [eax], edx
  00398	0f 85 80 08 00
	00		 jne	 $LN122@insert_op
  0039e	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  003a3	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  003a6	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  003ac	83 fa 08	 cmp	 edx, 8
  003af	0f 85 69 08 00
	00		 jne	 $LN122@insert_op
  003b5	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  003b8	81 e1 2a fc ff
	ff		 and	 ecx, -982		; fffffc2aH
  003be	83 c9 2a	 or	 ecx, 42			; 0000002aH
  003c1	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  003c4	e9 55 08 00 00	 jmp	 $LN122@insert_op
$LN106@insert_op:

; 420  :       OCOMPRESS(UNIFY_VARIABLE,UNIFY_VAR_VAR,GET_STRUCTURE,
; 421  :         GET_UNIFY_VAR_VAR)

  003c9	3b cd		 cmp	 ecx, ebp
  003cb	0f 85 3a 08 00
	00		 jne	 $LN67@insert_op
  003d1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  003d4	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  003d8	81 e2 1f fc ff
	ff		 and	 edx, -993		; fffffc1fH
  003de	83 ca 1f	 or	 edx, 31			; 0000001fH
  003e1	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  003e4	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  003e9	2b c7		 sub	 eax, edi
  003eb	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  003f0	8b 10		 mov	 edx, DWORD PTR [eax]
  003f2	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  003f8	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  003fb	81 e2 ff 03 e0
	ff		 and	 edx, -2096129		; ffe003ffH
  00401	0b ca		 or	 ecx, edx
  00403	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _prev_prev_len, 2
  0040a	89 08		 mov	 DWORD PTR [eax], ecx
  0040c	0f 85 0c 08 00
	00		 jne	 $LN122@insert_op
  00412	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00417	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0041a	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00420	83 f9 08	 cmp	 ecx, 8
  00423	0f 85 f5 07 00
	00		 jne	 $LN122@insert_op
  00429	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  0042c	81 e2 1e fc ff
	ff		 and	 edx, -994		; fffffc1eH
  00432	83 ca 1e	 or	 edx, 30			; 0000001eH
  00435	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00438	e9 e1 07 00 00	 jmp	 $LN122@insert_op
$LN65@insert_op:

; 422  : #endif
; 423  :       SETREG(ctop,reg);
; 424  :     break;
; 425  : 
; 426  :     case UNIFY_VALUE: SKIPBAD();

  0043d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00444	0f 85 bb fc ff
	ff		 jne	 $LN129@insert_op

; 427  : #if STRUCT_COMPRESS
; 428  :       OCOMPRESS(UNIFY_VALUE,UNIFY_VAL_VAL,GET_STRUCTURE,
; 429  :         GET_UNIFY_VAL_VAL)

  0044a	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0044f	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  00455	0f 85 b0 07 00
	00		 jne	 $LN67@insert_op
  0045b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0045e	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00464	83 f9 03	 cmp	 ecx, 3
  00467	75 6c		 jne	 SHORT $LN107@insert_op
  00469	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0046c	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00470	81 e1 23 fc ff
	ff		 and	 ecx, -989		; fffffc23H
  00476	83 c9 23	 or	 ecx, 35			; 00000023H
  00479	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  0047c	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00481	2b c7		 sub	 eax, edi
  00483	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  00488	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048a	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00490	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00493	81 e1 ff 03 e0
	ff		 and	 ecx, -2096129		; ffe003ffH
  00499	0b d1		 or	 edx, ecx
  0049b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _prev_prev_len, 2
  004a2	89 10		 mov	 DWORD PTR [eax], edx
  004a4	0f 85 74 07 00
	00		 jne	 $LN122@insert_op
  004aa	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  004af	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  004b2	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  004b8	83 fa 08	 cmp	 edx, 8
  004bb	0f 85 5d 07 00
	00		 jne	 $LN122@insert_op
  004c1	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  004c4	81 e1 22 fc ff
	ff		 and	 ecx, -990		; fffffc22H
  004ca	83 c9 22	 or	 ecx, 34			; 00000022H
  004cd	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  004d0	e9 49 07 00 00	 jmp	 $LN122@insert_op
$LN107@insert_op:

; 430  :       OCOMPRESS(UNIFY_VARIABLE,UNIFY_VAR_VAL,GET_STRUCTURE,
; 431  :         GET_UNIFY_VAR_VAL)

  004d5	3b cd		 cmp	 ecx, ebp
  004d7	0f 85 2e 07 00
	00		 jne	 $LN67@insert_op
  004dd	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004e0	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  004e4	81 e2 27 fc ff
	ff		 and	 edx, -985		; fffffc27H
  004ea	83 ca 27	 or	 edx, 39			; 00000027H
  004ed	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  004f0	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  004f5	2b c7		 sub	 eax, edi
  004f7	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  004fc	8b 10		 mov	 edx, DWORD PTR [eax]
  004fe	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  00504	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00507	81 e2 ff 03 e0
	ff		 and	 edx, -2096129		; ffe003ffH
  0050d	0b ca		 or	 ecx, edx
  0050f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _prev_prev_len, 2
  00516	89 08		 mov	 DWORD PTR [eax], ecx
  00518	0f 85 00 07 00
	00		 jne	 $LN122@insert_op
  0051e	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00523	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00526	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0052c	83 f9 08	 cmp	 ecx, 8
  0052f	0f 85 e9 06 00
	00		 jne	 $LN122@insert_op
  00535	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00538	81 e2 26 fc ff
	ff		 and	 edx, -986		; fffffc26H
  0053e	83 ca 26	 or	 edx, 38			; 00000026H
  00541	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00544	e9 d5 06 00 00	 jmp	 $LN122@insert_op
$LN59@insert_op:

; 432  : #endif
; 433  :       SETREG(ctop,reg);
; 434  :     break;
; 435  : 
; 436  :     case PUSH_VARIABLE:
; 437  :          SKIPBAD();

  00549	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00550	0f 85 af fb ff
	ff		 jne	 $LN129@insert_op

; 438  :          opcode=WRITE_VARIABLE;
; 439  :          SETOP(ctop,opcode);

  00556	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0055b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055d	81 e1 02 fc ff
	ff		 and	 ecx, -1022		; fffffc02H
  00563	0b ca		 or	 ecx, edx
  00565	8b da		 mov	 ebx, edx
  00567	89 08		 mov	 DWORD PTR [eax], ecx

; 440  :     case WRITE_VARIABLE: SKIPBAD();

  00569	eb 0d		 jmp	 SHORT $LN56@insert_op
$LN57@insert_op:
  0056b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00572	0f 85 8d fb ff
	ff		 jne	 $LN129@insert_op
$LN56@insert_op:

; 441  : #if STRUCT_COMPRESS
; 442  :       PCOMPRESS(WRITE_VALUE,WRITE_VAL_VAR,
; 443  :          PUT_STRUCTURE,PUT_WRITE_VAL_VAR,
; 444  :          PUSH_STRUCTURE,PUSH_VAL_VAR,
; 445  :          WRITE_CONSTANT,CONSTANT_VAL_VAR)

  00578	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0057d	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  00583	0f 85 82 06 00
	00		 jne	 $LN67@insert_op
  00589	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0058c	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00592	3b cf		 cmp	 ecx, edi
  00594	0f 85 9c 00 00
	00		 jne	 $LN108@insert_op
  0059a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0059d	81 e1 2d fc ff
	ff		 and	 ecx, -979		; fffffc2dH
  005a3	83 c9 2d	 or	 ecx, 45			; 0000002dH
  005a6	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  005a9	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  005ae	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  005b2	2b c7		 sub	 eax, edi
  005b4	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  005b9	8b 30		 mov	 esi, DWORD PTR [eax]
  005bb	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  005c1	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  005c4	81 e6 ff 03 e0
	ff		 and	 esi, -2096129		; ffe003ffH
  005ca	0b ce		 or	 ecx, esi
  005cc	89 08		 mov	 DWORD PTR [eax], ecx
  005ce	39 15 00 00 00
	00		 cmp	 DWORD PTR _prev_prev_len, edx
  005d4	0f 85 44 06 00
	00		 jne	 $LN122@insert_op
  005da	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  005e0	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  005e3	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  005e8	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  005eb	75 14		 jne	 SHORT $LN109@insert_op
  005ed	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  005f0	81 e2 2c fc ff
	ff		 and	 edx, -980		; fffffc2cH
  005f6	83 ca 2c	 or	 edx, 44			; 0000002cH
  005f9	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  005fc	e9 1d 06 00 00	 jmp	 $LN122@insert_op
$LN109@insert_op:
  00601	83 f8 33	 cmp	 eax, 51			; 00000033H
  00604	75 13		 jne	 SHORT $LN110@insert_op
  00606	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00609	25 37 fc ff ff	 and	 eax, -969		; fffffc37H
  0060e	83 c8 37	 or	 eax, 55			; 00000037H
  00611	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00614	e9 05 06 00 00	 jmp	 $LN122@insert_op
$LN110@insert_op:
  00619	83 f8 06	 cmp	 eax, 6
  0061c	0f 85 fc 05 00
	00		 jne	 $LN122@insert_op
  00622	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00625	81 e2 38 fc ff
	ff		 and	 edx, -968		; fffffc38H
  0062b	83 ca 38	 or	 edx, 56			; 00000038H
  0062e	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  00631	e9 e8 05 00 00	 jmp	 $LN122@insert_op
$LN108@insert_op:

; 446  : 
; 447  :       PCOMPRESS(WRITE_VARIABLE,WRITE_VAR_VAR,
; 448  :          PUT_STRUCTURE,PUT_WRITE_VAR_VAR,
; 449  :          PUSH_STRUCTURE,PUSH_VAR_VAR,
; 450  :          WRITE_CONSTANT,CONSTANT_VAR_VAR)

  00636	3b ca		 cmp	 ecx, edx
  00638	0f 85 cd 05 00
	00		 jne	 $LN67@insert_op
  0063e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00641	81 e1 21 fc ff
	ff		 and	 ecx, -991		; fffffc21H
  00647	83 c9 21	 or	 ecx, 33			; 00000021H
  0064a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  0064d	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00652	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  00656	2b c7		 sub	 eax, edi
  00658	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  0065d	8b 30		 mov	 esi, DWORD PTR [eax]
  0065f	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  00665	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  00668	81 e6 ff 03 e0
	ff		 and	 esi, -2096129		; ffe003ffH
  0066e	0b ce		 or	 ecx, esi
  00670	89 08		 mov	 DWORD PTR [eax], ecx
  00672	39 15 00 00 00
	00		 cmp	 DWORD PTR _prev_prev_len, edx
  00678	0f 85 a0 05 00
	00		 jne	 $LN122@insert_op
  0067e	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00684	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00687	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0068c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0068f	75 14		 jne	 SHORT $LN111@insert_op
  00691	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00694	81 e2 20 fc ff
	ff		 and	 edx, -992		; fffffc20H
  0069a	83 ca 20	 or	 edx, 32			; 00000020H
  0069d	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  006a0	e9 79 05 00 00	 jmp	 $LN122@insert_op
$LN111@insert_op:
  006a5	83 f8 33	 cmp	 eax, 51			; 00000033H
  006a8	75 13		 jne	 SHORT $LN112@insert_op
  006aa	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  006ad	25 35 fc ff ff	 and	 eax, -971		; fffffc35H
  006b2	83 c8 35	 or	 eax, 53			; 00000035H
  006b5	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  006b8	e9 61 05 00 00	 jmp	 $LN122@insert_op
$LN112@insert_op:
  006bd	83 f8 06	 cmp	 eax, 6
  006c0	0f 85 58 05 00
	00		 jne	 $LN122@insert_op
  006c6	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  006c9	81 e2 36 fc ff
	ff		 and	 edx, -970		; fffffc36H
  006cf	83 ca 36	 or	 edx, 54			; 00000036H
  006d2	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  006d5	e9 44 05 00 00	 jmp	 $LN122@insert_op
$LN43@insert_op:

; 451  : #endif
; 452  :       SETREG(ctop,reg);
; 453  :     break;
; 454  : 
; 455  :    case WRITE_VALUE: SKIPBAD();

  006da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  006e1	0f 85 1e fa ff
	ff		 jne	 $LN129@insert_op

; 456  : #if STRUCT_COMPRESS
; 457  :       PCOMPRESS(WRITE_VALUE,WRITE_VAL_VAL,
; 458  :         PUT_STRUCTURE,PUT_WRITE_VAL_VAL,
; 459  :         PUSH_STRUCTURE,PUSH_VAL_VAL,
; 460  :         WRITE_CONSTANT,CONSTANT_VAL_VAL)

  006e7	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  006ec	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  006f2	0f 85 13 05 00
	00		 jne	 $LN67@insert_op
  006f8	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  006fb	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00701	3b cf		 cmp	 ecx, edi
  00703	0f 85 9d 00 00
	00		 jne	 $LN113@insert_op
  00709	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0070c	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00710	81 e1 25 fc ff
	ff		 and	 ecx, -987		; fffffc25H
  00716	83 c9 25	 or	 ecx, 37			; 00000025H
  00719	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  0071c	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00721	2b c7		 sub	 eax, edi
  00723	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  00728	8b 08		 mov	 ecx, DWORD PTR [eax]
  0072a	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00730	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00733	81 e1 ff 03 e0
	ff		 and	 ecx, -2096129		; ffe003ffH
  00739	0b d1		 or	 edx, ecx
  0073b	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _prev_prev_len, 2
  00742	89 10		 mov	 DWORD PTR [eax], edx
  00744	0f 85 d4 04 00
	00		 jne	 $LN122@insert_op
  0074a	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00750	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00753	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00758	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0075b	75 14		 jne	 SHORT $LN114@insert_op
  0075d	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00760	81 e2 24 fc ff
	ff		 and	 edx, -988		; fffffc24H
  00766	83 ca 24	 or	 edx, 36			; 00000024H
  00769	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  0076c	e9 ad 04 00 00	 jmp	 $LN122@insert_op
$LN114@insert_op:
  00771	83 f8 33	 cmp	 eax, 51			; 00000033H
  00774	75 13		 jne	 SHORT $LN115@insert_op
  00776	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00779	25 39 fc ff ff	 and	 eax, -967		; fffffc39H
  0077e	83 c8 39	 or	 eax, 57			; 00000039H
  00781	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00784	e9 95 04 00 00	 jmp	 $LN122@insert_op
$LN115@insert_op:
  00789	83 f8 06	 cmp	 eax, 6
  0078c	0f 85 8c 04 00
	00		 jne	 $LN122@insert_op
  00792	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00795	81 e2 3a fc ff
	ff		 and	 edx, -966		; fffffc3aH
  0079b	83 ca 3a	 or	 edx, 58			; 0000003aH
  0079e	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  007a1	e9 78 04 00 00	 jmp	 $LN122@insert_op
$LN113@insert_op:

; 461  : 
; 462  :       PCOMPRESS(WRITE_VARIABLE,WRITE_VAR_VAL,
; 463  :         PUT_STRUCTURE,PUT_WRITE_VAR_VAL,
; 464  :         PUSH_STRUCTURE,PUSH_VAR_VAL,
; 465  :         WRITE_CONSTANT,CONSTANT_VAR_VAL)

  007a6	3b ca		 cmp	 ecx, edx
  007a8	0f 85 5d 04 00
	00		 jne	 $LN67@insert_op
  007ae	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  007b1	81 e1 29 fc ff
	ff		 and	 ecx, -983		; fffffc29H
  007b7	83 c9 29	 or	 ecx, 41			; 00000029H
  007ba	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  007bd	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  007c2	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  007c6	2b c7		 sub	 eax, edi
  007c8	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  007cd	8b 30		 mov	 esi, DWORD PTR [eax]
  007cf	81 e1 ff 01 00
	00		 and	 ecx, 511		; 000001ffH
  007d5	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  007d8	81 e6 ff 03 e0
	ff		 and	 esi, -2096129		; ffe003ffH
  007de	0b ce		 or	 ecx, esi
  007e0	89 08		 mov	 DWORD PTR [eax], ecx
  007e2	39 15 00 00 00
	00		 cmp	 DWORD PTR _prev_prev_len, edx
  007e8	0f 85 30 04 00
	00		 jne	 $LN122@insert_op
  007ee	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  007f4	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  007f7	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  007fc	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  007ff	75 14		 jne	 SHORT $LN116@insert_op
  00801	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00804	81 e2 28 fc ff
	ff		 and	 edx, -984		; fffffc28H
  0080a	83 ca 28	 or	 edx, 40			; 00000028H
  0080d	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  00810	e9 09 04 00 00	 jmp	 $LN122@insert_op
$LN116@insert_op:
  00815	83 f8 33	 cmp	 eax, 51			; 00000033H
  00818	75 13		 jne	 SHORT $LN117@insert_op
  0081a	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0081d	25 3b fc ff ff	 and	 eax, -965		; fffffc3bH
  00822	83 c8 3b	 or	 eax, 59			; 0000003bH
  00825	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
  00828	e9 f1 03 00 00	 jmp	 $LN122@insert_op
$LN117@insert_op:
  0082d	83 f8 06	 cmp	 eax, 6
  00830	0f 85 e8 03 00
	00		 jne	 $LN122@insert_op
  00836	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00839	81 e2 3c fc ff
	ff		 and	 edx, -964		; fffffc3cH
  0083f	83 ca 3c	 or	 edx, 60			; 0000003cH
  00842	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
  00845	e9 d4 03 00 00	 jmp	 $LN122@insert_op
$LN29@insert_op:

; 466  : #endif
; 467  :       SETREG(ctop,reg);
; 468  :     break;
; 469  : 
; 470  :     case MOVE_REG: SKIPBAD();

  0084a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00851	0f 85 ae f8 ff
	ff		 jne	 $LN129@insert_op

; 471  : #if STRUCT_COMPRESS
; 472  :       if(1==prev_len && MOVE_REG==GETOP(ctop-1) &&
; 473  :          !(1==prev_prev_len && MOVE_REGx2==GETOP(ctop-2) )
; 474  :         )

  00857	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  0085c	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  00862	75 38		 jne	 SHORT $LN27@insert_op
  00864	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00867	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0086d	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00870	75 2a		 jne	 SHORT $LN27@insert_op
  00872	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_prev_len, ebp
  00878	75 0e		 jne	 SHORT $LN26@insert_op
  0087a	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  0087d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00883	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00886	74 14		 je	 SHORT $LN27@insert_op
$LN26@insert_op:

; 475  :         SETOP(ctop-1,MOVE_REGx2); /* instr compression */

  00888	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0088b	81 e1 2e fc ff
	ff		 and	 ecx, -978		; fffffc2eH
  00891	83 c9 2e	 or	 ecx, 46			; 0000002eH
  00894	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  00897	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
$LN27@insert_op:

; 476  : #endif
; 477  :       SETREG(ctop,reg);

  0089c	8b 10		 mov	 edx, DWORD PTR [eax]
  0089e	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  008a2	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  008a8	c1 e1 17	 shl	 ecx, 23			; 00000017H
  008ab	0b d1		 or	 edx, ecx
  008ad	89 10		 mov	 DWORD PTR [eax], edx

; 478  :       SETLEFT(ctop,arity);

  008af	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  008b4	8b 54 24 20	 mov	 edx, DWORD PTR _arity$[esp+12]
  008b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  008ba	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  008c0	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  008c3	81 e1 ff 03 e0
	ff		 and	 ecx, -2096129		; ffe003ffH
  008c9	0b d1		 or	 edx, ecx
  008cb	89 10		 mov	 DWORD PTR [eax], edx

; 479  :     break;

  008cd	e9 4c 03 00 00	 jmp	 $LN122@insert_op
$LN25@insert_op:

; 480  : 
; 481  :     case LOAD_VALUE: SKIPBAD();

  008d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  008d9	0f 85 26 f8 ff
	ff		 jne	 $LN129@insert_op

; 482  : #if STRUCT_COMPRESS
; 483  :       if(1==prev_len && LOAD_VALUE==GETOP(ctop-1)
; 484  :          && 1==GETREG(ctop-1) && 2==reg)

  008df	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  008e3	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  008e8	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  008ee	75 57		 jne	 SHORT $LN23@insert_op
  008f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  008f3	8b f2		 mov	 esi, edx
  008f5	81 e6 ff 03 00
	00		 and	 esi, 1023		; 000003ffH
  008fb	83 fe 1d	 cmp	 esi, 29			; 0000001dH
  008fe	75 47		 jne	 SHORT $LN23@insert_op
  00900	81 e2 00 00 80
	ff		 and	 edx, -8388608		; ff800000H
  00906	81 fa 00 00 80
	00		 cmp	 edx, 8388608		; 00800000H
  0090c	75 39		 jne	 SHORT $LN23@insert_op
  0090e	83 f9 02	 cmp	 ecx, 2
  00911	75 34		 jne	 SHORT $LN23@insert_op

; 485  :         {
; 486  :           SETOP(ctop-1,LOAD_VALUEx2); SETREG(ctop-1,arity); ctop--; break;

  00913	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00916	81 e2 2f fc ff
	ff		 and	 edx, -977		; fffffc2fH
  0091c	83 ca 2f	 or	 edx, 47			; 0000002fH
  0091f	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  00922	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00927	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0092a	8b 54 24 20	 mov	 edx, DWORD PTR _arity$[esp+12]
  0092e	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00934	c1 e2 17	 shl	 edx, 23			; 00000017H
  00937	0b ca		 or	 ecx, edx
  00939	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  0093c	29 3d 7c 01 00
	00		 sub	 DWORD PTR _g+380, edi
  00942	e9 d7 02 00 00	 jmp	 $LN122@insert_op
$LN23@insert_op:

; 487  :           /* An = REG = second,  Ai = LEFT = first */
; 488  :         } /* instr  compression */
; 489  : #endif
; 490  :       SETREG(ctop,reg);

  00947	8b 10		 mov	 edx, DWORD PTR [eax]
  00949	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  0094f	c1 e1 17	 shl	 ecx, 23			; 00000017H
  00952	0b d1		 or	 edx, ecx
  00954	89 10		 mov	 DWORD PTR [eax], edx

; 491  :       SETLEFT(ctop,arity);
; 492  :     break;

  00956	e9 a3 f9 ff ff	 jmp	 $LN127@insert_op
$LN22@insert_op:

; 493  : 
; 494  :     case LOAD_CONSTANT:
; 495  : #if STRUCT_COMPRESS
; 496  :       { cell small;
; 497  :         if( 1==prev_len && LOAD_VALUE==GETOP(ctop-1)
; 498  :             && 1==GETREG(ctop-1) && 2==reg
; 499  :             && ((small=input_fun(name,arity)), INTEGER(small))
; 500  :             && (no)OUTPUT_INT(small) <
; 501  :                  (no)(1<<(2-LSCALE+ARITYBITS-TAGBITS)))

  0095b	39 2d 00 00 00
	00		 cmp	 DWORD PTR _prev_len, ebp
  00961	8b 7c 24 20	 mov	 edi, DWORD PTR _arity$[esp+12]
  00965	8b 6c 24 1c	 mov	 ebp, DWORD PTR _name$[esp+12]
  00969	8b 74 24 18	 mov	 esi, DWORD PTR _reg$[esp+12]
  0096d	0f 85 8f 00 00
	00		 jne	 $LN121@insert_op
  00973	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00978	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0097b	8b d1		 mov	 edx, ecx
  0097d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00983	83 fa 1d	 cmp	 edx, 29			; 0000001dH
  00986	0f 85 7b 00 00
	00		 jne	 $LN21@insert_op
  0098c	81 e1 00 00 80
	ff		 and	 ecx, -8388608		; ff800000H
  00992	81 f9 00 00 80
	00		 cmp	 ecx, 8388608		; 00800000H
  00998	75 6d		 jne	 SHORT $LN21@insert_op
  0099a	83 fe 02	 cmp	 esi, 2
  0099d	75 68		 jne	 SHORT $LN21@insert_op
  0099f	57		 push	 edi
  009a0	55		 push	 ebp
  009a1	e8 00 00 00 00	 call	 _input_fun
  009a6	8b c8		 mov	 ecx, eax
  009a8	80 e1 03	 and	 cl, 3
  009ab	83 c4 08	 add	 esp, 8
  009ae	80 f9 01	 cmp	 cl, 1
  009b1	75 4f		 jne	 SHORT $LN121@insert_op
  009b3	8b d0		 mov	 edx, eax
  009b5	c1 fa 02	 sar	 edx, 2
  009b8	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  009be	73 42		 jae	 SHORT $LN121@insert_op

; 502  :           {
; 503  :             SETOP(ctop-1, opcode=LOAD_VAL_SHORT);

  009c0	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  009c6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  009c9	81 e2 30 fc ff
	ff		 and	 edx, -976		; fffffc30H
  009cf	bb 30 00 00 00	 mov	 ebx, 48			; 00000030H
  009d4	0b d3		 or	 edx, ebx
  009d6	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 504  :             SETREG(ctop-1,small); ctop--;

  009d9	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  009df	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  009e2	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  009e8	c1 e0 17	 shl	 eax, 23			; 00000017H
  009eb	0b d0		 or	 edx, eax
  009ed	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
  009f0	83 2d 7c 01 00
	00 04		 sub	 DWORD PTR _g+380, 4

; 505  :             break;

  009f7	8d 6e ff	 lea	 ebp, DWORD PTR [esi-1]
  009fa	8d 7e 02	 lea	 edi, DWORD PTR [esi+2]
  009fd	e9 1c 02 00 00	 jmp	 $LN122@insert_op
$LN121@insert_op:
  00a02	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
$LN21@insert_op:

; 506  :           }
; 507  :       } /* instr compression */
; 508  : #endif
; 509  :       SETREG(ctop,reg);

  00a07	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a09	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00a0f	c1 e6 17	 shl	 esi, 23			; 00000017H
  00a12	0b ce		 or	 ecx, esi

; 510  :       SETFUN(ctop,input_fun(name,arity));

  00a14	57		 push	 edi
  00a15	89 08		 mov	 DWORD PTR [eax], ecx
  00a17	83 05 7c 01 00
	00 04		 add	 DWORD PTR _g+380, 4
  00a1e	55		 push	 ebp
  00a1f	e8 00 00 00 00	 call	 _input_fun
  00a24	8b 15 7c 01 00
	00		 mov	 edx, DWORD PTR _g+380

; 511  :     break;

  00a2a	bd 01 00 00 00	 mov	 ebp, 1
  00a2f	83 c4 08	 add	 esp, 8
  00a32	89 02		 mov	 DWORD PTR [edx], eax
  00a34	8d 7d 03	 lea	 edi, DWORD PTR [ebp+3]
  00a37	e9 e2 01 00 00	 jmp	 $LN122@insert_op
$LN20@insert_op:

; 512  : 
; 513  :     case GET_CONSTANT:
; 514  :     case PUT_CONSTANT:
; 515  :     case UNIFY_CONSTANT:
; 516  :     case WRITE_CONSTANT: SKIPBAD();

  00a3c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00a43	0f 85 bc f6 ff
	ff		 jne	 $LN129@insert_op
$LN19@insert_op:

; 517  :       SETREG(ctop,reg);

  00a49	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00a4e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a50	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00a54	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00a5a	c1 e2 17	 shl	 edx, 23			; 00000017H
  00a5d	0b ca		 or	 ecx, edx
  00a5f	89 08		 mov	 DWORD PTR [eax], ecx
$LN76@insert_op:

; 518  :       SETFUN(ctop,input_fun(name,arity));

  00a61	8b 44 24 20	 mov	 eax, DWORD PTR _arity$[esp+12]
  00a65	8b 4c 24 1c	 mov	 ecx, DWORD PTR _name$[esp+12]
  00a69	01 3d 7c 01 00
	00		 add	 DWORD PTR _g+380, edi
  00a6f	50		 push	 eax
  00a70	51		 push	 ecx
  00a71	e8 00 00 00 00	 call	 _input_fun
  00a76	8b 15 7c 01 00
	00		 mov	 edx, DWORD PTR _g+380
  00a7c	83 c4 08	 add	 esp, 8
  00a7f	89 02		 mov	 DWORD PTR [edx], eax

; 519  :     break;

  00a81	e9 98 01 00 00	 jmp	 $LN122@insert_op
$LN18@insert_op:

; 520  : 
; 521  :     case BEGIN_C_CHUNK:
; 522  : #if defined(BEGIN_END)
; 523  :     if(TRUE)
; 524  : #else
; 525  :     if(g.inC)

  00a86	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  00a8d	74 3a		 je	 SHORT $LN17@insert_op

; 526  : #endif
; 527  :     {
; 528  :       SKIPBAD();

  00a8f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00a96	0f 85 69 f6 ff
	ff		 jne	 $LN129@insert_op

; 529  :       SETREG(ctop,reg);

  00a9c	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00aa1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00aa3	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00aa7	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00aad	c1 e2 17	 shl	 edx, 23			; 00000017H
  00ab0	0b ca		 or	 ecx, edx
  00ab2	89 08		 mov	 DWORD PTR [eax], ecx

; 530  :       SETFUN(ctop,(cell)name);

  00ab4	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00ab9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _name$[esp+12]
  00abd	03 c7		 add	 eax, edi
  00abf	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax

; 531  :     }
; 532  :     else

  00ac4	e9 53 01 00 00	 jmp	 $LN126@insert_op
$LN17@insert_op:

; 533  :        fatal_error("unexpected BEGIN_C_CHUNK");

  00ac9	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GJGDFOIO@unexpected?5BEGIN_C_CHUNK?$AA@
  00ace	e8 00 00 00 00	 call	 _fatal_error
  00ad3	83 c4 04	 add	 esp, 4

; 534  :     break;

  00ad6	e9 43 01 00 00	 jmp	 $LN122@insert_op
$LN14@insert_op:

; 535  : 
; 536  :     case END_C_CHUNK:
; 537  : #if defined(BEGIN_END)
; 538  :     if(TRUE)
; 539  : #else
; 540  :     if(g.inC)

  00adb	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  00ae2	74 1d		 je	 SHORT $LN13@insert_op

; 541  : #endif
; 542  :       SETREG(ctop,reg);

  00ae4	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00ae9	8b 10		 mov	 edx, DWORD PTR [eax]
  00aeb	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  00aef	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  00af5	c1 e1 17	 shl	 ecx, 23			; 00000017H
  00af8	0b d1		 or	 edx, ecx
  00afa	89 10		 mov	 DWORD PTR [eax], edx

; 543  :     else

  00afc	e9 1d 01 00 00	 jmp	 $LN122@insert_op
$LN13@insert_op:

; 544  :       fatal_error("unexpected END_C_CHUNK");

  00b01	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DCOCMCNK@unexpected?5END_C_CHUNK?$AA@
  00b06	e8 00 00 00 00	 call	 _fatal_error
  00b0b	83 c4 04	 add	 esp, 4

; 545  :     break;

  00b0e	e9 0b 01 00 00	 jmp	 $LN122@insert_op
$LN11@insert_op:

; 546  : 
; 547  :     case END: SKIPBAD();

  00b13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00b1a	0f 85 e5 f5 ff
	ff		 jne	 $LN129@insert_op

; 548  :       SETREG(ctop,reg); ctop++;

  00b20	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00b25	8b 10		 mov	 edx, DWORD PTR [eax]
  00b27	8b 4c 24 18	 mov	 ecx, DWORD PTR _reg$[esp+12]
  00b2b	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  00b31	c1 e1 17	 shl	 ecx, 23			; 00000017H
  00b34	0b d1		 or	 edx, ecx
  00b36	89 10		 mov	 DWORD PTR [eax], edx

; 549  :       badcode=TRUE;
; 550  :       if(!link_code((instr)bak_ctop,wam)) return FALSE;

  00b38	8b 54 24 24	 mov	 edx, DWORD PTR _wam$[esp+12]
  00b3c	a1 80 01 00 00	 mov	 eax, DWORD PTR _g+384
  00b41	01 3d 7c 01 00
	00		 add	 DWORD PTR _g+380, edi
  00b47	52		 push	 edx
  00b48	89 2d 00 00 00
	00		 mov	 DWORD PTR _badcode, ebp
  00b4e	e8 00 00 00 00	 call	 _link_code
  00b53	83 c4 04	 add	 esp, 4
  00b56	85 c0		 test	 eax, eax
  00b58	0f 84 a7 f5 ff
	ff		 je	 $LN129@insert_op

; 551  :       g.linking=INPUT_INT(0);

  00b5e	89 2d f4 00 00
	00		 mov	 DWORD PTR _g+244, ebp

; 552  :     break;

  00b64	e9 b5 00 00 00	 jmp	 $LN122@insert_op
$LN8@insert_op:

; 553  : 
; 554  :     case ARITH:
; 555  :       SKIPBAD();

  00b69	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00b70	0f 85 8f f5 ff
	ff		 jne	 $LN129@insert_op

; 556  :       SETOP(ctop,(opcode+arity));

  00b76	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00b7b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b7d	8b 54 24 20	 mov	 edx, DWORD PTR _arity$[esp+12]
  00b81	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  00b87	83 c2 4a	 add	 edx, 74			; 0000004aH
  00b8a	0b ca		 or	 ecx, edx
  00b8c	89 08		 mov	 DWORD PTR [eax], ecx

; 557  :       if(reg)

  00b8e	8b 44 24 18	 mov	 eax, DWORD PTR _reg$[esp+12]
  00b92	85 c0		 test	 eax, eax
  00b94	0f 84 84 00 00
	00		 je	 $LN122@insert_op

; 558  :         {
; 559  :           SETREG(ctop,reg);

  00b9a	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00ba0	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ba2	c1 e0 17	 shl	 eax, 23			; 00000017H
  00ba5	81 e2 ff ff 1f
	00		 and	 edx, 2097151		; 001fffffH
  00bab	0b d0		 or	 edx, eax

; 560  : #if 0
; 561  :           if(SELF_INFO_1==opcode+arity)
; 562  :             {cell n=GETARITY(currpred)-1;
; 563  :              SETLEFT(ctop,n);
; 564  :             }
; 565  :           else
; 566  : #endif
; 567  :             SETLEFT(ctop,((cell)(*name-'0')));

  00bad	8b 44 24 1c	 mov	 eax, DWORD PTR _name$[esp+12]
  00bb1	89 11		 mov	 DWORD PTR [ecx], edx
  00bb3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00bb6	83 e9 30	 sub	 ecx, 48			; 00000030H

; 568  :         }
; 569  :     break;

  00bb9	e9 44 f7 ff ff	 jmp	 $LN128@insert_op
$LN5@insert_op:

; 570  : 
; 571  :     case INLINE:
; 572  :     case BUILTIN:
; 573  :       SKIPBAD();

  00bbe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00bc5	0f 85 3a f5 ff
	ff		 jne	 $LN129@insert_op

; 574  :       SETREG(ctop,reg);

  00bcb	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00bd0	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bd2	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00bd6	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00bdc	c1 e2 17	 shl	 edx, 23			; 00000017H
  00bdf	0b ca		 or	 ecx, edx
  00be1	89 08		 mov	 DWORD PTR [eax], ecx

; 575  :       SETOP(ctop,opcode+arity);

  00be3	8b 44 24 20	 mov	 eax, DWORD PTR _arity$[esp+12]
  00be7	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  00bea	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00bef	8b 10		 mov	 edx, DWORD PTR [eax]
  00bf1	81 e2 00 fc ff
	ff		 and	 edx, -1024		; fffffc00H

; 576  :     break;

  00bf7	eb 21		 jmp	 SHORT $LN125@insert_op
$LN3@insert_op:

; 577  : 
; 578  :     default: SKIPBAD();

  00bf9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _badcode, 0
  00c00	0f 85 ff f4 ff
	ff		 jne	 $LN129@insert_op

; 579  :       SETREG(ctop,reg);

  00c06	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
$LN67@insert_op:
  00c0b	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c0d	8b 54 24 18	 mov	 edx, DWORD PTR _reg$[esp+12]
  00c11	81 e1 ff ff 1f
	00		 and	 ecx, 2097151		; 001fffffH
  00c17	c1 e2 17	 shl	 edx, 23			; 00000017H
$LN125@insert_op:
  00c1a	0b ca		 or	 ecx, edx
$LN126@insert_op:
  00c1c	89 08		 mov	 DWORD PTR [eax], ecx
$LN122@insert_op:

; 580  :   }
; 581  :   IF_OVERSTACK("insert_op",(term *)(ctop),InstrStk,g.shared,NO());

  00c1e	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00c23	3b 05 88 01 00
	00		 cmp	 eax, DWORD PTR _g+392
  00c29	72 1c		 jb	 SHORT $LN1@insert_op
  00c2b	68 00 00 00 00	 push	 OFFSET ??_C@_09OLBFBHOO@insert_op?$AA@
  00c30	68 74 01 00 00	 push	 OFFSET _g+372
  00c35	6a 00		 push	 0
  00c37	50		 push	 eax
  00c38	e8 00 00 00 00	 call	 _overflow_by
  00c3d	83 c4 10	 add	 esp, 16			; 00000010H
  00c40	5f		 pop	 edi
  00c41	5e		 pop	 esi
  00c42	5d		 pop	 ebp
  00c43	33 c0		 xor	 eax, eax
  00c45	5b		 pop	 ebx

; 586  : }

  00c46	c3		 ret	 0
$LN1@insert_op:

; 582  :   prev_prev_len=prev_len;

  00c47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _prev_len

; 583  :   prev_len=instr_len[opcode];

  00c4d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instr_len

; 584  :   ctop++;

  00c53	03 c7		 add	 eax, edi
  00c55	5f		 pop	 edi
  00c56	89 0d 00 00 00
	00		 mov	 DWORD PTR _prev_prev_len, ecx
  00c5c	0f b6 0c 1a	 movzx	 ecx, BYTE PTR [edx+ebx]
  00c60	5e		 pop	 esi
  00c61	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax

; 585  :   return TRUE;

  00c66	8b c5		 mov	 eax, ebp
  00c68	5d		 pop	 ebp
  00c69	89 0d 00 00 00
	00		 mov	 DWORD PTR _prev_len, ecx
  00c6f	5b		 pop	 ebx

; 586  : }

  00c70	c3		 ret	 0
  00c71	8d 49 00	 npad	 3
$LN131@insert_op:
  00c74	00 00 00 00	 DD	 $LN11@insert_op
  00c78	00 00 00 00	 DD	 $LN71@insert_op
  00c7c	00 00 00 00	 DD	 $LN57@insert_op
  00c80	00 00 00 00	 DD	 $LN65@insert_op
  00c84	00 00 00 00	 DD	 $LN43@insert_op
  00c88	00 00 00 00	 DD	 $LN20@insert_op
  00c8c	00 00 00 00	 DD	 $LN73@insert_op
  00c90	00 00 00 00	 DD	 $LN29@insert_op
  00c94	00 00 00 00	 DD	 $LN75@insert_op
  00c98	00 00 00 00	 DD	 $LN77@insert_op
  00c9c	00 00 00 00	 DD	 $LN22@insert_op
  00ca0	00 00 00 00	 DD	 $LN25@insert_op
  00ca4	00 00 00 00	 DD	 $LN59@insert_op
  00ca8	00 00 00 00	 DD	 $LN18@insert_op
  00cac	00 00 00 00	 DD	 $LN14@insert_op
  00cb0	00 00 00 00	 DD	 $LN5@insert_op
  00cb4	00 00 00 00	 DD	 $LN8@insert_op
  00cb8	00 00 00 00	 DD	 $LN99@insert_op
  00cbc	00 00 00 00	 DD	 $LN82@insert_op
  00cc0	00 00 00 00	 DD	 $LN3@insert_op
$LN118@insert_op:
  00cc4	00		 DB	 0
  00cc5	01		 DB	 1
  00cc6	02		 DB	 2
  00cc7	03		 DB	 3
  00cc8	04		 DB	 4
  00cc9	05		 DB	 5
  00cca	05		 DB	 5
  00ccb	05		 DB	 5
  00ccc	06		 DB	 6
  00ccd	05		 DB	 5
  00cce	06		 DB	 6
  00ccf	07		 DB	 7
  00cd0	08		 DB	 8
  00cd1	08		 DB	 8
  00cd2	13		 DB	 19			; 00000013H
  00cd3	13		 DB	 19			; 00000013H
  00cd4	13		 DB	 19			; 00000013H
  00cd5	09		 DB	 9
  00cd6	13		 DB	 19			; 00000013H
  00cd7	13		 DB	 19			; 00000013H
  00cd8	13		 DB	 19			; 00000013H
  00cd9	13		 DB	 19			; 00000013H
  00cda	13		 DB	 19			; 00000013H
  00cdb	13		 DB	 19			; 00000013H
  00cdc	13		 DB	 19			; 00000013H
  00cdd	13		 DB	 19			; 00000013H
  00cde	13		 DB	 19			; 00000013H
  00cdf	13		 DB	 19			; 00000013H
  00ce0	0a		 DB	 10			; 0000000aH
  00ce1	0b		 DB	 11			; 0000000bH
  00ce2	13		 DB	 19			; 00000013H
  00ce3	13		 DB	 19			; 00000013H
  00ce4	13		 DB	 19			; 00000013H
  00ce5	13		 DB	 19			; 00000013H
  00ce6	13		 DB	 19			; 00000013H
  00ce7	13		 DB	 19			; 00000013H
  00ce8	13		 DB	 19			; 00000013H
  00ce9	13		 DB	 19			; 00000013H
  00cea	13		 DB	 19			; 00000013H
  00ceb	13		 DB	 19			; 00000013H
  00cec	13		 DB	 19			; 00000013H
  00ced	13		 DB	 19			; 00000013H
  00cee	13		 DB	 19			; 00000013H
  00cef	13		 DB	 19			; 00000013H
  00cf0	13		 DB	 19			; 00000013H
  00cf1	13		 DB	 19			; 00000013H
  00cf2	13		 DB	 19			; 00000013H
  00cf3	13		 DB	 19			; 00000013H
  00cf4	13		 DB	 19			; 00000013H
  00cf5	13		 DB	 19			; 00000013H
  00cf6	08		 DB	 8
  00cf7	06		 DB	 6
  00cf8	0c		 DB	 12			; 0000000cH
  00cf9	13		 DB	 19			; 00000013H
  00cfa	13		 DB	 19			; 00000013H
  00cfb	13		 DB	 19			; 00000013H
  00cfc	13		 DB	 19			; 00000013H
  00cfd	13		 DB	 19			; 00000013H
  00cfe	13		 DB	 19			; 00000013H
  00cff	13		 DB	 19			; 00000013H
  00d00	13		 DB	 19			; 00000013H
  00d01	13		 DB	 19			; 00000013H
  00d02	13		 DB	 19			; 00000013H
  00d03	0d		 DB	 13			; 0000000dH
  00d04	0e		 DB	 14			; 0000000eH
  00d05	13		 DB	 19			; 00000013H
  00d06	0f		 DB	 15			; 0000000fH
  00d07	13		 DB	 19			; 00000013H
  00d08	13		 DB	 19			; 00000013H
  00d09	13		 DB	 19			; 00000013H
  00d0a	13		 DB	 19			; 00000013H
  00d0b	13		 DB	 19			; 00000013H
  00d0c	13		 DB	 19			; 00000013H
  00d0d	13		 DB	 19			; 00000013H
  00d0e	10		 DB	 16			; 00000010H
  00d0f	13		 DB	 19			; 00000013H
  00d10	13		 DB	 19			; 00000013H
  00d11	13		 DB	 19			; 00000013H
  00d12	13		 DB	 19			; 00000013H
  00d13	13		 DB	 19			; 00000013H
  00d14	13		 DB	 19			; 00000013H
  00d15	13		 DB	 19			; 00000013H
  00d16	13		 DB	 19			; 00000013H
  00d17	13		 DB	 19			; 00000013H
  00d18	13		 DB	 19			; 00000013H
  00d19	13		 DB	 19			; 00000013H
  00d1a	13		 DB	 19			; 00000013H
  00d1b	13		 DB	 19			; 00000013H
  00d1c	13		 DB	 19			; 00000013H
  00d1d	13		 DB	 19			; 00000013H
  00d1e	13		 DB	 19			; 00000013H
  00d1f	13		 DB	 19			; 00000013H
  00d20	13		 DB	 19			; 00000013H
  00d21	13		 DB	 19			; 00000013H
  00d22	13		 DB	 19			; 00000013H
  00d23	13		 DB	 19			; 00000013H
  00d24	13		 DB	 19			; 00000013H
  00d25	13		 DB	 19			; 00000013H
  00d26	13		 DB	 19			; 00000013H
  00d27	13		 DB	 19			; 00000013H
  00d28	13		 DB	 19			; 00000013H
  00d29	13		 DB	 19			; 00000013H
  00d2a	13		 DB	 19			; 00000013H
  00d2b	13		 DB	 19			; 00000013H
  00d2c	13		 DB	 19			; 00000013H
  00d2d	13		 DB	 19			; 00000013H
  00d2e	13		 DB	 19			; 00000013H
  00d2f	13		 DB	 19			; 00000013H
  00d30	13		 DB	 19			; 00000013H
  00d31	13		 DB	 19			; 00000013H
  00d32	13		 DB	 19			; 00000013H
  00d33	13		 DB	 19			; 00000013H
  00d34	13		 DB	 19			; 00000013H
  00d35	13		 DB	 19			; 00000013H
  00d36	13		 DB	 19			; 00000013H
  00d37	13		 DB	 19			; 00000013H
  00d38	13		 DB	 19			; 00000013H
  00d39	13		 DB	 19			; 00000013H
  00d3a	13		 DB	 19			; 00000013H
  00d3b	13		 DB	 19			; 00000013H
  00d3c	13		 DB	 19			; 00000013H
  00d3d	13		 DB	 19			; 00000013H
  00d3e	13		 DB	 19			; 00000013H
  00d3f	13		 DB	 19			; 00000013H
  00d40	13		 DB	 19			; 00000013H
  00d41	13		 DB	 19			; 00000013H
  00d42	13		 DB	 19			; 00000013H
  00d43	13		 DB	 19			; 00000013H
  00d44	13		 DB	 19			; 00000013H
  00d45	13		 DB	 19			; 00000013H
  00d46	13		 DB	 19			; 00000013H
  00d47	13		 DB	 19			; 00000013H
  00d48	13		 DB	 19			; 00000013H
  00d49	13		 DB	 19			; 00000013H
  00d4a	13		 DB	 19			; 00000013H
  00d4b	13		 DB	 19			; 00000013H
  00d4c	13		 DB	 19			; 00000013H
  00d4d	13		 DB	 19			; 00000013H
  00d4e	13		 DB	 19			; 00000013H
  00d4f	13		 DB	 19			; 00000013H
  00d50	13		 DB	 19			; 00000013H
  00d51	13		 DB	 19			; 00000013H
  00d52	13		 DB	 19			; 00000013H
  00d53	13		 DB	 19			; 00000013H
  00d54	13		 DB	 19			; 00000013H
  00d55	13		 DB	 19			; 00000013H
  00d56	13		 DB	 19			; 00000013H
  00d57	13		 DB	 19			; 00000013H
  00d58	13		 DB	 19			; 00000013H
  00d59	13		 DB	 19			; 00000013H
  00d5a	13		 DB	 19			; 00000013H
  00d5b	13		 DB	 19			; 00000013H
  00d5c	13		 DB	 19			; 00000013H
  00d5d	13		 DB	 19			; 00000013H
  00d5e	13		 DB	 19			; 00000013H
  00d5f	13		 DB	 19			; 00000013H
  00d60	13		 DB	 19			; 00000013H
  00d61	13		 DB	 19			; 00000013H
  00d62	13		 DB	 19			; 00000013H
  00d63	13		 DB	 19			; 00000013H
  00d64	13		 DB	 19			; 00000013H
  00d65	13		 DB	 19			; 00000013H
  00d66	13		 DB	 19			; 00000013H
  00d67	13		 DB	 19			; 00000013H
  00d68	13		 DB	 19			; 00000013H
  00d69	13		 DB	 19			; 00000013H
  00d6a	13		 DB	 19			; 00000013H
  00d6b	13		 DB	 19			; 00000013H
  00d6c	13		 DB	 19			; 00000013H
  00d6d	13		 DB	 19			; 00000013H
  00d6e	13		 DB	 19			; 00000013H
  00d6f	13		 DB	 19			; 00000013H
  00d70	13		 DB	 19			; 00000013H
  00d71	13		 DB	 19			; 00000013H
  00d72	13		 DB	 19			; 00000013H
  00d73	13		 DB	 19			; 00000013H
  00d74	13		 DB	 19			; 00000013H
  00d75	13		 DB	 19			; 00000013H
  00d76	13		 DB	 19			; 00000013H
  00d77	13		 DB	 19			; 00000013H
  00d78	13		 DB	 19			; 00000013H
  00d79	13		 DB	 19			; 00000013H
  00d7a	13		 DB	 19			; 00000013H
  00d7b	13		 DB	 19			; 00000013H
  00d7c	13		 DB	 19			; 00000013H
  00d7d	13		 DB	 19			; 00000013H
  00d7e	13		 DB	 19			; 00000013H
  00d7f	13		 DB	 19			; 00000013H
  00d80	13		 DB	 19			; 00000013H
  00d81	13		 DB	 19			; 00000013H
  00d82	13		 DB	 19			; 00000013H
  00d83	13		 DB	 19			; 00000013H
  00d84	13		 DB	 19			; 00000013H
  00d85	13		 DB	 19			; 00000013H
  00d86	13		 DB	 19			; 00000013H
  00d87	13		 DB	 19			; 00000013H
  00d88	13		 DB	 19			; 00000013H
  00d89	13		 DB	 19			; 00000013H
  00d8a	13		 DB	 19			; 00000013H
  00d8b	13		 DB	 19			; 00000013H
  00d8c	13		 DB	 19			; 00000013H
  00d8d	13		 DB	 19			; 00000013H
  00d8e	0f		 DB	 15			; 0000000fH
  00d8f	13		 DB	 19			; 00000013H
  00d90	13		 DB	 19			; 00000013H
  00d91	13		 DB	 19			; 00000013H
  00d92	13		 DB	 19			; 00000013H
  00d93	13		 DB	 19			; 00000013H
  00d94	13		 DB	 19			; 00000013H
  00d95	13		 DB	 19			; 00000013H
  00d96	13		 DB	 19			; 00000013H
  00d97	13		 DB	 19			; 00000013H
  00d98	13		 DB	 19			; 00000013H
  00d99	13		 DB	 19			; 00000013H
  00d9a	13		 DB	 19			; 00000013H
  00d9b	13		 DB	 19			; 00000013H
  00d9c	13		 DB	 19			; 00000013H
  00d9d	13		 DB	 19			; 00000013H
  00d9e	13		 DB	 19			; 00000013H
  00d9f	13		 DB	 19			; 00000013H
  00da0	11		 DB	 17			; 00000011H
  00da1	12		 DB	 18			; 00000012H
_insert_op ENDP
_TEXT	ENDS
PUBLIC	_init_code
EXTRN	_opcount:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _init_code
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_init_code PROC						; COMDAT

; 590  :   no ok; opcount=ZERO;
; 591  :   SETOP(ctop,END); /* therfore the code array starts with an END */

  00000	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  00005	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _opcount, 0
  0000f	81 20 00 fc ff
	ff		 and	 DWORD PTR [eax], -1024	; fffffc00H

; 592  :   ctop+=instr_len[END]; /* this creates the action if the WAM fails */

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _instr_len
  0001a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0001d	8b 15 7c 01 00
	00		 mov	 edx, DWORD PTR _g+380
  00023	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 593  :   currpred=g.true;

  00026	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR _g+100
  0002c	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax

; 594  :   badcode=TRUE;
; 595  :   prev_prev_len=prev_len=2;
; 596  :   SETOP(ctop,PROCEED);    /* this creates true/0 => if the WAM succeeds */

  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	81 e2 12 fc ff
	ff		 and	 edx, -1006		; fffffc12H
  00039	83 ca 12	 or	 edx, 18			; 00000012H
  0003c	89 10		 mov	 DWORD PTR [eax], edx

; 597  :   ok=DEFPRED(g.true,(no)ctop);

  0003e	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00045	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR _g+100
  0004b	89 0d 00 00 00
	00		 mov	 DWORD PTR _currpred, ecx
  00051	56		 push	 esi
  00052	b9 02 00 00 00	 mov	 ecx, 2
  00057	50		 push	 eax
  00058	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  0005d	89 0d 00 00 00
	00		 mov	 DWORD PTR _prev_len, ecx
  00063	89 0d 00 00 00
	00		 mov	 DWORD PTR _prev_prev_len, ecx
  00069	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  0006f	51		 push	 ecx
  00070	52		 push	 edx
  00071	50		 push	 eax
  00072	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _badcode, 1
  0007c	e8 00 00 00 00	 call	 _hdef
  00081	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  00088	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR _g+100
  0008e	51		 push	 ecx
  0008f	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  00095	8b f0		 mov	 esi, eax
  00097	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  0009c	52		 push	 edx
  0009d	50		 push	 eax
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 _hdef

; 598  :   SETFUN(ctop,g.true);

  000a4	a1 7c 01 00 00	 mov	 eax, DWORD PTR _g+380
  000a9	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR _g+100
  000af	83 c0 04	 add	 eax, 4
  000b2	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  000b7	89 10		 mov	 DWORD PTR [eax], edx

; 599  :   ctop++;

  000b9	83 05 7c 01 00
	00 04		 add	 DWORD PTR _g+380, 4
  000c0	83 c4 20	 add	 esp, 32			; 00000020H

; 600  :   return ok;

  000c3	8b c6		 mov	 eax, esi
  000c5	5e		 pop	 esi

; 601  : }

  000c6	c3		 ret	 0
_init_code ENDP
_TEXT	ENDS
EXTRN	_ungetc:PROC
EXTRN	_getc:PROC
; Function compile flags: /Ogtpy
;	COMDAT _skip_header
_TEXT	SEGMENT
_skip_header PROC					; COMDAT
; _f$ = edi

; 607  :   no b,c=getc(f);

  00000	57		 push	 edi
  00001	e8 00 00 00 00	 call	 _getc
  00006	83 c4 04	 add	 esp, 4

; 608  :   if('#'!=c)

  00009	83 f8 23	 cmp	 eax, 35			; 00000023H
  0000c	74 0b		 je	 SHORT $LN7@skip_heade

; 609  :     { ungetc(c,f);

  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _ungetc
  00015	83 c4 08	 add	 esp, 8

; 619  :   }
; 620  : }

  00018	c3		 ret	 0
$LN7@skip_heade:
  00019	56		 push	 esi

; 610  :       return;
; 611  :     }
; 612  :   else
; 613  :     b=c;
; 614  :   while(TRUE)
; 615  :   {
; 616  :     b=c;
; 617  :     GET_BYTE(c);

  0001a	57		 push	 edi
  0001b	be 23 00 00 00	 mov	 esi, 35			; 00000023H
  00020	e8 00 00 00 00	 call	 _getc
  00025	83 c4 04	 add	 esp, 4
  00028	83 f8 ff	 cmp	 eax, -1
  0002b	74 28		 je	 SHORT $LN14@skip_heade
  0002d	8d 49 00	 npad	 3
$LL5@skip_heade:

; 618  :     if('$'==b && '0'==c) {GET_BYTE(c); break;}

  00030	83 fe 24	 cmp	 esi, 36			; 00000024H
  00033	75 05		 jne	 SHORT $LN2@skip_heade
  00035	83 f8 30	 cmp	 eax, 48			; 00000030H
  00038	74 12		 je	 SHORT $LN13@skip_heade
$LN2@skip_heade:

; 610  :       return;
; 611  :     }
; 612  :   else
; 613  :     b=c;
; 614  :   while(TRUE)
; 615  :   {
; 616  :     b=c;
; 617  :     GET_BYTE(c);

  0003a	57		 push	 edi
  0003b	8b f0		 mov	 esi, eax
  0003d	e8 00 00 00 00	 call	 _getc
  00042	83 c4 04	 add	 esp, 4
  00045	83 f8 ff	 cmp	 eax, -1
  00048	75 e6		 jne	 SHORT $LL5@skip_heade
  0004a	5e		 pop	 esi

; 619  :   }
; 620  : }

  0004b	c3		 ret	 0
$LN13@skip_heade:

; 618  :     if('$'==b && '0'==c) {GET_BYTE(c); break;}

  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 _getc
  00052	83 c4 04	 add	 esp, 4
$LN14@skip_heade:
  00055	5e		 pop	 esi

; 619  :   }
; 620  : }

  00056	c3		 ret	 0
_skip_header ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@GAECLDEH@Invalid?5operator?5declaration?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NABFCGDP@opcount?$DN?$CFld?5g?4timestamp?$DN?$CFd?5op?3?5?$CF@ ; `string'
PUBLIC	??_C@_07LOAHCGEB@?$CFld?$CFs?$CFs?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	_make_op:PROC
EXTRN	_sscanf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BN@GAECLDEH@Invalid?5operator?5declaration?$AA@
CONST	SEGMENT
??_C@_0BN@GAECLDEH@Invalid?5operator?5declaration?$AA@ DB 'Invalid operat'
	DB	'or declaration', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NABFCGDP@opcount?$DN?$CFld?5g?4timestamp?$DN?$CFd?5op?3?5?$CF@
CONST	SEGMENT
??_C@_0CJ@NABFCGDP@opcount?$DN?$CFld?5g?4timestamp?$DN?$CFd?5op?3?5?$CF@ DB 'o'
	DB	'pcount=%ld g.timestamp=%d op: %ld,%s,%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LOAHCGEB@?$CFld?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_07LOAHCGEB@?$CFld?$CFs?$CFs?$AA@ DB '%ld%s%s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _loadoperator
_TEXT	SEGMENT
_val$7358 = -524					; size = 4
_val$7351 = -524					; size = 4
_pri$ = -520						; size = 4
_name$ = -516						; size = 256
_assoc$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_buf$ = 8						; size = 4
_loadoperator PROC					; COMDAT

; 624  : {

  00000	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 08 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+524], eax

; 625  :   char assoc[MAXNAME], name[MAXNAME];
; 626  :   no pri,ok=TRUE; bp_long self=g.self; /* backup the value of g.self */
; 627  : 
; 628  :   if(g.inC)

  00014	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  0001b	8b 84 24 10 02
	00 00		 mov	 eax, DWORD PTR _buf$[esp+520]
  00022	53		 push	 ebx
  00023	8b 1d f0 00 00
	00		 mov	 ebx, DWORD PTR _g+240
  00029	57		 push	 edi
  0002a	bf 01 00 00 00	 mov	 edi, 1
  0002f	74 13		 je	 SHORT $LN3@loadoperat

; 629  :   {
; 630  :      /* we do this to force internalizing operator names */
; 631  :      if(LOADTIME==g.timestamp) g.self=0; /* overrides g.inC */

  00031	80 3d 70 01 00
	00 01		 cmp	 BYTE PTR _g+368, 1
  00038	75 0a		 jne	 SHORT $LN3@loadoperat
  0003a	c7 05 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g+240, 0
$LN3@loadoperat:
  00044	56		 push	 esi

; 632  :    }
; 633  : 
; 634  :   sscanf(buf, "%ld%s%s", &pri, assoc, name);

  00045	8d 4c 24 14	 lea	 ecx, DWORD PTR _name$[esp+536]
  00049	51		 push	 ecx
  0004a	8d 94 24 18 01
	00 00		 lea	 edx, DWORD PTR _assoc$[esp+540]
  00051	52		 push	 edx
  00052	8d 4c 24 18	 lea	 ecx, DWORD PTR _pri$[esp+544]
  00056	51		 push	 ecx
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_07LOAHCGEB@?$CFld?$CFs?$CFs?$AA@
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _sscanf

; 635  : 
; 636  :   if (!make_op(input_fun(name,0),
; 637  :                input_fun(assoc,0),INPUT_INT(pri),g.timestamp))

  00062	8d 54 24 20	 lea	 edx, DWORD PTR _val$7351[esp+556]
  00066	52		 push	 edx
  00067	8d 84 24 2c 01
	00 00		 lea	 eax, DWORD PTR _assoc$[esp+560]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _get_one_int
  00074	83 c4 1c	 add	 esp, 28			; 0000001cH
  00077	85 c0		 test	 eax, eax
  00079	74 0c		 je	 SHORT $LN8@loadoperat
  0007b	8b 74 24 0c	 mov	 esi, DWORD PTR _val$7351[esp+536]
  0007f	03 f6		 add	 esi, esi
  00081	03 f6		 add	 esi, esi
  00083	0b f7		 or	 esi, edi
  00085	eb 14		 jmp	 SHORT $LN7@loadoperat
$LN8@loadoperat:
  00087	8d 8c 24 14 01
	00 00		 lea	 ecx, DWORD PTR _assoc$[esp+536]
  0008e	6a 00		 push	 0
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 _new_func
  00096	83 c4 08	 add	 esp, 8
  00099	8b f0		 mov	 esi, eax
$LN7@loadoperat:
  0009b	8d 54 24 0c	 lea	 edx, DWORD PTR _val$7358[esp+536]
  0009f	52		 push	 edx
  000a0	8d 44 24 18	 lea	 eax, DWORD PTR _name$[esp+540]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _get_one_int
  000aa	83 c4 08	 add	 esp, 8
  000ad	85 c0		 test	 eax, eax
  000af	74 0d		 je	 SHORT $LN12@loadoperat
  000b1	8b 44 24 0c	 mov	 eax, DWORD PTR _val$7358[esp+536]
  000b5	03 c0		 add	 eax, eax
  000b7	03 c0		 add	 eax, eax
  000b9	83 c8 01	 or	 eax, 1
  000bc	eb 0f		 jmp	 SHORT $LN11@loadoperat
$LN12@loadoperat:
  000be	8d 4c 24 14	 lea	 ecx, DWORD PTR _name$[esp+536]
  000c2	6a 00		 push	 0
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 _new_func
  000ca	83 c4 08	 add	 esp, 8
$LN11@loadoperat:
  000cd	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  000d4	8b 4c 24 10	 mov	 ecx, DWORD PTR _pri$[esp+536]
  000d8	52		 push	 edx
  000d9	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  000e0	0b d7		 or	 edx, edi
  000e2	52		 push	 edx
  000e3	56		 push	 esi
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _make_op
  000ea	83 c4 10	 add	 esp, 16			; 00000010H
  000ed	5e		 pop	 esi
  000ee	85 c0		 test	 eax, eax
  000f0	75 43		 jne	 SHORT $LN2@loadoperat

; 638  :     {
; 639  :       fprintf(STD_err, "opcount=%ld g.timestamp=%d op: %ld,%s,%s",
; 640  :            opcount,g.timestamp, pri, assoc, name);

  000f2	8b 54 24 0c	 mov	 edx, DWORD PTR _pri$[esp+532]
  000f6	8d 44 24 10	 lea	 eax, DWORD PTR _name$[esp+532]
  000fa	50		 push	 eax
  000fb	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00102	8d 8c 24 14 01
	00 00		 lea	 ecx, DWORD PTR _assoc$[esp+536]
  00109	51		 push	 ecx
  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _opcount
  00110	52		 push	 edx
  00111	50		 push	 eax
  00112	51		 push	 ecx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NABFCGDP@opcount?$DN?$CFld?5g?4timestamp?$DN?$CFd?5op?3?5?$CF@
  00118	e8 00 00 00 00	 call	 ___iob_func
  0011d	83 c0 40	 add	 eax, 64			; 00000040H
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _fprintf

; 641  :       warnmes("Invalid operator declaration");

  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GAECLDEH@Invalid?5operator?5declaration?$AA@
  0012b	e8 00 00 00 00	 call	 _warnmes
  00130	83 c4 20	 add	 esp, 32			; 00000020H

; 642  :       ok=FALSE;

  00133	33 ff		 xor	 edi, edi
$LN2@loadoperat:

; 643  :     }
; 644  : 
; 645  :   if(g.inC)

  00135	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0

; 648  :      }
; 649  :   return ok;

  0013c	8b c7		 mov	 eax, edi
  0013e	74 06		 je	 SHORT $LN1@loadoperat

; 646  :      {
; 647  :        g.self=self; /* restores g.self */

  00140	89 1d f0 00 00
	00		 mov	 DWORD PTR _g+240, ebx
$LN1@loadoperat:

; 650  : }

  00146	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+532]
  0014d	5f		 pop	 edi
  0014e	5b		 pop	 ebx
  0014f	33 cc		 xor	 ecx, esp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	81 c4 0c 02 00
	00		 add	 esp, 524		; 0000020cH
  0015c	c3		 ret	 0
_loadoperator ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _ii
_TEXT	SEGMENT
_reg$ = 8						; size = 4
_arity$ = 12						; size = 4
_wam$ = 16						; size = 4
_ii	PROC						; COMDAT
; _opcode$ = eax
; _name$ = ecx

; 655  :   return (opcode == OPERATOR)?
; 656  :          loadoperator(name):
; 657  :          insert_op(opcode,reg,name,arity,wam);

  00000	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  00005	75 0a		 jne	 SHORT $LN3@ii
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _loadoperator
  0000d	83 c4 04	 add	 esp, 4

; 658  : }

  00010	c3		 ret	 0
$LN3@ii:

; 655  :   return (opcode == OPERATOR)?
; 656  :          loadoperator(name):
; 657  :          insert_op(opcode,reg,name,arity,wam);

  00011	8b 54 24 0c	 mov	 edx, DWORD PTR _wam$[esp-4]
  00015	52		 push	 edx
  00016	8b 54 24 0c	 mov	 edx, DWORD PTR _arity$[esp]
  0001a	52		 push	 edx
  0001b	51		 push	 ecx
  0001c	8b 4c 24 10	 mov	 ecx, DWORD PTR _reg$[esp+8]
  00020	51		 push	 ecx
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _insert_op
  00027	83 c4 14	 add	 esp, 20			; 00000014H

; 658  : }

  0002a	c3		 ret	 0
_ii	ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BL@BHPFGAP@unable?5to?5load?5kernel?5file?$AA@ ; `string'
PUBLIC	??_C@_0P@LJOCCCLG@file?5not?5found?$AA@		; `string'
PUBLIC	??_C@_04IFHEJEN@?$DP?$DP?$DP?5?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	_wam$GSCopy$
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fclose:PROC
EXTRN	_quietmes:PROC
EXTRN	_fopen:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BHPFGAP@unable?5to?5load?5kernel?5file?$AA@
CONST	SEGMENT
??_C@_0BL@BHPFGAP@unable?5to?5load?5kernel?5file?$AA@ DB 'unable to load '
	DB	'kernel file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LJOCCCLG@file?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@LJOCCCLG@file?5not?5found?$AA@ DB 'file not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFHEJEN@?$DP?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_04IFHEJEN@?$DP?$DP?$DP?5?$AA@ DB '??? ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_file
_TEXT	SEGMENT
_reg$ = -65548						; size = 4
_wam$GSCopy$ = -65544					; size = 4
_sbuf$ = -65540						; size = 65536
__$ArrayPad$ = -4					; size = 4
_wam$ = 8						; size = 4
_load_file PROC						; COMDAT
; _fname$ = ecx

; 661  : {

  00000	b8 0c 00 01 00	 mov	 eax, 65548		; 0001000cH
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 08 00
	01 00		 mov	 DWORD PTR __$ArrayPad$[esp+65548], eax
  00018	8b 84 24 10 00
	01 00		 mov	 eax, DWORD PTR _wam$[esp+65544]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	8b f1		 mov	 esi, ecx

; 662  :   register no opcode,reg,arity;
; 663  :   no ok; FILE *f=fopen(fname,"rb");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00028	56		 push	 esi

; 684  :       ok=ii(opcode,reg,arity,sbuf,wam);

  00029	89 44 24 14	 mov	 DWORD PTR _wam$GSCopy$[esp+65564], eax
  0002d	e8 00 00 00 00	 call	 _fopen
  00032	8b f8		 mov	 edi, eax
  00034	83 c4 08	 add	 esp, 8
  00037	85 ff		 test	 edi, edi
  00039	75 40		 jne	 SHORT $LN12@load_file

; 664  :   char sbuf[MAXNBUF];
; 665  :   if(!f) {quietmes("%s",fname);

  0003b	56		 push	 esi
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00041	e8 00 00 00 00	 call	 _quietmes

; 666  :           quietmes("%s","??? ");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_04IFHEJEN@?$DP?$DP?$DP?5?$AA@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00050	e8 00 00 00 00	 call	 _quietmes

; 667  :           ERREXIT("file not found")

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LJOCCCLG@file?5not?5found?$AA@
  0005a	e8 00 00 00 00	 call	 _warnmes
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	5f		 pop	 edi
  00063	33 c0		 xor	 eax, eax
  00065	5e		 pop	 esi

; 690  :   return ok;
; 691  : }

  00066	8b 8c 24 08 00
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+65548]
  0006d	33 cc		 xor	 ecx, esp
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	81 c4 0c 00 01
	00		 add	 esp, 65548		; 0001000cH
  0007a	c3		 ret	 0
$LN12@load_file:

; 668  :   }
; 669  : 
; 670  :   /* quietmes("begin loading %s...",fname); */
; 671  : 
; 672  :   skip_header(f); ok=TRUE;

  0007b	e8 00 00 00 00	 call	 _skip_header
  00080	53		 push	 ebx
  00081	be 01 00 00 00	 mov	 esi, 1
  00086	55		 push	 ebp
$LL11@load_file:

; 673  :   while(ok)
; 674  :     {
; 675  :       register bp_long i;
; 676  :       GET_BYTE(opcode); GET_BYTE(reg); GET_BYTE(arity);

  00087	57		 push	 edi
  00088	e8 00 00 00 00	 call	 _getc
  0008d	8b e8		 mov	 ebp, eax
  0008f	83 c4 04	 add	 esp, 4
  00092	83 fd ff	 cmp	 ebp, -1
  00095	0f 84 83 00 00
	00		 je	 $LN29@load_file
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 _getc
  000a1	83 c4 04	 add	 esp, 4
  000a4	89 44 24 10	 mov	 DWORD PTR _reg$[esp+65564], eax
  000a8	83 f8 ff	 cmp	 eax, -1
  000ab	74 71		 je	 SHORT $LN29@load_file
  000ad	57		 push	 edi
  000ae	e8 00 00 00 00	 call	 _getc
  000b3	8b d8		 mov	 ebx, eax
  000b5	83 c4 04	 add	 esp, 4
  000b8	83 fb ff	 cmp	 ebx, -1
  000bb	74 61		 je	 SHORT $LN29@load_file

; 677  :       for(i=0; i<(bp_long)MAXNBUF; i++)

  000bd	33 f6		 xor	 esi, esi
  000bf	90		 npad	 1
$LL6@load_file:

; 678  :         { register int c;
; 679  :           GET_BYTE(c);

  000c0	57		 push	 edi
  000c1	e8 00 00 00 00	 call	 _getc
  000c6	83 c4 04	 add	 esp, 4
  000c9	83 f8 ff	 cmp	 eax, -1
  000cc	74 11		 je	 SHORT $LN21@load_file

; 680  :           if(!c) break;

  000ce	85 c0		 test	 eax, eax
  000d0	74 0d		 je	 SHORT $LN21@load_file

; 681  :           sbuf[i]=(char)c;

  000d2	88 44 34 18	 mov	 BYTE PTR _sbuf$[esp+esi+65564], al
  000d6	46		 inc	 esi
  000d7	81 fe 00 00 01
	00		 cmp	 esi, 65536		; 00010000H
  000dd	7c e1		 jl	 SHORT $LL6@load_file
$LN21@load_file:

; 682  :         }
; 683  :       sbuf[i]='\0';

  000df	c6 44 34 18 00	 mov	 BYTE PTR _sbuf$[esp+esi+65564], 0

; 684  :       ok=ii(opcode,reg,arity,sbuf,wam);

  000e4	81 fd de 00 00
	00		 cmp	 ebp, 222		; 000000deH
  000ea	75 0f		 jne	 SHORT $LN17@load_file
  000ec	8d 4c 24 18	 lea	 ecx, DWORD PTR _sbuf$[esp+65564]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 _loadoperator
  000f6	83 c4 04	 add	 esp, 4
  000f9	eb 19		 jmp	 SHORT $LN30@load_file
$LN17@load_file:
  000fb	8b 54 24 14	 mov	 edx, DWORD PTR _wam$GSCopy$[esp+65564]
  000ff	8b 4c 24 10	 mov	 ecx, DWORD PTR _reg$[esp+65564]
  00103	52		 push	 edx
  00104	53		 push	 ebx
  00105	8d 44 24 20	 lea	 eax, DWORD PTR _sbuf$[esp+65572]
  00109	50		 push	 eax
  0010a	51		 push	 ecx
  0010b	55		 push	 ebp
  0010c	e8 00 00 00 00	 call	 _insert_op
  00111	83 c4 14	 add	 esp, 20			; 00000014H
$LN30@load_file:
  00114	8b f0		 mov	 esi, eax
  00116	85 f6		 test	 esi, esi
  00118	0f 85 69 ff ff
	ff		 jne	 $LL11@load_file
$LN29@load_file:

; 685  :     }
; 686  :   fclose(f);

  0011e	57		 push	 edi
  0011f	e8 00 00 00 00	 call	 _fclose
  00124	83 c4 04	 add	 esp, 4
  00127	5d		 pop	 ebp
  00128	5b		 pop	 ebx

; 687  : 
; 688  :   if(!ok)

  00129	85 f6		 test	 esi, esi
  0012b	75 12		 jne	 SHORT $LN1@load_file

; 689  :     quietmes("%s\n","unable to load kernel file");

  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@BHPFGAP@unable?5to?5load?5kernel?5file?$AA@
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00137	e8 00 00 00 00	 call	 _quietmes
  0013c	83 c4 08	 add	 esp, 8
$LN1@load_file:

; 690  :   return ok;
; 691  : }

  0013f	8b 8c 24 10 00
	01 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+65556]
  00146	5f		 pop	 edi
  00147	8b c6		 mov	 eax, esi
  00149	5e		 pop	 esi
  0014a	33 cc		 xor	 ecx, esp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 0c 00 01
	00		 add	 esp, 65548		; 0001000cH
  00157	c3		 ret	 0
_load_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@JOAJABMC@load?11?3?5bad?5argument?$AA@ ; `string'
PUBLIC	_load_1
;	COMDAT ??_C@_0BF@JOAJABMC@load?11?3?5bad?5argument?$AA@
CONST	SEGMENT
??_C@_0BF@JOAJABMC@load?11?3?5bad?5argument?$AA@ DB 'load/1: bad argument'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_1
_TEXT	SEGMENT
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_load_1	PROC						; COMDAT

; 695  :   FDEREF(regs[1]);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _regs$[esp-4]
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	f6 c1 03	 test	 cl, 3
  0000a	74 04		 je	 SHORT $LN9@load_1
  0000c	8b c1		 mov	 eax, ecx
  0000e	eb 12		 jmp	 SHORT $LN3@load_1
$LN9@load_1:
  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	a8 03		 test	 al, 3
  00014	75 0c		 jne	 SHORT $LN3@load_1
$LL4@load_1:
  00016	3b c8		 cmp	 ecx, eax
  00018	74 08		 je	 SHORT $LN3@load_1
  0001a	8b c8		 mov	 ecx, eax
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	a8 03		 test	 al, 3
  00020	74 f4		 je	 SHORT $LL4@load_1
$LN3@load_1:

; 696  :   if(!SYMCONST(xval)) return (no)LOCAL_ERR(xval,"load/1: bad argument");

  00022	8b c8		 mov	 ecx, eax
  00024	83 e1 03	 and	 ecx, 3
  00027	80 f9 03	 cmp	 cl, 3
  0002a	75 26		 jne	 SHORT $LN1@load_1
  0002c	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00031	75 1f		 jne	 SHORT $LN1@load_1

; 697  :   return load_file(NAME(xval),wam);

  00033	8b 54 24 08	 mov	 edx, DWORD PTR _wam$[esp-4]
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  0003d	c1 e8 02	 shr	 eax, 2
  00040	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00045	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _load_file
  0004e	83 c4 04	 add	 esp, 4

; 698  : }

  00051	c3		 ret	 0
$LN1@load_1:

; 696  :   if(!SYMCONST(xval)) return (no)LOCAL_ERR(xval,"load/1: bad argument");

  00052	8b 54 24 08	 mov	 edx, DWORD PTR _wam$[esp-4]
  00056	52		 push	 edx
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JOAJABMC@load?11?3?5bad?5argument?$AA@
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _local_error
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 698  : }

  00065	c3		 ret	 0
_load_1	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@JLIEHGDN@Finished?5loading?5?$CFs?5C?9code?5?$CI?$CFld?5@ ; `string'
PUBLIC	??_C@_0BK@KCPCOHMJ@invalid?5c_chunk?3?5bad?5size?$AA@ ; `string'
PUBLIC	??_C@_0P@EJFMDLGA@?$HL?$CFd?0?$CFd?0?$CFd?0?$CFs?$HN?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@JGICAOFM@instruction?$DN?$FL?$CFld?$FN?5size?$CIfound?$DN?$CFd?0@ ; `string'
EXTRN	_sprintf:PROC
;	COMDAT ??_C@_0DA@JLIEHGDN@Finished?5loading?5?$CFs?5C?9code?5?$CI?$CFld?5@
CONST	SEGMENT
??_C@_0DA@JLIEHGDN@Finished?5loading?5?$CFs?5C?9code?5?$CI?$CFld?5@ DB 'F'
	DB	'inished loading %s C-code (%ld instructions).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KCPCOHMJ@invalid?5c_chunk?3?5bad?5size?$AA@
CONST	SEGMENT
??_C@_0BK@KCPCOHMJ@invalid?5c_chunk?3?5bad?5size?$AA@ DB 'invalid c_chunk'
	DB	': bad size', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJFMDLGA@?$HL?$CFd?0?$CFd?0?$CFd?0?$CFs?$HN?6?$AA@
CONST	SEGMENT
??_C@_0P@EJFMDLGA@?$HL?$CFd?0?$CFd?0?$CFd?0?$CFs?$HN?6?$AA@ DB '{%d,%d,%d'
	DB	',%s}', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JGICAOFM@instruction?$DN?$FL?$CFld?$FN?5size?$CIfound?$DN?$CFd?0@
CONST	SEGMENT
??_C@_0DA@JGICAOFM@instruction?$DN?$FL?$CFld?$FN?5size?$CIfound?$DN?$CFd?0@ DB 'i'
	DB	'nstruction=[%ld] size(found=%d, computed=%ld)', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_instr_array
_TEXT	SEGMENT
_i$ = -12						; size = 4
_val$7414 = -8						; size = 4
tv266 = -4						; size = 4
_from_file$ = 8						; size = 4
_wam$ = 12						; size = 4
_p$ = 16						; size = 4
_end$ = 20						; size = 1
_load_instr_array PROC					; COMDAT

; 708  : {  bp_long i,j; no ok; no op;

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 709  :    g.self=1;
; 710  : 
; 711  :    for(i=0,j=1; end!=(op=p[i].op) ;i += j)

  00003	0f b6 44 24 1c	 movzx	 eax, BYTE PTR _end$[esp+8]
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7c 24 28	 mov	 edi, DWORD PTR _p$[esp+24]
  00010	c7 05 f0 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g+240, 1
  0001a	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  0001d	33 ed		 xor	 ebp, ebp
  0001f	89 6c 24 10	 mov	 DWORD PTR _i$[esp+28], ebp
  00023	3b c6		 cmp	 eax, esi
  00025	0f 84 48 01 00
	00		 je	 $LN10@load_instr
  0002b	eb 03 8d 49 00	 npad	 5
$LL12@load_instr:

; 712  :    {
; 713  :       ok=ii(p[i].op,
; 714  :             p[i].reg,
; 715  :             p[i].arity,
; 716  :             p[i].name,
; 717  :             wam);

  00030	0f b7 57 04	 movzx	 edx, WORD PTR [edi+4]
  00034	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00037	0f b7 5f 02	 movzx	 ebx, WORD PTR [edi+2]
  0003b	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0003e	89 44 24 18	 mov	 DWORD PTR tv266[esp+28], eax
  00042	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00045	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  0004a	75 0b		 jne	 SHORT $LN17@load_instr
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _loadoperator
  00052	83 c4 04	 add	 esp, 4
  00055	eb 10		 jmp	 SHORT $LN18@load_instr
$LN17@load_instr:
  00057	ff 74 24 24	 push	 DWORD PTR _wam$[esp+24]
  0005b	52		 push	 edx
  0005c	51		 push	 ecx
  0005d	53		 push	 ebx
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _insert_op
  00064	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@load_instr:

; 718  : 
; 719  :       if(!ok)

  00067	85 c0		 test	 eax, eax
  00069	0f 84 2b 01 00
	00		 je	 $LN26@load_instr

; 721  : 
; 722  :       j=1;

  0006f	bb 01 00 00 00	 mov	 ebx, 1

; 723  :       if(BEGIN_C_CHUNK==op) {

  00074	83 fe 3f	 cmp	 esi, 63			; 0000003fH
  00077	0f 85 d4 00 00
	00		 jne	 $LN11@load_instr

; 724  :         for(; END_C_CHUNK!=p[i+j].op; j++)

  0007d	8b 4c 24 28	 mov	 ecx, DWORD PTR _p$[esp+24]
  00081	8d 44 6d 03	 lea	 eax, DWORD PTR [ebp+ebp*2+3]
  00085	80 3c 81 40	 cmp	 BYTE PTR [ecx+eax*4], 64 ; 00000040H
  00089	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0008c	74 51		 je	 SHORT $LN5@load_instr
  0008e	83 c7 0c	 add	 edi, 12			; 0000000cH
$LL7@load_instr:

; 725  :          {*ctop++=(instr)input_fun(p[i+j].name,p[i+j].arity);

  00091	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00094	0f b7 68 04	 movzx	 ebp, WORD PTR [eax+4]
  00098	8d 54 24 14	 lea	 edx, DWORD PTR _val$7414[esp+28]
  0009c	52		 push	 edx
  0009d	56		 push	 esi
  0009e	e8 00 00 00 00	 call	 _get_one_int
  000a3	83 c4 08	 add	 esp, 8
  000a6	85 c0		 test	 eax, eax
  000a8	74 0d		 je	 SHORT $LN20@load_instr
  000aa	8b 44 24 14	 mov	 eax, DWORD PTR _val$7414[esp+28]
  000ae	03 c0		 add	 eax, eax
  000b0	03 c0		 add	 eax, eax
  000b2	83 c8 01	 or	 eax, 1
  000b5	eb 0a		 jmp	 SHORT $LN19@load_instr
$LN20@load_instr:
  000b7	55		 push	 ebp
  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 _new_func
  000be	83 c4 08	 add	 esp, 8
$LN19@load_instr:
  000c1	8b 0d 7c 01 00
	00		 mov	 ecx, DWORD PTR _g+380
  000c7	89 01		 mov	 DWORD PTR [ecx], eax
  000c9	83 05 7c 01 00
	00 04		 add	 DWORD PTR _g+380, 4
  000d0	83 c7 0c	 add	 edi, 12			; 0000000cH
  000d3	43		 inc	 ebx
  000d4	80 3f 40	 cmp	 BYTE PTR [edi], 64	; 00000040H
  000d7	8b c7		 mov	 eax, edi
  000d9	75 b6		 jne	 SHORT $LL7@load_instr

; 724  :         for(; END_C_CHUNK!=p[i+j].op; j++)

  000db	8b 6c 24 10	 mov	 ebp, DWORD PTR _i$[esp+28]
$LN5@load_instr:

; 726  :          }
; 727  :         if(p[i+j].arity!=j) {

  000df	8d 04 2b	 lea	 eax, DWORD PTR [ebx+ebp]
  000e2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000e5	8b 44 24 28	 mov	 eax, DWORD PTR _p$[esp+24]
  000e9	0f b7 44 90 04	 movzx	 eax, WORD PTR [eax+edx*4+4]
  000ee	3b c3		 cmp	 eax, ebx
  000f0	74 5f		 je	 SHORT $LN11@load_instr

; 728  :           fprintf(STD_err,
; 729  :             "instruction=[%ld] size(found=%d, computed=%ld)\n",
; 730  :              i, p[i+j].arity, j);

  000f2	53		 push	 ebx
  000f3	50		 push	 eax
  000f4	55		 push	 ebp
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JGICAOFM@instruction?$DN?$FL?$CFld?$FN?5size?$CIfound?$DN?$CFd?0@
  000fa	e8 00 00 00 00	 call	 ___iob_func
  000ff	83 c0 40	 add	 eax, 64			; 00000040H
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _fprintf
  00108	83 c4 14	 add	 esp, 20			; 00000014H

; 731  :           {  bp_long k;
; 732  :              for(k=0;k<=j;k++)

  0010b	85 db		 test	 ebx, ebx
  0010d	78 35		 js	 SHORT $LN1@load_instr

; 728  :           fprintf(STD_err,
; 729  :             "instruction=[%ld] size(found=%d, computed=%ld)\n",
; 730  :              i, p[i+j].arity, j);

  0010f	8b 74 24 18	 mov	 esi, DWORD PTR tv266[esp+28]
  00113	8d 7b 01	 lea	 edi, DWORD PTR [ebx+1]
$LL3@load_instr:

; 733  :               fprintf(STD_err,"{%d,%d,%d,%s}\n",
; 734  :                  p[i+k].op, p[i+k].reg, p[i+k].arity, p[i+k].name
; 735  :               );

  00116	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00119	0f b7 16	 movzx	 edx, WORD PTR [esi]
  0011c	0f b7 46 fe	 movzx	 eax, WORD PTR [esi-2]
  00120	51		 push	 ecx
  00121	0f b6 4e fc	 movzx	 ecx, BYTE PTR [esi-4]
  00125	52		 push	 edx
  00126	50		 push	 eax
  00127	51		 push	 ecx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EJFMDLGA@?$HL?$CFd?0?$CFd?0?$CFd?0?$CFs?$HN?6?$AA@
  0012d	e8 00 00 00 00	 call	 ___iob_func
  00132	83 c0 40	 add	 eax, 64			; 00000040H
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _fprintf
  0013b	83 c4 18	 add	 esp, 24			; 00000018H
  0013e	83 c6 0c	 add	 esi, 12			; 0000000cH
  00141	4f		 dec	 edi
  00142	75 d2		 jne	 SHORT $LL3@load_instr
$LN1@load_instr:

; 736  :           }
; 737  :           fatal_error("invalid c_chunk: bad size");

  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KCPCOHMJ@invalid?5c_chunk?3?5bad?5size?$AA@
  00149	e8 00 00 00 00	 call	 _fatal_error
  0014e	83 c4 04	 add	 esp, 4
$LN11@load_instr:

; 709  :    g.self=1;
; 710  : 
; 711  :    for(i=0,j=1; end!=(op=p[i].op) ;i += j)

  00151	8b 44 24 28	 mov	 eax, DWORD PTR _p$[esp+24]
  00155	03 eb		 add	 ebp, ebx
  00157	8d 54 6d 00	 lea	 edx, DWORD PTR [ebp+ebp*2]
  0015b	0f b6 34 90	 movzx	 esi, BYTE PTR [eax+edx*4]
  0015f	8d 3c 90	 lea	 edi, DWORD PTR [eax+edx*4]
  00162	0f b6 44 24 2c	 movzx	 eax, BYTE PTR _end$[esp+24]
  00167	89 6c 24 10	 mov	 DWORD PTR _i$[esp+28], ebp
  0016b	3b c6		 cmp	 eax, esi
  0016d	0f 85 bd fe ff
	ff		 jne	 $LL12@load_instr
$LN10@load_instr:

; 738  :         }
; 739  :       }
; 740  :     }
; 741  :   sprintf(g.sbuf,"Finished loading %s C-code (%ld instructions).\n",
; 742  :      from_file,i);

  00173	8b 4c 24 20	 mov	 ecx, DWORD PTR _from_file$[esp+24]
  00177	8b 15 4c 01 00
	00		 mov	 edx, DWORD PTR _g+332
  0017d	55		 push	 ebp
  0017e	51		 push	 ecx
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JLIEHGDN@Finished?5loading?5?$CFs?5C?9code?5?$CI?$CFld?5@
  00184	52		 push	 edx
  00185	e8 00 00 00 00	 call	 _sprintf
  0018a	83 c4 10	 add	 esp, 16			; 00000010H
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5d		 pop	 ebp

; 743  :   /*quietmes("%s",g.sbuf);*/
; 744  : 
; 745  :   return TRUE;

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	5b		 pop	 ebx

; 746  : }

  00196	83 c4 0c	 add	 esp, 12			; 0000000cH
  00199	c3		 ret	 0
$LN26@load_instr:
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	5d		 pop	 ebp

; 720  :          return FALSE;

  0019d	33 c0		 xor	 eax, eax
  0019f	5b		 pop	 ebx

; 746  : }

  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a3	c3		 ret	 0
_load_instr_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_04CCHAHKJA@user?$AA@			; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
EXTRN	_user_bp:BYTE
EXTRN	_wam_bp:BYTE
;	COMDAT ??_C@_04CCHAHKJA@user?$AA@
CONST	SEGMENT
??_C@_04CCHAHKJA@user?$AA@ DB 'user', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_self
_TEXT	SEGMENT
_load_self PROC						; COMDAT
; _wam$ = esi

; 750  :   return ( load_instr_array("system",wam,wam_bp,0) &&
; 751  :            load_instr_array("user",wam,user_bp,255)
; 752  :   );

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET _wam_bp
  00007	56		 push	 esi
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_06FHFOAHML@system?$AA@
  0000d	e8 00 00 00 00	 call	 _load_instr_array
  00012	83 c4 10	 add	 esp, 16			; 00000010H
  00015	85 c0		 test	 eax, eax
  00017	74 22		 je	 SHORT $LN3@load_self
  00019	68 ff 00 00 00	 push	 255			; 000000ffH
  0001e	68 00 00 00 00	 push	 OFFSET _user_bp
  00023	56		 push	 esi
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_04CCHAHKJA@user?$AA@
  00029	e8 00 00 00 00	 call	 _load_instr_array
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
  00031	85 c0		 test	 eax, eax
  00033	74 06		 je	 SHORT $LN3@load_self
  00035	b8 01 00 00 00	 mov	 eax, 1

; 753  : }

  0003a	c3		 ret	 0
$LN3@load_self:

; 750  :   return ( load_instr_array("system",wam,wam_bp,0) &&
; 751  :            load_instr_array("user",wam,user_bp,255)
; 752  :   );

  0003b	33 c0		 xor	 eax, eax

; 753  : }

  0003d	c3		 ret	 0
_load_self ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PKDKJOFG@?4bp?$AA@			; `string'
;	COMDAT ??_C@_03PKDKJOFG@?4bp?$AA@
CONST	SEGMENT
??_C@_03PKDKJOFG@?4bp?$AA@ DB '.bp', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _is_bp_file
_TEXT	SEGMENT
_is_bp_file PROC					; COMDAT
; _fname$ = esi

; 757  : {  bp_long l=strlen(fname);

  00000	8b c6		 mov	 eax, esi
  00002	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@is_bp_file:
  00005	8a 08		 mov	 cl, BYTE PTR [eax]
  00007	40		 inc	 eax
  00008	84 c9		 test	 cl, cl
  0000a	75 f9		 jne	 SHORT $LL5@is_bp_file
  0000c	2b c2		 sub	 eax, edx

; 758  :    return (l>=3 && 0==strcmp(fname+(l-3),".bp"));

  0000e	83 f8 03	 cmp	 eax, 3
  00011	7c 3c		 jl	 SHORT $LN3@is_bp_file
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03PKDKJOFG@?4bp?$AA@
  00018	8d 44 30 fd	 lea	 eax, DWORD PTR [eax+esi-3]
  0001c	8d 64 24 00	 npad	 4
$LL6@is_bp_file:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00024	75 1a		 jne	 SHORT $LN7@is_bp_file
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN8@is_bp_file
  0002a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00030	75 0e		 jne	 SHORT $LN7@is_bp_file
  00032	83 c0 02	 add	 eax, 2
  00035	83 c1 02	 add	 ecx, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL6@is_bp_file
$LN8@is_bp_file:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN9@is_bp_file
$LN7@is_bp_file:
  00040	1b c0		 sbb	 eax, eax
  00042	83 d8 ff	 sbb	 eax, -1
$LN9@is_bp_file:
  00045	85 c0		 test	 eax, eax
  00047	75 06		 jne	 SHORT $LN3@is_bp_file
  00049	b8 01 00 00 00	 mov	 eax, 1

; 759  : }

  0004e	c3		 ret	 0
$LN3@is_bp_file:

; 758  :    return (l>=3 && 0==strcmp(fname+(l-3),".bp"));

  0004f	33 c0		 xor	 eax, eax

; 759  : }

  00051	c3		 ret	 0
_is_bp_file ENDP
_TEXT	ENDS
PUBLIC	??_C@_06MNNHBPJC@wam?4bp?$AA@			; `string'
PUBLIC	_load_kernel
;	COMDAT ??_C@_06MNNHBPJC@wam?4bp?$AA@
CONST	SEGMENT
??_C@_06MNNHBPJC@wam?4bp?$AA@ DB 'wam.bp', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _load_kernel
_TEXT	SEGMENT
_fname$ = 8						; size = 4
_wam$ = 12						; size = 4
_load_kernel PROC					; COMDAT

; 767  : {

  00000	57		 push	 edi

; 768  :   if(!init_code(wam)) return 0;

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR _wam$[esp]
  00005	57		 push	 edi
  00006	e8 00 00 00 00	 call	 _init_code
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	75 02		 jne	 SHORT $LN7@load_kerne
  00012	5f		 pop	 edi

; 784  : }

  00013	c3		 ret	 0
$LN7@load_kerne:
  00014	56		 push	 esi

; 769  : 
; 770  :   if(!fname || is_bp_file(fname)) g.startup_file_name=g.empty;

  00015	8b 74 24 0c	 mov	 esi, DWORD PTR _fname$[esp+4]
  00019	85 f6		 test	 esi, esi
  0001b	74 1a		 je	 SHORT $LN5@load_kerne
  0001d	e8 00 00 00 00	 call	 _is_bp_file
  00022	85 c0		 test	 eax, eax
  00024	75 11		 jne	 SHORT $LN5@load_kerne

; 771  :   else
; 772  :     { g.startup_file_name=INPUT_STRING(fname);

  00026	50		 push	 eax
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 _new_func
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 e0 00 00 00	 mov	 DWORD PTR _g+224, eax

; 773  :       fname=NULL;

  00035	eb 0e		 jmp	 SHORT $LN10@load_kerne
$LN5@load_kerne:

; 769  : 
; 770  :   if(!fname || is_bp_file(fname)) g.startup_file_name=g.empty;

  00037	a1 38 00 00 00	 mov	 eax, DWORD PTR _g+56
  0003c	a3 e0 00 00 00	 mov	 DWORD PTR _g+224, eax

; 774  :     }
; 775  : 
; 776  :   if(!fname)

  00041	85 f6		 test	 esi, esi
  00043	75 18		 jne	 SHORT $LN1@load_kerne
$LN10@load_kerne:

; 777  :     {
; 778  :       if(g.inC)

  00045	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  0004c	74 0a		 je	 SHORT $LN2@load_kerne

; 779  :         return load_self(wam);

  0004e	8b f7		 mov	 esi, edi
  00050	e8 00 00 00 00	 call	 _load_self
  00055	5e		 pop	 esi
  00056	5f		 pop	 edi

; 784  : }

  00057	c3		 ret	 0
$LN2@load_kerne:

; 780  :      else
; 781  :         fname="wam.bp";

  00058	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_06MNNHBPJC@wam?4bp?$AA@
$LN1@load_kerne:

; 782  :     }
; 783  :   return load_file(fname,wam);

  0005d	57		 push	 edi
  0005e	8b ce		 mov	 ecx, esi
  00060	e8 00 00 00 00	 call	 _load_file
  00065	83 c4 04	 add	 esp, 4
  00068	5e		 pop	 esi
  00069	5f		 pop	 edi

; 784  : }

  0006a	c3		 ret	 0
_load_kernel ENDP
_TEXT	ENDS
END
