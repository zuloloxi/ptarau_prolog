; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\gc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BP@DPNAMAP@?$CFs?0?5tolerance?$DN?$CFld?5?$CIbytes?$CJ?6?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@KADGKGKI@?$CK?$CK?$CK?5Not?5enough?5memory?5recovered?5@ ; `string'
PUBLIC	??_C@_0DB@IIELHGDO@?$CK?$CK?$CK?5Please?5start?5with?5more?5heap?0@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	_fflush:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_sprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
; File c:\a17\prolog\ptarau_prolog\src\gc.c
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DPNAMAP@?$CFs?0?5tolerance?$DN?$CFld?5?$CIbytes?$CJ?6?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BP@DPNAMAP@?$CFs?0?5tolerance?$DN?$CFld?5?$CIbytes?$CJ?6?5?$CFs?6?$AA@ DB '%'
	DB	's, tolerance=%ld (bytes)', 0aH, ' %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KADGKGKI@?$CK?$CK?$CK?5Not?5enough?5memory?5recovered?5@
CONST	SEGMENT
??_C@_0CK@KADGKGKI@?$CK?$CK?$CK?5Not?5enough?5memory?5recovered?5@ DB '**'
	DB	'* Not enough memory recovered during GC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IIELHGDO@?$CK?$CK?$CK?5Please?5start?5with?5more?5heap?0@
CONST	SEGMENT
??_C@_0DB@IIELHGDO@?$CK?$CK?$CK?5Please?5start?5with?5more?5heap?0@ DB '*'
	DB	'** Please start with more heap, using option -h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _gc_mes
_TEXT	SEGMENT
_lline$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_tolerance$ = 8						; size = 4
_gc_mes	PROC						; COMDAT

; 33   : static void gc_mes(bp_long tolerance) {  

  00000	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 00 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+260], eax

; 34   :   char lline[255];
; 35   :   sprintf(lline, "%s, tolerance=%ld (bytes)\n %s\n",
; 36   :     "*** Not enough memory recovered during GC",
; 37   :     tolerance, 
; 38   :     "*** Please start with more heap, using option -h"
; 39   :   );

  00014	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR _tolerance$[esp+256]
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IIELHGDO@?$CK?$CK?$CK?5Please?5start?5with?5more?5heap?0@
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KADGKGKI@?$CK?$CK?$CK?5Not?5enough?5memory?5recovered?5@
  00026	8d 4c 24 0c	 lea	 ecx, DWORD PTR _lline$[esp+272]
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DPNAMAP@?$CFs?0?5tolerance?$DN?$CFld?5?$CIbytes?$CJ?6?5?$CFs?6?$AA@
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _sprintf
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 40   :   fprintf(STD_err,"%s",lline);

  00038	8d 14 24	 lea	 edx, DWORD PTR _lline$[esp+260]
  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00041	e8 00 00 00 00	 call	 ___iob_func
  00046	83 c0 40	 add	 eax, 64			; 00000040H
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _fprintf

; 41   :   fflush(STD_err);

  0004f	e8 00 00 00 00	 call	 ___iob_func
  00054	83 c0 40	 add	 eax, 64			; 00000040H
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _fflush

; 42   : }

  0005d	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+276]
  00064	83 c4 10	 add	 esp, 16			; 00000010H
  00067	33 cc		 xor	 ecx, esp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  00074	c3		 ret	 0
_gc_mes	ENDP
_TEXT	ENDS
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _gc_check
_TEXT	SEGMENT
_gc_time$ = 8						; size = 4
_gc_check PROC						; COMDAT
; _H$ = eax
; _wam$ = edx

; 46   :   bp_long tolerance = wam[HeapStk].margin-wam[HeapStk].base;

  00000	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00003	2b 4a 10	 sub	 ecx, DWORD PTR [edx+16]
  00006	56		 push	 esi

; 47   :        tolerance = tolerance >> 1; /* 1/4 crashes => 1/2 of existing space */
; 48   : 
; 49   :   g.gctime += gc_time;

  00007	8b 74 24 08	 mov	 esi, DWORD PTR _gc_time$[esp]
  0000b	01 35 2c 01 00
	00		 add	 DWORD PTR _g+300, esi
  00011	c1 f9 03	 sar	 ecx, 3

; 50   : 
; 51   :   if(H+tolerance >= (term)wam[HeapStk].margin)

  00014	8d 34 88	 lea	 esi, DWORD PTR [eax+ecx*4]
  00017	3b 72 14	 cmp	 esi, DWORD PTR [edx+20]
  0001a	5e		 pop	 esi
  0001b	72 0b		 jb	 SHORT $LN2@gc_check

; 52   :     {
; 53   :       gc_mes(tolerance);

  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _gc_mes
  00023	83 c4 04	 add	 esp, 4

; 54   :       return NULL;

  00026	33 c0		 xor	 eax, eax
$LN2@gc_check:

; 55   :     }
; 56   :   return H;
; 57   : }

  00028	c3		 ret	 0
_gc_check ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _init_cps
_TEXT	SEGMENT
_A$ = 8							; size = 4
_cpoint$ = 12						; size = 4
_init_cps PROC						; COMDAT
; _wam$ = ebx

; 62   :   term chptr=CH_BASE;

  00000	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  00003	55		 push	 ebp
  00004	8b 6c 24 08	 mov	 ebp, DWORD PTR _A$[esp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	33 f6		 xor	 esi, esi

; 63   : 
; 64   :   while(chptr<=(term)A)

  0000e	3b c5		 cmp	 eax, ebp
  00010	77 41		 ja	 SHORT $LN3@init_cps

; 61   :   bp_long count=0, arity=0;

  00012	8b 4c 24 14	 mov	 ecx, DWORD PTR _cpoint$[esp+8]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@init_cps:

; 65   :     {
; 66   :       if(((term)(*(chptr+1))>=TR_BASE)
; 67   : 	 && ((term)(*(chptr+1))<=TR_GCTOP) && (VAR(((term)(*(chptr+1))))))

  00020	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00023	3b 53 34	 cmp	 edx, DWORD PTR [ebx+52]
  00026	72 23		 jb	 SHORT $LN2@init_cps
  00028	3b 53 2c	 cmp	 edx, DWORD PTR [ebx+44]
  0002b	77 1e		 ja	 SHORT $LN2@init_cps
  0002d	f6 c2 03	 test	 dl, 3
  00030	75 19		 jne	 SHORT $LN2@init_cps

; 68   : 	{
; 69   : 	  cpoint[count].H = chptr++;

  00032	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  00035	83 c0 04	 add	 eax, 4

; 70   : 	  cpoint[count].TR = chptr++;

  00038	89 01		 mov	 DWORD PTR [ecx], eax

; 71   : 	  cpoint[count++].arity = arity;

  0003a	89 71 f8	 mov	 DWORD PTR [ecx-8], esi
  0003d	83 c1 10	 add	 ecx, 16			; 00000010H
  00040	47		 inc	 edi

; 72   : 	  arity=0;

  00041	33 f6		 xor	 esi, esi

; 73   : 	  cpoint[count].start = ++chptr;

  00043	83 c0 08	 add	 eax, 8
  00046	89 41 f4	 mov	 DWORD PTR [ecx-12], eax

; 74   : 	}
; 75   :       else

  00049	eb 04		 jmp	 SHORT $LN1@init_cps
$LN2@init_cps:

; 76   : 	{
; 77   : 	  arity++;

  0004b	46		 inc	 esi
  0004c	83 c0 04	 add	 eax, 4
$LN1@init_cps:

; 63   : 
; 64   :   while(chptr<=(term)A)

  0004f	3b c5		 cmp	 eax, ebp
  00051	76 cd		 jbe	 SHORT $LL4@init_cps
$LN3@init_cps:

; 78   : 	  chptr++;
; 79   : 	}
; 80   :     }
; 81   :   count = count-1;
; 82   :   
; 83   :   /* adjust for the first choice-point */
; 84   :   cpoint[0].arity--;

  00053	8b 44 24 14	 mov	 eax, DWORD PTR _cpoint$[esp+8]
  00057	ff 48 04	 dec	 DWORD PTR [eax+4]

; 85   :   cpoint[0].start = CH_BASE+1;

  0005a	8b 4b 58	 mov	 ecx, DWORD PTR [ebx+88]
  0005d	83 c1 04	 add	 ecx, 4
  00060	89 08		 mov	 DWORD PTR [eax], ecx
  00062	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5d		 pop	 ebp

; 86   :   return count ;
; 87   : } /* init_cps */

  00068	c3		 ret	 0
_init_cps ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _mark_cell1
_TEXT	SEGMENT
_m$ = -4						; size = 4
_arity$ = 8						; size = 4
_tomark$ = 8						; size = 4
_heapstart$ = 12					; size = 4
_marked$ = 16						; size = 4
_begin_old_heap$ = 20					; size = 4
_H$ = 24						; size = 4
_mark_cell1 PROC					; COMDAT

; 125  : { /* begin mark_cell1 */

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi

; 126  :   register bp_long arity;
; 127  :   register cell star_tomark ;
; 128  :   register bp_long m = 0 ;
; 129  :   register char *pmark ;
; 130  : 
; 131  : label_last_call_opt1:
; 132  : 
; 133  : if(! TO_HEAP(((cell)tomark))) 

  00004	8b 74 24 14	 mov	 esi, DWORD PTR _tomark$[esp+12]
  00008	57		 push	 edi
  00009	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _m$[esp+20], 0
  00011	39 74 24 24	 cmp	 DWORD PTR _begin_old_heap$[esp+16], esi
  00015	0f 87 03 01 00
	00		 ja	 $LN15@mark_cell1
  0001b	8b 6c 24 20	 mov	 ebp, DWORD PTR _marked$[esp+16]
  0001f	90		 npad	 1
$label_last_call_opt1$5123:
  00020	39 74 24 28	 cmp	 DWORD PTR _H$[esp+16], esi
  00024	0f 86 f4 00 00
	00		 jbe	 $LN15@mark_cell1

; 135  : 
; 136  :   if(!REACHABLE(tomark,heapstart,marked))

  0002a	8b 54 24 1c	 mov	 edx, DWORD PTR _heapstart$[esp+16]
  0002e	8b de		 mov	 ebx, esi
  00030	2b da		 sub	 ebx, edx
  00032	8b fb		 mov	 edi, ebx
  00034	c1 ff 02	 sar	 edi, 2
  00037	03 fd		 add	 edi, ebp
  00039	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0003c	0f 85 d2 00 00
	00		 jne	 $LN12@mark_cell1

; 137  :     {
; 138  :       pmark = marked + (tomark-heapstart) ;
; 139  :       *pmark = REACHABLE_TAG ;

  00042	c6 07 01	 mov	 BYTE PTR [edi], 1

; 140  : 
; 141  :       MARK_REACHABLE(tomark,heapstart,marked);

  00045	c6 07 01	 mov	 BYTE PTR [edi], 1
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$label_last_call_opt2$5134:

; 142  : 
; 143  : label_last_call_opt2:
; 144  :       DEBUG1(mark_info, "\tmarking Heap[%d] : ", HP(tomark));
; 145  :       DEBUG_CELL(mark_info, *((term)(tomark)),wam);
; 146  : 
; 147  :       if(! TO_HEAP(((cell)tomark))) { 

  00050	39 74 24 24	 cmp	 DWORD PTR _begin_old_heap$[esp+16], esi
  00054	0f 87 ba 00 00
	00		 ja	 $LN12@mark_cell1
  0005a	39 74 24 28	 cmp	 DWORD PTR _H$[esp+16], esi
  0005e	0f 86 b0 00 00
	00		 jbe	 $LN12@mark_cell1

; 148  :         DEBUG1(mark_info, "\tbut not to heap %d", 0); return(m) ; } 
; 149  :       m++;
; 150  :       star_tomark = *tomark ;

  00064	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00066	ff 44 24 10	 inc	 DWORD PTR _m$[esp+20]

; 151  :       if( VAR(star_tomark)) {

  0006a	8b c1		 mov	 eax, ecx
  0006c	83 e0 03	 and	 eax, 3
  0006f	0f 84 7c 00 00
	00		 je	 $LN24@mark_cell1

; 155  : 	        goto label_last_call_opt1 ;
; 156  :         }
; 157  : 	        else return(m) ; /* i.e. treat as IDENTIFIER with arity == 0 */
; 158  :       }
; 159  :       if(IDENTIFIER(star_tomark)) {

  00075	83 f8 03	 cmp	 eax, 3
  00078	0f 85 96 00 00
	00		 jne	 $LN12@mark_cell1

; 160  : 	      if (! (arity = GETARITY(star_tomark))) { return(m) ;}

  0007e	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00081	85 c9		 test	 ecx, ecx
  00083	0f 84 8b 00 00
	00		 je	 $LN12@mark_cell1

; 161  : 	      while(--arity) { 

  00089	49		 dec	 ecx
  0008a	89 4c 24 18	 mov	 DWORD PTR _arity$[esp+16], ecx
  0008e	74 36		 je	 SHORT $LN31@mark_cell1
$LL30@mark_cell1:

; 162  :           m += mark_cell(++tomark,heapstart,marked);

  00090	8b 4c 24 28	 mov	 ecx, DWORD PTR _H$[esp+16]
  00094	8b 44 24 24	 mov	 eax, DWORD PTR _begin_old_heap$[esp+16]
  00098	51		 push	 ecx
  00099	50		 push	 eax
  0009a	55		 push	 ebp
  0009b	52		 push	 edx
  0009c	83 c6 04	 add	 esi, 4
  0009f	56		 push	 esi
  000a0	83 c3 04	 add	 ebx, 4
  000a3	e8 00 00 00 00	 call	 _mark_cell1
  000a8	01 44 24 24	 add	 DWORD PTR _m$[esp+40], eax
  000ac	8b 54 24 30	 mov	 edx, DWORD PTR _heapstart$[esp+36]

; 163  : 	        *(++pmark) = REACHABLE_INTERNAL_TAG ;

  000b0	47		 inc	 edi

; 164  : 	          MARK_INTERNAL(tomark,heapstart,marked);

  000b1	8b cb		 mov	 ecx, ebx
  000b3	c1 f9 02	 sar	 ecx, 2
  000b6	83 c4 14	 add	 esp, 20			; 00000014H
  000b9	ff 4c 24 18	 dec	 DWORD PTR _arity$[esp+16]
  000bd	c6 07 03	 mov	 BYTE PTR [edi], 3
  000c0	c6 04 29 03	 mov	 BYTE PTR [ecx+ebp], 3
  000c4	75 ca		 jne	 SHORT $LL30@mark_cell1
$LN31@mark_cell1:

; 165  :         }
; 166  :         ++tomark; pmark++;

  000c6	47		 inc	 edi
  000c7	83 c6 04	 add	 esi, 4

; 167  : 	  if (*pmark)

  000ca	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000cd	74 0d		 je	 SHORT $LN2@mark_cell1

; 168  : 
; 169  : 	  if (REACHABLE(tomark,heapstart,marked))

  000cf	8b c6		 mov	 eax, esi
  000d1	2b c2		 sub	 eax, edx
  000d3	c1 f8 02	 sar	 eax, 2
  000d6	80 3c 28 00	 cmp	 BYTE PTR [eax+ebp], 0
  000da	75 2c		 jne	 SHORT $LN26@mark_cell1
$LN2@mark_cell1:

; 174  : 	  	}
; 175  : 	  *pmark = REACHABLE_INTERNAL_TAG ;
; 176  : 
; 177  : 	  MARK_INTERNAL(tomark,heapstart,marked) ;

  000dc	8b de		 mov	 ebx, esi
  000de	2b da		 sub	 ebx, edx
  000e0	8b cb		 mov	 ecx, ebx
  000e2	c1 f9 02	 sar	 ecx, 2
  000e5	c6 07 03	 mov	 BYTE PTR [edi], 3
  000e8	c6 04 29 03	 mov	 BYTE PTR [ecx+ebp], 3

; 178  : 
; 179  : 	  goto label_last_call_opt2 ;

  000ec	e9 5f ff ff ff	 jmp	 $label_last_call_opt2$5134
$LN24@mark_cell1:

; 152  : 	      if (TO_HEAP(star_tomark)) {

  000f1	39 4c 24 24	 cmp	 DWORD PTR _begin_old_heap$[esp+16], ecx
  000f5	77 1d		 ja	 SHORT $LN12@mark_cell1
  000f7	39 4c 24 28	 cmp	 DWORD PTR _H$[esp+16], ecx
  000fb	76 17		 jbe	 SHORT $LN12@mark_cell1

; 153  :           if (tomark == (term)star_tomark) { return(m);}

  000fd	3b f1		 cmp	 esi, ecx
  000ff	74 13		 je	 SHORT $LN12@mark_cell1

; 154  : 	        tomark = (term)star_tomark ;

  00101	8b f1		 mov	 esi, ecx

; 126  :   register bp_long arity;
; 127  :   register cell star_tomark ;
; 128  :   register bp_long m = 0 ;
; 129  :   register char *pmark ;
; 130  : 
; 131  : label_last_call_opt1:
; 132  : 
; 133  : if(! TO_HEAP(((cell)tomark))) 

  00103	e9 18 ff ff ff	 jmp	 $label_last_call_opt1$5123
$LN26@mark_cell1:

; 170  : 
; 171  : 	  	{ MARK_INTERNAL(tomark,heapstart,marked);

  00108	2b f2		 sub	 esi, edx
  0010a	c1 fe 02	 sar	 esi, 2
  0010d	c6 04 2e 03	 mov	 BYTE PTR [esi+ebp], 3

; 172  : 	  	  *pmark = REACHABLE_INTERNAL_TAG ;

  00111	c6 07 03	 mov	 BYTE PTR [edi], 3
$LN12@mark_cell1:

; 173  : 	  	  return(m) ;

  00114	8b 44 24 10	 mov	 eax, DWORD PTR _m$[esp+20]
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5d		 pop	 ebp
  0011b	5b		 pop	 ebx

; 180  : 	}
; 181  :     return(m) ;
; 182  :     }
; 183  :   else {
; 184  :       DEBUG1(mark_info, "\tdone Heap[%d] : ", HP(tomark));
; 185  :       DEBUG_CELL(mark_info, *((term)(tomark)),wam);
; 186  :       return(m) ;
; 187  :     }
; 188  :     
; 189  : } /* mark_cell */

  0011c	59		 pop	 ecx
  0011d	c3		 ret	 0
$LN15@mark_cell1:
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5d		 pop	 ebp

; 134  : 	{ DEBUG1(mark_info, "\tbut not to heap %d", 0); return(0) ; } 

  00121	33 c0		 xor	 eax, eax
  00123	5b		 pop	 ebx

; 180  : 	}
; 181  :     return(m) ;
; 182  :     }
; 183  :   else {
; 184  :       DEBUG1(mark_info, "\tdone Heap[%d] : ", HP(tomark));
; 185  :       DEBUG_CELL(mark_info, *((term)(tomark)),wam);
; 186  :       return(m) ;
; 187  :     }
; 188  :     
; 189  : } /* mark_cell */

  00124	59		 pop	 ecx
  00125	c3		 ret	 0
_mark_cell1 ENDP
_TEXT	ENDS
EXTRN	_max:BYTE
EXTRN	_htable:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _mark_and_early_reset
_TEXT	SEGMENT
_num_marked$ = -24					; size = 4
_trail_cells_deleted$ = -20				; size = 4
_endtr$ = -16						; size = 4
tv818 = -12						; size = 4
_current_H$5270 = -8					; size = 4
_count$ = -4						; size = 4
_wam$ = 8						; size = 4
_H$ = 12						; size = 4
_cpoints$ = 16						; size = 4
_cpoint$ = 20						; size = 4
_begin_old_heap$ = 24					; size = 4
_marked$ = 28						; size = 4
_mark_and_early_reset PROC				; COMDAT
; _arity$ = ecx
; _regs$ = eax

; 193  :                                  bp_long cpoints, cp *cpoint, term begin_old_heap, char *marked) {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b 6c 24 34	 mov	 ebp, DWORD PTR _begin_old_heap$[esp+28]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax

; 194  :   bp_long count, i, trail_cells_deleted=0, num_marked = 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	8b d9		 mov	 ebx, ecx

; 195  : #ifdef DEBUG_GC
; 196  :   bp_long num_skipped=0 ;
; 197  : #endif
; 198  :   term trptr, free_trptr, chptr, refptr;
; 199  :   term begintr, endtr;
; 200  :   
; 201  :   DEBUG0(mark_info, "MARK THE REACHABLE CELLS ...\n\n");
; 202  :   DEBUG1(mark_info, "CALCULATED ARITY : %d\n\n", arity);
; 203  :   DEBUG0(mark_info, "MARK FROM REGISTERS\n");
; 204  :   
; 205  :   /** should be 0? some data is in regs[0]? $$BUG??? */
; 206  :   for(i=FIRSTREG; i<=arity; i++) {

  00011	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00014	89 44 24 14	 mov	 DWORD PTR _trail_cells_deleted$[esp+40], eax
  00018	89 44 24 10	 mov	 DWORD PTR _num_marked$[esp+40], eax
  0001c	3b de		 cmp	 ebx, esi
  0001e	7c 25		 jl	 SHORT $LN58@mark_and_e
$LL60@mark_and_e:

; 207  :     DEBUG1(mark_info, "   MARK FROM REGISTER %d\n", i);
; 208  :     if(VAR(regs[i]))

  00020	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  00023	a8 03		 test	 al, 3
  00025	75 19		 jne	 SHORT $LN59@mark_and_e

; 209  :       num_marked += mark_cell((term)(regs[i]),begin_old_heap,marked);

  00027	8b 4c 24 30	 mov	 ecx, DWORD PTR _H$[esp+36]
  0002b	8b 54 24 40	 mov	 edx, DWORD PTR _marked$[esp+36]
  0002f	51		 push	 ecx
  00030	55		 push	 ebp
  00031	52		 push	 edx
  00032	55		 push	 ebp
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _mark_cell1
  00039	83 c4 14	 add	 esp, 20			; 00000014H
  0003c	01 44 24 10	 add	 DWORD PTR _num_marked$[esp+40], eax
$LN59@mark_and_e:

; 195  : #ifdef DEBUG_GC
; 196  :   bp_long num_skipped=0 ;
; 197  : #endif
; 198  :   term trptr, free_trptr, chptr, refptr;
; 199  :   term begintr, endtr;
; 200  :   
; 201  :   DEBUG0(mark_info, "MARK THE REACHABLE CELLS ...\n\n");
; 202  :   DEBUG1(mark_info, "CALCULATED ARITY : %d\n\n", arity);
; 203  :   DEBUG0(mark_info, "MARK FROM REGISTERS\n");
; 204  :   
; 205  :   /** should be 0? some data is in regs[0]? $$BUG??? */
; 206  :   for(i=FIRSTREG; i<=arity; i++) {

  00040	46		 inc	 esi
  00041	3b f3		 cmp	 esi, ebx
  00043	7e db		 jle	 SHORT $LL60@mark_and_e
$LN58@mark_and_e:

; 210  :     else {
; 211  :       DEBUG0(mark_info, "\tno variable : ");
; 212  :       DEBUG_CELL(mark_info, regs[i],wam);
; 213  :     }
; 214  :   }
; 215  :   
; 216  :   DEBUG0(mark_info, "\nMARK FROM CHOICE-POINTS\n");
; 217  :   
; 218  :   /* first mark all lval entries */ 
; 219  :   DEBUG0(mark_info, "   MARK lval entries first\n");
; 220  :   begintr = TR_GCTOP-1 ;
; 221  :   endtr = (term)(*cpoint[0].TR) ;

  00045	8b 44 24 38	 mov	 eax, DWORD PTR _cpoint$[esp+36]
  00049	8b 4c 24 2c	 mov	 ecx, DWORD PTR _wam$[esp+36]
  0004d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00050	8b 71 2c	 mov	 esi, DWORD PTR [ecx+44]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	83 ee 04	 sub	 esi, 4
  00058	89 44 24 18	 mov	 DWORD PTR _endtr$[esp+40], eax

; 222  :   /* the following should be made conditional: if there are any trailed hash entries ...*/
; 223  :   for( trptr = begintr ; trptr >= endtr ; trptr-- ) { 

  0005c	3b f0		 cmp	 esi, eax
  0005e	72 79		 jb	 SHORT $LN53@mark_and_e
  00060	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
$LL55@mark_and_e:

; 224  :     if (pvtrailentry(trptr)) { trptr-- ; continue ; }

  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	a8 01		 test	 al, 1
  0006a	74 05		 je	 SHORT $LN52@mark_and_e
  0006c	83 ee 04	 sub	 esi, 4
  0006f	eb 5f		 jmp	 SHORT $LN54@mark_and_e
$LN52@mark_and_e:

; 225  :     if(TO_HEAP((*trptr)) || TO_CODE((*trptr))) continue ;

  00071	8b 54 24 30	 mov	 edx, DWORD PTR _H$[esp+36]
  00075	3b e8		 cmp	 ebp, eax
  00077	77 04		 ja	 SHORT $LN49@mark_and_e
  00079	3b d0		 cmp	 edx, eax
  0007b	77 53		 ja	 SHORT $LN54@mark_and_e
$LN49@mark_and_e:
  0007d	3b 05 84 01 00
	00		 cmp	 eax, DWORD PTR _g+388
  00083	72 08		 jb	 SHORT $LN51@mark_and_e
  00085	3b 05 88 01 00
	00		 cmp	 eax, DWORD PTR _g+392
  0008b	72 43		 jb	 SHORT $LN54@mark_and_e
$LN51@mark_and_e:

; 226  :     /* else it should point to the hash table */
; 227  :     /* test this and then start marking from *trptr as a normal root */
; 228  :     { 
; 229  :     hentry hptr =(hentry)(*trptr) ;
; 230  :     cell val=(cell)hptr->val;

  0008d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]

; 231  :     if(ON_HTABLE(hptr) && val) {  

  00090	3b c7		 cmp	 eax, edi
  00092	72 3c		 jb	 SHORT $LN54@mark_and_e
  00094	8b 1d 14 00 00
	00		 mov	 ebx, DWORD PTR _max+20
  0009a	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  0009d	8d 1c 9f	 lea	 ebx, DWORD PTR [edi+ebx*4]
  000a0	3b c3		 cmp	 eax, ebx
  000a2	73 2c		 jae	 SHORT $LN54@mark_and_e
  000a4	85 c9		 test	 ecx, ecx
  000a6	74 28		 je	 SHORT $LN54@mark_and_e

; 232  :       DEBUG1(mark_info, "     mark from Hash Table[%d] : ", hptr-htable );
; 233  :       DEBUG_CELL(mark_info, val, wam );
; 234  :       if(VAR(val) && TO_HEAP(val)) {

  000a8	f6 c1 03	 test	 cl, 3
  000ab	75 23		 jne	 SHORT $LN54@mark_and_e
  000ad	3b e9		 cmp	 ebp, ecx
  000af	77 1f		 ja	 SHORT $LN54@mark_and_e
  000b1	3b d1		 cmp	 edx, ecx
  000b3	76 1b		 jbe	 SHORT $LN54@mark_and_e

; 235  : 		      num_marked +=
; 236  :             mark_cell((term)val,begin_old_heap,marked);

  000b5	52		 push	 edx
  000b6	8b 54 24 44	 mov	 edx, DWORD PTR _marked$[esp+40]
  000ba	55		 push	 ebp
  000bb	52		 push	 edx
  000bc	55		 push	 ebp
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _mark_cell1
  000c3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  000c9	83 c4 14	 add	 esp, 20			; 00000014H
  000cc	01 44 24 10	 add	 DWORD PTR _num_marked$[esp+40], eax
$LN54@mark_and_e:

; 222  :   /* the following should be made conditional: if there are any trailed hash entries ...*/
; 223  :   for( trptr = begintr ; trptr >= endtr ; trptr-- ) { 

  000d0	83 ee 04	 sub	 esi, 4
  000d3	3b 74 24 18	 cmp	 esi, DWORD PTR _endtr$[esp+40]
  000d7	73 8d		 jae	 SHORT $LL55@mark_and_e
$LN53@mark_and_e:

; 237  :       } 
; 238  :     } /* end if: hash table entry */
; 239  :     }
; 240  :   }
; 241  :   
; 242  : #if FIXGC>0
; 243  :   /* AG-DCG registers $$$ */
; 244  :   for( trptr = begintr ; trptr >= endtr ; trptr-- ) { 
; 245  :     if(!pvtrailentry(trptr)) continue;
; 246  :     { term t = (term)(*trptr);
; 247  :     if(ON_DCGS(t)) {
; 248  : 		    /* num_marked +=
; 249  :         * mark_cell(t,begin_old_heap,marked);
; 250  :         */
; 251  :       fprintf(STD_err,"trail[%ld]->%ld\n",TRGC(trptr),t-(term)wam[HeapStk].base);
; 252  :     }
; 253  :     }
; 254  :   }
; 255  : #endif
; 256  :   
; 257  :   for(count=cpoints; count>=0; count--) {

  000d9	8b 54 24 34	 mov	 edx, DWORD PTR _cpoints$[esp+36]
  000dd	8b c2		 mov	 eax, edx
  000df	89 44 24 24	 mov	 DWORD PTR _count$[esp+40], eax
  000e3	85 d2		 test	 edx, edx
  000e5	0f 88 3b 02 00
	00		 js	 $LN87@mark_and_e
  000eb	8b 74 24 38	 mov	 esi, DWORD PTR _cpoint$[esp+36]
  000ef	8b ca		 mov	 ecx, edx
  000f1	03 c9		 add	 ecx, ecx
  000f3	8d 7c ce 1c	 lea	 edi, DWORD PTR [esi+ecx*8+28]
  000f7	89 7c 24 1c	 mov	 DWORD PTR tv818[esp+40], edi
  000fb	eb 03 8d 49 00	 npad	 5
$LL94@mark_and_e:

; 258  :     term current_H ;
; 259  :     DEBUG1(mark_info, "   SCAN TRAIL SEGMENT YOUNGER THAN CHOICE-POINT %d\n",count);
; 260  :     current_H = (term)(*cpoint[count].H) ;

  00100	8b 4f ec	 mov	 ecx, DWORD PTR [edi-20]
  00103	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00105	89 4c 24 20	 mov	 DWORD PTR _current_H$5270[esp+40], ecx

; 261  :     begintr = ((count==cpoints)?TR_GCTOP-1:(((term)(*cpoint[count+1].TR))-1)) ;

  00109	3b c2		 cmp	 eax, edx
  0010b	75 09		 jne	 SHORT $LN63@mark_and_e
  0010d	8b 44 24 2c	 mov	 eax, DWORD PTR _wam$[esp+36]
  00111	8b 70 2c	 mov	 esi, DWORD PTR [eax+44]
  00114	eb 04		 jmp	 SHORT $LN100@mark_and_e
$LN63@mark_and_e:
  00116	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00118	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN100@mark_and_e:

; 262  :     endtr = (term)(*cpoint[count].TR) ;

  0011a	8b 47 f0	 mov	 eax, DWORD PTR [edi-16]
  0011d	8b 00		 mov	 eax, DWORD PTR [eax]
  0011f	83 ee 04	 sub	 esi, 4
  00122	89 44 24 18	 mov	 DWORD PTR _endtr$[esp+40], eax

; 263  :     
; 264  :     for ( trptr = begintr ; trptr >= endtr ; trptr-- ) {

  00126	3b f0		 cmp	 esi, eax
  00128	0f 82 ed 00 00
	00		 jb	 $LN41@mark_and_e
  0012e	8b ff		 npad	 2
$LL98@mark_and_e:

; 265  :       if (pvtrailentry(trptr) /*&& TO_HEAP(*trptr)*/) { /* begin value trail */

  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	a8 01		 test	 al, 1
  00134	0f 84 a1 00 00
	00		 je	 $LN40@mark_and_e

; 266  :         cell temp, val;
; 267  :         /* switch ref and value on trail */
; 268  :         refptr = (term)(*trptr) ;
; 269  :                
; 270  :         *trptr = val = *(trptr-1);

  0013a	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]

; 271  :         *(trptr-1) = (cell)refptr ;
; 272  :         /* refptr = (term)((cell)refptr & ~ (cell)TR_VTAG);  $$$PT */
; 273  :         refptr = (term)((cell)refptr-TR_VTAG);
; 274  : #ifdef DEBUG_GC
; 275  :         if(! TO_HEAP(refptr)) 
; 276  :           DEBUG2(mark_info,"\tRTrail[%d] -> (?) ????[%ld]\n",TRGC(trptr), (cell)refptr);
; 277  : #endif
; 278  :         /* early reset possible ? */
; 279  :         
; 280  :         /* DLL BUG here - switching this off does not help !!! $$$ */
; 281  :         
; 282  :         if(!REACHABLE(refptr,begin_old_heap,marked)) { /* $$$ */

  0013d	8b 5c 24 40	 mov	 ebx, DWORD PTR _marked$[esp+36]
  00141	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  00144	48		 dec	 eax
  00145	8b d0		 mov	 edx, eax
  00147	2b d5		 sub	 edx, ebp
  00149	c1 fa 02	 sar	 edx, 2
  0014c	03 da		 add	 ebx, edx
  0014e	89 0e		 mov	 DWORD PTR [esi], ecx
  00150	8a 13		 mov	 dl, BYTE PTR [ebx]
  00152	84 d2		 test	 dl, dl
  00154	75 15		 jne	 SHORT $LN39@mark_and_e

; 283  :           DEBUG2(mark_info,"\tRTrail[%d] -> (?) ????[%ld] unreachable\n",TRGC(trptr), (cell)refptr);
; 284  :           DEBUG0(mark_info, "\t\tearly reset of value trail\n");
; 285  : 		      *refptr = val;

  00156	89 08		 mov	 DWORD PTR [eax], ecx

; 286  :           *trptr=(cell)NULL;

  00158	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0015e	83 c6 fc	 add	 esi, -4			; fffffffcH

; 287  :           trptr-- ;
; 288  :           *trptr=(cell)NULL;
; 289  :           trail_cells_deleted+=2;

  00161	83 44 24 14 02	 add	 DWORD PTR _trail_cells_deleted$[esp+40], 2
  00166	e9 99 00 00 00	 jmp	 $LN101@mark_and_e
$LN39@mark_and_e:

; 290  :         }
; 291  :         else if (refptr >= current_H) /* check if can be tidied */ { 

  0016b	3b 44 24 20	 cmp	 eax, DWORD PTR _current_H$5270[esp+40]
  0016f	72 14		 jb	 SHORT $LN37@mark_and_e

; 292  :           *trptr=(cell)NULL ;
; 293  :           trptr-- ;
; 294  :           *trptr=(cell)NULL;
; 295  :           trail_cells_deleted +=2 ;
; 296  :         } else { /* $$$ restore the state before value trailing */

  00171	8b 7c 24 1c	 mov	 edi, DWORD PTR tv818[esp+40]
  00175	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0017b	83 c6 fc	 add	 esi, -4			; fffffffcH
  0017e	83 44 24 14 02	 add	 DWORD PTR _trail_cells_deleted$[esp+40], 2
  00183	eb 7f		 jmp	 SHORT $LN101@mark_and_e
$LN37@mark_and_e:

; 297  :           bp_long was_internal ;
; 298  :           was_internal = INTERNAL(refptr,begin_old_heap,marked) ;

  00185	0f be fa	 movsx	 edi, dl

; 299  :           DEBUG0(mark_info,"\t\trestoring state before value trailing\n");
; 300  :           temp = *refptr;

  00188	8b 10		 mov	 edx, DWORD PTR [eax]

; 301  :           *refptr = val ;

  0018a	89 08		 mov	 DWORD PTR [eax], ecx

; 302  :           *trptr = temp;

  0018c	89 16		 mov	 DWORD PTR [esi], edx

; 303  :           if(COMPOUND(val) || VAR((term)val)) { 

  0018e	8b d1		 mov	 edx, ecx
  00190	83 e2 03	 and	 edx, 3
  00193	83 e7 02	 and	 edi, 2
  00196	83 fa 03	 cmp	 edx, 3
  00199	75 08		 jne	 SHORT $LN33@mark_and_e
  0019b	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  001a1	75 04		 jne	 SHORT $LN34@mark_and_e
$LN33@mark_and_e:
  001a3	85 d2		 test	 edx, edx
  001a5	75 24		 jne	 SHORT $LN35@mark_and_e
$LN34@mark_and_e:

; 304  :             DEBUG0(mark_info, "\t\trestored value is a functor or var\n");
; 305  :             UNMARK_REACHABLE(refptr,begin_old_heap,marked);
; 306  :             num_marked--;
; 307  :             num_marked += mark_cell(refptr,begin_old_heap,marked);

  001a7	8b 4c 24 30	 mov	 ecx, DWORD PTR _H$[esp+36]
  001ab	8b 54 24 40	 mov	 edx, DWORD PTR _marked$[esp+36]
  001af	51		 push	 ecx
  001b0	55		 push	 ebp
  001b1	52		 push	 edx
  001b2	55		 push	 ebp
  001b3	50		 push	 eax
  001b4	c6 03 00	 mov	 BYTE PTR [ebx], 0
  001b7	e8 00 00 00 00	 call	 _mark_cell1
  001bc	8b 4c 24 24	 mov	 ecx, DWORD PTR _num_marked$[esp+60]
  001c0	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  001c4	83 c4 14	 add	 esp, 20			; 00000014H
  001c7	89 54 24 10	 mov	 DWORD PTR _num_marked$[esp+40], edx
$LN35@mark_and_e:

; 308  :           }
; 309  :           if (was_internal) MARK_INTERNAL(refptr,begin_old_heap,marked);

  001cb	85 ff		 test	 edi, edi
  001cd	74 03		 je	 SHORT $LN32@mark_and_e
  001cf	c6 03 03	 mov	 BYTE PTR [ebx], 3
$LN32@mark_and_e:

; 310  :           trptr--;
; 311  :         }

  001d2	8b 7c 24 1c	 mov	 edi, DWORD PTR tv818[esp+40]
  001d6	83 c6 fc	 add	 esi, -4			; fffffffcH
  001d9	eb 2f		 jmp	 SHORT $LN42@mark_and_e
$LN40@mark_and_e:

; 312  :       } /* end value trail entry */
; 313  :       else if TO_HEAP(*trptr) {

  001db	3b e8		 cmp	 ebp, eax
  001dd	77 2b		 ja	 SHORT $LN42@mark_and_e
  001df	39 44 24 30	 cmp	 DWORD PTR _H$[esp+36], eax
  001e3	76 25		 jbe	 SHORT $LN42@mark_and_e

; 314  :         DEBUG3(mark_info, "\t Trail[%d] -> %s Heap[%d] : ",TRGC(trptr), 
; 315  :           REACHABLE((term)*trptr,begin_old_heap,marked) ? "(r)" : "( )",HP(*trptr));
; 316  :         DEBUG_CELL(mark_info, **(term *)trptr,wam);
; 317  :         
; 318  :         /* early reset possible ? */
; 319  :         if(!REACHABLE((term)(*trptr),begin_old_heap,marked)) { 

  001e5	8b 54 24 40	 mov	 edx, DWORD PTR _marked$[esp+36]
  001e9	8b c8		 mov	 ecx, eax
  001eb	2b cd		 sub	 ecx, ebp
  001ed	c1 f9 02	 sar	 ecx, 2
  001f0	80 3c 11 00	 cmp	 BYTE PTR [ecx+edx], 0
  001f4	75 04		 jne	 SHORT $LN29@mark_and_e

; 320  :           DEBUG0(mark_info, "\t\tearly reset ordinary trail\n");
; 321  :           *(*(term *)trptr) = *trptr;

  001f6	89 00		 mov	 DWORD PTR [eax], eax

; 322  :           *trptr=(cell)NULL;
; 323  :           trail_cells_deleted++;

  001f8	eb 06		 jmp	 SHORT $LN102@mark_and_e
$LN29@mark_and_e:

; 324  :         }
; 325  :         /* check if can be tidied */
; 326  :         else if ((term)(*trptr) >= current_H) { 

  001fa	3b 44 24 20	 cmp	 eax, DWORD PTR _current_H$5270[esp+40]
  001fe	72 0a		 jb	 SHORT $LN42@mark_and_e
$LN102@mark_and_e:

; 328  :           trail_cells_deleted++ ;

  00200	ff 44 24 14	 inc	 DWORD PTR _trail_cells_deleted$[esp+40]
$LN101@mark_and_e:

; 327  :           *trptr=(cell)NULL ;

  00204	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN42@mark_and_e:

; 263  :     
; 264  :     for ( trptr = begintr ; trptr >= endtr ; trptr-- ) {

  0020a	83 ee 04	 sub	 esi, 4
  0020d	3b 74 24 18	 cmp	 esi, DWORD PTR _endtr$[esp+40]
  00211	0f 83 19 ff ff
	ff		 jae	 $LL98@mark_and_e
  00217	8b 54 24 34	 mov	 edx, DWORD PTR _cpoints$[esp+36]
$LN41@mark_and_e:

; 329  :         }
; 330  :       } /* end ordinary trail entry */
; 331  :       else { 
; 332  :         /* it should point to the hash table */
; 333  :         /* it has been marked already */
; 334  :         /* quietmes("hash entry in gc %s\n","found"); */
; 335  :       }
; 336  :     } /* end for */
; 337  :     
; 338  :     
; 339  :     DEBUG1(mark_info, "   MARK FROM CHOICE-POINT %d\n", count);
; 340  :     trptr = cpoint[count].start+cpoint[count].arity ;

  0021b	8b 77 e4	 mov	 esi, DWORD PTR [edi-28]
  0021e	8b 47 e8	 mov	 eax, DWORD PTR [edi-24]
  00221	8d 1c 86	 lea	 ebx, DWORD PTR [esi+eax*4]

; 341  :     
; 342  :     
; 343  :     /* VCC GC BUG starts here */
; 344  :     
; 345  :     for(chptr=cpoint[count].start; chptr<trptr; chptr++) {

  00224	3b f3		 cmp	 esi, ebx
  00226	73 2a		 jae	 SHORT $LN45@mark_and_e
$LL25@mark_and_e:

; 346  : 	     DEBUG1(mark_info, "     mark from Choice[%d] : ", CH(chptr) );
; 347  :        DEBUG_CELL(mark_info, (cell)(*chptr), wam );
; 348  :        if(VAR(*chptr))

  00228	8b 06		 mov	 eax, DWORD PTR [esi]
  0022a	a8 03		 test	 al, 3
  0022c	75 19		 jne	 SHORT $LN24@mark_and_e

; 349  : 	        num_marked += mark_cell((term)(*chptr),begin_old_heap,marked);

  0022e	8b 4c 24 30	 mov	 ecx, DWORD PTR _H$[esp+36]
  00232	8b 54 24 40	 mov	 edx, DWORD PTR _marked$[esp+36]
  00236	51		 push	 ecx
  00237	55		 push	 ebp
  00238	52		 push	 edx
  00239	55		 push	 ebp
  0023a	50		 push	 eax
  0023b	e8 00 00 00 00	 call	 _mark_cell1
  00240	83 c4 14	 add	 esp, 20			; 00000014H
  00243	01 44 24 10	 add	 DWORD PTR _num_marked$[esp+40], eax
$LN24@mark_and_e:

; 341  :     
; 342  :     
; 343  :     /* VCC GC BUG starts here */
; 344  :     
; 345  :     for(chptr=cpoint[count].start; chptr<trptr; chptr++) {

  00247	83 c6 04	 add	 esi, 4
  0024a	3b f3		 cmp	 esi, ebx
  0024c	72 da		 jb	 SHORT $LL25@mark_and_e
  0024e	8b 54 24 34	 mov	 edx, DWORD PTR _cpoints$[esp+36]
$LN45@mark_and_e:

; 237  :       } 
; 238  :     } /* end if: hash table entry */
; 239  :     }
; 240  :   }
; 241  :   
; 242  : #if FIXGC>0
; 243  :   /* AG-DCG registers $$$ */
; 244  :   for( trptr = begintr ; trptr >= endtr ; trptr-- ) { 
; 245  :     if(!pvtrailentry(trptr)) continue;
; 246  :     { term t = (term)(*trptr);
; 247  :     if(ON_DCGS(t)) {
; 248  : 		    /* num_marked +=
; 249  :         * mark_cell(t,begin_old_heap,marked);
; 250  :         */
; 251  :       fprintf(STD_err,"trail[%ld]->%ld\n",TRGC(trptr),t-(term)wam[HeapStk].base);
; 252  :     }
; 253  :     }
; 254  :   }
; 255  : #endif
; 256  :   
; 257  :   for(count=cpoints; count>=0; count--) {

  00252	8b 44 24 24	 mov	 eax, DWORD PTR _count$[esp+40]
  00256	48		 dec	 eax
  00257	83 ef 10	 sub	 edi, 16			; 00000010H
  0025a	89 44 24 24	 mov	 DWORD PTR _count$[esp+40], eax
  0025e	89 7c 24 1c	 mov	 DWORD PTR tv818[esp+40], edi
  00262	85 c0		 test	 eax, eax
  00264	0f 89 96 fe ff
	ff		 jns	 $LL94@mark_and_e

; 350  : 	   }
; 351  :   } /* end of choice point "for" */
; 352  :   
; 353  :   DEBUG1(mark_info, "\nCOMPACT THE TRAIL (%d entries to delete)\n",trail_cells_deleted);  
; 354  :   if(trail_cells_deleted>0) {

  0026a	83 7c 24 14 00	 cmp	 DWORD PTR _trail_cells_deleted$[esp+40], 0
  0026f	0f 8e b1 00 00
	00		 jle	 $LN87@mark_and_e

; 355  : #ifdef DEBUG_GC
; 356  :     print_trail("before.compacting.trail", H, wam, A,1);
; 357  : #endif
; 358  :     /* search for the first NULL entry (there is at least one) */
; 359  :     trptr=TR_BASE;

  00275	8b 5c 24 2c	 mov	 ebx, DWORD PTR _wam$[esp+36]
  00279	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]

; 360  :     while(*trptr)

  0027c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0027f	74 08		 je	 SHORT $LN19@mark_and_e
$LL20@mark_and_e:

; 361  :       trptr++;

  00281	83 c0 04	 add	 eax, 4
  00284	83 38 00	 cmp	 DWORD PTR [eax], 0
  00287	75 f8		 jne	 SHORT $LL20@mark_and_e
$LN19@mark_and_e:

; 362  :     
; 363  :     DEBUG1(mark_info, "\tThe first NULL entry on trail : Trail[%d]\n",TRGC(trptr));
; 364  :     /* find the oldest younger choice-point (if there is one) */
; 365  :     
; 366  :     for(count=0; count<=cpoints; count++) 

  00289	8b 74 24 38	 mov	 esi, DWORD PTR _cpoint$[esp+36]
  0028d	33 c9		 xor	 ecx, ecx
  0028f	85 d2		 test	 edx, edx
  00291	78 13		 js	 SHORT $LN97@mark_and_e
  00293	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
$LL18@mark_and_e:

; 367  :       if((term)(*cpoint[count].TR)>trptr) break;

  00296	8b 3a		 mov	 edi, DWORD PTR [edx]
  00298	39 07		 cmp	 DWORD PTR [edi], eax
  0029a	77 0a		 ja	 SHORT $LN97@mark_and_e

; 362  :     
; 363  :     DEBUG1(mark_info, "\tThe first NULL entry on trail : Trail[%d]\n",TRGC(trptr));
; 364  :     /* find the oldest younger choice-point (if there is one) */
; 365  :     
; 366  :     for(count=0; count<=cpoints; count++) 

  0029c	41		 inc	 ecx
  0029d	83 c2 10	 add	 edx, 16			; 00000010H
  002a0	3b 4c 24 34	 cmp	 ecx, DWORD PTR _cpoints$[esp+36]
  002a4	7e f0		 jle	 SHORT $LL18@mark_and_e
$LN97@mark_and_e:

; 368  :       
; 369  :       if((count<cpoints)||((count==cpoints) && ((term)(*cpoint[count].TR)>trptr))) { 

  002a6	8b 54 24 34	 mov	 edx, DWORD PTR _cpoints$[esp+36]
  002aa	3b ca		 cmp	 ecx, edx
  002ac	7c 15		 jl	 SHORT $LN13@mark_and_e
  002ae	75 0c		 jne	 SHORT $LN14@mark_and_e
  002b0	8b d1		 mov	 edx, ecx
  002b2	03 d2		 add	 edx, edx
  002b4	8b 54 d6 0c	 mov	 edx, DWORD PTR [esi+edx*8+12]
  002b8	39 02		 cmp	 DWORD PTR [edx], eax
  002ba	77 07		 ja	 SHORT $LN13@mark_and_e
$LN14@mark_and_e:

; 386  :         }
; 387  :       } else { 
; 388  :         DEBUG0(mark_info, "\tThere is no younger choice-point\n");
; 389  :         free_trptr = trptr;

  002bc	8b d0		 mov	 edx, eax

; 390  :         trptr++;

  002be	83 c0 04	 add	 eax, 4
  002c1	eb 45		 jmp	 SHORT $LN96@mark_and_e
$LN13@mark_and_e:

; 372  :         trptr++;
; 373  :         for(i=count; i<=cpoints; i++) { 

  002c3	8b 7c 24 34	 mov	 edi, DWORD PTR _cpoints$[esp+36]
  002c7	8b d0		 mov	 edx, eax
  002c9	83 c0 04	 add	 eax, 4
  002cc	3b cf		 cmp	 ecx, edi
  002ce	7f 38		 jg	 SHORT $LN96@mark_and_e

; 370  :         DEBUG1(mark_info,"\toldest younger choice-point : Choice[%d]\n",CH(cpoint[count].TR));
; 371  :         free_trptr = trptr;

  002d0	8b d9		 mov	 ebx, ecx
  002d2	03 db		 add	 ebx, ebx
  002d4	2b f9		 sub	 edi, ecx
  002d6	8d 74 de 0c	 lea	 esi, DWORD PTR [esi+ebx*8+12]
  002da	47		 inc	 edi
  002db	eb 03 8d 49 00	 npad	 5
$LL12@mark_and_e:

; 374  :           while((term)(*cpoint[i].TR)>trptr) { 

  002e0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002e2	39 01		 cmp	 DWORD PTR [ecx], eax
  002e4	76 14		 jbe	 SHORT $LN8@mark_and_e
$LL9@mark_and_e:

; 375  :             if(*trptr)

  002e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e8	85 c9		 test	 ecx, ecx
  002ea	74 05		 je	 SHORT $LN93@mark_and_e

; 376  :               *(free_trptr++) = *trptr;

  002ec	89 0a		 mov	 DWORD PTR [edx], ecx
  002ee	83 c2 04	 add	 edx, 4
$LN93@mark_and_e:

; 377  :             else { 
; 378  :               DEBUG1(mark_info, "\tSkipping NULL entry on Trail[%d]\n",TRGC(trptr));
; 379  : #ifdef DEBUG_GC
; 380  :               num_skipped++;
; 381  : #endif
; 382  :             }
; 383  :             trptr++;

  002f1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002f3	83 c0 04	 add	 eax, 4
  002f6	39 01		 cmp	 DWORD PTR [ecx], eax
  002f8	77 ec		 ja	 SHORT $LL9@mark_and_e
$LN8@mark_and_e:

; 384  :           }
; 385  :           *cpoint[i].TR=(cell)free_trptr;

  002fa	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002fc	83 c6 10	 add	 esi, 16			; 00000010H
  002ff	4f		 dec	 edi
  00300	89 11		 mov	 DWORD PTR [ecx], edx
  00302	75 dc		 jne	 SHORT $LL12@mark_and_e

; 372  :         trptr++;
; 373  :         for(i=count; i<=cpoints; i++) { 

  00304	8b 5c 24 2c	 mov	 ebx, DWORD PTR _wam$[esp+36]
$LN96@mark_and_e:

; 391  :       }
; 392  :       while(trptr<TR_GCTOP) { 

  00308	3b 43 2c	 cmp	 eax, DWORD PTR [ebx+44]
  0030b	73 16		 jae	 SHORT $LN3@mark_and_e
  0030d	8d 49 00	 npad	 3
$LL4@mark_and_e:

; 393  :         if(*trptr)

  00310	8b 08		 mov	 ecx, DWORD PTR [eax]
  00312	85 c9		 test	 ecx, ecx
  00314	74 05		 je	 SHORT $LN99@mark_and_e

; 394  :           *(free_trptr++) = *trptr;

  00316	89 0a		 mov	 DWORD PTR [edx], ecx
  00318	83 c2 04	 add	 edx, 4
$LN99@mark_and_e:

; 395  :         else { 
; 396  :           DEBUG1(mark_info, "\tSkipping NULL entry on Trail[%d]\n",TRGC(trptr));
; 397  : #ifdef DEBUG_GC
; 398  :           num_skipped++;
; 399  : #endif
; 400  :         }
; 401  :         trptr++;

  0031b	83 c0 04	 add	 eax, 4
  0031e	3b 43 2c	 cmp	 eax, DWORD PTR [ebx+44]
  00321	72 ed		 jb	 SHORT $LL4@mark_and_e
$LN3@mark_and_e:

; 402  :       }
; 403  :       SET_TR_GCTOP(free_trptr);

  00323	89 53 2c	 mov	 DWORD PTR [ebx+44], edx
$LN87@mark_and_e:

; 404  :       DEBUG1(mark_info, "TRAIL COMPACTED : deleted %d NULL entries\n",num_skipped+1);
; 405  :   }
; 406  :   DEBUG1(mark_info, "\nMARK PHASE DONE !! (%d cells marked)\n\n", num_marked);
; 407  :   DEBUG_CLOSE(mark_info);
; 408  :   return(num_marked) ;

  00326	8b 44 24 10	 mov	 eax, DWORD PTR _num_marked$[esp+40]
  0032a	5f		 pop	 edi
  0032b	5e		 pop	 esi
  0032c	5d		 pop	 ebp
  0032d	5b		 pop	 ebx

; 409  :   
; 410  : } /* mark_and_early_reset */

  0032e	83 c4 18	 add	 esp, 24			; 00000018H
  00331	c3		 ret	 0
_mark_and_early_reset ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _scan_forwarded
_TEXT	SEGMENT
_scan$ = 8						; size = 4
_offset$ = 12						; size = 4
_H$ = 16						; size = 4
_segment_boundary$ = 20					; size = 4
_begin_old_heap$ = 24					; size = 4
_begin_new_heap$ = 28					; size = 4
_end_new_heap$ = 32					; size = 4
_marked$ = 36						; size = 4
_scan_forwarded PROC					; COMDAT
; _next$ = eax

; 416  :   term hpptr, lower, upper, srcptr;
; 417  :   cell starscan ;
; 418  :   
; 419  :   DEBUG2(copy_info, "\tscan from Extra[%d] to Extra[%d]\n", EX(scan),EX(next-1));
; 420  :   while(scan<next)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _scan$[esp-4]
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax
  00007	3b d7		 cmp	 edx, edi
  00009	0f 83 f6 00 00
	00		 jae	 $LN21@scan_forwa
  0000f	53		 push	 ebx
  00010	55		 push	 ebp
  00011	56		 push	 esi
$LL22@scan_forwa:

; 421  :   {
; 422  :     DEBUG1(copy_info, "\t\tscan -> Extra[%d] : ", EX(scan));
; 423  :     starscan = *scan ;

  00012	8b 02		 mov	 eax, DWORD PTR [edx]

; 424  :     if(VAR(starscan))

  00014	a8 03		 test	 al, 3
  00016	0f 85 d5 00 00
	00		 jne	 $LN4@scan_forwa

; 425  :     {
; 426  : #if 1 /* AS NOT ALL VARS ARE ON THE HEAP!!! - Paul */
; 427  :       if(TO_HEAP(starscan))

  0001c	8b 5c 24 24	 mov	 ebx, DWORD PTR _begin_old_heap$[esp+12]
  00020	3b d8		 cmp	 ebx, eax
  00022	0f 87 b0 00 00
	00		 ja	 $LN19@scan_forwa
  00028	39 44 24 1c	 cmp	 DWORD PTR _H$[esp+12], eax
  0002c	0f 86 a6 00 00
	00		 jbe	 $LN19@scan_forwa

; 428  : #endif
; 429  :       {
; 430  :         DEBUG_CELL(copy_info, starscan,wam);
; 431  :         if((term)(starscan) < segment_boundary)

  00032	3b 44 24 20	 cmp	 eax, DWORD PTR _segment_boundary$[esp+12]
  00036	0f 83 b5 00 00
	00		 jae	 $LN4@scan_forwa

; 432  :         {
; 433  :           DEBUG0(copy_info, "\t\tintra- or backward-segment ");
; 434  :           hpptr = (term)(starscan);
; 435  :           if(!FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap))

  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	f6 c1 03	 test	 cl, 3
  00041	75 10		 jne	 SHORT $LN16@scan_forwa
  00043	39 4c 24 28	 cmp	 DWORD PTR _begin_new_heap$[esp+12], ecx
  00047	77 0a		 ja	 SHORT $LN16@scan_forwa
  00049	3b 4c 24 2c	 cmp	 ecx, DWORD PTR _end_new_heap$[esp+12]
  0004d	0f 82 81 00 00
	00		 jb	 $LN9@scan_forwa
$LN16@scan_forwa:

; 436  :           {
; 437  :             DEBUG0(copy_info, "and not forwarded yet\n");
; 438  :             FIND_BLOCK;

  00053	8b c8		 mov	 ecx, eax
  00055	2b cb		 sub	 ecx, ebx
  00057	8b 5c 24 30	 mov	 ebx, DWORD PTR _marked$[esp+12]
  0005b	8b d1		 mov	 edx, ecx
  0005d	c1 fa 02	 sar	 edx, 2
  00060	f6 04 1a 02	 test	 BYTE PTR [edx+ebx], 2
  00064	8b f0		 mov	 esi, eax
  00066	74 11		 je	 SHORT $LN14@scan_forwa
$LL15@scan_forwa:
  00068	83 e9 04	 sub	 ecx, 4
  0006b	8b d1		 mov	 edx, ecx
  0006d	c1 fa 02	 sar	 edx, 2
  00070	83 ee 04	 sub	 esi, 4
  00073	f6 04 1a 02	 test	 BYTE PTR [edx+ebx], 2
  00077	75 ef		 jne	 SHORT $LL15@scan_forwa
$LN14@scan_forwa:
  00079	8b 2e		 mov	 ebp, DWORD PTR [esi]
  0007b	8b cd		 mov	 ecx, ebp
  0007d	83 e1 03	 and	 ecx, 3
  00080	8b d6		 mov	 edx, esi
  00082	80 f9 03	 cmp	 cl, 3
  00085	75 23		 jne	 SHORT $LN12@scan_forwa
  00087	8b cd		 mov	 ecx, ebp
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL13@scan_forwa:
  00090	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00093	85 c9		 test	 ecx, ecx
  00095	74 13		 je	 SHORT $LN12@scan_forwa
  00097	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0009a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009c	8b d9		 mov	 ebx, ecx
  0009e	83 e3 03	 and	 ebx, 3
  000a1	80 fb 03	 cmp	 bl, 3
  000a4	8b 5c 24 30	 mov	 ebx, DWORD PTR _marked$[esp+12]
  000a8	74 e6		 je	 SHORT $LL13@scan_forwa
$LN12@scan_forwa:

; 439  :             FORWARD_BLOCK(lower, upper, next);

  000aa	8b ce		 mov	 ecx, esi
  000ac	3b f2		 cmp	 esi, edx
  000ae	77 20		 ja	 SHORT $LN35@scan_forwa
  000b0	2b 74 24 24	 sub	 esi, DWORD PTR _begin_old_heap$[esp+12]
$LL11@scan_forwa:
  000b4	8b ee		 mov	 ebp, esi
  000b6	c1 fd 02	 sar	 ebp, 2
  000b9	c6 04 2b 00	 mov	 BYTE PTR [ebx+ebp], 0
  000bd	8b 29		 mov	 ebp, DWORD PTR [ecx]
  000bf	89 2f		 mov	 DWORD PTR [edi], ebp
  000c1	89 39		 mov	 DWORD PTR [ecx], edi
  000c3	83 c1 04	 add	 ecx, 4
  000c6	83 c7 04	 add	 edi, 4
  000c9	83 c6 04	 add	 esi, 4
  000cc	3b ca		 cmp	 ecx, edx
  000ce	76 e4		 jbe	 SHORT $LL11@scan_forwa
$LN35@scan_forwa:
  000d0	8b 54 24 14	 mov	 edx, DWORD PTR _scan$[esp+12]
$LN9@scan_forwa:

; 440  :           }
; 441  :           else DEBUG0(copy_info, "but already forwarded\n");
; 442  :           DEBUG2(copy_info, "\t\tredirect Extra[%d] to Extra[%d]\n",
; 443  :             EX(scan), EX((**(term **)scan)));
; 444  :           *scan = (cell)((*(term *)starscan)+offset);

  000d4	8b 00		 mov	 eax, DWORD PTR [eax]

; 445  :         } /* an intra- or backward-segment heap reference */
; 446  :         else
; 447  :         {
; 448  :           DEBUG0(copy_info,"\t\ta forward-segment heap reference : wait\n");
; 449  :           DEBUG1(copy_info,"\t\theapcell -> Heap[%d] should be trailed !?!\n",
; 450  :             HP((term)(*scan)));
; 451  :         } /* a forward-segment heap reference */
; 452  :       } /* *scan points in heap */
; 453  : #if 1
; 454  :       else

  000d6	eb 10		 jmp	 SHORT $LN36@scan_forwa
$LN19@scan_forwa:

; 455  :       {
; 456  :         if(TO_EXTRA(*scan))

  000d8	39 44 24 28	 cmp	 DWORD PTR _begin_new_heap$[esp+12], eax
  000dc	77 13		 ja	 SHORT $LN4@scan_forwa
  000de	39 44 24 2c	 cmp	 DWORD PTR _end_new_heap$[esp+12], eax
  000e2	76 0d		 jbe	 SHORT $LN4@scan_forwa

; 457  :         { DEBUG1(copy_info, "VAR -> Extra[%d]\n", EX(*scan));
; 458  : 		      if((term)(*scan)==scan)

  000e4	3b c2		 cmp	 eax, edx
  000e6	75 09		 jne	 SHORT $LN4@scan_forwa
$LN36@scan_forwa:

; 459  :           { DEBUG0(copy_info, "\t\tit's an undef : adjust\n");
; 460  :           *scan = (cell)((term)(*scan) + offset);

  000e8	8b 4c 24 18	 mov	 ecx, DWORD PTR _offset$[esp+12]
  000ec	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000ef	89 02		 mov	 DWORD PTR [edx], eax
$LN4@scan_forwa:

; 461  :           }
; 462  :           else DEBUG0(copy_info,"\t\tNOT an undef but points in extra ????\n");
; 463  :         } /* *scan points in extra */
; 464  :         else DEBUG0(copy_info, "does NOT point in heap or extra ????\n");
; 465  :       }
; 466  : #endif
; 467  :     } /* *scan is a variable */
; 468  :     else DEBUG0(copy_info, "not a variable\n");
; 469  :     scan++;

  000f1	83 c2 04	 add	 edx, 4
  000f4	89 54 24 14	 mov	 DWORD PTR _scan$[esp+12], edx
  000f8	3b d7		 cmp	 edx, edi
  000fa	0f 82 12 ff ff
	ff		 jb	 $LL22@scan_forwa

; 470  :   }
; 471  :   return(next) ;

  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	8b c7		 mov	 eax, edi
  00104	5b		 pop	 ebx
$LN21@scan_forwa:
  00105	5f		 pop	 edi

; 472  : } /* scan_forwarded */

  00106	c3		 ret	 0
_scan_forwarded ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@MJEIKDBG@different?5number?5of?5forwarded?5th@ ; `string'
PUBLIC	??_C@_0CN@FBCFPGMN@Cannot?5allocate?5the?5extra_segmen@ ; `string'
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_0DE@MJEIKDBG@different?5number?5of?5forwarded?5th@
CONST	SEGMENT
??_C@_0DE@MJEIKDBG@different?5number?5of?5forwarded?5th@ DB 'different nu'
	DB	'mber of forwarded than space allocated', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FBCFPGMN@Cannot?5allocate?5the?5extra_segmen@
CONST	SEGMENT
??_C@_0CN@FBCFPGMN@Cannot?5allocate?5the?5extra_segmen@ DB 'Cannot alloca'
	DB	'te the extra_segment_end array', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _copy_to_extra_heap
_TEXT	SEGMENT
_offset$ = -40						; size = 4
_scan$ = -36						; size = 4
tv782 = -32						; size = 4
_a_value_trail_entry$ = -28				; size = 4
_chptr$ = -28						; size = 4
_current_H$ = -24					; size = 4
_endtr$ = -20						; size = 4
_count$ = -16						; size = 4
tv1166 = -12						; size = 4
tv765 = -12						; size = 4
tv716 = -12						; size = 4
_hpptr$ = -12						; size = 4
tv775 = -8						; size = 4
tv680 = -8						; size = 4
_trptr$ = -8						; size = 4
_next$ = -8						; size = 4
_extra_segment_end$ = -4				; size = 4
_arity$ = 8						; size = 4
_H$ = 12						; size = 4
_wam$ = 16						; size = 4
_regs$ = 20						; size = 4
_begin_new_heap$ = 24					; size = 4
_end_new_heap$ = 28					; size = 4
_cpoints$ = 32						; size = 4
_cpoint$ = 36						; size = 4
_begin_old_heap$ = 40					; size = 4
_marked$ = 44						; size = 4
_copy_to_extra_heap PROC				; COMDAT
; _max_num_choice_points$ = eax

; 479  :                                bp_long cpoints, cp *cpoint, term begin_old_heap, char *marked) {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	56		 push	 esi
  00004	8b 74 24 54	 mov	 esi, DWORD PTR _marked$[esp+40]
  00008	57		 push	 edi
  00009	8b 7c 24 44	 mov	 edi, DWORD PTR _begin_new_heap$[esp+44]

; 480  :   term chptr, hpptr, lower, upper, scan, next, trptr, *extra_segment_end;
; 481  :   term begintr, endtr;
; 482  :   bp_long count, offset, reg_i, a_value_trail_entry ;
; 483  :   term srcptr, current_H;
; 484  :   
; 485  : #ifdef DEBUG_GC
; 486  :   if(!(copy_info=fopen("info.copy", "w")))
; 487  :     EXIT0("Cannot open file : info.copy\n");
; 488  :   num_forwarded = blocks_internal_referenced = blocks_total = 0;
; 489  : #endif
; 490  :   
; 491  :   if(!(extra_segment_end=TALLOC(max_num_choice_points )))

  0000d	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 _malloc
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 44 24 2c	 mov	 DWORD PTR _extra_segment_end$[esp+48], eax
  00021	85 c0		 test	 eax, eax
  00023	75 2b		 jne	 SHORT $LN94@copy_to_ex

; 492  :     EXIT0("Cannot allocate the extra_segment_end array\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FBCFPGMN@Cannot?5allocate?5the?5extra_segmen@
  0002a	e8 00 00 00 00	 call	 ___iob_func
  0002f	83 c0 40	 add	 eax, 64			; 00000040H
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _fprintf
  00038	e8 00 00 00 00	 call	 ___iob_func
  0003d	83 c0 40	 add	 eax, 64			; 00000040H
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _fflush
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	6a ff		 push	 -1
  0004b	e8 00 00 00 00	 call	 _exit
$LN94@copy_to_ex:

; 493  :   offset = begin_old_heap-begin_new_heap;

  00050	8b 44 24 54	 mov	 eax, DWORD PTR _begin_old_heap$[esp+44]
  00054	2b c7		 sub	 eax, edi
  00056	c1 f8 02	 sar	 eax, 2

; 494  :   
; 495  :   scan = begin_new_heap ;
; 496  :   
; 497  :   DEBUG0(copy_info, "COPY TO EXTRA HEAP ...\n\n");
; 498  :   next = begin_new_heap;  
; 499  :   DEBUG0(copy_info, "DO CHOICE-POINTS (bottom-up)\n");
; 500  :   for( count=0; count<=cpoints; count++) {

  00059	83 7c 24 4c 00	 cmp	 DWORD PTR _cpoints$[esp+44], 0
  0005e	53		 push	 ebx
  0005f	89 44 24 0c	 mov	 DWORD PTR _offset$[esp+52], eax
  00063	55		 push	 ebp
  00064	89 7c 24 14	 mov	 DWORD PTR _scan$[esp+56], edi
  00068	8b c7		 mov	 eax, edi
  0006a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR _count$[esp+56], 0
  00072	0f 8c 33 05 00
	00		 jl	 $LN91@copy_to_ex
  00078	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL93@copy_to_ex:

; 501  :     current_H = (term)(*cpoint[count].H) ;

  00080	8b 54 24 28	 mov	 edx, DWORD PTR _count$[esp+56]

; 502  :     DEBUG1(copy_info, "   DO CHOICE-POINT %d\n", count);
; 503  :     endtr = cpoint[count].start+cpoint[count].arity ;
; 504  :     for(chptr=cpoint[count].start; chptr<endtr; chptr++) {

  00084	8b 5c 24 5c	 mov	 ebx, DWORD PTR _begin_old_heap$[esp+52]
  00088	c1 e2 04	 shl	 edx, 4
  0008b	03 54 24 58	 add	 edx, DWORD PTR _cpoint$[esp+52]
  0008f	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00092	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00094	89 54 24 30	 mov	 DWORD PTR tv680[esp+56], edx
  00098	89 4c 24 20	 mov	 DWORD PTR _current_H$[esp+56], ecx
  0009c	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009e	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a1	8d 3c 91	 lea	 edi, DWORD PTR [ecx+edx*4]
  000a4	8b d1		 mov	 edx, ecx
  000a6	89 7c 24 24	 mov	 DWORD PTR _endtr$[esp+56], edi
  000aa	89 4c 24 1c	 mov	 DWORD PTR _chptr$[esp+56], ecx
  000ae	3b d7		 cmp	 edx, edi
  000b0	0f 83 cd 00 00
	00		 jae	 $LN88@copy_to_ex
  000b6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL90@copy_to_ex:

; 505  :       DEBUG1(copy_info, "\tconsidering Choice[%d] : ", CH(chptr));
; 506  :       if(VAR(*chptr)&&TO_HEAP(*chptr)) {

  000c0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000c2	f6 c1 03	 test	 cl, 3
  000c5	0f 85 a9 00 00
	00		 jne	 $LN89@copy_to_ex
  000cb	3b d9		 cmp	 ebx, ecx
  000cd	0f 87 a1 00 00
	00		 ja	 $LN89@copy_to_ex
  000d3	39 4c 24 40	 cmp	 DWORD PTR _H$[esp+52], ecx
  000d7	0f 86 97 00 00
	00		 jbe	 $LN89@copy_to_ex

; 507  :         DEBUG1(copy_info, "root to Heap[%d] ", HP(*chptr));
; 508  :         hpptr = (term)(*chptr);
; 509  :         if(!FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap)) {

  000dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000df	f6 c2 03	 test	 dl, 3
  000e2	75 0c		 jne	 SHORT $LN85@copy_to_ex
  000e4	39 54 24 4c	 cmp	 DWORD PTR _begin_new_heap$[esp+52], edx
  000e8	77 06		 ja	 SHORT $LN85@copy_to_ex
  000ea	3b 54 24 50	 cmp	 edx, DWORD PTR _end_new_heap$[esp+52]
  000ee	72 6d		 jb	 SHORT $LN78@copy_to_ex
$LN85@copy_to_ex:

; 510  :           DEBUG0(copy_info, "and not forwarded yet\n");
; 511  :           FIND_BLOCK;

  000f0	8b f9		 mov	 edi, ecx
  000f2	2b cb		 sub	 ecx, ebx
  000f4	8b d1		 mov	 edx, ecx
  000f6	c1 fa 02	 sar	 edx, 2
  000f9	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  000fd	74 12		 je	 SHORT $LN83@copy_to_ex
  000ff	90		 npad	 1
$LL84@copy_to_ex:
  00100	83 e9 04	 sub	 ecx, 4
  00103	8b d1		 mov	 edx, ecx
  00105	c1 fa 02	 sar	 edx, 2
  00108	83 ef 04	 sub	 edi, 4
  0010b	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  0010f	75 ef		 jne	 SHORT $LL84@copy_to_ex
$LN83@copy_to_ex:
  00111	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00113	8b cd		 mov	 ecx, ebp
  00115	83 e1 03	 and	 ecx, 3
  00118	8b d7		 mov	 edx, edi
  0011a	80 f9 03	 cmp	 cl, 3
  0011d	75 1a		 jne	 SHORT $LN81@copy_to_ex
  0011f	90		 npad	 1
$LL82@copy_to_ex:
  00120	8b cd		 mov	 ecx, ebp
  00122	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00125	85 c9		 test	 ecx, ecx
  00127	74 10		 je	 SHORT $LN81@copy_to_ex
  00129	8b 2c 8a	 mov	 ebp, DWORD PTR [edx+ecx*4]
  0012c	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0012f	8b cd		 mov	 ecx, ebp
  00131	83 e1 03	 and	 ecx, 3
  00134	80 f9 03	 cmp	 cl, 3
  00137	74 e7		 je	 SHORT $LL82@copy_to_ex
$LN81@copy_to_ex:

; 512  :           FORWARD_BLOCK(lower, upper, next);

  00139	8b cf		 mov	 ecx, edi
  0013b	3b fa		 cmp	 edi, edx
  0013d	77 1e		 ja	 SHORT $LN78@copy_to_ex
  0013f	2b fb		 sub	 edi, ebx
$LL80@copy_to_ex:
  00141	8b ef		 mov	 ebp, edi
  00143	c1 fd 02	 sar	 ebp, 2
  00146	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  0014a	8b 29		 mov	 ebp, DWORD PTR [ecx]
  0014c	89 28		 mov	 DWORD PTR [eax], ebp
  0014e	89 01		 mov	 DWORD PTR [ecx], eax
  00150	83 c1 04	 add	 ecx, 4
  00153	83 c0 04	 add	 eax, 4
  00156	83 c7 04	 add	 edi, 4
  00159	3b ca		 cmp	 ecx, edx
  0015b	76 e4		 jbe	 SHORT $LL80@copy_to_ex
$LN78@copy_to_ex:

; 513  :         }
; 514  :         else
; 515  :           DEBUG0(copy_info, "but already forwarded\n");
; 516  :         DEBUG2(copy_info, "\t\tredirect Choice[%d] to Extra[%d]\n",
; 517  :           CH(chptr), EX(**(term *)chptr));
; 518  :         *chptr = (cell)((term)(**(term *)chptr) + offset);

  0015d	8b 4c 24 1c	 mov	 ecx, DWORD PTR _chptr$[esp+56]
  00161	8b 11		 mov	 edx, DWORD PTR [ecx]
  00163	8b 12		 mov	 edx, DWORD PTR [edx]
  00165	8b 7c 24 10	 mov	 edi, DWORD PTR _offset$[esp+56]
  00169	8d 14 ba	 lea	 edx, DWORD PTR [edx+edi*4]
  0016c	8b 7c 24 24	 mov	 edi, DWORD PTR _endtr$[esp+56]
  00170	89 11		 mov	 DWORD PTR [ecx], edx
  00172	8b d1		 mov	 edx, ecx
$LN89@copy_to_ex:

; 502  :     DEBUG1(copy_info, "   DO CHOICE-POINT %d\n", count);
; 503  :     endtr = cpoint[count].start+cpoint[count].arity ;
; 504  :     for(chptr=cpoint[count].start; chptr<endtr; chptr++) {

  00174	83 c2 04	 add	 edx, 4
  00177	89 54 24 1c	 mov	 DWORD PTR _chptr$[esp+56], edx
  0017b	3b d7		 cmp	 edx, edi
  0017d	0f 82 3d ff ff
	ff		 jb	 $LL90@copy_to_ex
$LN88@copy_to_ex:

; 519  :       }
; 520  :       else {
; 521  :         DEBUG0(copy_info, "no root-pointer : ");
; 522  :         DEBUG_CELL(copy_info, *chptr, wam);
; 523  :       }
; 524  :     }
; 525  :     
; 526  :     { next = scan_forwarded(scan,next,offset,H,wam,current_H,
; 527  :       begin_old_heap,begin_new_heap,end_new_heap,marked);

  00183	8b 4c 24 50	 mov	 ecx, DWORD PTR _end_new_heap$[esp+52]
  00187	8b 54 24 4c	 mov	 edx, DWORD PTR _begin_new_heap$[esp+52]
  0018b	56		 push	 esi
  0018c	51		 push	 ecx
  0018d	8b 4c 24 28	 mov	 ecx, DWORD PTR _current_H$[esp+64]
  00191	52		 push	 edx
  00192	8b 54 24 4c	 mov	 edx, DWORD PTR _H$[esp+64]
  00196	53		 push	 ebx
  00197	51		 push	 ecx
  00198	8b 4c 24 24	 mov	 ecx, DWORD PTR _offset$[esp+76]
  0019c	52		 push	 edx
  0019d	8b 54 24 2c	 mov	 edx, DWORD PTR _scan$[esp+80]
  001a1	51		 push	 ecx
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 _scan_forwarded

; 528  :     scan = next ;
; 529  :     }
; 530  :     
; 531  :     
; 532  :     DEBUG1(copy_info, "   CLOSE BACKTRACK SEGMENT %d\n", count);
; 533  :     extra_segment_end[count] = next;

  001a8	8b 4c 24 54	 mov	 ecx, DWORD PTR _extra_segment_end$[esp+88]
  001ac	8b 7c 24 48	 mov	 edi, DWORD PTR _count$[esp+88]

; 534  :     
; 535  :     DEBUG1(copy_info,"SCAN TRAIL SEGMENT YOUNGER THAN CHOICE-POINT %d\n",count+1);
; 536  :     begintr = (term)(*cpoint[count].TR) ;

  001b0	8b 5c 24 50	 mov	 ebx, DWORD PTR tv680[esp+88]
  001b4	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  001b7	8b 2a		 mov	 ebp, DWORD PTR [edx]
  001b9	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax

; 537  :     endtr = ((count==cpoints)?TR_GCTOP:(term)(*cpoint[count+1].TR)) ;

  001bc	8b 4c 24 74	 mov	 ecx, DWORD PTR _cpoints$[esp+84]
  001c0	83 c4 20	 add	 esp, 32			; 00000020H
  001c3	89 44 24 14	 mov	 DWORD PTR _scan$[esp+56], eax
  001c7	3b f9		 cmp	 edi, ecx
  001c9	75 09		 jne	 SHORT $LN97@copy_to_ex
  001cb	8b 54 24 44	 mov	 edx, DWORD PTR _wam$[esp+52]
  001cf	8b 52 2c	 mov	 edx, DWORD PTR [edx+44]
  001d2	eb 05		 jmp	 SHORT $LN163@copy_to_ex
$LN97@copy_to_ex:
  001d4	8b 53 1c	 mov	 edx, DWORD PTR [ebx+28]
  001d7	8b 12		 mov	 edx, DWORD PTR [edx]
$LN163@copy_to_ex:
  001d9	89 54 24 24	 mov	 DWORD PTR _endtr$[esp+56], edx

; 538  :     current_H = ((count==cpoints)?H:(term)(*cpoint[count+1].H)) ;

  001dd	3b f9		 cmp	 edi, ecx
  001df	75 06		 jne	 SHORT $LN99@copy_to_ex
  001e1	8b 4c 24 40	 mov	 ecx, DWORD PTR _H$[esp+52]
  001e5	eb 05		 jmp	 SHORT $LN164@copy_to_ex
$LN99@copy_to_ex:
  001e7	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  001ea	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN164@copy_to_ex:
  001ec	89 4c 24 20	 mov	 DWORD PTR _current_H$[esp+56], ecx

; 539  :     a_value_trail_entry = 0 ;

  001f0	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _a_value_trail_entry$[esp+56], 0

; 540  :     for(trptr = begintr ; trptr < endtr ; trptr++) {	

  001f8	89 6c 24 30	 mov	 DWORD PTR _trptr$[esp+56], ebp
  001fc	3b ea		 cmp	 ebp, edx
  001fe	0f 83 94 03 00
	00		 jae	 $LN92@copy_to_ex
$LL75@copy_to_ex:

; 541  :       DEBUG1(copy_info, "\tconsider Trail[%d] : ", TRGC(trptr));
; 542  :       if( pvtrailentry(trptr) ) { 

  00204	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00207	89 4c 24 2c	 mov	 DWORD PTR tv765[esp+56], ecx
  0020b	f6 c1 01	 test	 cl, 1
  0020e	0f 84 ff 00 00
	00		 je	 $LN72@copy_to_ex

; 543  :         a_value_trail_entry = TR_VTAG ;
; 544  :         /* *trptr = ((*trptr) & ~ TR_VTAG) ; $$$PT */
; 545  :         *trptr = ((*trptr) - TR_VTAG) ;

  00214	49		 dec	 ecx
  00215	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _a_value_trail_entry$[esp+56], 1
  0021d	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$treat_ordinary_trail_entry$5637:

; 571  :         
; 572  : treat_ordinary_trail_entry:
; 573  :       
; 574  :       if(FORWARDED((term)(*trptr),begin_new_heap,end_new_heap,begin_old_heap)) { 

  00220	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00223	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00225	89 4c 24 2c	 mov	 DWORD PTR tv765[esp+56], ecx
  00229	89 5c 24 18	 mov	 DWORD PTR tv782[esp+56], ebx
  0022d	f6 c3 03	 test	 bl, 3
  00230	0f 85 a6 01 00
	00		 jne	 $LN58@copy_to_ex
  00236	8b 54 24 4c	 mov	 edx, DWORD PTR _begin_new_heap$[esp+52]
  0023a	3b d3		 cmp	 edx, ebx
  0023c	0f 87 9a 01 00
	00		 ja	 $LN58@copy_to_ex
  00242	8b 7c 24 50	 mov	 edi, DWORD PTR _end_new_heap$[esp+52]
  00246	3b df		 cmp	 ebx, edi
  00248	0f 83 8e 01 00
	00		 jae	 $LN58@copy_to_ex

; 575  :         term newheappointer, oldheappointer ;
; 576  :         DEBUG1(copy_info,"points to Heap[%d] : already forwarded\n",HP(*trptr));
; 577  :         DEBUG2(copy_info,
; 578  :           "\t\tredirect Trail[%d] to Extra[%d]\n",TRGC(trptr), EX(**(term *)trptr));
; 579  :         oldheappointer = (term)(*trptr) ;
; 580  :         *trptr = **(term *)trptr;

  0024e	89 5d 00	 mov	 DWORD PTR [ebp], ebx

; 581  :         newheappointer = (term)(*trptr) ;
; 582  :         hpptr = (term)(* newheappointer) ;

  00251	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00253	89 5c 24 2c	 mov	 DWORD PTR _hpptr$[esp+56], ebx

; 583  :         
; 584  :         if(VAR(hpptr) && (!a_value_trail_entry)) {

  00257	f6 c3 03	 test	 bl, 3
  0025a	0f 85 a3 00 00
	00		 jne	 $LN56@copy_to_ex
  00260	83 7c 24 1c 00	 cmp	 DWORD PTR _a_value_trail_entry$[esp+56], 0
  00265	0f 85 98 00 00
	00		 jne	 $LN56@copy_to_ex

; 585  : #ifdef DEBUG_GC
; 586  :           if(TO_EXTRA(hpptr)) { 
; 587  :             DEBUG2(copy_info,"\t\t?done? Extra[%d] -> Extra[%d]\n",
; 588  :               EX((term)(*trptr)),EX(hpptr-offset));
; 589  :             /* this is an error ? */
; 590  :           }
; 591  :           else
; 592  : #endif
; 593  :           { if(hpptr >= oldheappointer) { 

  0026b	3b d9		 cmp	 ebx, ecx
  0026d	0f 82 90 00 00
	00		 jb	 $LN56@copy_to_ex

; 594  :             DEBUG2(copy_info, "\t\tExtra[%d] -> Heap[%d] ",
; 595  :               EX((term)(*trptr)),HP((term)(**(term *)trptr)));
; 596  :             if(FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap)) {

  00273	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00275	f6 c1 03	 test	 cl, 3
  00278	75 08		 jne	 SHORT $LN55@copy_to_ex
  0027a	3b d1		 cmp	 edx, ecx
  0027c	77 04		 ja	 SHORT $LN55@copy_to_ex
  0027e	3b cf		 cmp	 ecx, edi
  00280	72 6e		 jb	 SHORT $LN161@copy_to_ex
$LN55@copy_to_ex:

; 597  :               DEBUG0(copy_info, "but already forwarded\n");}
; 598  :             else { 
; 599  :               DEBUG0(copy_info, "and not forwarded yet\n");
; 600  :               FIND_BLOCK;

  00282	8b cb		 mov	 ecx, ebx
  00284	2b 4c 24 5c	 sub	 ecx, DWORD PTR _begin_old_heap$[esp+52]
  00288	8b fb		 mov	 edi, ebx
  0028a	8b d1		 mov	 edx, ecx
  0028c	c1 fa 02	 sar	 edx, 2
  0028f	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00293	74 11		 je	 SHORT $LN52@copy_to_ex
$LL53@copy_to_ex:
  00295	83 e9 04	 sub	 ecx, 4
  00298	8b d1		 mov	 edx, ecx
  0029a	c1 fa 02	 sar	 edx, 2
  0029d	83 ef 04	 sub	 edi, 4
  002a0	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  002a4	75 ef		 jne	 SHORT $LL53@copy_to_ex
$LN52@copy_to_ex:
  002a6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002a8	8b d9		 mov	 ebx, ecx
  002aa	83 e3 03	 and	 ebx, 3
  002ad	8b d7		 mov	 edx, edi
  002af	80 fb 03	 cmp	 bl, 3
  002b2	75 16		 jne	 SHORT $LN159@copy_to_ex
$LL51@copy_to_ex:
  002b4	c1 e9 18	 shr	 ecx, 24			; 00000018H
  002b7	85 c9		 test	 ecx, ecx
  002b9	74 0f		 je	 SHORT $LN159@copy_to_ex
  002bb	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  002be	8b 0a		 mov	 ecx, DWORD PTR [edx]
  002c0	8b d9		 mov	 ebx, ecx
  002c2	83 e3 03	 and	 ebx, 3
  002c5	80 fb 03	 cmp	 bl, 3
  002c8	74 ea		 je	 SHORT $LL51@copy_to_ex
$LN159@copy_to_ex:

; 601  :               FORWARD_BLOCK(lower, upper, next);

  002ca	8b cf		 mov	 ecx, edi
  002cc	3b fa		 cmp	 edi, edx
  002ce	77 20		 ja	 SHORT $LN161@copy_to_ex
  002d0	2b 7c 24 5c	 sub	 edi, DWORD PTR _begin_old_heap$[esp+52]
$LL49@copy_to_ex:
  002d4	8b df		 mov	 ebx, edi
  002d6	c1 fb 02	 sar	 ebx, 2
  002d9	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0
  002dd	8b 19		 mov	 ebx, DWORD PTR [ecx]
  002df	89 18		 mov	 DWORD PTR [eax], ebx
  002e1	89 01		 mov	 DWORD PTR [ecx], eax
  002e3	83 c1 04	 add	 ecx, 4
  002e6	83 c0 04	 add	 eax, 4
  002e9	83 c7 04	 add	 edi, 4
  002ec	3b ca		 cmp	 ecx, edx
  002ee	76 e4		 jbe	 SHORT $LL49@copy_to_ex
$LN161@copy_to_ex:

; 602  :             }
; 603  :             DEBUG2(copy_info,"\t\tredir Extra[%d] to Extra[%d]\n",
; 604  :               EX(*(term *)trptr),EX(***(term ***)trptr));
; 605  :             *newheappointer = (cell)((term)(*hpptr)+offset);

  002f0	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hpptr$[esp+56]
  002f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f6	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+56]
  002fa	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  002fd	8b 4c 24 18	 mov	 ecx, DWORD PTR tv782[esp+56]
  00301	89 11		 mov	 DWORD PTR [ecx], edx
$LN56@copy_to_ex:

; 606  :           } /* that extra-cell points to heap */
; 607  :           else DEBUG1(copy_info,"\t\tExtra[%d] points not to newer Heap segment\n",
; 608  :             EX((term)(*trptr)));
; 609  :           }
; 610  :         } /* that extra-cell is a variable */
; 611  :         else { DEBUG1(copy_info, "\t\tExtra[%d] is not a variable\n",EX((term)(*trptr))); }
; 612  :         /* now adjust trail entry */
; 613  :         *trptr = (cell)((term)(*trptr) + offset) ;

  00303	8b 5c 24 10	 mov	 ebx, DWORD PTR _offset$[esp+56]
  00307	03 db		 add	 ebx, ebx
  00309	03 db		 add	 ebx, ebx
  0030b	01 5d 00	 add	 DWORD PTR [ebp], ebx

; 614  :       } /* *trptr is forwarded */
; 615  :       else { 

  0030e	e9 53 01 00 00	 jmp	 $LN44@copy_to_ex
$LN72@copy_to_ex:

; 546  :         DEBUG1(copy_info, "\tconsider Value Trail[%d] : ", TRGC(trptr));
; 547  : #if FIXGC>0
; 548  :         if(ON_DCGS((term)*trptr)) {
; 549  :           fprintf(STD_err,"ON_DCGS copy_to_extra_segment=%ld\n",(bp_long)((term)(*trptr)-DCGSTART()));
; 550  :         }
; 551  : #endif
; 552  :         goto treat_ordinary_trail_entry ;
; 553  :       } /* trptr points to a value trail */
; 554  :       else if(ON_HTABLE(*trptr)) { 

  00313	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  00319	3b cf		 cmp	 ecx, edi
  0031b	0f 82 ff fe ff
	ff		 jb	 $treat_ordinary_trail_entry$5637
  00321	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _max+20
  00327	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  0032a	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  0032d	3b ca		 cmp	 ecx, edx
  0032f	0f 83 eb fe ff
	ff		 jae	 $treat_ordinary_trail_entry$5637

; 555  :         /* it should point to the hash table */
; 556  :         /* test this and then start copying from *trptr as a normal root */
; 557  :        
; 558  :         hentry phte = (hentry)(*trptr);
; 559  :         if (phte->val) { 

  00335	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00338	89 7c 24 30	 mov	 DWORD PTR tv775[esp+56], edi
  0033c	85 ff		 test	 edi, edi
  0033e	0f 84 43 02 00
	00		 je	 $LN74@copy_to_ex

; 560  :           DEBUG1(copy_info, "     copy from Hash Table[%d] : ", phte-htable );
; 561  :           DEBUG_CELL(copy_info, phte->val, wam );
; 562  :           hpptr=(term)phte->val;
; 563  :           if (! FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap)) { 

  00344	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00346	f6 c1 03	 test	 cl, 3
  00349	75 0c		 jne	 SHORT $LN67@copy_to_ex
  0034b	39 4c 24 4c	 cmp	 DWORD PTR _begin_new_heap$[esp+52], ecx
  0034f	77 06		 ja	 SHORT $LN67@copy_to_ex
  00351	3b 4c 24 50	 cmp	 ecx, DWORD PTR _end_new_heap$[esp+52]
  00355	72 6c		 jb	 SHORT $LN60@copy_to_ex
$LN67@copy_to_ex:

; 564  :             FIND_BLOCK;

  00357	8b cf		 mov	 ecx, edi
  00359	2b 4c 24 5c	 sub	 ecx, DWORD PTR _begin_old_heap$[esp+52]
  0035d	8b d1		 mov	 edx, ecx
  0035f	c1 fa 02	 sar	 edx, 2
  00362	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00366	74 11		 je	 SHORT $LN65@copy_to_ex
$LL66@copy_to_ex:
  00368	83 e9 04	 sub	 ecx, 4
  0036b	8b d1		 mov	 edx, ecx
  0036d	c1 fa 02	 sar	 edx, 2
  00370	83 ef 04	 sub	 edi, 4
  00373	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00377	75 ef		 jne	 SHORT $LL66@copy_to_ex
$LN65@copy_to_ex:
  00379	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0037b	8b d9		 mov	 ebx, ecx
  0037d	83 e3 03	 and	 ebx, 3
  00380	8b d7		 mov	 edx, edi
  00382	80 fb 03	 cmp	 bl, 3
  00385	75 16		 jne	 SHORT $LN160@copy_to_ex
$LL64@copy_to_ex:
  00387	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0038a	85 c9		 test	 ecx, ecx
  0038c	74 0f		 je	 SHORT $LN160@copy_to_ex
  0038e	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00391	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00393	8b d9		 mov	 ebx, ecx
  00395	83 e3 03	 and	 ebx, 3
  00398	80 fb 03	 cmp	 bl, 3
  0039b	74 ea		 je	 SHORT $LL64@copy_to_ex
$LN160@copy_to_ex:

; 565  :             FORWARD_BLOCK(lower, upper, next);

  0039d	8b cf		 mov	 ecx, edi
  0039f	3b fa		 cmp	 edi, edx
  003a1	77 20		 ja	 SHORT $LN60@copy_to_ex
  003a3	2b 7c 24 5c	 sub	 edi, DWORD PTR _begin_old_heap$[esp+52]
$LL62@copy_to_ex:
  003a7	8b df		 mov	 ebx, edi
  003a9	c1 fb 02	 sar	 ebx, 2
  003ac	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0
  003b0	8b 19		 mov	 ebx, DWORD PTR [ecx]
  003b2	89 18		 mov	 DWORD PTR [eax], ebx
  003b4	89 01		 mov	 DWORD PTR [ecx], eax
  003b6	83 c1 04	 add	 ecx, 4
  003b9	83 c0 04	 add	 eax, 4
  003bc	83 c7 04	 add	 edi, 4
  003bf	3b ca		 cmp	 ecx, edx
  003c1	76 e4		 jbe	 SHORT $LL62@copy_to_ex
$LN60@copy_to_ex:

; 566  :           }
; 567  :           phte->val = (cell)(  ((term)(*hpptr)) + offset) ;

  003c3	8b 4c 24 30	 mov	 ecx, DWORD PTR tv775[esp+56]
  003c7	8b 11		 mov	 edx, DWORD PTR [ecx]
  003c9	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+56]
  003cd	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  003d0	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv765[esp+56]
  003d4	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 568  :         } /* pointer to trailed hash entry */
; 569  :       }
; 570  :       else {

  003d7	e9 ab 01 00 00	 jmp	 $LN74@copy_to_ex
$LN58@copy_to_ex:

; 616  :         DEBUG1(copy_info,"points to Heap[%d] : not forwarded yet ?\n",HP(*trptr));
; 617  :         hpptr=(term)(*trptr) ;
; 618  :         FIND_BLOCK;

  003dc	8b f9		 mov	 edi, ecx
  003de	2b 4c 24 5c	 sub	 ecx, DWORD PTR _begin_old_heap$[esp+52]
  003e2	8b d1		 mov	 edx, ecx
  003e4	c1 fa 02	 sar	 edx, 2
  003e7	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  003eb	74 14		 je	 SHORT $LN42@copy_to_ex
  003ed	8d 49 00	 npad	 3
$LL43@copy_to_ex:
  003f0	83 e9 04	 sub	 ecx, 4
  003f3	8b d1		 mov	 edx, ecx
  003f5	c1 fa 02	 sar	 edx, 2
  003f8	83 ef 04	 sub	 edi, 4
  003fb	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  003ff	75 ef		 jne	 SHORT $LL43@copy_to_ex
$LN42@copy_to_ex:
  00401	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00403	8b cd		 mov	 ecx, ebp
  00405	83 e1 03	 and	 ecx, 3
  00408	8b d7		 mov	 edx, edi
  0040a	80 f9 03	 cmp	 cl, 3
  0040d	75 1a		 jne	 SHORT $LN40@copy_to_ex
  0040f	90		 npad	 1
$LL41@copy_to_ex:
  00410	8b cd		 mov	 ecx, ebp
  00412	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00415	85 c9		 test	 ecx, ecx
  00417	74 10		 je	 SHORT $LN40@copy_to_ex
  00419	8b 2c 8a	 mov	 ebp, DWORD PTR [edx+ecx*4]
  0041c	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0041f	8b cd		 mov	 ecx, ebp
  00421	83 e1 03	 and	 ecx, 3
  00424	80 f9 03	 cmp	 cl, 3
  00427	74 e7		 je	 SHORT $LL41@copy_to_ex
$LN40@copy_to_ex:

; 619  :         FORWARD_BLOCK(lower, upper, next);

  00429	8b cf		 mov	 ecx, edi
  0042b	3b fa		 cmp	 edi, edx
  0042d	77 20		 ja	 SHORT $LN150@copy_to_ex
  0042f	2b 7c 24 5c	 sub	 edi, DWORD PTR _begin_old_heap$[esp+52]
$LL39@copy_to_ex:
  00433	8b df		 mov	 ebx, edi
  00435	c1 fb 02	 sar	 ebx, 2
  00438	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0
  0043c	8b 19		 mov	 ebx, DWORD PTR [ecx]
  0043e	89 18		 mov	 DWORD PTR [eax], ebx
  00440	89 01		 mov	 DWORD PTR [ecx], eax
  00442	83 c1 04	 add	 ecx, 4
  00445	83 c0 04	 add	 eax, 4
  00448	83 c7 04	 add	 edi, 4
  0044b	3b ca		 cmp	 ecx, edx
  0044d	76 e4		 jbe	 SHORT $LL39@copy_to_ex
$LN150@copy_to_ex:

; 620  :         *trptr = (cell)(  ((term)(*hpptr)) + offset) ;

  0044f	8b 5c 24 10	 mov	 ebx, DWORD PTR _offset$[esp+56]
  00453	8b 54 24 2c	 mov	 edx, DWORD PTR tv765[esp+56]
  00457	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00459	8b 6c 24 30	 mov	 ebp, DWORD PTR _trptr$[esp+56]
  0045d	03 db		 add	 ebx, ebx
  0045f	03 db		 add	 ebx, ebx
  00461	03 cb		 add	 ecx, ebx
  00463	89 4d 00	 mov	 DWORD PTR [ebp], ecx
$LN44@copy_to_ex:

; 621  :       }
; 622  :       if (a_value_trail_entry){ 

  00466	83 7c 24 1c 00	 cmp	 DWORD PTR _a_value_trail_entry$[esp+56], 0
  0046b	0f 84 16 01 00
	00		 je	 $LN74@copy_to_ex

; 623  :         cell newval ;
; 624  :         term poldval ;
; 625  :         a_value_trail_entry = 0 ;
; 626  :         next = scan_forwarded(scan,next,offset,H,wam,current_H,
; 627  :           begin_old_heap,begin_new_heap,end_new_heap,marked) ;

  00471	8b 54 24 50	 mov	 edx, DWORD PTR _end_new_heap$[esp+52]
  00475	8b 4c 24 4c	 mov	 ecx, DWORD PTR _begin_new_heap$[esp+52]
  00479	56		 push	 esi
  0047a	52		 push	 edx
  0047b	8b 54 24 64	 mov	 edx, DWORD PTR _begin_old_heap$[esp+60]
  0047f	51		 push	 ecx
  00480	8b 4c 24 2c	 mov	 ecx, DWORD PTR _current_H$[esp+68]
  00484	52		 push	 edx
  00485	8b 54 24 50	 mov	 edx, DWORD PTR _H$[esp+68]
  00489	51		 push	 ecx
  0048a	8b 4c 24 24	 mov	 ecx, DWORD PTR _offset$[esp+76]
  0048e	52		 push	 edx
  0048f	8b 54 24 2c	 mov	 edx, DWORD PTR _scan$[esp+80]
  00493	51		 push	 ecx
  00494	52		 push	 edx
  00495	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR _a_value_trail_entry$[esp+88], 0
  0049d	e8 00 00 00 00	 call	 _scan_forwarded

; 628  :         scan = next ;
; 629  :         poldval = ((term)(*trptr)) - offset ;

  004a2	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  004a5	8b f9		 mov	 edi, ecx
  004a7	2b fb		 sub	 edi, ebx

; 630  :         newval = *(trptr+1) ;

  004a9	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]

; 631  :         
; 632  :         /* switch back tagged pointer and value */
; 633  :         *(trptr+1) = (*trptr) + TR_VTAG ;

  004ac	41		 inc	 ecx
  004ad	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx

; 634  :         *trptr = *poldval ;

  004b0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  004b2	83 c4 20	 add	 esp, 32			; 00000020H
  004b5	89 44 24 14	 mov	 DWORD PTR _scan$[esp+56], eax
  004b9	89 4d 00	 mov	 DWORD PTR [ebp], ecx

; 635  :         
; 636  :         /* now the newval is treated as a register */
; 637  :         /* and in the end, it is copied to the place where oldval was */
; 638  :         
; 639  :         DEBUG0(copy_info, "\tconsider new value\n");
; 640  :         if(VAR(newval)) { 

  004bc	f6 c3 03	 test	 bl, 3
  004bf	0f 85 bd 00 00
	00		 jne	 $LN35@copy_to_ex

; 641  :           if(TO_HEAP(newval)) { 

  004c5	39 5c 24 5c	 cmp	 DWORD PTR _begin_old_heap$[esp+52], ebx
  004c9	0f 87 a9 00 00
	00		 ja	 $LN153@copy_to_ex
  004cf	39 5c 24 40	 cmp	 DWORD PTR _H$[esp+52], ebx
  004d3	0f 86 9f 00 00
	00		 jbe	 $LN153@copy_to_ex

; 642  :             DEBUG1(copy_info, "points to Heap[%d] : ", HP(newval));
; 643  :             hpptr=(term)newval;
; 644  :             if(!FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap)) { 

  004d9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  004db	f6 c1 03	 test	 cl, 3
  004de	75 10		 jne	 SHORT $LN32@copy_to_ex
  004e0	39 4c 24 4c	 cmp	 DWORD PTR _begin_new_heap$[esp+52], ecx
  004e4	77 0a		 ja	 SHORT $LN32@copy_to_ex
  004e6	3b 4c 24 50	 cmp	 ecx, DWORD PTR _end_new_heap$[esp+52]
  004ea	0f 82 82 00 00
	00		 jb	 $LN148@copy_to_ex
$LN32@copy_to_ex:

; 645  :               DEBUG0(copy_info, "not forwarded yet\n");
; 646  :               FIND_BLOCK;

  004f0	8b cb		 mov	 ecx, ebx
  004f2	2b 4c 24 5c	 sub	 ecx, DWORD PTR _begin_old_heap$[esp+52]
  004f6	8b eb		 mov	 ebp, ebx
  004f8	8b d1		 mov	 edx, ecx
  004fa	c1 fa 02	 sar	 edx, 2
  004fd	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00501	74 11		 je	 SHORT $LN30@copy_to_ex
$LL31@copy_to_ex:
  00503	83 e9 04	 sub	 ecx, 4
  00506	8b d1		 mov	 edx, ecx
  00508	c1 fa 02	 sar	 edx, 2
  0050b	83 ed 04	 sub	 ebp, 4
  0050e	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00512	75 ef		 jne	 SHORT $LL31@copy_to_ex
$LN30@copy_to_ex:
  00514	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00517	83 e1 03	 and	 ecx, 3
  0051a	8b d5		 mov	 edx, ebp
  0051c	80 f9 03	 cmp	 cl, 3
  0051f	75 1b		 jne	 SHORT $LN28@copy_to_ex
  00521	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00524	eb 02		 jmp	 SHORT $LN29@copy_to_ex
$LL149@copy_to_ex:
  00526	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN29@copy_to_ex:
  00528	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0052b	85 c9		 test	 ecx, ecx
  0052d	74 0d		 je	 SHORT $LN28@copy_to_ex
  0052f	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00532	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00534	83 e1 03	 and	 ecx, 3
  00537	80 f9 03	 cmp	 cl, 3
  0053a	74 ea		 je	 SHORT $LL149@copy_to_ex
$LN28@copy_to_ex:

; 647  :               FORWARD_BLOCK(lower, upper, next);

  0053c	8b cd		 mov	 ecx, ebp
  0053e	3b ea		 cmp	 ebp, edx
  00540	77 30		 ja	 SHORT $LN148@copy_to_ex
  00542	2b 6c 24 5c	 sub	 ebp, DWORD PTR _begin_old_heap$[esp+52]
  00546	89 6c 24 2c	 mov	 DWORD PTR tv1166[esp+56], ebp
  0054a	8d 9b 00 00 00
	00		 npad	 6
$LL27@copy_to_ex:
  00550	c1 fd 02	 sar	 ebp, 2
  00553	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  00557	8b 29		 mov	 ebp, DWORD PTR [ecx]
  00559	89 28		 mov	 DWORD PTR [eax], ebp
  0055b	8b 6c 24 2c	 mov	 ebp, DWORD PTR tv1166[esp+56]
  0055f	89 01		 mov	 DWORD PTR [ecx], eax
  00561	83 c1 04	 add	 ecx, 4
  00564	83 c5 04	 add	 ebp, 4
  00567	83 c0 04	 add	 eax, 4
  0056a	89 6c 24 2c	 mov	 DWORD PTR tv1166[esp+56], ebp
  0056e	3b ca		 cmp	 ecx, edx
  00570	76 de		 jbe	 SHORT $LL27@copy_to_ex
$LN148@copy_to_ex:

; 648  :             }
; 649  :             else 
; 650  :               DEBUG0(copy_info, "already forwarded\n");
; 651  :             DEBUG1(copy_info, "\t\tredirect new value to Extra[%d]\n", EX(*(term)newval));
; 652  :             newval = (cell)((term)(*(term)newval));

  00572	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00574	8b 6c 24 30	 mov	 ebp, DWORD PTR _trptr$[esp+56]
$LN153@copy_to_ex:

; 653  :           } /* newval points to heap */
; 654  :           else 
; 655  :             DEBUG0(copy_info, "a variable that doesn't point to heap ??\n");
; 656  :           newval = (cell)((term)newval+offset);

  00578	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+56]
  0057c	03 c9		 add	 ecx, ecx
  0057e	03 c9		 add	 ecx, ecx
  00580	03 d9		 add	 ebx, ecx
$LN35@copy_to_ex:

; 657  :         } /* newval is a variable */
; 658  :         else 
; 659  :           DEBUG0(copy_info, "is not a variable\n");
; 660  :         
; 661  :         *poldval = newval ;

  00582	89 1f		 mov	 DWORD PTR [edi], ebx
  00584	83 c5 04	 add	 ebp, 4
$LN74@copy_to_ex:

; 540  :     for(trptr = begintr ; trptr < endtr ; trptr++) {	

  00587	83 c5 04	 add	 ebp, 4
  0058a	89 6c 24 30	 mov	 DWORD PTR _trptr$[esp+56], ebp
  0058e	3b 6c 24 24	 cmp	 ebp, DWORD PTR _endtr$[esp+56]
  00592	0f 82 6c fc ff
	ff		 jb	 $LL75@copy_to_ex
$LN92@copy_to_ex:

; 494  :   
; 495  :   scan = begin_new_heap ;
; 496  :   
; 497  :   DEBUG0(copy_info, "COPY TO EXTRA HEAP ...\n\n");
; 498  :   next = begin_new_heap;  
; 499  :   DEBUG0(copy_info, "DO CHOICE-POINTS (bottom-up)\n");
; 500  :   for( count=0; count<=cpoints; count++) {

  00598	8b 4c 24 28	 mov	 ecx, DWORD PTR _count$[esp+56]
  0059c	41		 inc	 ecx
  0059d	89 4c 24 28	 mov	 DWORD PTR _count$[esp+56], ecx
  005a1	3b 4c 24 54	 cmp	 ecx, DWORD PTR _cpoints$[esp+52]
  005a5	0f 8e d5 fa ff
	ff		 jle	 $LL93@copy_to_ex
$LN91@copy_to_ex:

; 662  :         trptr++ ; /* skip an extra trail entry */
; 663  :       }
; 664  :       } /* trptr points to ordinary trail entry */
; 665  :       } /* stop scan next trail segment */
; 666  :     } /* stop do choice-points */
; 667  :     
; 668  :     DEBUG0(copy_info, "DO THE REGISTERS\n");
; 669  :     for(reg_i=FIRSTREG; reg_i<=arity; reg_i++) {

  005ab	bb 01 00 00 00	 mov	 ebx, 1
  005b0	39 5c 24 3c	 cmp	 DWORD PTR _arity$[esp+52], ebx
  005b4	0f 8c cc 00 00
	00		 jl	 $LN154@copy_to_ex
  005ba	8b 54 24 48	 mov	 edx, DWORD PTR _regs$[esp+52]
  005be	8b ff		 npad	 2
$LL21@copy_to_ex:

; 670  :       DEBUG1(copy_info, "\tconsider regs[%d] : ", reg_i);
; 671  :       if(VAR(regs[reg_i]))

  005c0	8b 0c 9a	 mov	 ecx, DWORD PTR [edx+ebx*4]
  005c3	f6 c1 03	 test	 cl, 3
  005c6	0f 85 af 00 00
	00		 jne	 $LN20@copy_to_ex

; 672  :       {
; 673  :         if(TO_HEAP(regs[reg_i]))

  005cc	39 4c 24 5c	 cmp	 DWORD PTR _begin_old_heap$[esp+52], ecx
  005d0	0f 87 9a 00 00
	00		 ja	 $LN17@copy_to_ex
  005d6	39 4c 24 40	 cmp	 DWORD PTR _H$[esp+52], ecx
  005da	0f 86 90 00 00
	00		 jbe	 $LN17@copy_to_ex

; 674  :         {
; 675  :           DEBUG1(copy_info, "points to Heap[%d] : ", HP(regs[reg_i]));
; 676  :           hpptr=(term)regs[reg_i];
; 677  :           if(!FORWARDED(hpptr,begin_new_heap,end_new_heap,begin_old_heap))

  005e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  005e2	f6 c2 03	 test	 dl, 3
  005e5	75 0c		 jne	 SHORT $LN15@copy_to_ex
  005e7	39 54 24 4c	 cmp	 DWORD PTR _begin_new_heap$[esp+52], edx
  005eb	77 06		 ja	 SHORT $LN15@copy_to_ex
  005ed	3b 54 24 50	 cmp	 edx, DWORD PTR _end_new_heap$[esp+52]
  005f1	72 6f		 jb	 SHORT $LN8@copy_to_ex
$LN15@copy_to_ex:

; 678  :           {
; 679  :             DEBUG0(copy_info, "not forwarded yet\n");
; 680  :             FIND_BLOCK;

  005f3	8b f9		 mov	 edi, ecx
  005f5	2b 4c 24 5c	 sub	 ecx, DWORD PTR _begin_old_heap$[esp+52]
  005f9	8b d1		 mov	 edx, ecx
  005fb	c1 fa 02	 sar	 edx, 2
  005fe	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00602	74 11		 je	 SHORT $LN13@copy_to_ex
$LL14@copy_to_ex:
  00604	83 e9 04	 sub	 ecx, 4
  00607	8b d1		 mov	 edx, ecx
  00609	c1 fa 02	 sar	 edx, 2
  0060c	83 ef 04	 sub	 edi, 4
  0060f	f6 04 32 02	 test	 BYTE PTR [edx+esi], 2
  00613	75 ef		 jne	 SHORT $LL14@copy_to_ex
$LN13@copy_to_ex:
  00615	8b 2f		 mov	 ebp, DWORD PTR [edi]
  00617	8b cd		 mov	 ecx, ebp
  00619	83 e1 03	 and	 ecx, 3
  0061c	8b d7		 mov	 edx, edi
  0061e	80 f9 03	 cmp	 cl, 3
  00621	75 19		 jne	 SHORT $LN11@copy_to_ex
$LL12@copy_to_ex:
  00623	8b cd		 mov	 ecx, ebp
  00625	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00628	85 c9		 test	 ecx, ecx
  0062a	74 10		 je	 SHORT $LN11@copy_to_ex
  0062c	8b 2c 8a	 mov	 ebp, DWORD PTR [edx+ecx*4]
  0062f	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00632	8b cd		 mov	 ecx, ebp
  00634	83 e1 03	 and	 ecx, 3
  00637	80 f9 03	 cmp	 cl, 3
  0063a	74 e7		 je	 SHORT $LL12@copy_to_ex
$LN11@copy_to_ex:

; 681  :             FORWARD_BLOCK(lower, upper, next);

  0063c	8b cf		 mov	 ecx, edi
  0063e	3b fa		 cmp	 edi, edx
  00640	77 20		 ja	 SHORT $LN8@copy_to_ex
  00642	2b 7c 24 5c	 sub	 edi, DWORD PTR _begin_old_heap$[esp+52]
$LL10@copy_to_ex:
  00646	8b ef		 mov	 ebp, edi
  00648	c1 fd 02	 sar	 ebp, 2
  0064b	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  0064f	8b 29		 mov	 ebp, DWORD PTR [ecx]
  00651	89 28		 mov	 DWORD PTR [eax], ebp
  00653	89 01		 mov	 DWORD PTR [ecx], eax
  00655	83 c1 04	 add	 ecx, 4
  00658	83 c0 04	 add	 eax, 4
  0065b	83 c7 04	 add	 edi, 4
  0065e	3b ca		 cmp	 ecx, edx
  00660	76 e4		 jbe	 SHORT $LL10@copy_to_ex
$LN8@copy_to_ex:

; 682  :           }
; 683  :           else
; 684  :             DEBUG0(copy_info, "already forwarded\n");
; 685  :           DEBUG2(copy_info, "\t\tredirect regs[%d] to Extra[%d]\n", reg_i,
; 686  :             EX(*(term)regs[reg_i]));
; 687  :           regs[reg_i] = (cell)((term)(*(term)regs[reg_i]));

  00662	8b 4c 24 48	 mov	 ecx, DWORD PTR _regs$[esp+52]
  00666	8b 14 99	 mov	 edx, DWORD PTR [ecx+ebx*4]
  00669	8b 12		 mov	 edx, DWORD PTR [edx]
  0066b	89 14 99	 mov	 DWORD PTR [ecx+ebx*4], edx
  0066e	8b d1		 mov	 edx, ecx
$LN17@copy_to_ex:

; 688  :         } /* regs[i] points to heap */
; 689  :         else
; 690  :           DEBUG0(copy_info, "a variable that doesn't point to heap ??\n");
; 691  :         regs[reg_i] = (cell)((term)regs[reg_i]+offset);

  00670	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+56]
  00674	03 c9		 add	 ecx, ecx
  00676	03 c9		 add	 ecx, ecx
  00678	01 0c 9a	 add	 DWORD PTR [edx+ebx*4], ecx
$LN20@copy_to_ex:

; 662  :         trptr++ ; /* skip an extra trail entry */
; 663  :       }
; 664  :       } /* trptr points to ordinary trail entry */
; 665  :       } /* stop scan next trail segment */
; 666  :     } /* stop do choice-points */
; 667  :     
; 668  :     DEBUG0(copy_info, "DO THE REGISTERS\n");
; 669  :     for(reg_i=FIRSTREG; reg_i<=arity; reg_i++) {

  0067b	43		 inc	 ebx
  0067c	3b 5c 24 3c	 cmp	 ebx, DWORD PTR _arity$[esp+52]
  00680	0f 8e 3a ff ff
	ff		 jle	 $LL21@copy_to_ex
$LN154@copy_to_ex:

; 692  :       } /* regs[i] is a variable */
; 693  :       else
; 694  :         DEBUG0(copy_info, "is not a variable\n");
; 695  :     } /* stop do registers */
; 696  :     
; 697  :     next = scan_forwarded(scan,next,offset,H,wam,H,
; 698  :                 begin_old_heap,begin_new_heap,end_new_heap,marked) ;

  00686	8b 54 24 50	 mov	 edx, DWORD PTR _end_new_heap$[esp+52]
  0068a	8b 4c 24 4c	 mov	 ecx, DWORD PTR _begin_new_heap$[esp+52]
  0068e	8b 7c 24 10	 mov	 edi, DWORD PTR _offset$[esp+56]
  00692	56		 push	 esi
  00693	52		 push	 edx
  00694	8b 54 24 64	 mov	 edx, DWORD PTR _begin_old_heap$[esp+60]
  00698	51		 push	 ecx
  00699	8b 4c 24 4c	 mov	 ecx, DWORD PTR _H$[esp+64]
  0069d	52		 push	 edx
  0069e	51		 push	 ecx
  0069f	51		 push	 ecx
  006a0	8b 4c 24 2c	 mov	 ecx, DWORD PTR _scan$[esp+80]
  006a4	57		 push	 edi
  006a5	51		 push	 ecx
  006a6	e8 00 00 00 00	 call	 _scan_forwarded

; 699  :     scan = next ;
; 700  :     
; 701  :     DEBUG0(copy_info, "\nADJUST THE H FIELD IN THE CHOICE-POINTS\n");
; 702  :     for(count=0; count<=cpoints; count++)    {

  006ab	8b 54 24 74	 mov	 edx, DWORD PTR _cpoints$[esp+84]
  006af	8b f0		 mov	 esi, eax
  006b1	83 c4 20	 add	 esp, 32			; 00000020H
  006b4	33 c0		 xor	 eax, eax
  006b6	89 74 24 30	 mov	 DWORD PTR _next$[esp+56], esi
  006ba	85 d2		 test	 edx, edx
  006bc	78 2a		 js	 SHORT $LN155@copy_to_ex

; 692  :       } /* regs[i] is a variable */
; 693  :       else
; 694  :         DEBUG0(copy_info, "is not a variable\n");
; 695  :     } /* stop do registers */
; 696  :     
; 697  :     next = scan_forwarded(scan,next,offset,H,wam,H,
; 698  :                 begin_old_heap,begin_new_heap,end_new_heap,marked) ;

  006be	8b 4c 24 58	 mov	 ecx, DWORD PTR _cpoint$[esp+52]
  006c2	8d 34 bd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*4]
  006c9	8b 7c 24 34	 mov	 edi, DWORD PTR _extra_segment_end$[esp+56]
  006cd	83 c1 08	 add	 ecx, 8
$LL4@copy_to_ex:

; 703  :       DEBUG2(copy_info, "\tredirect Choice[%d] to Extra[%d]\n",
; 704  :         CH(cpoint[count].H), EX(extra_segment_end[count]));
; 705  :       *(term *)cpoint[count].H = extra_segment_end[count] + offset ;

  006d0	8b 1c 87	 mov	 ebx, DWORD PTR [edi+eax*4]
  006d3	8b 29		 mov	 ebp, DWORD PTR [ecx]
  006d5	03 de		 add	 ebx, esi
  006d7	40		 inc	 eax
  006d8	83 c1 10	 add	 ecx, 16			; 00000010H
  006db	89 5d 00	 mov	 DWORD PTR [ebp], ebx
  006de	3b c2		 cmp	 eax, edx
  006e0	7e ee		 jle	 SHORT $LL4@copy_to_ex

; 699  :     scan = next ;
; 700  :     
; 701  :     DEBUG0(copy_info, "\nADJUST THE H FIELD IN THE CHOICE-POINTS\n");
; 702  :     for(count=0; count<=cpoints; count++)    {

  006e2	8b 74 24 30	 mov	 esi, DWORD PTR _next$[esp+56]
  006e6	eb 04		 jmp	 SHORT $LN2@copy_to_ex
$LN155@copy_to_ex:
  006e8	8b 7c 24 34	 mov	 edi, DWORD PTR _extra_segment_end$[esp+56]
$LN2@copy_to_ex:

; 706  :     }
; 707  :     
; 708  :     DEBUG1(copy_info, "\nCOPY PHASE DONE (%d cells forwarded)\n\n",num_forwarded);
; 709  :     DEBUG1(copy_info, "#blocks forwarded : %d\n", blocks_total);
; 710  :     DEBUG1(copy_info, "#blocks first referenced via internal cel : %d\n",
; 711  :       blocks_internal_referenced);
; 712  :     
; 713  : #ifdef DEBUG_GC
; 714  :     { bp_long c = 0 ;
; 715  :     for(hpptr=begin_old_heap; hpptr<H; hpptr++)
; 716  :       if(REACHABLE(hpptr,begin_old_heap,marked)) { 
; 717  :         c++ ;
; 718  :         fprintf(copy_info, 
; 719  :           "\n\n Error : Heap[%d] reachable but not forwarded !!!\n",
; 720  :           HP(hpptr));
; 721  :         fflush(copy_info);
; 722  :         fprintf(STD_err, "Error in GC : look at bottom of info.copy !!!\n");
; 723  :         fflush(STD_err);
; 724  :       }
; 725  :       if (c) exit(-1);
; 726  :     }
; 727  : #endif
; 728  :     
; 729  :     DEBUG_CLOSE(copy_info);
; 730  :     XFREE(extra_segment_end);

  006ec	57		 push	 edi
  006ed	e8 00 00 00 00	 call	 _free
  006f2	83 c4 04	 add	 esp, 4
  006f5	5d		 pop	 ebp
  006f6	5b		 pop	 ebx

; 731  :     
; 732  :     /* adjust the real H pointer */
; 733  :     if (end_new_heap != next)

  006f7	39 74 24 48	 cmp	 DWORD PTR _end_new_heap$[esp+44], esi
  006fb	74 16		 je	 SHORT $LN1@copy_to_ex

; 734  :       fprintf(STD_err,"different number of forwarded than space allocated\n") ;

  006fd	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MJEIKDBG@different?5number?5of?5forwarded?5th@
  00702	e8 00 00 00 00	 call	 ___iob_func
  00707	83 c0 40	 add	 eax, 64			; 00000040H
  0070a	50		 push	 eax
  0070b	e8 00 00 00 00	 call	 _fprintf
  00710	83 c4 08	 add	 esp, 8
$LN1@copy_to_ex:

; 735  :     return next;

  00713	5f		 pop	 edi
  00714	8b c6		 mov	 eax, esi
  00716	5e		 pop	 esi

; 736  : } /* copy_to_extra_heap */

  00717	83 c4 28	 add	 esp, 40			; 00000028H
  0071a	c3		 ret	 0
$LN162@copy_to_ex:
_copy_to_extra_heap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@DAKIFLNE@more?5marked?5then?5forwarded?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@ENFGAIDP@more?5forwarded?5then?5marked?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@KKBEEMPA@Cannot?5allocate?5the?5begin_new_he@ ; `string'
PUBLIC	??_C@_0CK@DFNLKAFE@Cannot?5allocate?5the?5cpoint?5array@ ; `string'
EXTRN	_cputime:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0CA@DAKIFLNE@more?5marked?5then?5forwarded?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0CA@DAKIFLNE@more?5marked?5then?5forwarded?$DN?$CFld?6?$AA@ DB 'mor'
	DB	'e marked then forwarded=%ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ENFGAIDP@more?5forwarded?5then?5marked?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0CA@ENFGAIDP@more?5forwarded?5then?5marked?$DN?$CFld?6?$AA@ DB 'mor'
	DB	'e forwarded then marked=%ld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KKBEEMPA@Cannot?5allocate?5the?5begin_new_he@
CONST	SEGMENT
??_C@_0CE@KKBEEMPA@Cannot?5allocate?5the?5begin_new_he@ DB 'Cannot alloca'
	DB	'te the begin_new_heap', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DFNLKAFE@Cannot?5allocate?5the?5cpoint?5array@
CONST	SEGMENT
??_C@_0CK@DFNLKAFE@Cannot?5allocate?5the?5cpoint?5array@ DB 'Cannot alloc'
	DB	'ate the cpoint array of cp''s', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _gc_test0
_TEXT	SEGMENT
tv330 = -20						; size = 4
_num_marked$ = -20					; size = 4
_marked$ = -16						; size = 4
_cpoints$ = -12						; size = 4
_max_num_choice_points$ = -8				; size = 4
_gc_time$ = -4						; size = 4
_H$ = 8							; size = 4
_regs$ = 12						; size = 4
_arity$ = 16						; size = 4
_gc_test0 PROC						; COMDAT
; _A$ = ecx
; _wam$ = eax

; 740  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b d8		 mov	 ebx, eax
  00009	8b f1		 mov	 esi, ecx

; 741  :   bp_long max_num_choice_points, offset, size_new_heap,gc_time;
; 742  : #ifdef PROFILE_GC
; 743  :   bp_long mark_time, copy_time, move_time ;
; 744  : #endif
; 745  :   bp_long num_marked;
; 746  : #ifndef DEBUG_GC
; 747  :   cp *cpoint;
; 748  :   bp_long cpoints;
; 749  :   term begin_new_heap, end_new_heap, begin_old_heap ;
; 750  :   char *marked ;
; 751  : #endif
; 752  : #ifndef TRACE_GC_MEM
; 753  :   bp_long size_old_heap ;
; 754  : #endif
; 755  : #ifdef PROFILE_GC
; 756  :   static bp_long total_gc_time = 0 ;
; 757  : #endif
; 758  : #if defined DEBUG_GC || defined PROFILE_GC
; 759  :   static bp_long nr_gcs = 0 ;
; 760  :   nr_gcs++ ;
; 761  : #endif
; 762  : 
; 763  :   gc_time = cputime();

  0000b	e8 00 00 00 00	 call	 _cputime

; 764  :   begin_old_heap = HP_BASE ;

  00010	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00013	89 44 24 20	 mov	 DWORD PTR _gc_time$[esp+36], eax

; 765  : 
; 766  :   /* initialize some structures */
; 767  :   max_num_choice_points = 3 + ((term)A-CH_BASE)/3;

  00017	8b ce		 mov	 ecx, esi
  00019	2b 4b 58	 sub	 ecx, DWORD PTR [ebx+88]
  0001c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00021	c1 f9 02	 sar	 ecx, 2
  00024	f7 e9		 imul	 ecx
  00026	8b c2		 mov	 eax, edx
  00028	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002b	8d 44 02 03	 lea	 eax, DWORD PTR [edx+eax+3]
  0002f	89 44 24 1c	 mov	 DWORD PTR _max_num_choice_points$[esp+36], eax

; 768  :   if(!(cpoint=XALLOC(max_num_choice_points,cp )))

  00033	c1 e0 04	 shl	 eax, 4
  00036	50		 push	 eax
  00037	81 c7 1c 20 00
	00		 add	 edi, 8220		; 0000201cH
  0003d	e8 00 00 00 00	 call	 _malloc
  00042	8b e8		 mov	 ebp, eax
  00044	83 c4 04	 add	 esp, 4
  00047	85 ed		 test	 ebp, ebp
  00049	75 2b		 jne	 SHORT $LN5@gc_test0

; 769  :     EXIT0("Cannot allocate the cpoint array of cp's\n");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DFNLKAFE@Cannot?5allocate?5the?5cpoint?5array@
$LN14@gc_test0:
  00050	e8 00 00 00 00	 call	 ___iob_func
  00055	83 c0 40	 add	 eax, 64			; 00000040H
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _fprintf
  0005e	e8 00 00 00 00	 call	 ___iob_func
  00063	83 c0 40	 add	 eax, 64			; 00000040H
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _fflush
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	6a ff		 push	 -1
  00071	e8 00 00 00 00	 call	 _exit
$LN5@gc_test0:

; 770  :   cpoints = init_cps(A, wam,cpoint);

  00076	55		 push	 ebp
  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 _init_cps

; 771  : 
; 772  :   /* allocate the marked and internal bits */
; 773  :   size_old_heap = H - begin_old_heap ;
; 774  :   marked = (char *)(wam[MarkStk].base) ;

  0007d	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [ebx+160]

; 775  : #ifdef DEBUG_GC
; 776  :   print_choice("before.gc.choice", H, wam, A);
; 777  :   print_heap("before.gc.heap", H, wam, A);
; 778  :   print_trail("before.gc.trail", H, wam, A,0);
; 779  :   print_regs("before.gc.regs", H, wam, A, regs);
; 780  :   if(!(mark_info=fopen("info.mark", "w")))
; 781  :     EXIT0("Cannot open file : info.mark\n");
; 782  : #endif
; 783  : 
; 784  :   /* marking and early reset */
; 785  : #ifdef PROFILE_GC
; 786  :   mark_time = cputime();
; 787  : #endif
; 788  : 
; 789  :   /* VCC GC BUG happens here */
; 790  :   num_marked = mark_and_early_reset(arity, A, wam, regs, H,
; 791  : 					cpoints,cpoint,begin_old_heap,marked);

  00083	51		 push	 ecx
  00084	57		 push	 edi
  00085	55		 push	 ebp
  00086	89 4c 24 28	 mov	 DWORD PTR _marked$[esp+56], ecx
  0008a	8b 4c 24 3c	 mov	 ecx, DWORD PTR _H$[esp+52]
  0008e	50		 push	 eax
  0008f	8b 44 24 44	 mov	 eax, DWORD PTR _regs$[esp+56]
  00093	51		 push	 ecx
  00094	8b 4c 24 4c	 mov	 ecx, DWORD PTR _arity$[esp+60]
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 _mark_and_early_reset

; 792  :   				
; 793  :   /* update the structure that describes the choice_points */
; 794  :   cpoints = init_cps(A, wam,cpoint); /* actually only TR is reset here */

  0009e	55		 push	 ebp
  0009f	56		 push	 esi
  000a0	89 44 24 38	 mov	 DWORD PTR _num_marked$[esp+76], eax
  000a4	e8 00 00 00 00	 call	 _init_cps
  000a9	89 44 24 40	 mov	 DWORD PTR _cpoints$[esp+76], eax

; 795  :   
; 796  : #ifdef PROFILE_GC
; 797  :   mark_time = cputime() - mark_time ;
; 798  : #endif
; 799  : #ifdef DEBUG_GC
; 800  :   print_choice("after.marking.choice", H, wam, A);
; 801  :   print_heap("after.marking.heap", H, wam, A);
; 802  :   print_trail("after.marking.trail", H, wam, A,1);
; 803  :   print_regs("after.marking.regs", H, wam, A, regs);
; 804  : #endif
; 805  :   
; 806  : #ifdef TRACE_GC_MEM
; 807  :   /* allocate the forwarded bits and the extra heap */
; 808  :   if(!(globalforwarded=ZALLOC(size_old_heap, char)))
; 809  :     EXIT0("Cannot allocate the forwarded bits\n");
; 810  : #endif
; 811  :   size_new_heap = num_marked;
; 812  : #ifdef DEBUG_GC
; 813  :   if(!(begin_new_heap=ZALLOC(size_new_heap,cell)))
; 814  : #else
; 815  :   if(!(begin_new_heap=XALLOC(size_new_heap,cell )))

  000ad	8b 44 24 38	 mov	 eax, DWORD PTR _num_marked$[esp+76]
  000b1	03 c0		 add	 eax, eax
  000b3	03 c0		 add	 eax, eax
  000b5	50		 push	 eax
  000b6	89 44 24 3c	 mov	 DWORD PTR tv330[esp+80], eax
  000ba	e8 00 00 00 00	 call	 _malloc
  000bf	8b f0		 mov	 esi, eax
  000c1	83 c4 2c	 add	 esp, 44			; 0000002cH
  000c4	85 f6		 test	 esi, esi
  000c6	75 07		 jne	 SHORT $LN4@gc_test0

; 816  : #endif
; 817  :     EXIT0("Cannot allocate the begin_new_heap\n");

  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KKBEEMPA@Cannot?5allocate?5the?5begin_new_he@
  000cd	eb 81		 jmp	 SHORT $LN14@gc_test0
$LN4@gc_test0:

; 818  :   end_new_heap = begin_new_heap + size_new_heap ;
; 819  :   offset = begin_old_heap-begin_new_heap;
; 820  : 
; 821  :   /* copy phase */
; 822  : #ifdef PROFILE_GC
; 823  :   copy_time = cputime();
; 824  : #endif
; 825  :   H=copy_to_extra_heap(arity, H, wam, regs,max_num_choice_points,
; 826  : 		begin_new_heap,end_new_heap,
; 827  : 		cpoints,cpoint,begin_old_heap,marked);

  000cf	8b 54 24 14	 mov	 edx, DWORD PTR _marked$[esp+36]
  000d3	8b 44 24 18	 mov	 eax, DWORD PTR _cpoints$[esp+36]
  000d7	8b 4c 24 10	 mov	 ecx, DWORD PTR tv330[esp+36]
  000db	52		 push	 edx
  000dc	8b 54 24 30	 mov	 edx, DWORD PTR _regs$[esp+36]
  000e0	57		 push	 edi
  000e1	55		 push	 ebp
  000e2	50		 push	 eax
  000e3	8b 44 24 38	 mov	 eax, DWORD PTR _H$[esp+48]
  000e7	03 ce		 add	 ecx, esi
  000e9	51		 push	 ecx
  000ea	8b 4c 24 44	 mov	 ecx, DWORD PTR _arity$[esp+52]
  000ee	56		 push	 esi
  000ef	52		 push	 edx
  000f0	53		 push	 ebx
  000f1	50		 push	 eax
  000f2	8b 44 24 40	 mov	 eax, DWORD PTR _max_num_choice_points$[esp+72]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 _copy_to_extra_heap
  000fc	89 44 24 50	 mov	 DWORD PTR _H$[esp+72], eax

; 828  : #ifdef PROFILE_GC
; 829  :   copy_time = cputime() - copy_time;
; 830  : #endif
; 831  : 
; 832  : #ifdef DEBUG_GC
; 833  :   print_copy_extra("after.copying.extra_heap", H, wam, A, offset);
; 834  : #endif
; 835  :   
; 836  :   /* move back phase */
; 837  : #ifdef PROFILE_GC
; 838  :   move_time = cputime();
; 839  : #endif
; 840  :   memcpy((void *)begin_old_heap, (void *)begin_new_heap, 
; 841  : 				((term)H-begin_new_heap)*sizeof(cell));

  00100	2b c6		 sub	 eax, esi
  00102	c1 f8 02	 sar	 eax, 2
  00105	03 c0		 add	 eax, eax
  00107	03 c0		 add	 eax, eax
  00109	50		 push	 eax
  0010a	56		 push	 esi
  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 _memcpy

; 842  : 
; 843  :   /* adjust the real H */
; 844  :   H = H+offset;

  00111	8b 44 24 5c	 mov	 eax, DWORD PTR _H$[esp+84]
  00115	8b d7		 mov	 edx, edi
  00117	2b d6		 sub	 edx, esi
  00119	c1 fa 02	 sar	 edx, 2
  0011c	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]

; 845  : #ifdef PROFILE_GC
; 846  :   move_time = cputime() - move_time ;
; 847  : #endif
; 848  : 
; 849  : #ifdef DEBUG_GC
; 850  :   print_choice("after.gc.choice", H, wam, A);
; 851  :   print_heap("after.gc.heap", H, wam, A);
; 852  :   print_trail("after.gc.trail", H, wam, A,0);
; 853  :   print_regs("after.gc.regs", H, wam, A, regs);
; 854  : #endif
; 855  : 
; 856  :   XFREE(cpoint);

  0011f	55		 push	 ebp
  00120	89 4c 24 60	 mov	 DWORD PTR _H$[esp+88], ecx
  00124	e8 00 00 00 00	 call	 _free

; 857  :   XFREE(begin_new_heap);

  00129	56		 push	 esi
  0012a	e8 00 00 00 00	 call	 _free
  0012f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 858  : #ifdef TRACE_GC_MEM
; 859  :   XFREE(globalforwarded);
; 860  : #endif
; 861  : 
; 862  :   gc_time = cputime() - gc_time;

  00132	e8 00 00 00 00	 call	 _cputime

; 863  : 
; 864  :   if (H != (begin_old_heap + size_new_heap))

  00137	8b 4c 24 10	 mov	 ecx, DWORD PTR tv330[esp+36]
  0013b	8b 6c 24 28	 mov	 ebp, DWORD PTR _H$[esp+32]
  0013f	8b f0		 mov	 esi, eax
  00141	2b 74 24 20	 sub	 esi, DWORD PTR _gc_time$[esp+36]
  00145	8d 14 39	 lea	 edx, DWORD PTR [ecx+edi]
  00148	3b ea		 cmp	 ebp, edx
  0014a	74 2b		 je	 SHORT $LN11@gc_test0

; 865  :   	{ 
; 866  :   	  bp_long i = H - (begin_old_heap + size_new_heap);

  0014c	8b c5		 mov	 eax, ebp
  0014e	2b c1		 sub	 eax, ecx
  00150	2b c7		 sub	 eax, edi
  00152	c1 f8 02	 sar	 eax, 2

; 867  :   	  if (i>0)
; 868  :              fprintf(STD_err,"more forwarded then marked=%ld\n",i) ;

  00155	50		 push	 eax
  00156	85 c0		 test	 eax, eax
  00158	7e 07		 jle	 SHORT $LN2@gc_test0
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@ENFGAIDP@more?5forwarded?5then?5marked?$DN?$CFld?6?$AA@

; 869  :   	  else 

  0015f	eb 05		 jmp	 SHORT $LN13@gc_test0
$LN2@gc_test0:

; 870  :              fprintf(STD_err,"more marked then forwarded=%ld\n",i) ;

  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DAKIFLNE@more?5marked?5then?5forwarded?$DN?$CFld?6?$AA@
$LN13@gc_test0:
  00166	e8 00 00 00 00	 call	 ___iob_func
  0016b	83 c0 40	 add	 eax, 64			; 00000040H
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _fprintf
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@gc_test0:

; 871  :   	}
; 872  : 
; 873  : #ifdef PROFILE_GC
; 874  :   total_gc_time += gc_time ;
; 875  :   fprintf(STD_err,"bin(before = %d, after = %d, total = %d, increment = %d, mark = %d, copy = %d, back = %d, rest = %d, gcnr = %d).\n",
; 876  :   size_old_heap*sizeof(cell),
; 877  :   size_new_heap*sizeof(cell),total_gc_time,gc_time,mark_time,
; 878  :   copy_time,move_time,gc_time-mark_time-copy_time-move_time,nr_gcs) ;
; 879  :   fflush(STD_err);
; 880  : #endif
; 881  : 
; 882  : 
; 883  : #ifdef MIMICK_LOOSE_SEGMENT_ORDER
; 884  :   setallHBtoH(H,A,wam) ;
; 885  : #endif
; 886  : 
; 887  :   return gc_check(H,wam,gc_time);

  00177	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0017a	2b 43 10	 sub	 eax, DWORD PTR [ebx+16]
  0017d	01 35 2c 01 00
	00		 add	 DWORD PTR _g+300, esi
  00183	c1 f8 03	 sar	 eax, 3
  00186	8d 4c 85 00	 lea	 ecx, DWORD PTR [ebp+eax*4]
  0018a	3b 4b 14	 cmp	 ecx, DWORD PTR [ebx+20]
  0018d	72 13		 jb	 SHORT $LN8@gc_test0
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _gc_mes
  00195	83 c4 04	 add	 esp, 4
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi
  0019a	5d		 pop	 ebp
  0019b	33 c0		 xor	 eax, eax
  0019d	5b		 pop	 ebx

; 888  : } /* 

  0019e	83 c4 14	 add	 esp, 20			; 00000014H
  001a1	c3		 ret	 0

; 871  :   	}
; 872  : 
; 873  : #ifdef PROFILE_GC
; 874  :   total_gc_time += gc_time ;
; 875  :   fprintf(STD_err,"bin(before = %d, after = %d, total = %d, increment = %d, mark = %d, copy = %d, back = %d, rest = %d, gcnr = %d).\n",
; 876  :   size_old_heap*sizeof(cell),
; 877  :   size_new_heap*sizeof(cell),total_gc_time,gc_time,mark_time,
; 878  :   copy_time,move_time,gc_time-mark_time-copy_time-move_time,nr_gcs) ;
; 879  :   fflush(STD_err);
; 880  : #endif
; 881  : 
; 882  : 
; 883  : #ifdef MIMICK_LOOSE_SEGMENT_ORDER
; 884  :   setallHBtoH(H,A,wam) ;
; 885  : #endif
; 886  : 
; 887  :   return gc_check(H,wam,gc_time);

$LN8@gc_test0:
  001a2	5f		 pop	 edi
  001a3	5e		 pop	 esi
  001a4	8b c5		 mov	 eax, ebp
  001a6	5d		 pop	 ebp
  001a7	5b		 pop	 ebx

; 888  : } /* 

  001a8	83 c4 14	 add	 esp, 20			; 00000014H
  001ab	c3		 ret	 0
$LN12@gc_test0:
_gc_test0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@DIGKHJAB@GC?9error?3?5no?5memory?5for?5mark?5arr@ ; `string'
PUBLIC	??_C@_04KJJCFCK@mark?$AA@			; `string'
EXTRN	_overflow_by:PROC
EXTRN	_make_stack:PROC
;	COMDAT ??_C@_0CD@DIGKHJAB@GC?9error?3?5no?5memory?5for?5mark?5arr@
CONST	SEGMENT
??_C@_0CD@DIGKHJAB@GC?9error?3?5no?5memory?5for?5mark?5arr@ DB 'GC-error:'
	DB	' no memory for mark array', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJJCFCK@mark?$AA@
CONST	SEGMENT
??_C@_04KJJCFCK@mark?$AA@ DB 'mark', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _gc_test1
_TEXT	SEGMENT
_regs$ = 8						; size = 4
_A$ = 12						; size = 4
_ires$ = 16						; size = 4
_gc_test1 PROC						; COMDAT
; _H$ = edi
; _wam$ = esi

; 906  :   if(ZERO==wam[MarkStk].size)

  00000	83 be 90 00 00
	00 00		 cmp	 DWORD PTR [esi+144], 0
  00007	8d 96 90 00 00
	00		 lea	 edx, DWORD PTR [esi+144]
  0000d	75 36		 jne	 SHORT $LN1@gc_test1

; 907  :   {  bp_long heap_size=wam[HeapStk].size;
; 908  :      bp_long check=wam[HeapStk].over;

  0000f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00012	8b 06		 mov	 eax, DWORD PTR [esi]

; 909  :      
; 910  :      /*
; 911  :      bp_long heap_size=wam[HeapStk].margin-wam[HeapStk].base;
; 912  :      bp_long check=wam[HeapStk].end-wam[HeapStk].margin;
; 913  :      */
; 914  : 
; 915  :      if(!make_stack(&wam[MarkStk],
; 916  :         heap_size>>TAGBITS,
; 917  :         check>> TAGBITS,
; 918  :         "mark",NULL,0))

  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_04KJJCFCK@mark?$AA@
  0001d	c1 f9 02	 sar	 ecx, 2
  00020	51		 push	 ecx
  00021	c1 f8 02	 sar	 eax, 2
  00024	50		 push	 eax
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _make_stack
  0002b	83 c4 18	 add	 esp, 24			; 00000018H
  0002e	85 c0		 test	 eax, eax
  00030	75 13		 jne	 SHORT $LN1@gc_test1

; 919  :            OVER("GC-error: no memory for mark array",
; 920  :                            (term *)H,HeapStk,NO());

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DIGKHJAB@GC?9error?3?5no?5memory?5for?5mark?5arr@
  00037	56		 push	 esi
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 _overflow_by
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	33 c0		 xor	 eax, eax

; 926  : }

  00044	c3		 ret	 0
$LN1@gc_test1:

; 921  :   }
; 922  : 
; 923  :    /* ires contains arity - save regs[arity+1]..MAXDCG,MAXREGS */
; 924  :    /* $$$ seems to be missed by GC PT */
; 925  :    return gc_test0(H, regs, A, P, wam, ires); /*+MAXDCG);*/

  00045	8b 44 24 0c	 mov	 eax, DWORD PTR _ires$[esp-4]
  00049	8b 4c 24 04	 mov	 ecx, DWORD PTR _regs$[esp-4]
  0004d	50		 push	 eax
  0004e	51		 push	 ecx
  0004f	8b 4c 24 10	 mov	 ecx, DWORD PTR _A$[esp+4]
  00053	57		 push	 edi
  00054	8b c6		 mov	 eax, esi
  00056	e8 00 00 00 00	 call	 _gc_test0
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 926  : }

  0005e	c3		 ret	 0
_gc_test1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BJBJKHHB@after?5GC?5at?3?5?$CFs?1?$CFld?5?$CIrecovered?5?$CF@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0CH@GDGCLJEA@before?5GC?5at?3?5?$CFs?1?$CFld?5?$CIleft?5?$CFld?5b@ ; `string'
PUBLIC	_A$GSCopy$
PUBLIC	_regs$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	_debugmes:PROC
EXTRN	_atomtable:DWORD
EXTRN	_hget:PROC
;	COMDAT ??_C@_0CL@BJBJKHHB@after?5GC?5at?3?5?$CFs?1?$CFld?5?$CIrecovered?5?$CF@
CONST	SEGMENT
??_C@_0CL@BJBJKHHB@after?5GC?5at?3?5?$CFs?1?$CFld?5?$CIrecovered?5?$CF@ DB 'a'
	DB	'fter GC at: %s/%ld (recovered %ld bytes)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GDGCLJEA@before?5GC?5at?3?5?$CFs?1?$CFld?5?$CIleft?5?$CFld?5b@
CONST	SEGMENT
??_C@_0CH@GDGCLJEA@before?5GC?5at?3?5?$CFs?1?$CFld?5?$CIleft?5?$CFld?5b@ DB 'b'
	DB	'efore GC at: %s/%ld (left %ld bytes)', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _gc_test
_TEXT	SEGMENT
_regs$GSCopy$ = -272					; size = 4
tv168 = -268						; size = 4
_A$GSCopy$ = -264					; size = 4
_sbuf$6107 = -260					; size = 255
_sbuf$6097 = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_regs$ = 8						; size = 4
_P$ = 12						; size = 4
_wam$ = 16						; size = 4
_gc_test PROC						; COMDAT
; _H$ = edx
; _A$ = ecx

; 932  : { term xref;

  00000	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+272], eax
  00014	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR _regs$[esp+268]
  0001b	53		 push	 ebx
  0001c	55		 push	 ebp
  0001d	56		 push	 esi
  0001e	8b b4 24 28 01
	00 00		 mov	 esi, DWORD PTR _wam$[esp+280]
  00025	57		 push	 edi
  00026	8b fa		 mov	 edi, edx

; 933  :   cell xval=ADDR2FUN(P);

  00028	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104

; 934  :   register bp_long ires=GETARITY(xval);
; 935  :   GC_SHOW_BEFORE(H,(term)wam[HeapStk].margin);

  0002e	89 44 24 10	 mov	 DWORD PTR _regs$GSCopy$[esp+288], eax
  00032	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR _P$[esp+284]
  00039	52		 push	 edx
  0003a	50		 push	 eax
  0003b	89 4c 24 20	 mov	 DWORD PTR _A$GSCopy$[esp+296], ecx
  0003f	e8 00 00 00 00	 call	 _hget
  00044	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00047	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  0004d	8b d8		 mov	 ebx, eax
  0004f	c1 e8 02	 shr	 eax, 2
  00052	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00057	03 c0		 add	 eax, eax
  00059	2b cf		 sub	 ecx, edi
  0005b	51		 push	 ecx
  0005c	03 c0		 add	 eax, eax
  0005e	c1 eb 18	 shr	 ebx, 24			; 00000018H
  00061	8d 6b ff	 lea	 ebp, DWORD PTR [ebx-1]
  00064	89 44 24 20	 mov	 DWORD PTR tv168[esp+300], eax
  00068	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  0006b	55		 push	 ebp
  0006c	50		 push	 eax
  0006d	8d 4c 24 30	 lea	 ecx, DWORD PTR _sbuf$6097[esp+308]
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GDGCLJEA@before?5GC?5at?3?5?$CFs?1?$CFld?5?$CIleft?5?$CFld?5b@
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 _sprintf
  0007c	8d 54 24 38	 lea	 edx, DWORD PTR _sbuf$6097[esp+316]
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00086	e8 00 00 00 00	 call	 _debugmes

; 936  :   xref=gc_test1(H, regs, A, P, wam, ires);

  0008b	8b 44 24 3c	 mov	 eax, DWORD PTR _A$GSCopy$[esp+324]
  0008f	8b 4c 24 34	 mov	 ecx, DWORD PTR _regs$GSCopy$[esp+324]
  00093	53		 push	 ebx
  00094	50		 push	 eax
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _gc_test1

; 937  :   GC_SHOW_AFTER(H,xref);

  0009b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  000a1	8b f0		 mov	 esi, eax
  000a3	8b 44 24 44	 mov	 eax, DWORD PTR tv168[esp+336]
  000a7	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  000aa	2b fe		 sub	 edi, esi
  000ac	57		 push	 edi
  000ad	55		 push	 ebp
  000ae	51		 push	 ecx
  000af	8d 54 24 58	 lea	 edx, DWORD PTR _sbuf$6107[esp+348]
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BJBJKHHB@after?5GC?5at?3?5?$CFs?1?$CFld?5?$CIrecovered?5?$CF@
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 _sprintf
  000be	83 c4 44	 add	 esp, 68			; 00000044H
  000c1	8d 44 24 1c	 lea	 eax, DWORD PTR _sbuf$6107[esp+288]
  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  000cb	e8 00 00 00 00	 call	 _debugmes

; 938  :   return xref;
; 939  : }

  000d0	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+296]
  000d7	83 c4 08	 add	 esp, 8
  000da	5f		 pop	 edi
  000db	8b c6		 mov	 eax, esi
  000dd	5e		 pop	 esi
  000de	5d		 pop	 ebp
  000df	5b		 pop	 ebx
  000e0	33 cc		 xor	 ecx, esp
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  000ed	c3		 ret	 0
_gc_test ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@NCOAGJKH@Please?5enlarge?5heap?5with?5option?5@ ; `string'
PUBLIC	_trigger_gc
;	COMDAT ??_C@_0CD@NCOAGJKH@Please?5enlarge?5heap?5with?5option?5@
CONST	SEGMENT
??_C@_0CD@NCOAGJKH@Please?5enlarge?5heap?5with?5option?5@ DB 'Please enla'
	DB	'rge heap with option -h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _trigger_gc
_TEXT	SEGMENT
_H$ = 8							; size = 4
_regs$ = 12						; size = 4
_A$ = 16						; size = 4
_P$ = 20						; size = 4
_wam$ = 24						; size = 4
_trigger_gc PROC					; COMDAT

; 945  :   if(!OUTPUT_INT(g.gc)) 

  00000	f7 05 f8 00 00
	00 fc ff ff ff	 test	 DWORD PTR _g+248, -4	; fffffffcH
  0000a	75 1c		 jne	 SHORT $LN1@trigger_gc

; 946  :     OVER("Please enlarge heap with option -h",(term *)H,HeapStk,NO());

  0000c	8b 44 24 14	 mov	 eax, DWORD PTR _wam$[esp-4]
  00010	8b 4c 24 04	 mov	 ecx, DWORD PTR _H$[esp-4]
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NCOAGJKH@Please?5enlarge?5heap?5with?5option?5@
  00019	50		 push	 eax
  0001a	6a 00		 push	 0
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _overflow_by
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	33 c0		 xor	 eax, eax

; 956  : }

  00027	c3		 ret	 0
$LN1@trigger_gc:

; 947  :   BUG("gc_called");
; 948  :   X(1)=INPUT_INT(0);

  00028	8b 44 24 08	 mov	 eax, DWORD PTR _regs$[esp-4]

; 949  : #if 0
; 950  :   X(2)=new_func("shunt",0);
; 951  :   X(3)=new_func("no_wait",0);
; 952  : #else
; 953  :   X(2)=X(3)=X(1);
; 954  : #endif
; 955  :   return gc_test(H, regs, A, P, wam);

  0002c	8b 54 24 14	 mov	 edx, DWORD PTR _wam$[esp-4]
  00030	b9 01 00 00 00	 mov	 ecx, 1
  00035	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
  00038	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
  0003b	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
  0003e	8b 4c 24 10	 mov	 ecx, DWORD PTR _P$[esp-4]
  00042	52		 push	 edx
  00043	8b 54 24 08	 mov	 edx, DWORD PTR _H$[esp]
  00047	51		 push	 ecx
  00048	8b 4c 24 14	 mov	 ecx, DWORD PTR _A$[esp+4]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _gc_test
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 956  : }

  00055	c3		 ret	 0
_trigger_gc ENDP
_TEXT	ENDS
END
