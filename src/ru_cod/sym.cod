; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\sym.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_newlex:DWORD
COMM	_atomstamp:DWORD
COMM	_lextable:DWORD
COMM	_atomtable:DWORD
COMM	_newatom:DWORD
_DATA	ENDS
PUBLIC	_make_symtable
EXTRN	_make_char_array:PROC
EXTRN	_make_byte_array:PROC
EXTRN	_make_atomtable:PROC
EXTRN	_max:BYTE
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\sym.c
;	COMDAT _make_symtable
_TEXT	SEGMENT
_make_symtable PROC					; COMDAT

; 22   :   errctr+=!(atomtable=make_atomtable(MAXATOM));

  00000	a1 18 00 00 00	 mov	 eax, DWORD PTR _max+24
  00005	56		 push	 esi
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _make_atomtable

; 23   :   errctr+=!(atomstamp=make_byte_array(MAXATOM));

  0000c	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR _max+24
  00012	33 c9		 xor	 ecx, ecx
  00014	85 c0		 test	 eax, eax
  00016	0f 94 c1	 sete	 cl
  00019	52		 push	 edx
  0001a	a3 00 00 00 00	 mov	 DWORD PTR _atomtable, eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 _make_byte_array

; 24   :   newatom=0;
; 25   :   errctr+=!(lextable=newlex=make_char_array(MAXLEX));

  00026	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR _max+24
  0002c	33 c9		 xor	 ecx, ecx
  0002e	85 c0		 test	 eax, eax
  00030	0f 94 c1	 sete	 cl
  00033	c1 e2 04	 shl	 edx, 4
  00036	52		 push	 edx
  00037	a3 00 00 00 00	 mov	 DWORD PTR _atomstamp, eax
  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _newatom, 0
  00046	03 f1		 add	 esi, ecx
  00048	e8 00 00 00 00	 call	 _make_char_array
  0004d	33 c9		 xor	 ecx, ecx
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	85 c0		 test	 eax, eax
  00054	0f 94 c1	 sete	 cl
  00057	a3 00 00 00 00	 mov	 DWORD PTR _newlex, eax
  0005c	a3 00 00 00 00	 mov	 DWORD PTR _lextable, eax
  00061	03 ce		 add	 ecx, esi

; 26   :   return !errctr;

  00063	f7 d9		 neg	 ecx
  00065	1b c9		 sbb	 ecx, ecx
  00067	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0006a	5e		 pop	 esi

; 27   : }

  0006b	c3		 ret	 0
_make_symtable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DHPMNAOG@string?5table?5overflow?$AA@	; `string'
EXTRN	_fatal_error:PROC
;	COMDAT ??_C@_0BG@DHPMNAOG@string?5table?5overflow?$AA@
CONST	SEGMENT
??_C@_0BG@DHPMNAOG@string?5table?5overflow?$AA@ DB 'string table overflow'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _insert_lex
_TEXT	SEGMENT
_insert_lex PROC					; COMDAT
; _from$ = eax

; 30   : { string currlex=newlex;

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _newlex
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f0		 mov	 esi, eax
  0000b	8b d9		 mov	 ebx, ecx

; 31   :   if(newlex+strlen(from)>=lextable+(MAXLEX-1)) 

  0000d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL7@insert_lex:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL7@insert_lex
  00017	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR _max+24
  0001d	2b c7		 sub	 eax, edi
  0001f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _lextable
  00025	03 d2		 add	 edx, edx
  00027	8d 54 d7 ff	 lea	 edx, DWORD PTR [edi+edx*8-1]
  0002b	03 c1		 add	 eax, ecx
  0002d	3b c2		 cmp	 eax, edx
  0002f	72 13		 jb	 SHORT $LL2@insert_lex

; 32   :     fatal_error("string table overflow");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DHPMNAOG@string?5table?5overflow?$AA@
  00036	e8 00 00 00 00	 call	 _fatal_error
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _newlex
  00041	83 c4 04	 add	 esp, 4
$LL2@insert_lex:

; 33   :   while((*newlex++ = *from++))

  00044	8a 06		 mov	 al, BYTE PTR [esi]
  00046	88 01		 mov	 BYTE PTR [ecx], al
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _newlex
  0004e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00050	41		 inc	 ecx
  00051	46		 inc	 esi
  00052	89 0d 00 00 00
	00		 mov	 DWORD PTR _newlex, ecx
  00058	84 d2		 test	 dl, dl
  0005a	75 e8		 jne	 SHORT $LL2@insert_lex

; 34   :   ;
; 35   :   return currlex;

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	8b c3		 mov	 eax, ebx
  00060	5b		 pop	 ebx

; 36   : }

  00061	c3		 ret	 0
_insert_lex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@GADLEGAB@symbol?5hashing?5table?5?$CIalmost?$CJ?5fu@ ; `string'
PUBLIC	??_C@_0BE@IDADGMOM@?$CFld?5symbols?0?5?$CFs?$CB?$CB?$CB?5?$AA@ ; `string'
PUBLIC	_sfull
EXTRN	_bp_halt:PROC
EXTRN	_warnmes:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0CD@GADLEGAB@symbol?5hashing?5table?5?$CIalmost?$CJ?5fu@
CONST	SEGMENT
??_C@_0CD@GADLEGAB@symbol?5hashing?5table?5?$CIalmost?$CJ?5fu@ DB 'symbol'
	DB	' hashing table (almost) full', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IDADGMOM@?$CFld?5symbols?0?5?$CFs?$CB?$CB?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BE@IDADGMOM@?$CFld?5symbols?0?5?$CFs?$CB?$CB?$CB?5?$AA@ DB '%ld sy'
	DB	'mbols, %s!!! ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sfull
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_sfull	PROC						; COMDAT

; 81   :    fprintf(STD_err,"%ld symbols, %s!!! ",newatom,mes);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _newatom
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IDADGMOM@?$CFld?5symbols?0?5?$CFs?$CB?$CB?$CB?5?$AA@
  00011	e8 00 00 00 00	 call	 ___iob_func
  00016	83 c0 40	 add	 eax, 64			; 00000040H
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _fprintf

; 82   :    warnmes("symbol hashing table (almost) full");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GADLEGAB@symbol?5hashing?5table?5?$CIalmost?$CJ?5fu@
  00024	e8 00 00 00 00	 call	 _warnmes
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 83   :    bp_halt(5);

  0002c	c7 44 24 04 05
	00 00 00	 mov	 DWORD PTR _mes$[esp-4], 5
  00034	e9 00 00 00 00	 jmp	 _bp_halt
_sfull	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@HPGGIJEI@unexpected?$CB?$CB?$CB?$AA@	; `string'
PUBLIC	??_C@_05KHPJABPL@?$CI?$CF75?$CJ?$AA@		; `string'
EXTRN	_g:BYTE
;	COMDAT ??_C@_0O@HPGGIJEI@unexpected?$CB?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0O@HPGGIJEI@unexpected?$CB?$CB?$CB?$AA@ DB 'unexpected!!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KHPJABPL@?$CI?$CF75?$CJ?$AA@
CONST	SEGMENT
??_C@_05KHPJABPL@?$CI?$CF75?$CJ?$AA@ DB '(%75)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _atomno
_TEXT	SEGMENT
_s$ = 8							; size = 4
_atomno	PROC						; COMDAT

; 87   : {

  00000	53		 push	 ebx

; 88   :   register no i,last;
; 89   :   SKEY();

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _s$[esp]
  00005	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b d3		 mov	 edx, ebx
  0000c	be 05 15 00 00	 mov	 esi, 5381		; 00001505H
  00011	84 c9		 test	 cl, cl
  00013	74 13		 je	 SHORT $LN15@atomno
$LL16@atomno:
  00015	8b c6		 mov	 eax, esi
  00017	c1 e0 05	 shl	 eax, 5
  0001a	0f be c9	 movsx	 ecx, cl
  0001d	03 f0		 add	 esi, eax
  0001f	42		 inc	 edx
  00020	03 f1		 add	 esi, ecx
  00022	8a 0a		 mov	 cl, BYTE PTR [edx]
  00024	84 c9		 test	 cl, cl
  00026	75 ed		 jne	 SHORT $LL16@atomno
$LN15@atomno:
  00028	a1 18 00 00 00	 mov	 eax, DWORD PTR _max+24

; 90   :   last=MOD((i+newatom-1),MAXATOM);

  0002d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _newatom

; 91   :   while(i!=last && SUSED() && !SFOUND())

  00033	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _atomtable
  00039	48		 dec	 eax
  0003a	23 f0		 and	 esi, eax
  0003c	8d 7c 32 ff	 lea	 edi, DWORD PTR [edx+esi-1]
  00040	23 f8		 and	 edi, eax
  00042	3b f7		 cmp	 esi, edi
  00044	74 4f		 je	 SHORT $LN13@atomno
  00046	eb 0c		 jmp	 SHORT $LN14@atomno
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@atomno:
  00050	8b 5c 24 14	 mov	 ebx, DWORD PTR _s$[esp+12]
$LN14@atomno:
  00054	83 7c b5 00 00	 cmp	 DWORD PTR [ebp+esi*4], 0
  00059	74 45		 je	 SHORT $LN35@atomno
  0005b	8b 54 b5 00	 mov	 edx, DWORD PTR [ebp+esi*4]
  0005f	8b cb		 mov	 ecx, ebx
$LL27@atomno:
  00061	8a 19		 mov	 bl, BYTE PTR [ecx]
  00063	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00065	75 1a		 jne	 SHORT $LN28@atomno
  00067	84 db		 test	 bl, bl
  00069	74 12		 je	 SHORT $LN29@atomno
  0006b	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  0006e	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00071	75 0e		 jne	 SHORT $LN28@atomno
  00073	83 c1 02	 add	 ecx, 2
  00076	83 c2 02	 add	 edx, 2
  00079	84 db		 test	 bl, bl
  0007b	75 e4		 jne	 SHORT $LL27@atomno
$LN29@atomno:
  0007d	33 c9		 xor	 ecx, ecx
  0007f	eb 05		 jmp	 SHORT $LN30@atomno
$LN28@atomno:
  00081	1b c9		 sbb	 ecx, ecx
  00083	83 d9 ff	 sbb	 ecx, -1
$LN30@atomno:
  00086	85 c9		 test	 ecx, ecx
  00088	74 07		 je	 SHORT $LN33@atomno

; 92   :     i=MOD((i+1),MAXATOM);

  0008a	46		 inc	 esi
  0008b	23 f0		 and	 esi, eax
  0008d	3b f7		 cmp	 esi, edi
  0008f	75 bf		 jne	 SHORT $LL31@atomno
$LN33@atomno:

; 91   :   while(i!=last && SUSED() && !SFOUND())

  00091	8b 5c 24 14	 mov	 ebx, DWORD PTR _s$[esp+12]
$LN13@atomno:

; 93   :   if(!SUSED())

  00095	83 7c b5 00 00	 cmp	 DWORD PTR [ebp+esi*4], 0
  0009a	0f 85 84 00 00
	00		 jne	 $LN11@atomno
$LN35@atomno:

; 94   :   {
; 95   :     INSERT_LEX();

  000a0	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  000a7	75 1b		 jne	 SHORT $LN10@atomno
  000a9	80 3d 70 01 00
	00 00		 cmp	 BYTE PTR _g+368, 0
  000b0	74 3c		 je	 SHORT $LN5@atomno
  000b2	8b c3		 mov	 eax, ebx
  000b4	e8 00 00 00 00	 call	 _insert_lex
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  000bf	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  000c2	eb 2e		 jmp	 SHORT $LN4@atomno
$LN10@atomno:
  000c4	8a 0d 70 01 00
	00		 mov	 cl, BYTE PTR _g+368
  000ca	84 c9		 test	 cl, cl
  000cc	74 20		 je	 SHORT $LN5@atomno
  000ce	83 3d f0 00 00
	00 00		 cmp	 DWORD PTR _g+240, 0
  000d5	74 05		 je	 SHORT $LN6@atomno
  000d7	80 f9 01	 cmp	 cl, 1
  000da	74 12		 je	 SHORT $LN5@atomno
$LN6@atomno:
  000dc	8b c3		 mov	 eax, ebx
  000de	e8 00 00 00 00	 call	 _insert_lex
  000e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  000e9	89 04 b2	 mov	 DWORD PTR [edx+esi*4], eax
  000ec	eb 04		 jmp	 SHORT $LN4@atomno
$LN5@atomno:
  000ee	89 5c b5 00	 mov	 DWORD PTR [ebp+esi*4], ebx
$LN4@atomno:

; 96   :     newatom++; atomstamp[i]=g.timestamp;

  000f2	ff 05 00 00 00
	00		 inc	 DWORD PTR _newatom
  000f8	a0 70 01 00 00	 mov	 al, BYTE PTR _g+368
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomstamp
  00103	88 04 31	 mov	 BYTE PTR [ecx+esi], al

; 97   :     if(newatom>(MAXATOM>>1)+(MAXATOM>>2) ) sfull("(%75)");

  00106	a1 18 00 00 00	 mov	 eax, DWORD PTR _max+24
  0010b	8b d0		 mov	 edx, eax
  0010d	d1 e8		 shr	 eax, 1
  0010f	c1 ea 02	 shr	 edx, 2
  00112	03 d0		 add	 edx, eax
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR _newatom
  00119	3b c2		 cmp	 eax, edx
  0011b	76 3d		 jbe	 SHORT $LN21@atomno
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_05KHPJABPL@?$CI?$CF75?$CJ?$AA@

; 98   :     return i;

  00122	eb 0e		 jmp	 SHORT $LN36@atomno
$LN11@atomno:

; 99   :   }
; 100  :    else if(i==last)

  00124	3b f7		 cmp	 esi, edi
  00126	75 32		 jne	 SHORT $LN21@atomno

; 101  :   {
; 102  :     sfull("unexpected!!!"); 

  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR _newatom
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HPGGIJEI@unexpected?$CB?$CB?$CB?$AA@
$LN36@atomno:
  00132	50		 push	 eax
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IDADGMOM@?$CFld?5symbols?0?5?$CFs?$CB?$CB?$CB?5?$AA@
  00138	e8 00 00 00 00	 call	 ___iob_func
  0013d	83 c0 40	 add	 eax, 64			; 00000040H
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _fprintf
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GADLEGAB@symbol?5hashing?5table?5?$CIalmost?$CJ?5fu@
  0014b	e8 00 00 00 00	 call	 _warnmes
  00150	6a 05		 push	 5
  00152	e8 00 00 00 00	 call	 _bp_halt
  00157	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@atomno:

; 103  :   }
; 104  :   /* else if found */
; 105  :   return i;

  0015a	5f		 pop	 edi
  0015b	8b c6		 mov	 eax, esi
  0015d	5e		 pop	 esi
  0015e	5d		 pop	 ebp
  0015f	5b		 pop	 ebx

; 106  : 
; 107  : }

  00160	c3		 ret	 0
_atomno	ENDP
_TEXT	ENDS
PUBLIC	_atombak
; Function compile flags: /Ogtpy
;	COMDAT _atombak
_TEXT	SEGMENT
_stamp$ = 8						; size = 1
_atombak PROC						; COMDAT

; 111  :   for(i=0; i<MAXATOM; i++)

  00000	33 c0		 xor	 eax, eax
  00002	39 05 18 00 00
	00		 cmp	 DWORD PTR _max+24, eax
  00008	76 39		 jbe	 SHORT $LN2@atombak
  0000a	8a 54 24 04	 mov	 dl, BYTE PTR _stamp$[esp-4]
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  00014	57		 push	 edi
$LL4@atombak:

; 112  :     if(atomstamp[i]>stamp && atomtable[i])

  00015	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _atomstamp
  0001b	38 14 07	 cmp	 BYTE PTR [edi+eax], dl
  0001e	76 19		 jbe	 SHORT $LN3@atombak
  00020	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00024	74 13		 je	 SHORT $LN3@atombak

; 113  :     { 
; 114  : #if TRACE>2
; 115  :       fprintf(STD_err,"cleaned up atom-> [%ld],%s\n",i,atomtable[i]);
; 116  : #endif
; 117  :       atomtable[i]=NULL;

  00026	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [ecx+eax*4], 0

; 118  :       newatom--;

  0002d	ff 0d 00 00 00
	00		 dec	 DWORD PTR _newatom
  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
$LN3@atombak:

; 111  :   for(i=0; i<MAXATOM; i++)

  00039	40		 inc	 eax
  0003a	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _max+24
  00040	72 d3		 jb	 SHORT $LL4@atombak
  00042	5f		 pop	 edi
$LN2@atombak:

; 119  :     }
; 120  : }

  00043	c3		 ret	 0
_atombak ENDP
_TEXT	ENDS
PUBLIC	_atomcommit
; Function compile flags: /Ogtpy
;	COMDAT _atomcommit
_TEXT	SEGMENT
_stamp$ = 8						; size = 1
_atomcommit PROC					; COMDAT

; 125  :   for(i=0; i<MAXATOM; i++)

  00000	33 c0		 xor	 eax, eax
  00002	39 05 18 00 00
	00		 cmp	 DWORD PTR _max+24, eax
  00008	76 2f		 jbe	 SHORT $LN2@atomcommit
  0000a	8a 54 24 04	 mov	 dl, BYTE PTR _stamp$[esp-4]
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomstamp
  00014	56		 push	 esi
$LL4@atomcommit:

; 126  :     if(atomstamp[i]>stamp && atomtable[i])

  00015	38 14 01	 cmp	 BYTE PTR [ecx+eax], dl
  00018	76 15		 jbe	 SHORT $LN3@atomcommit
  0001a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _atomtable
  00020	83 3c 86 00	 cmp	 DWORD PTR [esi+eax*4], 0
  00024	74 09		 je	 SHORT $LN3@atomcommit

; 127  :     { 
; 128  : #if TRACE>2
; 129  :       if(atomstamp[i]>RUNTIME) 
; 130  :          fprintf(STD_err,"strange atom-> [%ld],%s\n",i,atomtable[i]);
; 131  : #endif
; 132  :       atomstamp[i]=stamp;

  00026	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomstamp
$LN3@atomcommit:

; 125  :   for(i=0; i<MAXATOM; i++)

  0002f	40		 inc	 eax
  00030	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR _max+24
  00036	72 dd		 jb	 SHORT $LL4@atomcommit
  00038	5e		 pop	 esi
$LN2@atomcommit:

; 133  :     }
; 134  : }

  00039	c3		 ret	 0
_atomcommit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NLMJGCCD@arity?5limit?5exceeded?$AA@	; `string'
PUBLIC	??_C@_06OGIBDCOL@?$CFs?1?$CFld?$AA@		; `string'
PUBLIC	_new_func
;	COMDAT ??_C@_0BF@NLMJGCCD@arity?5limit?5exceeded?$AA@
CONST	SEGMENT
??_C@_0BF@NLMJGCCD@arity?5limit?5exceeded?$AA@ DB 'arity limit exceeded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGIBDCOL@?$CFs?1?$CFld?$AA@
CONST	SEGMENT
??_C@_06OGIBDCOL@?$CFs?1?$CFld?$AA@ DB '%s/%ld', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _new_func
_TEXT	SEGMENT
_name$ = 8						; size = 4
_argctr$ = 12						; size = 4
_new_func PROC						; COMDAT

; 137  : { 

  00000	56		 push	 esi

; 138  :   if(argctr>MAXARITY)

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _argctr$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 0c	 mov	 edi, DWORD PTR _name$[esp+4]
  0000a	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  00010	76 24		 jbe	 SHORT $LN1@new_func

; 139  :     { fprintf(STD_err,"%s/%ld",name,argctr);warnmes("arity limit exceeded");

  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_06OGIBDCOL@?$CFs?1?$CFld?$AA@
  00019	e8 00 00 00 00	 call	 ___iob_func
  0001e	83 c0 40	 add	 eax, 64			; 00000040H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _fprintf
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NLMJGCCD@arity?5limit?5exceeded?$AA@
  0002c	e8 00 00 00 00	 call	 _warnmes
  00031	83 c4 14	 add	 esp, 20			; 00000014H

; 140  :       argctr=0;

  00034	33 f6		 xor	 esi, esi
$LN1@new_func:

; 141  :     }
; 142  :   return C2C(PUTARITY(PUTSYMNO(FUNTAG,atomno(name)),argctr));

  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _atomno
  0003c	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00041	c1 e6 16	 shl	 esi, 22			; 00000016H
  00044	0b c6		 or	 eax, esi
  00046	83 c4 04	 add	 esp, 4
  00049	03 c0		 add	 eax, eax
  0004b	03 c0		 add	 eax, eax
  0004d	5f		 pop	 edi
  0004e	83 c8 03	 or	 eax, 3
  00051	5e		 pop	 esi

; 143  : }

  00052	c3		 ret	 0
_new_func ENDP
_TEXT	ENDS
END
