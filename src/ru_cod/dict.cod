; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\dict.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_opcount
_DATA	SEGMENT
COMM	_hstamp:DWORD
COMM	_hcount:DWORD
COMM	_htable:DWORD
_DATA	ENDS
_BSS	SEGMENT
_opcount DD	01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BM@ILODNDAJ@hashing?5table?5?$CIalmost?$CJ?5full?$AA@ ; `string'
PUBLIC	??_C@_0BC@CMNHBGAJ@?$CFld?5bytes?0?5?$CFs?$CB?$CB?$CB?5?$AA@ ; `string'
PUBLIC	_hfull
EXTRN	_bp_halt:PROC
EXTRN	_warnmes:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0BM@ILODNDAJ@hashing?5table?5?$CIalmost?$CJ?5full?$AA@
; File c:\a17\prolog\ptarau_prolog\src\dict.c
CONST	SEGMENT
??_C@_0BM@ILODNDAJ@hashing?5table?5?$CIalmost?$CJ?5full?$AA@ DB 'hashing '
	DB	'table (almost) full', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CMNHBGAJ@?$CFld?5bytes?0?5?$CFs?$CB?$CB?$CB?5?$AA@
CONST	SEGMENT
??_C@_0BC@CMNHBGAJ@?$CFld?5bytes?0?5?$CFs?$CB?$CB?$CB?5?$AA@ DB '%ld byte'
	DB	's, %s!!! ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hfull
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_hfull	PROC						; COMDAT

; 60   :    fprintf(STD_err,"%ld bytes, %s!!! ",hcount*sizeof(struct hentry),mes);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	50		 push	 eax
  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR _hcount
  0000a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0000d	03 c9		 add	 ecx, ecx
  0000f	03 c9		 add	 ecx, ecx
  00011	51		 push	 ecx
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CMNHBGAJ@?$CFld?5bytes?0?5?$CFs?$CB?$CB?$CB?5?$AA@
  00017	e8 00 00 00 00	 call	 ___iob_func
  0001c	83 c0 40	 add	 eax, 64			; 00000040H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf

; 61   :    warnmes("hashing table (almost) full");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@ILODNDAJ@hashing?5table?5?$CIalmost?$CJ?5full?$AA@
  0002a	e8 00 00 00 00	 call	 _warnmes
  0002f	83 c4 14	 add	 esp, 20			; 00000014H

; 62   :    bp_halt(6);

  00032	c7 44 24 04 06
	00 00 00	 mov	 DWORD PTR _mes$[esp-4], 6
  0003a	e9 00 00 00 00	 jmp	 _bp_halt
_hfull	ENDP
_TEXT	ENDS
PUBLIC	_hinit
EXTRN	_make_byte_array:PROC
EXTRN	_make_hentry:PROC
EXTRN	_max:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _hinit
_TEXT	SEGMENT
_hinit	PROC						; COMDAT

; 67   :   htable=make_hentry(HMAX);

  00000	a1 14 00 00 00	 mov	 eax, DWORD PTR _max+20
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _make_hentry

; 68   :   hstamp=make_byte_array(HMAX);

  0000b	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _max+20
  00011	51		 push	 ecx
  00012	a3 00 00 00 00	 mov	 DWORD PTR _htable, eax
  00017	e8 00 00 00 00	 call	 _make_byte_array
  0001c	83 c4 08	 add	 esp, 8

; 69   :   hcount= -1;
; 70   :   return htable && hstamp;

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _htable, 0
  00026	a3 00 00 00 00	 mov	 DWORD PTR _hstamp, eax
  0002b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _hcount, -1
  00035	74 0a		 je	 SHORT $LN3@hinit
  00037	85 c0		 test	 eax, eax
  00039	74 06		 je	 SHORT $LN3@hinit
  0003b	b8 01 00 00 00	 mov	 eax, 1

; 71   : }

  00040	c3		 ret	 0
$LN3@hinit:

; 69   :   hcount= -1;
; 70   :   return htable && hstamp;

  00041	33 c0		 xor	 eax, eax

; 71   : }

  00043	c3		 ret	 0
_hinit	ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@		; `string'
PUBLIC	_hdef
;	COMDAT ??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@
CONST	SEGMENT
??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@ DB '(75%)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hdef
_TEXT	SEGMENT
_pred$ = 8						; size = 4
_fun$ = 12						; size = 4
_val$ = 16						; size = 4
_stamp$ = 20						; size = 1
_hdef	PROC						; COMDAT

; 113  :   register no i=HKEY(pred,fun),last;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _max+20
  00006	53		 push	 ebx

; 114  :   HLIMIT(last);
; 115  :   while(HNOTFULL() && HUSED() && !(HFOUND()))

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _htable
  0000d	55		 push	 ebp
  0000e	8b 6c 24 10	 mov	 ebp, DWORD PTR _fun$[esp+4]
  00012	8b c5		 mov	 eax, ebp
  00014	c1 e8 11	 shr	 eax, 17			; 00000011H
  00017	8b d5		 mov	 edx, ebp
  00019	c1 e2 05	 shl	 edx, 5
  0001c	33 c2		 xor	 eax, edx
  0001e	8b 54 24 0c	 mov	 edx, DWORD PTR _pred$[esp+4]
  00022	56		 push	 esi
  00023	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _hcount
  0002b	57		 push	 edi
  0002c	8d 79 ff	 lea	 edi, DWORD PTR [ecx-1]
  0002f	23 f7		 and	 esi, edi
  00031	03 c6		 add	 eax, esi
  00033	23 c7		 and	 eax, edi
  00035	3b f0		 cmp	 esi, eax
  00037	74 32		 je	 SHORT $LN5@hdef
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL6@hdef:
  00040	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00043	8b 14 8b	 mov	 edx, DWORD PTR [ebx+ecx*4]
  00046	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  00049	85 d2		 test	 edx, edx
  0004b	74 18		 je	 SHORT $LN15@hdef
  0004d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00050	85 c9		 test	 ecx, ecx
  00052	74 11		 je	 SHORT $LN15@hdef
  00054	3b 54 24 14	 cmp	 edx, DWORD PTR _pred$[esp+12]
  00058	75 04		 jne	 SHORT $LN4@hdef
  0005a	3b cd		 cmp	 ecx, ebp
  0005c	74 07		 je	 SHORT $LN15@hdef
$LN4@hdef:

; 116  :     HASH_NEXT();

  0005e	46		 inc	 esi
  0005f	23 f7		 and	 esi, edi
  00061	3b f0		 cmp	 esi, eax
  00063	75 db		 jne	 SHORT $LL6@hdef
$LN15@hdef:

; 114  :   HLIMIT(last);
; 115  :   while(HNOTFULL() && HUSED() && !(HFOUND()))

  00065	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR _max+20
$LN5@hdef:

; 117  :   if(!HUSED() || (HDELETED() && HFOUND()) )

  0006b	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  0006e	03 ff		 add	 edi, edi
  00070	03 ff		 add	 edi, edi
  00072	8b 04 1f	 mov	 eax, DWORD PTR [edi+ebx]
  00075	85 c0		 test	 eax, eax
  00077	74 20		 je	 SHORT $LN16@hdef
  00079	8b 54 1f 04	 mov	 edx, DWORD PTR [edi+ebx+4]
  0007d	85 d2		 test	 edx, edx
  0007f	74 18		 je	 SHORT $LN16@hdef
  00081	83 7c 1f 08 00	 cmp	 DWORD PTR [edi+ebx+8], 0
  00086	75 0a		 jne	 SHORT $LN3@hdef
  00088	3b 44 24 14	 cmp	 eax, DWORD PTR _pred$[esp+12]
  0008c	75 04		 jne	 SHORT $LN3@hdef
  0008e	3b d5		 cmp	 edx, ebp
  00090	74 07		 je	 SHORT $LN16@hdef
$LN3@hdef:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5d		 pop	 ebp

; 120  :         return 1;
; 121  :       }
; 122  :   return 0;     

  00095	33 c0		 xor	 eax, eax
  00097	5b		 pop	 ebx

; 123  : }

  00098	c3		 ret	 0
$LN16@hdef:

; 118  :       {
; 119  :         HPUT(i,pred,fun,val,stamp);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _hcount
  0009e	8b d1		 mov	 edx, ecx
  000a0	c1 ea 02	 shr	 edx, 2
  000a3	d1 e9		 shr	 ecx, 1
  000a5	03 d1		 add	 edx, ecx
  000a7	3b c2		 cmp	 eax, edx
  000a9	7e 3a		 jle	 SHORT $LN9@hdef
  000ab	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000ae	03 c0		 add	 eax, eax
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@
  000b5	03 c0		 add	 eax, eax
  000b7	50		 push	 eax
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CMNHBGAJ@?$CFld?5bytes?0?5?$CFs?$CB?$CB?$CB?5?$AA@
  000bd	e8 00 00 00 00	 call	 ___iob_func
  000c2	83 c0 40	 add	 eax, 64			; 00000040H
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _fprintf
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@ILODNDAJ@hashing?5table?5?$CIalmost?$CJ?5full?$AA@
  000d0	e8 00 00 00 00	 call	 _warnmes
  000d5	6a 06		 push	 6
  000d7	e8 00 00 00 00	 call	 _bp_halt
  000dc	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _htable
  000e2	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@hdef:
  000e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _pred$[esp+12]
  000e9	8b 44 24 1c	 mov	 eax, DWORD PTR _val$[esp+12]
  000ed	89 0c 1f	 mov	 DWORD PTR [edi+ebx], ecx
  000f0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  000f6	89 6c 17 04	 mov	 DWORD PTR [edi+edx+4], ebp
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable
  00100	8a 54 24 20	 mov	 dl, BYTE PTR _stamp$[esp+12]
  00104	89 44 0f 08	 mov	 DWORD PTR [edi+ecx+8], eax
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hstamp
  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	01 05 00 00 00
	00		 add	 DWORD PTR _hcount, eax
  00119	5f		 pop	 edi
  0011a	88 14 31	 mov	 BYTE PTR [ecx+esi], dl
  0011d	5e		 pop	 esi
  0011e	5d		 pop	 ebp
  0011f	5b		 pop	 ebx

; 123  : }

  00120	c3		 ret	 0
_hdef	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@OLOBIIND@hdef?13?5required?5before?5using?5hse@ ; `string'
PUBLIC	_hset
;	COMDAT ??_C@_0CE@OLOBIIND@hdef?13?5required?5before?5using?5hse@
CONST	SEGMENT
??_C@_0CE@OLOBIIND@hdef?13?5required?5before?5using?5hse@ DB 'hdef/3 requ'
	DB	'ired before using hset/3', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hset
_TEXT	SEGMENT
_pred$ = 8						; size = 4
_fun$ = 12						; size = 4
_val$ = 16						; size = 4
_hset	PROC						; COMDAT

; 127  :   register no i=HKEY(pred,fun),last; HLIMIT(last);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _pred$[esp-4]
  00004	53		 push	 ebx
  00005	8b 5c 24 0c	 mov	 ebx, DWORD PTR _fun$[esp]
  00009	55		 push	 ebp

; 128  :   while(HNOTFULL() && HUSED() && !(HFOUND()))

  0000a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _htable
  00010	8b c3		 mov	 eax, ebx
  00012	c1 e8 11	 shr	 eax, 17			; 00000011H
  00015	8b cb		 mov	 ecx, ebx
  00017	c1 e1 05	 shl	 ecx, 5
  0001a	57		 push	 edi
  0001b	8b 3d 14 00 00
	00		 mov	 edi, DWORD PTR _max+20
  00021	33 c1		 xor	 eax, ecx
  00023	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hcount
  0002c	4f		 dec	 edi
  0002d	23 c7		 and	 eax, edi
  0002f	03 d0		 add	 edx, eax
  00031	23 d7		 and	 edx, edi
  00033	3b c2		 cmp	 eax, edx
  00035	74 31		 je	 SHORT $LN10@hset
  00037	56		 push	 esi
  00038	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL4@hset:
  00040	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00043	8b 74 8d 00	 mov	 esi, DWORD PTR [ebp+ecx*4]
  00047	8d 4c 8d 00	 lea	 ecx, DWORD PTR [ebp+ecx*4]
  0004b	85 f6		 test	 esi, esi
  0004d	74 18		 je	 SHORT $LN12@hset
  0004f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00052	85 c9		 test	 ecx, ecx
  00054	74 11		 je	 SHORT $LN12@hset
  00056	3b 74 24 14	 cmp	 esi, DWORD PTR _pred$[esp+12]
  0005a	75 04		 jne	 SHORT $LN2@hset
  0005c	3b cb		 cmp	 ecx, ebx
  0005e	74 07		 je	 SHORT $LN12@hset
$LN2@hset:

; 129  :     HASH_NEXT();

  00060	40		 inc	 eax
  00061	23 c7		 and	 eax, edi
  00063	3b c2		 cmp	 eax, edx
  00065	75 d9		 jne	 SHORT $LL4@hset
$LN12@hset:
  00067	5e		 pop	 esi
$LN10@hset:

; 130  :   if(HFOUND())

  00068	8b 4c 24 10	 mov	 ecx, DWORD PTR _pred$[esp+8]
  0006c	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0006f	39 4c 95 00	 cmp	 DWORD PTR [ebp+edx*4], ecx
  00073	8d 44 95 00	 lea	 eax, DWORD PTR [ebp+edx*4]
  00077	75 15		 jne	 SHORT $LN1@hset
  00079	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0007c	75 10		 jne	 SHORT $LN1@hset

; 131  :       {
; 132  :         htable[i].val=val;

  0007e	8b 54 24 18	 mov	 edx, DWORD PTR _val$[esp+8]
  00082	5f		 pop	 edi
  00083	5d		 pop	 ebp
  00084	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 133  :         return 1;

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	5b		 pop	 ebx

; 143  : }

  0008d	c3		 ret	 0
$LN1@hset:

; 134  :       }
; 135  :   warnmes("hdef/3 required before using hset/3");

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OLOBIIND@hdef?13?5required?5before?5using?5hse@
  00093	e8 00 00 00 00	 call	 _warnmes
  00098	83 c4 04	 add	 esp, 4
  0009b	5f		 pop	 edi
  0009c	5d		 pop	 ebp

; 136  : #if 0
; 137  :   fprintf(STD_err,"%s/%ld+...->%s/%ld\n",
; 138  :      NAME(pred),GETARITY(pred),
; 139  :      NAME(val),GETARITY(val)
; 140  :     );
; 141  : #endif
; 142  :   return 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	5b		 pop	 ebx

; 143  : }

  000a0	c3		 ret	 0
_hset	ENDP
_TEXT	ENDS
PUBLIC	_hget
; Function compile flags: /Ogtpy
;	COMDAT _hget
_TEXT	SEGMENT
_last$ = 8						; size = 4
_pred$ = 8						; size = 4
_fun$ = 12						; size = 4
_hget	PROC						; COMDAT

; 148  : {

  00000	53		 push	 ebx

; 149  :   register no last,i=HKEY(pred,fun);
; 150  :   if(HFOUND()) return htable[i].val;

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _htable
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR _fun$[esp+4]
  0000c	56		 push	 esi
  0000d	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR _max+20
  00013	8b c5		 mov	 eax, ebp
  00015	c1 e8 11	 shr	 eax, 17			; 00000011H
  00018	8b cd		 mov	 ecx, ebp
  0001a	c1 e1 05	 shl	 ecx, 5
  0001d	33 c1		 xor	 eax, ecx
  0001f	57		 push	 edi
  00020	8b 7c 24 14	 mov	 edi, DWORD PTR _pred$[esp+12]
  00024	4e		 dec	 esi
  00025	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00028	23 c6		 and	 eax, esi
  0002a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0002d	39 3c 93	 cmp	 DWORD PTR [ebx+edx*4], edi
  00030	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  00033	75 0d		 jne	 SHORT $LN7@hget
  00035	39 69 04	 cmp	 DWORD PTR [ecx+4], ebp
  00038	75 08		 jne	 SHORT $LN7@hget
  0003a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5d		 pop	 ebp
  00040	5b		 pop	 ebx

; 158  : }

  00041	c3		 ret	 0
$LN7@hget:

; 151  :   HLIMIT(last);

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hcount
  00048	03 c8		 add	 ecx, eax
  0004a	23 ce		 and	 ecx, esi
  0004c	89 4c 24 14	 mov	 DWORD PTR _last$[esp+12], ecx
$LL6@hget:

; 152  :   do {
; 153  :        HASH_NEXT();

  00050	40		 inc	 eax
  00051	23 c6		 and	 eax, esi

; 154  :        if(HFOUND()) return htable[i].val;

  00053	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00056	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	3b d7		 cmp	 edx, edi
  0005d	75 05		 jne	 SHORT $LN5@hget
  0005f	39 69 04	 cmp	 DWORD PTR [ecx+4], ebp
  00062	74 16		 je	 SHORT $LN11@hget
$LN5@hget:

; 155  :      }
; 156  :   while(HNOTFULL() && HUSED());   

  00064	3b 44 24 14	 cmp	 eax, DWORD PTR _last$[esp+12]
  00068	74 1c		 je	 SHORT $LN2@hget
  0006a	85 d2		 test	 edx, edx
  0006c	74 18		 je	 SHORT $LN2@hget
  0006e	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00072	74 12		 je	 SHORT $LN2@hget
  00074	8b 6c 24 18	 mov	 ebp, DWORD PTR _fun$[esp+12]
  00078	eb d6		 jmp	 SHORT $LL6@hget
$LN11@hget:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 154  :        if(HFOUND()) return htable[i].val;

  0007c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0007f	8b 44 83 08	 mov	 eax, DWORD PTR [ebx+eax*4+8]
  00083	5d		 pop	 ebp
  00084	5b		 pop	 ebx

; 158  : }

  00085	c3		 ret	 0
$LN2@hget:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5d		 pop	 ebp

; 157  :   return (no)NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	5b		 pop	 ebx

; 158  : }

  0008c	c3		 ret	 0
_hget	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@HJGHDCKK@culprit?9?$DOhindex?$AA@	; `string'
PUBLIC	_hindex
;	COMDAT ??_C@_0BA@HJGHDCKK@culprit?9?$DOhindex?$AA@
CONST	SEGMENT
??_C@_0BA@HJGHDCKK@culprit?9?$DOhindex?$AA@ DB 'culprit->hindex', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hindex
_TEXT	SEGMENT
_last$ = 8						; size = 4
_pred$ = 8						; size = 4
_fun$ = 12						; size = 4
_index$ = 16						; size = 4
_hindex	PROC						; COMDAT

; 161  : {

  00000	53		 push	 ebx

; 162  :   register no last,i=HKEY(pred,fun);
; 163  :   if(HFOUND()) {*index=i; return FOUND;}

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _htable
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR _fun$[esp+4]
  0000c	56		 push	 esi
  0000d	8b 35 14 00 00
	00		 mov	 esi, DWORD PTR _max+20
  00013	8b c5		 mov	 eax, ebp
  00015	c1 e8 11	 shr	 eax, 17			; 00000011H
  00018	8b cd		 mov	 ecx, ebp
  0001a	c1 e1 05	 shl	 ecx, 5
  0001d	33 c1		 xor	 eax, ecx
  0001f	57		 push	 edi
  00020	8b 7c 24 14	 mov	 edi, DWORD PTR _pred$[esp+12]
  00024	4e		 dec	 esi
  00025	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00028	23 c6		 and	 eax, esi
  0002a	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0002d	8d 0c 93	 lea	 ecx, DWORD PTR [ebx+edx*4]
  00030	8b 11		 mov	 edx, DWORD PTR [ecx]
  00032	3b d7		 cmp	 edx, edi
  00034	75 15		 jne	 SHORT $LN11@hindex
  00036	39 69 04	 cmp	 DWORD PTR [ecx+4], ebp
  00039	75 10		 jne	 SHORT $LN11@hindex
  0003b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _index$[esp+12]
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp
  00042	89 01		 mov	 DWORD PTR [ecx], eax
  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	5b		 pop	 ebx

; 175  : }

  0004a	c3		 ret	 0
$LN11@hindex:

; 164  :   if(!HUSED()) {*index=i; return FREE;}

  0004b	85 d2		 test	 edx, edx
  0004d	74 71		 je	 SHORT $LN9@hindex
  0004f	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00053	74 6b		 je	 SHORT $LN9@hindex

; 165  :   HLIMIT(last); 

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hcount
  0005b	03 c8		 add	 ecx, eax
  0005d	23 ce		 and	 ecx, esi
  0005f	89 4c 24 14	 mov	 DWORD PTR _last$[esp+12], ecx
$LL8@hindex:

; 166  :   do  
; 167  :      {
; 168  :        HASH_NEXT();

  00063	40		 inc	 eax
  00064	23 c6		 and	 eax, esi

; 169  :        if(HFOUND()) {*index=i; return FOUND;}

  00066	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00069	8b 14 8b	 mov	 edx, DWORD PTR [ebx+ecx*4]
  0006c	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  0006f	3b d7		 cmp	 edx, edi
  00071	75 05		 jne	 SHORT $LN7@hindex
  00073	39 69 04	 cmp	 DWORD PTR [ecx+4], ebp
  00076	74 16		 je	 SHORT $LN15@hindex
$LN7@hindex:

; 170  :      }
; 171  :   while(HNOTFULL() && HUSED());

  00078	3b 44 24 14	 cmp	 eax, DWORD PTR _last$[esp+12]
  0007c	74 20		 je	 SHORT $LN16@hindex
  0007e	85 d2		 test	 edx, edx
  00080	74 31		 je	 SHORT $LN2@hindex
  00082	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00086	74 2b		 je	 SHORT $LN2@hindex
  00088	8b 6c 24 18	 mov	 ebp, DWORD PTR _fun$[esp+12]
  0008c	eb d5		 jmp	 SHORT $LL8@hindex
$LN15@hindex:

; 169  :        if(HFOUND()) {*index=i; return FOUND;}

  0008e	8b 54 24 1c	 mov	 edx, DWORD PTR _index$[esp+12]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5d		 pop	 ebp
  00095	89 02		 mov	 DWORD PTR [edx], eax
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	5b		 pop	 ebx

; 175  : }

  0009d	c3		 ret	 0
$LN16@hindex:

; 172  :  
; 173  :   if(!HNOTFULL()) {hfull("culprit->hindex"); return FULL;}

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HJGHDCKK@culprit?9?$DOhindex?$AA@
  000a3	e8 00 00 00 00	 call	 _hfull
  000a8	83 c4 04	 add	 esp, 4
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5d		 pop	 ebp
  000ae	83 c8 ff	 or	 eax, -1
  000b1	5b		 pop	 ebx

; 175  : }

  000b2	c3		 ret	 0
$LN2@hindex:

; 174  :   else {*index=i; return FREE;}

  000b3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _index$[esp+12]
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5d		 pop	 ebp
  000ba	89 01		 mov	 DWORD PTR [ecx], eax
  000bc	33 c0		 xor	 eax, eax
  000be	5b		 pop	 ebx

; 175  : }

  000bf	c3		 ret	 0
$LN9@hindex:

; 164  :   if(!HUSED()) {*index=i; return FREE;}

  000c0	8b 54 24 1c	 mov	 edx, DWORD PTR _index$[esp+12]
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5d		 pop	 ebp
  000c7	89 02		 mov	 DWORD PTR [edx], eax
  000c9	33 c0		 xor	 eax, eax
  000cb	5b		 pop	 ebx

; 175  : }

  000cc	c3		 ret	 0
_hindex	ENDP
_TEXT	ENDS
PUBLIC	_hbak
; Function compile flags: /Ogtpy
;	COMDAT _hbak
_TEXT	SEGMENT
_stamp$ = 8						; size = 1
_hbak	PROC						; COMDAT

; 179  : 
; 180  :   if(BBOARDTIME==stamp)

  00000	8a 54 24 04	 mov	 dl, BYTE PTR _stamp$[esp-4]
  00004	56		 push	 esi
  00005	80 fa 03	 cmp	 dl, 3
  00008	75 41		 jne	 SHORT $LN10@hbak

; 181  :     {
; 182  :      for(i=0; i<HMAX; i++)

  0000a	33 d2		 xor	 edx, edx
  0000c	39 15 14 00 00
	00		 cmp	 DWORD PTR _max+20, edx
  00012	0f 86 95 00 00
	00		 jbe	 $LN2@hbak
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _htable
  0001d	33 c9		 xor	 ecx, ecx
  0001f	90		 npad	 1
$LL9@hbak:

; 183  :        if(hstamp[i]>stamp && htable[i].pred)

  00020	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _hstamp
  00026	80 3c 16 03	 cmp	 BYTE PTR [esi+edx], 3
  0002a	76 11		 jbe	 SHORT $LN8@hbak
  0002c	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  00030	74 0b		 je	 SHORT $LN8@hbak

; 184  :         { /* if(VARTIME!=hstamp[i]) {warnmes("bad stamp"); bp_halt(7);} */
; 185  :         htable[i].val=(no)&htable[i].val;

  00032	8d 44 01 08	 lea	 eax, DWORD PTR [ecx+eax+8]
  00036	89 00		 mov	 DWORD PTR [eax], eax
  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _htable
$LN8@hbak:

; 181  :     {
; 182  :      for(i=0; i<HMAX; i++)

  0003d	42		 inc	 edx
  0003e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00041	3b 15 14 00 00
	00		 cmp	 edx, DWORD PTR _max+20
  00047	72 d7		 jb	 SHORT $LL9@hbak
  00049	5e		 pop	 esi

; 197  :        }
; 198  :    }
; 199  : }

  0004a	c3		 ret	 0
$LN10@hbak:

; 186  :       }
; 187  :     }
; 188  :   else 
; 189  :    {
; 190  :      for(i=0; i<HMAX; i++)

  0004b	33 c9		 xor	 ecx, ecx
  0004d	39 0d 14 00 00
	00		 cmp	 DWORD PTR _max+20, ecx
  00053	76 58		 jbe	 SHORT $LN2@hbak
  00055	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _htable
  0005b	33 c0		 xor	 eax, eax
  0005d	53		 push	 ebx
  0005e	8b ff		 npad	 2
$LL4@hbak:

; 191  :        if(hstamp[i]>stamp && htable[i].pred)

  00060	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _hstamp
  00066	38 14 0b	 cmp	 BYTE PTR [ebx+ecx], dl
  00069	76 35		 jbe	 SHORT $LN3@hbak
  0006b	83 3c 30 00	 cmp	 DWORD PTR [eax+esi], 0
  0006f	74 2f		 je	 SHORT $LN3@hbak

; 192  :        {       
; 193  :          hcount--;

  00071	ff 0d 00 00 00
	00		 dec	 DWORD PTR _hcount

; 194  :          htable[i].pred=0;

  00077	c7 04 30 00 00
	00 00		 mov	 DWORD PTR [eax+esi], 0

; 195  :          htable[i].fun=0;

  0007e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _htable
  00084	c7 44 30 04 00
	00 00 00	 mov	 DWORD PTR [eax+esi+4], 0

; 196  :          htable[i].val=0; 

  0008c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _htable
  00092	c7 44 30 08 00
	00 00 00	 mov	 DWORD PTR [eax+esi+8], 0
  0009a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _htable
$LN3@hbak:

; 186  :       }
; 187  :     }
; 188  :   else 
; 189  :    {
; 190  :      for(i=0; i<HMAX; i++)

  000a0	41		 inc	 ecx
  000a1	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a4	3b 0d 14 00 00
	00		 cmp	 ecx, DWORD PTR _max+20
  000aa	72 b4		 jb	 SHORT $LL4@hbak
  000ac	5b		 pop	 ebx
$LN2@hbak:
  000ad	5e		 pop	 esi

; 197  :        }
; 198  :    }
; 199  : }

  000ae	c3		 ret	 0
_hbak	ENDP
_TEXT	ENDS
PUBLIC	_hcommit
; Function compile flags: /Ogtpy
;	COMDAT _hcommit
_TEXT	SEGMENT
_stamp$ = 8						; size = 1
_hcommit PROC						; COMDAT

; 203  :      for(i=0; i<HMAX; i++)

  00000	33 c0		 xor	 eax, eax
  00002	39 05 14 00 00
	00		 cmp	 DWORD PTR _max+20, eax
  00008	76 36		 jbe	 SHORT $LN2@hcommit
  0000a	8a 54 24 04	 mov	 dl, BYTE PTR _stamp$[esp-4]
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hstamp
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	33 f6		 xor	 esi, esi
$LL4@hcommit:

; 204  :        if(hstamp[i]>stamp && htable[i].pred)

  00018	38 14 01	 cmp	 BYTE PTR [ecx+eax], dl
  0001b	76 15		 jbe	 SHORT $LN3@hcommit
  0001d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  00023	83 3c 3e 00	 cmp	 DWORD PTR [esi+edi], 0
  00027	74 09		 je	 SHORT $LN3@hcommit

; 205  :        {       
; 206  :          hstamp[i]=stamp;       

  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hstamp
$LN3@hcommit:

; 203  :      for(i=0; i<HMAX; i++)

  00032	40		 inc	 eax
  00033	83 c6 0c	 add	 esi, 12			; 0000000cH
  00036	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _max+20
  0003c	72 da		 jb	 SHORT $LL4@hcommit
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
$LN2@hcommit:

; 207  :        }
; 208  : }

  00040	c3		 ret	 0
_hcommit ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _cleanup
_TEXT	SEGMENT
_cleanup PROC						; COMDAT
; _p$ = eax
; _wam$ = edx

; 241  :   if(ON(HeapStk,p) && NONVARREF(p))

  00000	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00003	3b c8		 cmp	 ecx, eax
  00005	77 12		 ja	 SHORT $LN1@cleanup
  00007	8b 12		 mov	 edx, DWORD PTR [edx]
  00009	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  0000c	3b c1		 cmp	 eax, ecx
  0000e	73 09		 jae	 SHORT $LN1@cleanup
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	f6 c1 03	 test	 cl, 3
  00015	74 02		 je	 SHORT $LN1@cleanup

; 242  :     p=(term)GETREF(p);
; 243  :   return p; 

  00017	8b c1		 mov	 eax, ecx
$LN1@cleanup:

; 244  : }

  00019	c3		 ret	 0
_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DBDNEOGI@MEM?$FL?$CFlu?$FN?$AA@		; `string'
PUBLIC	??_C@_06LFFIBBPL@?$CFs?1?$CFlu?$AA@		; `string'
PUBLIC	??_C@_0N@KOPIHJE@bp_long?$CI?$CFld?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@LCHAFMBH@CODE?$FL_?$CFld?$FN?$AA@	; `string'
PUBLIC	??_C@_07KIJINGAM@?$CFs?$FL?$CFld?$FN?$AA@	; `string'
PUBLIC	??_C@_0N@NAKJDPOH@BBOARD?$FL_?$CFld?$FN?$AA@	; `string'
EXTRN	_atomtable:DWORD
EXTRN	_sprintf:PROC
EXTRN	_g:BYTE
;	COMDAT ??_C@_08DBDNEOGI@MEM?$FL?$CFlu?$FN?$AA@
CONST	SEGMENT
??_C@_08DBDNEOGI@MEM?$FL?$CFlu?$FN?$AA@ DB 'MEM[%lu]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LFFIBBPL@?$CFs?1?$CFlu?$AA@
CONST	SEGMENT
??_C@_06LFFIBBPL@?$CFs?1?$CFlu?$AA@ DB '%s/%lu', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KOPIHJE@bp_long?$CI?$CFld?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@KOPIHJE@bp_long?$CI?$CFld?$CJ?$AA@ DB 'bp_long(%ld)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LCHAFMBH@CODE?$FL_?$CFld?$FN?$AA@
CONST	SEGMENT
??_C@_0L@LCHAFMBH@CODE?$FL_?$CFld?$FN?$AA@ DB 'CODE[_%ld]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIJINGAM@?$CFs?$FL?$CFld?$FN?$AA@
CONST	SEGMENT
??_C@_07KIJINGAM@?$CFs?$FL?$CFld?$FN?$AA@ DB '%s[%ld]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAKJDPOH@BBOARD?$FL_?$CFld?$FN?$AA@
CONST	SEGMENT
??_C@_0N@NAKJDPOH@BBOARD?$FL_?$CFld?$FN?$AA@ DB 'BBOARD[_%ld]', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _str
_TEXT	SEGMENT
_str	PROC						; COMDAT
; _ptr$ = eax
; _wam$ = esi
; _s$ = edi

; 247  : { int i;

  00000	53		 push	 ebx

; 248  :   for(i=0; i<MaxStk; i++)

  00001	33 c9		 xor	 ecx, ecx
  00003	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  00006	55		 push	 ebp
$LL12@str:

; 249  :     if(ON(i,ptr))

  00007	39 02		 cmp	 DWORD PTR [edx], eax
  00009	77 0d		 ja	 SHORT $LN11@str
  0000b	8b 5a f0	 mov	 ebx, DWORD PTR [edx-16]
  0000e	8b 2a		 mov	 ebp, DWORD PTR [edx]
  00010	8d 5c 9d 00	 lea	 ebx, DWORD PTR [ebp+ebx*4]
  00014	3b c3		 cmp	 eax, ebx
  00016	72 37		 jb	 SHORT $LN16@str
$LN11@str:

; 248  :   for(i=0; i<MaxStk; i++)

  00018	41		 inc	 ecx
  00019	83 c2 24	 add	 edx, 36			; 00000024H
  0001c	83 f9 05	 cmp	 ecx, 5
  0001f	7c e6		 jl	 SHORT $LL12@str

; 252  :         return;
; 253  :       }
; 254  :   if(ONSTACK(g.shared[BBoardStk],ptr)) {

  00021	8b 0d a8 01 00
	00		 mov	 ecx, DWORD PTR _g+424
  00027	3b c8		 cmp	 ecx, eax
  00029	77 48		 ja	 SHORT $LN8@str
  0002b	8b 15 98 01 00
	00		 mov	 edx, DWORD PTR _g+408
  00031	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00034	3b c2		 cmp	 eax, edx
  00036	73 3b		 jae	 SHORT $LN8@str

; 255  :       sprintf(s,"BBOARD[_%ld]",(term)ptr-(term)g.shared[BBoardStk].base);

  00038	2b c1		 sub	 eax, ecx
  0003a	c1 f8 02	 sar	 eax, 2
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NAKJDPOH@BBOARD?$FL_?$CFld?$FN?$AA@

; 266  :     else
; 267  :       sprintf(s,"MEM[%lu]",(no)ptr);

  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _sprintf
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx

; 268  :   }
; 269  : }

  0004e	c3		 ret	 0
$LN16@str:

; 250  :       {
; 251  :         sprintf(s,"%s[%ld]",wam[i].name,(term*)ptr-wam[i].base);

  0004f	8d 0c c9	 lea	 ecx, DWORD PTR [ecx+ecx*8]
  00052	2b 44 8e 10	 sub	 eax, DWORD PTR [esi+ecx*4+16]
  00056	8b 54 8e 20	 mov	 edx, DWORD PTR [esi+ecx*4+32]
  0005a	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  0005d	c1 f8 02	 sar	 eax, 2
  00060	50		 push	 eax
  00061	52		 push	 edx
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_07KIJINGAM@?$CFs?$FL?$CFld?$FN?$AA@
  00067	57		 push	 edi
  00068	e8 00 00 00 00	 call	 _sprintf
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	5d		 pop	 ebp
  00071	5b		 pop	 ebx

; 268  :   }
; 269  : }

  00072	c3		 ret	 0
$LN8@str:

; 256  :     }
; 257  :   else if(ONSTACK(g.shared[InstrStk],ptr)) {

  00073	8b 0d 84 01 00
	00		 mov	 ecx, DWORD PTR _g+388
  00079	3b c8		 cmp	 ecx, eax
  0007b	77 24		 ja	 SHORT $LN6@str
  0007d	8b 15 74 01 00
	00		 mov	 edx, DWORD PTR _g+372
  00083	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00086	3b c2		 cmp	 eax, edx
  00088	73 17		 jae	 SHORT $LN6@str

; 258  :       sprintf(s,"CODE[_%ld]",(term)ptr-(term)g.shared[InstrStk].base);

  0008a	2b c1		 sub	 eax, ecx
  0008c	c1 f8 02	 sar	 eax, 2
  0008f	50		 push	 eax
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LCHAFMBH@CODE?$FL_?$CFld?$FN?$AA@

; 266  :     else
; 267  :       sprintf(s,"MEM[%lu]",(no)ptr);

  00095	57		 push	 edi
  00096	e8 00 00 00 00	 call	 _sprintf
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	5d		 pop	 ebp
  0009f	5b		 pop	 ebx

; 268  :   }
; 269  : }

  000a0	c3		 ret	 0
$LN6@str:

; 259  :   }
; 260  :   else if(INTEGER(ptr)) 

  000a1	8b c8		 mov	 ecx, eax
  000a3	80 e1 03	 and	 cl, 3
  000a6	80 f9 01	 cmp	 cl, 1
  000a9	75 15		 jne	 SHORT $LN4@str

; 261  :      sprintf(s,"bp_long(%ld)",OUTPUT_INT(ptr));

  000ab	c1 f8 02	 sar	 eax, 2
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KOPIHJE@bp_long?$CI?$CFld?$CJ?$AA@

; 266  :     else
; 267  :       sprintf(s,"MEM[%lu]",(no)ptr);

  000b4	57		 push	 edi
  000b5	e8 00 00 00 00	 call	 _sprintf
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	5d		 pop	 ebp
  000be	5b		 pop	 ebx

; 268  :   }
; 269  : }

  000bf	c3		 ret	 0
$LN4@str:

; 262  :   else 
; 263  :   {       
; 264  :     if(GETSYMNO(ptr)<MAXATOM && NAME(ptr))

  000c0	8b c8		 mov	 ecx, eax
  000c2	c1 e9 02	 shr	 ecx, 2
  000c5	81 e1 ff ff 3f
	00		 and	 ecx, 4194303		; 003fffffH
  000cb	3b 0d 18 00 00
	00		 cmp	 ecx, DWORD PTR _max+24
  000d1	73 25		 jae	 SHORT $LN2@str
  000d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  000d9	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  000dd	74 19		 je	 SHORT $LN2@str

; 265  :       sprintf(s,"%s/%lu",NAME(ptr),GETARITY(ptr));

  000df	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  000e2	c1 e8 18	 shr	 eax, 24			; 00000018H
  000e5	50		 push	 eax
  000e6	52		 push	 edx
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_06LFFIBBPL@?$CFs?1?$CFlu?$AA@
  000ec	57		 push	 edi
  000ed	e8 00 00 00 00	 call	 _sprintf
  000f2	83 c4 10	 add	 esp, 16			; 00000010H
  000f5	5d		 pop	 ebp
  000f6	5b		 pop	 ebx

; 268  :   }
; 269  : }

  000f7	c3		 ret	 0
$LN2@str:

; 266  :     else
; 267  :       sprintf(s,"MEM[%lu]",(no)ptr);

  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_08DBDNEOGI@MEM?$FL?$CFlu?$FN?$AA@
  000fe	57		 push	 edi
  000ff	e8 00 00 00 00	 call	 _sprintf
  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	5d		 pop	 ebp
  00108	5b		 pop	 ebx

; 268  :   }
; 269  : }

  00109	c3		 ret	 0
_str	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@MIIEFLAH@_?$CFld?5?9?$DO?5?$CFs?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_smartref
EXTRN	_strdup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0L@MIIEFLAH@_?$CFld?5?9?$DO?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@MIIEFLAH@_?$CFld?5?9?$DO?5?$CFs?$AA@ DB '_%ld -> %s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _smartref
_TEXT	SEGMENT
_s$ = -164						; size = 80
_t$5263 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_wam$ = 12						; size = 4
_smartref PROC						; COMDAT

; 272  : { char s[80];

  00000	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 a0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+164], eax
  00014	53		 push	 ebx
  00015	8b 9c 24 ac 00
	00 00		 mov	 ebx, DWORD PTR _x$[esp+164]
  0001c	56		 push	 esi
  0001d	8b b4 24 b4 00
	00 00		 mov	 esi, DWORD PTR _wam$[esp+168]
  00024	57		 push	 edi

; 273  :   if(VAR(x))
; 274  :   {
; 275  :     term ptr=(term)x;
; 276  :     term temp=(term)x;

  00025	8b c3		 mov	 eax, ebx
  00027	f6 c3 03	 test	 bl, 3
  0002a	75 74		 jne	 SHORT $LN6@smartref

; 277  :     HDEREF(temp);

  0002c	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0002f	3b d3		 cmp	 edx, ebx
  00031	77 1a		 ja	 SHORT $LN4@smartref
  00033	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00035	8d 3c 8a	 lea	 edi, DWORD PTR [edx+ecx*4]
$LL5@smartref:
  00038	3b c7		 cmp	 eax, edi
  0003a	73 11		 jae	 SHORT $LN4@smartref
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	f6 c1 03	 test	 cl, 3
  00041	75 0a		 jne	 SHORT $LN4@smartref
  00043	3b c1		 cmp	 eax, ecx
  00045	74 06		 je	 SHORT $LN4@smartref
  00047	8b c1		 mov	 eax, ecx
  00049	3b d0		 cmp	 edx, eax
  0004b	76 eb		 jbe	 SHORT $LL5@smartref
$LN4@smartref:

; 278  :     temp=cleanup(temp,wam); 

  0004d	3b d0		 cmp	 edx, eax
  0004f	77 12		 ja	 SHORT $LN9@smartref
  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00053	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00056	3b c1		 cmp	 eax, ecx
  00058	73 09		 jae	 SHORT $LN9@smartref
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	f6 c1 03	 test	 cl, 3
  0005f	74 02		 je	 SHORT $LN9@smartref
  00061	8b c1		 mov	 eax, ecx
$LN9@smartref:

; 279  :     if(ON(HeapStk,ptr) && !NONVARREF(ptr) && temp!=cleanup(ptr,wam))

  00063	3b d3		 cmp	 edx, ebx
  00065	77 39		 ja	 SHORT $LN6@smartref
  00067	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00069	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  0006c	3b da		 cmp	 ebx, edx
  0006e	73 30		 jae	 SHORT $LN6@smartref
  00070	f6 03 03	 test	 BYTE PTR [ebx], 3
  00073	75 2b		 jne	 SHORT $LN6@smartref
  00075	3b c3		 cmp	 eax, ebx
  00077	74 27		 je	 SHORT $LN6@smartref

; 280  :       { char t[80];
; 281  :         str((no)temp,wam,t);

  00079	8d 7c 24 5c	 lea	 edi, DWORD PTR _t$5263[esp+176]
  0007d	e8 00 00 00 00	 call	 _str

; 282  :         sprintf(s,"_%ld -> %s",ptr-(term)wam[HeapStk].base,t);

  00082	2b 5e 10	 sub	 ebx, DWORD PTR [esi+16]
  00085	8b c7		 mov	 eax, edi
  00087	50		 push	 eax
  00088	c1 fb 02	 sar	 ebx, 2
  0008b	53		 push	 ebx
  0008c	8d 4c 24 14	 lea	 ecx, DWORD PTR _s$[esp+184]
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MIIEFLAH@_?$CFld?5?9?$DO?5?$CFs?$AA@
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 _sprintf
  0009b	83 c4 10	 add	 esp, 16			; 00000010H

; 283  :       }
; 284  :     else

  0009e	eb 09		 jmp	 SHORT $LN1@smartref
$LN6@smartref:

; 285  :       str((cell)temp,wam,s);
; 286  :   }
; 287  :   else {
; 288  :     /*sprintf(s,"UNSIGNED=%lu",x); */ 
; 289  :     str(x,wam,s);

  000a0	8d 7c 24 0c	 lea	 edi, DWORD PTR _s$[esp+176]
  000a4	e8 00 00 00 00	 call	 _str
$LN1@smartref:

; 290  :   }
; 291  : 
; 292  :   return strdup(s);

  000a9	8d 54 24 0c	 lea	 edx, DWORD PTR _s$[esp+176]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 _strdup

; 293  : }

  000b3	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+180]
  000ba	83 c4 04	 add	 esp, 4
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	33 cc		 xor	 ecx, esp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	81 c4 a4 00 00
	00		 add	 esp, 164		; 000000a4H
  000cd	c3		 ret	 0
_smartref ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HHCNIID@COPY_KEYS?$AA@			; `string'
PUBLIC	_hlist
EXTRN	_overflow_by:PROC
;	COMDAT ??_C@_09HHCNIID@COPY_KEYS?$AA@
CONST	SEGMENT
??_C@_09HHCNIID@COPY_KEYS?$AA@ DB 'COPY_KEYS', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hlist
_TEXT	SEGMENT
_ival$ = -8						; size = 4
_i$ = -4						; size = 4
_H$ = 8							; size = 4
_stamp$ = 12						; size = 1
_regs$ = 12						; size = 4
_wam$ = 16						; size = 4
_hlist	PROC						; COMDAT

; 314  : #if TRACE>0
; 315  :   fprintf(STD_err,"entering hlist, wam=%d, bboard=%d H=%d\n",
; 316  :     wam,g.shared[BBoardStk].base,H);
; 317  :   bbcheck(wam);
; 318  : #endif
; 319  :   if(!INTEGER(X(1))) return NULL; /* first arg: stamp */

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _regs$[esp-4]
  00004	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00007	8b d0		 mov	 edx, eax
  00009	80 e2 03	 and	 dl, 3
  0000c	83 ec 08	 sub	 esp, 8
  0000f	80 fa 01	 cmp	 dl, 1
  00012	74 06		 je	 SHORT $LN27@hlist
$LN46@hlist:
  00014	33 c0		 xor	 eax, eax

; 378  :   return H;
; 379  : }

  00016	83 c4 08	 add	 esp, 8
  00019	c3		 ret	 0
$LN27@hlist:

; 320  :   stamp=(byte)(OUTPUT_INT(X(1)));

  0001a	c1 f8 02	 sar	 eax, 2
  0001d	88 44 24 10	 mov	 BYTE PTR _stamp$[esp+4], al

; 321  :   xval=X(2); /* second arg: starting arity of listed terms */

  00021	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]

; 322  :   if(!INTEGER(xval)) return NULL;

  00024	8b c8		 mov	 ecx, eax
  00026	80 e1 03	 and	 cl, 3
  00029	80 f9 01	 cmp	 cl, 1
  0002c	75 e6		 jne	 SHORT $LN46@hlist

; 323  :   ival=OUTPUT_INT(xval);

  0002e	c1 f8 02	 sar	 eax, 2
  00031	89 04 24	 mov	 DWORD PTR _ival$[esp+8], eax

; 324  :   for(i=0; i<HMAX; i++)

  00034	33 c0		 xor	 eax, eax
  00036	56		 push	 esi
  00037	8b 74 24 10	 mov	 esi, DWORD PTR _H$[esp+8]
  0003b	89 44 24 08	 mov	 DWORD PTR _i$[esp+12], eax
  0003f	39 05 14 00 00
	00		 cmp	 DWORD PTR _max+20, eax
  00045	0f 86 d8 01 00
	00		 jbe	 $LN23@hlist

; 323  :   ival=OUTPUT_INT(xval);

  0004b	53		 push	 ebx
  0004c	55		 push	 ebp
  0004d	57		 push	 edi
  0004e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  00054	33 ed		 xor	 ebp, ebp
  00056	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL43@hlist:

; 325  :     if(hstamp[i]>=stamp && HUSED())

  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hstamp
  00066	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  00069	3a 54 24 20	 cmp	 dl, BYTE PTR _stamp$[esp+20]
  0006d	0f 82 95 01 00
	00		 jb	 $LN24@hlist
  00073	8b 0c 2f	 mov	 ecx, DWORD PTR [edi+ebp]
  00076	85 c9		 test	 ecx, ecx
  00078	0f 84 8a 01 00
	00		 je	 $LN24@hlist
  0007e	8b 44 2f 04	 mov	 eax, DWORD PTR [edi+ebp+4]
  00082	85 c0		 test	 eax, eax
  00084	0f 84 7e 01 00
	00		 je	 $LN24@hlist

; 326  :       { term xref=C2T(g.predmark);
; 327  : 
; 328  :         if(hstamp[i]<=RUNTIME)

  0008a	80 fa 02	 cmp	 dl, 2
  0008d	77 1d		 ja	 SHORT $LN21@hlist

; 329  :           { /* gets preds of arity < ival `represented' as g.predmark*/
; 330  :             if(g.predmark!=htable[i].pred 
; 331  :                 || GETARITY(htable[i].fun)<(no)ival) 

  0008f	8b 1d 68 00 00
	00		 mov	 ebx, DWORD PTR _g+104
  00095	3b d9		 cmp	 ebx, ecx
  00097	0f 85 6b 01 00
	00		 jne	 $LN24@hlist
  0009d	c1 e8 18	 shr	 eax, 24			; 00000018H
  000a0	3b 44 24 10	 cmp	 eax, DWORD PTR _ival$[esp+24]
  000a4	0f 82 5e 01 00
	00		 jb	 $LN24@hlist

; 332  :               continue;
; 333  :               xval=g.predmark;
; 334  :           }
; 335  :         else

  000aa	eb 6a		 jmp	 SHORT $LN38@hlist
$LN21@hlist:

; 336  :           { /* gets RUNTIME data of arity > ival */
; 337  :             cell v=htable[i].val;

  000ac	8b 5c 2f 08	 mov	 ebx, DWORD PTR [edi+ebp+8]

; 338  : 			if(NULL==(term)v) 

  000b0	85 db		 test	 ebx, ebx
  000b2	0f 84 50 01 00
	00		 je	 $LN24@hlist

; 339  : 			  continue;
; 340  :             if(VAR(v) &&
; 341  :               !(
; 342  :                  ONSTACK(g.shared[BBoardStk],v) ||
; 343  :                  ONSTACK(g.shared[InstrStk],v) /*|| ON(HeapStk,v) */
; 344  :                )) { 
; 345  : #if TRACE>0
; 346  :                 fprintf(STD_err,
; 347  :                  "unexpected data in htable[%d]=>\n<%s,%s>->%s\n",i,
; 348  :                   smartref(htable[i].pred,wam),
; 349  :                   smartref(htable[i].fun,wam),
; 350  :                   smartref(v,wam));
; 351  : #endif
; 352  :                 /* continue; */
; 353  :             }      
; 354  :          
; 355  :             FDEREF(v);

  000b8	8b d3		 mov	 edx, ebx
  000ba	f6 c3 03	 test	 bl, 3
  000bd	75 14		 jne	 SHORT $LN10@hlist
  000bf	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  000c1	f6 c3 03	 test	 bl, 3
  000c4	75 0d		 jne	 SHORT $LN10@hlist
$LL11@hlist:
  000c6	3b d3		 cmp	 edx, ebx
  000c8	74 09		 je	 SHORT $LN10@hlist
  000ca	8b d3		 mov	 edx, ebx
  000cc	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  000ce	f6 c3 03	 test	 bl, 3
  000d1	74 f3		 je	 SHORT $LL11@hlist
$LN10@hlist:

; 356  : 
; 357  :             if((INTEGER(xval) && ival>0) 
; 358  :                 || VAR(xval)
; 359  :                 || (GETARITY(xval) < (no)ival)
; 360  :                 || xval==g.empty 
; 361  :              )  

  000d3	8b c3		 mov	 eax, ebx
  000d5	83 e0 03	 and	 eax, 3
  000d8	83 f8 01	 cmp	 eax, 1
  000db	75 0b		 jne	 SHORT $LN7@hlist
  000dd	83 7c 24 10 00	 cmp	 DWORD PTR _ival$[esp+24], 0
  000e2	0f 8f 20 01 00
	00		 jg	 $LN24@hlist
$LN7@hlist:
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 18 01 00
	00		 je	 $LN24@hlist
  000f0	8b cb		 mov	 ecx, ebx
  000f2	c1 e9 18	 shr	 ecx, 24			; 00000018H
  000f5	3b 4c 24 10	 cmp	 ecx, DWORD PTR _ival$[esp+24]
  000f9	0f 82 09 01 00
	00		 jb	 $LN24@hlist
  000ff	3b 1d 38 00 00
	00		 cmp	 ebx, DWORD PTR _g+56
  00105	0f 84 fd 00 00
	00		 je	 $LN24@hlist

; 362  :             continue;
; 363  :             if(COMPOUND(xval))

  0010b	83 f8 03	 cmp	 eax, 3
  0010e	75 06		 jne	 SHORT $LN38@hlist
  00110	85 c9		 test	 ecx, ecx
  00112	74 02		 je	 SHORT $LN38@hlist

; 364  :               xval=T2C(xref);

  00114	8b da		 mov	 ebx, edx
$LN38@hlist:

; 365  :           }
; 366  :         IF_OVER("COPY_KEYS",(term *)H,HeapStk,bp_halt(9));

  00116	8b 44 24 24	 mov	 eax, DWORD PTR _wam$[esp+20]
  0011a	3b 70 14	 cmp	 esi, DWORD PTR [eax+20]
  0011d	72 1e		 jb	 SHORT $LN5@hlist
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_09HHCNIID@COPY_KEYS?$AA@
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 _overflow_by
  0012d	6a 09		 push	 9
  0012f	e8 00 00 00 00	 call	 _bp_halt
  00134	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  0013a	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@hlist:

; 367  :         SAVE_FUN(htable[i].pred);

  0013d	8b 04 2f	 mov	 eax, DWORD PTR [edi+ebp]
  00140	8b c8		 mov	 ecx, eax
  00142	80 e1 03	 and	 cl, 3
  00145	80 f9 01	 cmp	 cl, 1
  00148	75 1c		 jne	 SHORT $LN4@hlist
  0014a	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _g+36
  00150	89 16		 mov	 DWORD PTR [esi], edx
  00152	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00155	a1 24 00 00 00	 mov	 eax, DWORD PTR _g+36
  0015a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0015d	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
  00164	eb 2c		 jmp	 SHORT $LN44@hlist
$LN4@hlist:
  00166	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _g+36
  0016c	8b d0		 mov	 edx, eax
  0016e	89 0e		 mov	 DWORD PTR [esi], ecx
  00170	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00176	25 ff ff 7f ff	 and	 eax, -8388609		; ff7fffffH
  0017b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0017e	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _g+36
  00184	0d 00 00 40 00	 or	 eax, 4194304		; 00400000H
  00189	c1 e8 16	 shr	 eax, 22			; 00000016H
  0018c	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0018f	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN44@hlist:

; 368  :         SAVE_FUN(htable[i].fun);

  00192	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  00198	8b 44 2a 04	 mov	 eax, DWORD PTR [edx+ebp+4]
  0019c	8b c8		 mov	 ecx, eax
  0019e	80 e1 03	 and	 cl, 3
  001a1	83 c6 10	 add	 esi, 16			; 00000010H
  001a4	80 f9 01	 cmp	 cl, 1
  001a7	75 1c		 jne	 SHORT $LN2@hlist
  001a9	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _g+36
  001af	89 16		 mov	 DWORD PTR [esi], edx
  001b1	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001b4	a1 24 00 00 00	 mov	 eax, DWORD PTR _g+36
  001b9	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001bc	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
  001c3	eb 2c		 jmp	 SHORT $LN45@hlist
$LN2@hlist:
  001c5	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _g+36
  001cb	8b d0		 mov	 edx, eax
  001cd	89 0e		 mov	 DWORD PTR [esi], ecx
  001cf	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  001d5	25 ff ff 7f ff	 and	 eax, -8388609		; ff7fffffH
  001da	89 56 04	 mov	 DWORD PTR [esi+4], edx
  001dd	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _g+36
  001e3	0d 00 00 40 00	 or	 eax, 4194304		; 00400000H
  001e8	c1 e8 16	 shr	 eax, 22			; 00000016H
  001eb	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  001ee	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN45@hlist:

; 369  : #if 0
; 370  :         ASSERT2(( ATOMIC(xval)
; 371  :            || ONSTACK(g.shared[BBoardStk],xval)
; 372  :            || ON(HeapStk,xval)), /* will fail with multiple engines */
; 373  :         xval);
; 374  : #endif
; 375  :         PUSH_LIST(xval);

  001f1	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _g+36
  001f7	83 c6 10	 add	 esi, 16			; 00000010H
  001fa	89 16		 mov	 DWORD PTR [esi], edx
  001fc	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  001ff	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _htable
  00205	83 c6 08	 add	 esi, 8
$LN24@hlist:

; 324  :   for(i=0; i<HMAX; i++)

  00208	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+24]
  0020c	40		 inc	 eax
  0020d	83 c5 0c	 add	 ebp, 12			; 0000000cH
  00210	89 44 24 14	 mov	 DWORD PTR _i$[esp+24], eax
  00214	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR _max+20
  0021a	0f 82 40 fe ff
	ff		 jb	 $LL43@hlist
  00220	5f		 pop	 edi
  00221	5d		 pop	 ebp
  00222	5b		 pop	 ebx
$LN23@hlist:

; 376  :       }
; 377  :   PUSH_NIL();

  00223	a1 20 00 00 00	 mov	 eax, DWORD PTR _g+32
  00228	89 06		 mov	 DWORD PTR [esi], eax
  0022a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0022d	5e		 pop	 esi

; 378  :   return H;
; 379  : }

  0022e	83 c4 08	 add	 esp, 8
  00231	c3		 ret	 0
_hlist	ENDP
_TEXT	ENDS
PUBLIC	_op_class
; Function compile flags: /Ogtpy
;	COMDAT _op_class
_TEXT	SEGMENT
_a$ = 8							; size = 4
_op_class PROC						; COMDAT

; 414  :    if(a==g.xfx||a==g.xfy||a==g.yfx) return g.infixop;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _a$[esp-4]
  00004	3b 05 4c 00 00
	00		 cmp	 eax, DWORD PTR _g+76
  0000a	74 3f		 je	 SHORT $LN5@op_class
  0000c	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR _g+80
  00012	74 37		 je	 SHORT $LN5@op_class
  00014	3b 05 54 00 00
	00		 cmp	 eax, DWORD PTR _g+84
  0001a	74 2f		 je	 SHORT $LN5@op_class

; 415  :    if(a==g.fx||a==g.fy) return g.prefixop;

  0001c	3b 05 3c 00 00
	00		 cmp	 eax, DWORD PTR _g+60
  00022	74 21		 je	 SHORT $LN3@op_class
  00024	3b 05 40 00 00
	00		 cmp	 eax, DWORD PTR _g+64
  0002a	74 19		 je	 SHORT $LN3@op_class

; 416  :    if(a==g.xf||a==g.yf) return g.postfixop;

  0002c	3b 05 44 00 00
	00		 cmp	 eax, DWORD PTR _g+68
  00032	74 0b		 je	 SHORT $LN1@op_class
  00034	3b 05 48 00 00
	00		 cmp	 eax, DWORD PTR _g+72
  0003a	74 03		 je	 SHORT $LN1@op_class

; 417  :    return 0;

  0003c	33 c0		 xor	 eax, eax

; 418  : }

  0003e	c3		 ret	 0
$LN1@op_class:

; 416  :    if(a==g.xf||a==g.yf) return g.postfixop;

  0003f	a1 60 00 00 00	 mov	 eax, DWORD PTR _g+96

; 418  : }

  00044	c3		 ret	 0
$LN3@op_class:

; 415  :    if(a==g.fx||a==g.fy) return g.prefixop;

  00045	a1 58 00 00 00	 mov	 eax, DWORD PTR _g+88

; 418  : }

  0004a	c3		 ret	 0
$LN5@op_class:

; 414  :    if(a==g.xfx||a==g.xfy||a==g.yfx) return g.infixop;

  0004b	a1 5c 00 00 00	 mov	 eax, DWORD PTR _g+92

; 418  : }

  00050	c3		 ret	 0
_op_class ENDP
_TEXT	ENDS
PUBLIC	_valid_op
; Function compile flags: /Ogtpy
;	COMDAT _valid_op
_TEXT	SEGMENT
_p$ = 8							; size = 4
_a$ = 12						; size = 4
_v$ = 16						; size = 4
_valid_op PROC						; COMDAT

; 422  :   if(
; 423  :       SYMCONST(p) && 
; 424  :       INTEGER(v) && ((i=OUTPUT_INT(v))>=0) && (i<=1200)
; 425  :     )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _p$[esp-4]
  00004	8b c8		 mov	 ecx, eax
  00006	83 e1 03	 and	 ecx, 3
  00009	80 f9 03	 cmp	 cl, 3
  0000c	75 2c		 jne	 SHORT $LN1@valid_op
  0000e	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00013	75 25		 jne	 SHORT $LN1@valid_op
  00015	8b 44 24 0c	 mov	 eax, DWORD PTR _v$[esp-4]
  00019	8b d0		 mov	 edx, eax
  0001b	22 d1		 and	 dl, cl
  0001d	80 fa 01	 cmp	 dl, 1
  00020	75 18		 jne	 SHORT $LN1@valid_op
  00022	c1 f8 02	 sar	 eax, 2
  00025	3d b0 04 00 00	 cmp	 eax, 1200		; 000004b0H
  0002a	77 0e		 ja	 SHORT $LN1@valid_op

; 426  :     return  op_class(a);

  0002c	8b 44 24 08	 mov	 eax, DWORD PTR _a$[esp-4]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _op_class
  00036	83 c4 04	 add	 esp, 4

; 428  : }

  00039	c3		 ret	 0
$LN1@valid_op:

; 427  :   return 0;

  0003a	33 c0		 xor	 eax, eax

; 428  : }

  0003c	c3		 ret	 0
_valid_op ENDP
_TEXT	ENDS
PUBLIC	_make_op
; Function compile flags: /Ogtpy
;	COMDAT _make_op
_TEXT	SEGMENT
_i$ = 8							; size = 4
_op$ = 8						; size = 4
_assoc$ = 12						; size = 4
_pri$ = 16						; size = 4
_stamp$ = 20						; size = 1
_make_op PROC						; COMDAT

; 433  : { bp_long i, found; cell cls;

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 434  :         if(!(cls=valid_op(op,assoc,pri))) return 0;

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _op$[esp+8]
  00007	8b c6		 mov	 eax, esi
  00009	83 e0 03	 and	 eax, 3
  0000c	57		 push	 edi
  0000d	3c 03		 cmp	 al, 3
  0000f	75 34		 jne	 SHORT $LN12@make_op
  00011	f7 c6 00 00 00
	ff		 test	 esi, -16777216		; ff000000H
  00017	75 2c		 jne	 SHORT $LN12@make_op
  00019	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pri$[esp+12]
  0001d	8b cb		 mov	 ecx, ebx
  0001f	22 c8		 and	 cl, al
  00021	80 f9 01	 cmp	 cl, 1
  00024	75 1f		 jne	 SHORT $LN12@make_op
  00026	8b c3		 mov	 eax, ebx
  00028	c1 f8 02	 sar	 eax, 2
  0002b	3d b0 04 00 00	 cmp	 eax, 1200		; 000004b0H
  00030	77 13		 ja	 SHORT $LN12@make_op
  00032	8b 6c 24 18	 mov	 ebp, DWORD PTR _assoc$[esp+12]
  00036	55		 push	 ebp
  00037	e8 00 00 00 00	 call	 _op_class
  0003c	8b f8		 mov	 edi, eax
  0003e	83 c4 04	 add	 esp, 4
  00041	85 ff		 test	 edi, edi
  00043	75 07		 jne	 SHORT $LN6@make_op
$LN12@make_op:
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	33 c0		 xor	 eax, eax
  0004a	5b		 pop	 ebx

; 463  : }

  0004b	c3		 ret	 0
$LN6@make_op:

; 435  : 
; 436  : 	found=hindex(op,cls,&i);

  0004c	8d 54 24 14	 lea	 edx, DWORD PTR _i$[esp+12]
  00050	52		 push	 edx
  00051	57		 push	 edi
  00052	56		 push	 esi
  00053	e8 00 00 00 00	 call	 _hindex
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 	if(FULL==found) return 0;

  0005b	83 f8 ff	 cmp	 eax, -1
  0005e	74 e5		 je	 SHORT $LN12@make_op

; 438  :         if(FOUND==found)

  00060	83 f8 01	 cmp	 eax, 1
  00063	75 26		 jne	 SHORT $LN4@make_op

; 439  :             {   htable[i].val=pri;

  00065	8b 44 24 14	 mov	 eax, DWORD PTR _i$[esp+12]
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable

; 440  :                 hset(cls,op,assoc);

  0006f	55		 push	 ebp
  00070	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00073	56		 push	 esi
  00074	57		 push	 edi
  00075	89 5c 81 08	 mov	 DWORD PTR [ecx+eax*4+8], ebx
  00079	e8 00 00 00 00	 call	 _hset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5d		 pop	 ebp

; 455  :                  }
; 456  : #if TRACE>2
; 457  : 	       fprintf(STD_err,
; 458  :                 "notfound(i) op=%s assoc=%s pri=%d i=%d, opcount=%d\n",
; 459  :                NAME(op),NAME(assoc),OUTPUT_INT(pri),i,opcount);
; 460  : #endif
; 461  : 	    }
; 462  : 	return 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
  00089	5b		 pop	 ebx

; 463  : }

  0008a	c3		 ret	 0
$LN4@make_op:

; 441  : #if TRACE>2
; 442  : 		fprintf(STD_err,
; 443  :                 "found op=%s assoc=%s pri=%d %d->?, opcount=%d\n",
; 444  :                 NAME(op),NAME(assoc),OUTPUT_INT(pri),i,opcount);
; 445  : #endif
; 446  : 	    }
; 447  :         else
; 448  : 	    {  cell k=INPUT_INT(opcount);
; 449  :                HPUT(i,op,cls,pri,stamp);

  0008b	a1 14 00 00 00	 mov	 eax, DWORD PTR _max+20
  00090	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _opcount
  00096	03 ed		 add	 ebp, ebp
  00098	8b d0		 mov	 edx, eax
  0009a	c1 ea 02	 shr	 edx, 2
  0009d	d1 e8		 shr	 eax, 1
  0009f	03 ed		 add	 ebp, ebp
  000a1	03 d0		 add	 edx, eax
  000a3	83 cd 01	 or	 ebp, 1
  000a6	39 15 00 00 00
	00		 cmp	 DWORD PTR _hcount, edx
  000ac	7e 0d		 jle	 SHORT $LN2@make_op
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@
  000b3	e8 00 00 00 00	 call	 _hfull
  000b8	83 c4 04	 add	 esp, 4
$LN2@make_op:
  000bb	8b 4c 24 14	 mov	 ecx, DWORD PTR _i$[esp+12]
  000bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  000c5	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000c8	03 c0		 add	 eax, eax
  000ca	03 c0		 add	 eax, eax
  000cc	89 34 10	 mov	 DWORD PTR [eax+edx], esi
  000cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  000d5	89 7c 10 04	 mov	 DWORD PTR [eax+edx+4], edi
  000d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  000df	89 5c 10 08	 mov	 DWORD PTR [eax+edx+8], ebx
  000e3	8b 5c 24 20	 mov	 ebx, DWORD PTR _stamp$[esp+12]
  000e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _hstamp
  000ec	ff 05 00 00 00
	00		 inc	 DWORD PTR _hcount
  000f2	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl

; 450  :                hdef(cls,op,assoc,stamp);

  000f5	8b 4c 24 18	 mov	 ecx, DWORD PTR _assoc$[esp+12]
  000f9	53		 push	 ebx
  000fa	51		 push	 ecx
  000fb	56		 push	 esi
  000fc	57		 push	 edi
  000fd	e8 00 00 00 00	 call	 _hdef

; 451  :                if(hdef(op,g.opmark,k,stamp))

  00102	8b 15 7c 00 00
	00		 mov	 edx, DWORD PTR _g+124
  00108	53		 push	 ebx
  00109	55		 push	 ebp
  0010a	52		 push	 edx
  0010b	56		 push	 esi
  0010c	e8 00 00 00 00	 call	 _hdef
  00111	83 c4 20	 add	 esp, 32			; 00000020H
  00114	85 c0		 test	 eax, eax
  00116	74 17		 je	 SHORT $LN13@make_op

; 452  :                  {
; 453  :                    hdef(g.opmark,k,op,stamp);

  00118	a1 7c 00 00 00	 mov	 eax, DWORD PTR _g+124
  0011d	53		 push	 ebx
  0011e	56		 push	 esi
  0011f	55		 push	 ebp
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _hdef
  00126	83 c4 10	 add	 esp, 16			; 00000010H

; 454  :                    opcount++;

  00129	ff 05 00 00 00
	00		 inc	 DWORD PTR _opcount
$LN13@make_op:

; 455  :                  }
; 456  : #if TRACE>2
; 457  : 	       fprintf(STD_err,
; 458  :                 "notfound(i) op=%s assoc=%s pri=%d i=%d, opcount=%d\n",
; 459  :                NAME(op),NAME(assoc),OUTPUT_INT(pri),i,opcount);
; 460  : #endif
; 461  : 	    }
; 462  : 	return 1;

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5d		 pop	 ebp
  00132	b8 01 00 00 00	 mov	 eax, 1
  00137	5b		 pop	 ebx

; 463  : }

  00138	c3		 ret	 0
_make_op ENDP
_TEXT	ENDS
PUBLIC	_op0
; Function compile flags: /Ogtpy
;	COMDAT _op0
_TEXT	SEGMENT
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_op0	PROC						; COMDAT

; 467  :   ATOMIZE(X(1)); ATOMIZE(X(2)); ATOMIZE(X(3));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _regs$[esp-4]
  00004	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00007	8b d1		 mov	 edx, ecx
  00009	83 e2 03	 and	 edx, 3
  0000c	74 0d		 je	 SHORT $LN5@op0
  0000e	83 fa 01	 cmp	 edx, 1
  00011	74 0d		 je	 SHORT $LN6@op0
  00013	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00019	74 05		 je	 SHORT $LN6@op0
$LN5@op0:
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN6@op0:
  00020	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00023	8b d1		 mov	 edx, ecx
  00025	83 e2 03	 and	 edx, 3
  00028	74 0d		 je	 SHORT $LN3@op0
  0002a	83 fa 01	 cmp	 edx, 1
  0002d	74 0d		 je	 SHORT $LN4@op0
  0002f	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00035	74 05		 je	 SHORT $LN4@op0
$LN3@op0:
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	89 50 f8	 mov	 DWORD PTR [eax-8], edx
$LN4@op0:
  0003c	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  0003f	8b d1		 mov	 edx, ecx
  00041	83 e2 03	 and	 edx, 3
  00044	74 0d		 je	 SHORT $LN1@op0
  00046	83 fa 01	 cmp	 edx, 1
  00049	74 0d		 je	 SHORT $LN2@op0
  0004b	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00051	74 05		 je	 SHORT $LN2@op0
$LN1@op0:
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
$LN2@op0:

; 468  :   return make_op(X(1),X(2),X(3),g.timestamp);

  00058	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  0005f	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  00062	52		 push	 edx
  00063	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00066	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00069	51		 push	 ecx
  0006a	52		 push	 edx
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _make_op
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 469  : }

  00074	c3		 ret	 0
_op0	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FHAAEEOJ@htable?5full?5in?5hash?5op?$AA@ ; `string'
PUBLIC	??_C@_0BM@JNLOEFCN@hash?5op?5on?5protected?5object?$AA@ ; `string'
PUBLIC	??_C@_0BN@PKHLKAEG@Stamp?5found?5?$CFd?0?5expected?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@PGGEBKLO@arg?52?5of?5hash?5op?5should?5be?5nonva@ ; `string'
PUBLIC	??_C@_0CC@LCMFDPKG@arg?51?5of?5hash?5op?5should?5be?5nonva@ ; `string'
PUBLIC	_lval
EXTRN	_local_error:PROC
;	COMDAT ??_C@_0BH@FHAAEEOJ@htable?5full?5in?5hash?5op?$AA@
CONST	SEGMENT
??_C@_0BH@FHAAEEOJ@htable?5full?5in?5hash?5op?$AA@ DB 'htable full in has'
	DB	'h op', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNLOEFCN@hash?5op?5on?5protected?5object?$AA@
CONST	SEGMENT
??_C@_0BM@JNLOEFCN@hash?5op?5on?5protected?5object?$AA@ DB 'hash op on pr'
	DB	'otected object', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PKHLKAEG@Stamp?5found?5?$CFd?0?5expected?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@PKHLKAEG@Stamp?5found?5?$CFd?0?5expected?5?$CFd?6?$AA@ DB 'Stam'
	DB	'p found %d, expected %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PGGEBKLO@arg?52?5of?5hash?5op?5should?5be?5nonva@
CONST	SEGMENT
??_C@_0CC@PGGEBKLO@arg?52?5of?5hash?5op?5should?5be?5nonva@ DB 'arg 2 of '
	DB	'hash op should be nonvar', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LCMFDPKG@arg?51?5of?5hash?5op?5should?5be?5nonva@
CONST	SEGMENT
??_C@_0CC@LCMFDPKG@arg?51?5of?5hash?5op?5should?5be?5nonva@ DB 'arg 1 of '
	DB	'hash op should be nonvar', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _lval
_TEXT	SEGMENT
_i$ = 8							; size = 4
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_stamp$ = 16						; size = 1
_lval	PROC						; COMDAT

; 476  : { bp_long i,found;

  00000	57		 push	 edi

; 477  :   SAFE_HASH_OP(stamp);

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR _regs$[esp]
  00005	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	83 e1 03	 and	 ecx, 3
  0000d	74 0c		 je	 SHORT $LN9@lval
  0000f	83 f9 01	 cmp	 ecx, 1
  00012	74 0c		 je	 SHORT $LN10@lval
  00014	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00019	74 05		 je	 SHORT $LN10@lval
$LN9@lval:
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 47 fc	 mov	 DWORD PTR [edi-4], eax
$LN10@lval:
  00020	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  00023	8b c8		 mov	 ecx, eax
  00025	83 e1 03	 and	 ecx, 3
  00028	74 0c		 je	 SHORT $LN7@lval
  0002a	83 f9 01	 cmp	 ecx, 1
  0002d	74 0c		 je	 SHORT $LN8@lval
  0002f	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00034	74 05		 je	 SHORT $LN8@lval
$LN7@lval:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 4f f8	 mov	 DWORD PTR [edi-8], ecx
$LN8@lval:
  0003b	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  0003e	f6 c1 03	 test	 cl, 3
  00041	75 11		 jne	 SHORT $LN6@lval
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LCMFDPKG@arg?51?5of?5hash?5op?5should?5be?5nonva@
  00048	e8 00 00 00 00	 call	 _warnmes
  0004d	83 c4 04	 add	 esp, 4
  00050	33 c0		 xor	 eax, eax
  00052	5f		 pop	 edi

; 482  : }

  00053	c3		 ret	 0
$LN6@lval:

; 477  :   SAFE_HASH_OP(stamp);

  00054	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  00057	a8 03		 test	 al, 3
  00059	75 11		 jne	 SHORT $LN5@lval
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PGGEBKLO@arg?52?5of?5hash?5op?5should?5be?5nonva@
  00060	e8 00 00 00 00	 call	 _warnmes
  00065	83 c4 04	 add	 esp, 4
  00068	33 c0		 xor	 eax, eax
  0006a	5f		 pop	 edi

; 482  : }

  0006b	c3		 ret	 0
$LN5@lval:
  0006c	56		 push	 esi

; 477  :   SAFE_HASH_OP(stamp);

  0006d	8d 54 24 0c	 lea	 edx, DWORD PTR _i$[esp+4]
  00071	52		 push	 edx
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 _hindex
  00079	8b 74 24 18	 mov	 esi, DWORD PTR _i$[esp+16]
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 63		 jne	 SHORT $LN4@lval
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _hstamp
  0008a	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  0008d	8a 4c 24 14	 mov	 cl, BYTE PTR _stamp$[esp+4]
  00091	3a c1		 cmp	 al, cl
  00093	0f 84 d3 00 00
	00		 je	 $LN13@lval
  00099	53		 push	 ebx
  0009a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _htable
  000a0	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  000a3	8b 54 93 08	 mov	 edx, DWORD PTR [ebx+edx*4+8]
  000a7	5b		 pop	 ebx
  000a8	3b 15 38 00 00
	00		 cmp	 edx, DWORD PTR _g+56
  000ae	0f 84 b8 00 00
	00		 je	 $LN13@lval
  000b4	0f b6 c0	 movzx	 eax, al
  000b7	0f b6 c9	 movzx	 ecx, cl
  000ba	50		 push	 eax
  000bb	51		 push	 ecx
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PKHLKAEG@Stamp?5found?5?$CFd?0?5expected?5?$CFd?6?$AA@
  000c1	e8 00 00 00 00	 call	 ___iob_func
  000c6	83 c0 40	 add	 eax, 64			; 00000040H
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _fprintf
  000cf	8b 54 24 20	 mov	 edx, DWORD PTR _wam$[esp+20]
  000d3	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  000d6	52		 push	 edx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JNLOEFCN@hash?5op?5on?5protected?5object?$AA@
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _local_error
  000e2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000e5	5e		 pop	 esi
  000e6	5f		 pop	 edi

; 482  : }

  000e7	c3		 ret	 0
$LN4@lval:

; 477  :   SAFE_HASH_OP(stamp);

  000e8	83 f8 ff	 cmp	 eax, -1
  000eb	75 19		 jne	 SHORT $LN3@lval
  000ed	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$[esp+4]
  000f1	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  000f4	51		 push	 ecx
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FHAAEEOJ@htable?5full?5in?5hash?5op?$AA@
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _local_error
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	5e		 pop	 esi
  00104	5f		 pop	 edi

; 482  : }

  00105	c3		 ret	 0
$LN3@lval:

; 478  : 	if(FREE==found ) {

  00106	85 c0		 test	 eax, eax
  00108	75 62		 jne	 SHORT $LN13@lval

; 479  :      HPUT(i,X(1),X(2),((cell)(&htable[i].val)),stamp);

  0010a	a1 14 00 00 00	 mov	 eax, DWORD PTR _max+20
  0010f	8b c8		 mov	 ecx, eax
  00111	c1 e9 02	 shr	 ecx, 2
  00114	d1 e8		 shr	 eax, 1
  00116	03 c8		 add	 ecx, eax
  00118	39 0d 00 00 00
	00		 cmp	 DWORD PTR _hcount, ecx
  0011e	7e 0d		 jle	 SHORT $LN1@lval
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@
  00125	e8 00 00 00 00	 call	 _hfull
  0012a	83 c4 04	 add	 esp, 4
$LN1@lval:
  0012d	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable
  00136	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00139	03 c0		 add	 eax, eax
  0013b	03 c0		 add	 eax, eax
  0013d	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
  00140	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  00143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable
  00149	89 54 08 04	 mov	 DWORD PTR [eax+ecx+4], edx
  0014d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  00153	8d 44 10 08	 lea	 eax, DWORD PTR [eax+edx+8]
  00157	89 00		 mov	 DWORD PTR [eax], eax
  00159	8a 44 24 14	 mov	 al, BYTE PTR _stamp$[esp+4]
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hstamp
  00163	ff 05 00 00 00
	00		 inc	 DWORD PTR _hcount
  00169	88 04 31	 mov	 BYTE PTR [ecx+esi], al
$LN13@lval:

; 480  : 	}
; 481  : 	return htable[i].val;

  0016c	a1 00 00 00 00	 mov	 eax, DWORD PTR _htable
  00171	8d 14 76	 lea	 edx, DWORD PTR [esi+esi*2]
  00174	8b 44 90 08	 mov	 eax, DWORD PTR [eax+edx*4+8]
  00178	5e		 pop	 esi
  00179	5f		 pop	 edi

; 482  : }

  0017a	c3		 ret	 0
_lval	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FANADJAP@unsafe?5data?5in?5def?13?5or?5set?13?$AA@ ; `string'
PUBLIC	_def
;	COMDAT ??_C@_0BO@FANADJAP@unsafe?5data?5in?5def?13?5or?5set?13?$AA@
CONST	SEGMENT
??_C@_0BO@FANADJAP@unsafe?5data?5in?5def?13?5or?5set?13?$AA@ DB 'unsafe d'
	DB	'ata in def/3 or set/3', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _def
_TEXT	SEGMENT
_xval$ = -4						; size = 4
_i$ = 8							; size = 4
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_stamp$ = 16						; size = 1
_def	PROC						; COMDAT

; 493  : { bp_long i,found; cell xval=X(3);

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	57		 push	 edi
  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _regs$[esp+8]

; 494  :   SAFE_HASH_OP(stamp);

  00007	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  0000a	8b 5f f4	 mov	 ebx, DWORD PTR [edi-12]
  0000d	8b c8		 mov	 ecx, eax
  0000f	83 e1 03	 and	 ecx, 3
  00012	89 5c 24 08	 mov	 DWORD PTR _xval$[esp+12], ebx
  00016	74 0c		 je	 SHORT $LN20@def
  00018	83 f9 01	 cmp	 ecx, 1
  0001b	74 0c		 je	 SHORT $LN21@def
  0001d	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00022	74 05		 je	 SHORT $LN21@def
$LN20@def:
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 47 fc	 mov	 DWORD PTR [edi-4], eax
$LN21@def:
  00029	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 e1 03	 and	 ecx, 3
  00031	74 0c		 je	 SHORT $LN23@def
  00033	83 f9 01	 cmp	 ecx, 1
  00036	74 0c		 je	 SHORT $LN13@def
  00038	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0003d	74 05		 je	 SHORT $LN13@def
$LN23@def:
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	89 4f f8	 mov	 DWORD PTR [edi-8], ecx
$LN13@def:
  00044	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  00047	f6 c1 03	 test	 cl, 3
  0004a	75 13		 jne	 SHORT $LN11@def
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LCMFDPKG@arg?51?5of?5hash?5op?5should?5be?5nonva@
  00051	e8 00 00 00 00	 call	 _warnmes
  00056	83 c4 04	 add	 esp, 4
  00059	5f		 pop	 edi
  0005a	33 c0		 xor	 eax, eax
  0005c	5b		 pop	 ebx

; 503  : }

  0005d	59		 pop	 ecx
  0005e	c3		 ret	 0
$LN11@def:

; 494  :   SAFE_HASH_OP(stamp);

  0005f	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  00062	a8 03		 test	 al, 3
  00064	75 13		 jne	 SHORT $LN10@def
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PGGEBKLO@arg?52?5of?5hash?5op?5should?5be?5nonva@
  0006b	e8 00 00 00 00	 call	 _warnmes
  00070	83 c4 04	 add	 esp, 4
  00073	5f		 pop	 edi
  00074	33 c0		 xor	 eax, eax
  00076	5b		 pop	 ebx

; 503  : }

  00077	59		 pop	 ecx
  00078	c3		 ret	 0
$LN10@def:
  00079	55		 push	 ebp
  0007a	56		 push	 esi

; 494  :   SAFE_HASH_OP(stamp);

  0007b	8d 54 24 18	 lea	 edx, DWORD PTR _i$[esp+16]
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 _hindex
  00087	8b 74 24 24	 mov	 esi, DWORD PTR _i$[esp+28]
  0008b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  00091	8b e8		 mov	 ebp, eax
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	83 fd 01	 cmp	 ebp, 1
  00099	75 55		 jne	 SHORT $LN9@def
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR _hstamp
  000a0	8a 0c 30	 mov	 cl, BYTE PTR [eax+esi]
  000a3	a1 38 00 00 00	 mov	 eax, DWORD PTR _g+56
  000a8	3a 4c 24 20	 cmp	 cl, BYTE PTR _stamp$[esp+16]
  000ac	74 67		 je	 SHORT $LN18@def
  000ae	8d 1c 76	 lea	 ebx, DWORD PTR [esi+esi*2]
  000b1	39 44 9a 08	 cmp	 DWORD PTR [edx+ebx*4+8], eax
  000b5	74 5a		 je	 SHORT $LN19@def
  000b7	0f b6 54 24 20	 movzx	 edx, BYTE PTR _stamp$[esp+16]
  000bc	0f b6 c9	 movzx	 ecx, cl
  000bf	51		 push	 ecx
  000c0	52		 push	 edx
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PKHLKAEG@Stamp?5found?5?$CFd?0?5expected?5?$CFd?6?$AA@
  000c6	e8 00 00 00 00	 call	 ___iob_func
  000cb	83 c0 40	 add	 eax, 64			; 00000040H
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _fprintf
  000d4	8b 44 24 2c	 mov	 eax, DWORD PTR _wam$[esp+32]
  000d8	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  000db	50		 push	 eax
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JNLOEFCN@hash?5op?5on?5protected?5object?$AA@
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 _local_error
  000e7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ea	5e		 pop	 esi
  000eb	5d		 pop	 ebp
  000ec	5f		 pop	 edi
  000ed	5b		 pop	 ebx

; 503  : }

  000ee	59		 pop	 ecx
  000ef	c3		 ret	 0
$LN9@def:

; 494  :   SAFE_HASH_OP(stamp);

  000f0	83 fd ff	 cmp	 ebp, -1
  000f3	75 31		 jne	 SHORT $LN7@def
  000f5	8b 54 24 1c	 mov	 edx, DWORD PTR _wam$[esp+16]
  000f9	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  000fc	52		 push	 edx
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FHAAEEOJ@htable?5full?5in?5hash?5op?$AA@
  00102	50		 push	 eax

; 497  :   BB_SAFE(xval);

  00103	e8 00 00 00 00	 call	 _local_error
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	5e		 pop	 esi
  0010c	5d		 pop	 ebp
  0010d	5f		 pop	 edi
  0010e	5b		 pop	 ebx

; 503  : }

  0010f	59		 pop	 ecx
  00110	c3		 ret	 0
$LN19@def:

; 494  :   SAFE_HASH_OP(stamp);

  00111	8b 5c 24 10	 mov	 ebx, DWORD PTR _xval$[esp+20]
$LN18@def:

; 495  :   if(FOUND==found && htable[i].val!=g.empty) 

  00115	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00118	39 44 8a 08	 cmp	 DWORD PTR [edx+ecx*4+8], eax
  0011c	74 08		 je	 SHORT $LN7@def

; 496  :     return 0;  

  0011e	5e		 pop	 esi
  0011f	5d		 pop	 ebp
  00120	5f		 pop	 edi
  00121	33 c0		 xor	 eax, eax
  00123	5b		 pop	 ebx

; 503  : }

  00124	59		 pop	 ecx
  00125	c3		 ret	 0
$LN7@def:

; 497  :   BB_SAFE(xval);

  00126	8b cb		 mov	 ecx, ebx
  00128	83 e1 03	 and	 ecx, 3
  0012b	74 0d		 je	 SHORT $LN22@def
  0012d	83 f9 01	 cmp	 ecx, 1
  00130	74 1c		 je	 SHORT $LN6@def
  00132	f7 c3 00 00 00
	ff		 test	 ebx, -16777216		; ff000000H
  00138	74 14		 je	 SHORT $LN6@def
$LN22@def:
  0013a	3b 1d a8 01 00
	00		 cmp	 ebx, DWORD PTR _g+424
  00140	0f 82 86 00 00
	00		 jb	 $LN4@def
  00146	3b 1d a0 01 00
	00		 cmp	 ebx, DWORD PTR _g+416
  0014c	73 7e		 jae	 SHORT $LN4@def
$LN6@def:

; 498  :   if(FOUND==found) 

  0014e	83 fd 01	 cmp	 ebp, 1
  00151	75 0f		 jne	 SHORT $LN3@def

; 499  : 	htable[i].val=xval;

  00153	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00156	5e		 pop	 esi
  00157	89 5c 82 08	 mov	 DWORD PTR [edx+eax*4+8], ebx

; 502  :   return 1;

  0015b	8b c5		 mov	 eax, ebp
  0015d	5d		 pop	 ebp
  0015e	5f		 pop	 edi
  0015f	5b		 pop	 ebx

; 503  : }

  00160	59		 pop	 ecx
  00161	c3		 ret	 0
$LN3@def:

; 500  :   else
; 501  :   	{HPUT(i,X(1),X(2),xval,stamp);}

  00162	a1 14 00 00 00	 mov	 eax, DWORD PTR _max+20
  00167	8b c8		 mov	 ecx, eax
  00169	c1 e9 02	 shr	 ecx, 2
  0016c	d1 e8		 shr	 eax, 1
  0016e	03 c8		 add	 ecx, eax
  00170	39 0d 00 00 00
	00		 cmp	 DWORD PTR _hcount, ecx
  00176	7e 13		 jle	 SHORT $LN1@def
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_05LPGKOOC@?$CI75?$CF?$CJ?$AA@
  0017d	e8 00 00 00 00	 call	 _hfull
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  00188	83 c4 04	 add	 esp, 4
$LN1@def:
  0018b	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
  0018e	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00191	03 c0		 add	 eax, eax
  00193	03 c0		 add	 eax, eax
  00195	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx
  00198	8b 57 f8	 mov	 edx, DWORD PTR [edi-8]
  0019b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable
  001a1	89 54 08 04	 mov	 DWORD PTR [eax+ecx+4], edx
  001a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _htable
  001ab	8a 4c 24 20	 mov	 cl, BYTE PTR _stamp$[esp+16]
  001af	89 5c 10 08	 mov	 DWORD PTR [eax+edx+8], ebx
  001b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _hstamp
  001b8	ff 05 00 00 00
	00		 inc	 DWORD PTR _hcount
  001be	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
  001c1	5e		 pop	 esi
  001c2	5d		 pop	 ebp
  001c3	5f		 pop	 edi

; 502  :   return 1;

  001c4	b8 01 00 00 00	 mov	 eax, 1
  001c9	5b		 pop	 ebx

; 503  : }

  001ca	59		 pop	 ecx
  001cb	c3		 ret	 0
$LN4@def:

; 497  :   BB_SAFE(xval);

  001cc	8b 54 24 1c	 mov	 edx, DWORD PTR _wam$[esp+16]
  001d0	52		 push	 edx
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FANADJAP@unsafe?5data?5in?5def?13?5or?5set?13?$AA@
  001d6	53		 push	 ebx
  001d7	e8 00 00 00 00	 call	 _local_error
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001df	5e		 pop	 esi
  001e0	5d		 pop	 ebp
  001e1	5f		 pop	 edi
  001e2	5b		 pop	 ebx

; 503  : }

  001e3	59		 pop	 ecx
  001e4	c3		 ret	 0
_def	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@DEFDAKJI@bad?5stamp?5or?5empty?5slot?5in?5set?13@ ; `string'
PUBLIC	??_C@_0CE@NLFKDJAM@def?13?5expected?5before?5set?13?5or?5r@ ; `string'
PUBLIC	_set
;	COMDAT ??_C@_0CJ@DEFDAKJI@bad?5stamp?5or?5empty?5slot?5in?5set?13@
CONST	SEGMENT
??_C@_0CJ@DEFDAKJI@bad?5stamp?5or?5empty?5slot?5in?5set?13@ DB 'bad stamp'
	DB	' or empty slot in set/3 or rm/2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NLFKDJAM@def?13?5expected?5before?5set?13?5or?5r@
CONST	SEGMENT
??_C@_0CE@NLFKDJAM@def?13?5expected?5before?5set?13?5or?5r@ DB 'def/3 exp'
	DB	'ected before set/3 or rm/2', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _set
_TEXT	SEGMENT
_i$ = 8							; size = 4
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_stamp$ = 16						; size = 1
_set	PROC						; COMDAT

; 506  : { bp_long i,found; cell xval=X(3);

  00000	56		 push	 esi
  00001	8b 74 24 08	 mov	 esi, DWORD PTR _regs$[esp]

; 507  :   ATOMIZE(X(1)); ATOMIZE(X(2));

  00005	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	83 e1 03	 and	 ecx, 3
  0000d	57		 push	 edi
  0000e	8b 7e f4	 mov	 edi, DWORD PTR [esi-12]
  00011	74 0c		 je	 SHORT $LN9@set
  00013	83 f9 01	 cmp	 ecx, 1
  00016	74 0c		 je	 SHORT $LN10@set
  00018	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0001d	74 05		 je	 SHORT $LN10@set
$LN9@set:
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 46 fc	 mov	 DWORD PTR [esi-4], eax
$LN10@set:
  00024	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00027	8b c8		 mov	 ecx, eax
  00029	83 e1 03	 and	 ecx, 3
  0002c	74 0c		 je	 SHORT $LN7@set
  0002e	83 f9 01	 cmp	 ecx, 1
  00031	74 0c		 je	 SHORT $LN8@set
  00033	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00038	74 05		 je	 SHORT $LN8@set
$LN7@set:
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	89 4e f8	 mov	 DWORD PTR [esi-8], ecx
$LN8@set:

; 508  :   found=hindex(X(1),X(2),&i);

  0003f	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00042	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00045	8d 54 24 0c	 lea	 edx, DWORD PTR _i$[esp+4]
  00049	52		 push	 edx
  0004a	50		 push	 eax
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 _hindex
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  :   if(FOUND!=found) 

  00054	83 f8 01	 cmp	 eax, 1
  00057	74 19		 je	 SHORT $LN6@set

; 510  :     return (no)local_error(X(1),
; 511  :      "def/3 expected before set/3 or rm/2",
; 512  :     wam);

  00059	8b 54 24 10	 mov	 edx, DWORD PTR _wam$[esp+4]
  0005d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00060	52		 push	 edx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NLFKDJAM@def?13?5expected?5before?5set?13?5or?5r@
  00066	50		 push	 eax

; 514  : #if 0
; 515  :     return 0;
; 516  : #else
; 517  :     return (no)local_error(X(1),
; 518  :      "bad stamp or empty slot in set/3 or rm/2",
; 519  :     wam);

  00067	e8 00 00 00 00	 call	 _local_error
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi

; 524  : }

  00071	c3		 ret	 0
$LN6@set:

; 513  :   if(hstamp[i]!=stamp || htable[i].val==g.empty) 

  00072	8b 44 24 0c	 mov	 eax, DWORD PTR _i$[esp+4]
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hstamp
  0007c	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0007f	3a 54 24 14	 cmp	 dl, BYTE PTR _stamp$[esp+4]
  00083	75 5d		 jne	 SHORT $LN4@set
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _htable
  0008b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0008e	8b 54 81 08	 mov	 edx, DWORD PTR [ecx+eax*4+8]
  00092	8d 4c 81 08	 lea	 ecx, DWORD PTR [ecx+eax*4+8]
  00096	3b 15 38 00 00
	00		 cmp	 edx, DWORD PTR _g+56
  0009c	74 44		 je	 SHORT $LN4@set

; 520  : #endif
; 521  :   BB_SAFE(xval);

  0009e	8b c7		 mov	 eax, edi
  000a0	83 e0 03	 and	 eax, 3
  000a3	74 0d		 je	 SHORT $LN2@set
  000a5	83 f8 01	 cmp	 eax, 1
  000a8	74 18		 je	 SHORT $LN3@set
  000aa	f7 c7 00 00 00
	ff		 test	 edi, -16777216		; ff000000H
  000b0	74 10		 je	 SHORT $LN3@set
$LN2@set:
  000b2	3b 3d a8 01 00
	00		 cmp	 edi, DWORD PTR _g+424
  000b8	72 12		 jb	 SHORT $LN1@set
  000ba	3b 3d a0 01 00
	00		 cmp	 edi, DWORD PTR _g+416
  000c0	73 0a		 jae	 SHORT $LN1@set
$LN3@set:

; 522  :   htable[i].val=xval;

  000c2	89 39		 mov	 DWORD PTR [ecx], edi
  000c4	5f		 pop	 edi

; 523  :   return 1;    

  000c5	b8 01 00 00 00	 mov	 eax, 1
  000ca	5e		 pop	 esi

; 524  : }

  000cb	c3		 ret	 0
$LN1@set:

; 520  : #endif
; 521  :   BB_SAFE(xval);

  000cc	8b 44 24 10	 mov	 eax, DWORD PTR _wam$[esp+4]
  000d0	50		 push	 eax
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FANADJAP@unsafe?5data?5in?5def?13?5or?5set?13?$AA@
  000d6	57		 push	 edi
  000d7	e8 00 00 00 00	 call	 _local_error
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi

; 524  : }

  000e1	c3		 ret	 0
$LN4@set:

; 514  : #if 0
; 515  :     return 0;
; 516  : #else
; 517  :     return (no)local_error(X(1),
; 518  :      "bad stamp or empty slot in set/3 or rm/2",
; 519  :     wam);

  000e2	8b 4c 24 10	 mov	 ecx, DWORD PTR _wam$[esp+4]
  000e6	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000e9	51		 push	 ecx
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DEFDAKJI@bad?5stamp?5or?5empty?5slot?5in?5set?13@
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 _local_error
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 524  : }

  000fa	c3		 ret	 0
_set	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@CEIMMBFB@unable?5to?5override?5with?5itself?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OMAODBLO@bad?5option?5in?5override?13?$AA@ ; `string'
PUBLIC	??_C@_0P@GIDPBEIK@value?5trailing?$AA@		; `string'
PUBLIC	??_C@_0DL@MEFBIODE@unable?5to?5override?0?5maybe?5used?5a@ ; `string'
PUBLIC	??_C@_0CJ@CCEMHDOM@arg?51?5of?5of?5override?13?5should?5be@ ; `string'
PUBLIC	??_C@_07MFOEFAAB@?$CK?$CK?$CK?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BP@OABFGBJK@override?5can?5break?5gc?5and?5bbgc?$AA@ ; `string'
PUBLIC	_override
EXTRN	_debugmes:PROC
;	COMDAT ??_C@_0BP@CEIMMBFB@unable?5to?5override?5with?5itself?$AA@
CONST	SEGMENT
??_C@_0BP@CEIMMBFB@unable?5to?5override?5with?5itself?$AA@ DB 'unable to '
	DB	'override with itself', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OMAODBLO@bad?5option?5in?5override?13?$AA@
CONST	SEGMENT
??_C@_0BJ@OMAODBLO@bad?5option?5in?5override?13?$AA@ DB 'bad option in ov'
	DB	'erride/3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
CONST	SEGMENT
??_C@_0P@GIDPBEIK@value?5trailing?$AA@ DB 'value trailing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MEFBIODE@unable?5to?5override?0?5maybe?5used?5a@
CONST	SEGMENT
??_C@_0DL@MEFBIODE@unable?5to?5override?0?5maybe?5used?5a@ DB 'unable to '
	DB	'override, maybe used as a first goal in a clause', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CCEMHDOM@arg?51?5of?5of?5override?13?5should?5be@
CONST	SEGMENT
??_C@_0CJ@CCEMHDOM@arg?51?5of?5of?5override?13?5should?5be@ DB 'arg 1 of '
	DB	'of override/3 should be integer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFOEFAAB@?$CK?$CK?$CK?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_07MFOEFAAB@?$CK?$CK?$CK?5?$CFs?6?$AA@ DB '*** %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OABFGBJK@override?5can?5break?5gc?5and?5bbgc?$AA@
CONST	SEGMENT
??_C@_0BP@OABFGBJK@override?5can?5break?5gc?5and?5bbgc?$AA@ DB 'override '
	DB	'can break gc and bbgc', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _override
_TEXT	SEGMENT
tv258 = -4						; size = 4
_fun$ = 8						; size = 4
_regs$ = 8						; size = 4
_wam$ = 12						; size = 4
_override PROC						; COMDAT

; 562  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 563  :   instr P,NewP; cell xval,fun;
; 564  :   debugmes("*** %s\n","override can break gc and bbgc");

  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OABFGBJK@override?5can?5break?5gc?5and?5bbgc?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_07MFOEFAAB@?$CK?$CK?$CK?5?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 _debugmes

; 565  : 
; 566  :   ATOMIZE(X(1));

  00011	8b 5c 24 14	 mov	 ebx, DWORD PTR _regs$[esp+12]
  00015	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  00018	8b c8		 mov	 ecx, eax
  0001a	83 c4 08	 add	 esp, 8
  0001d	83 e1 03	 and	 ecx, 3
  00020	74 0c		 je	 SHORT $LN24@override
  00022	83 f9 01	 cmp	 ecx, 1
  00025	74 0c		 je	 SHORT $LN27@override
  00027	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0002c	74 05		 je	 SHORT $LN27@override
$LN24@override:
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
$LN27@override:

; 567  :   if( !INTEGER(X(1)) ) 

  00033	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  00036	8b c8		 mov	 ecx, eax
  00038	80 e1 03	 and	 cl, 3
  0003b	89 44 24 04	 mov	 DWORD PTR tv258[esp+8], eax
  0003f	80 f9 01	 cmp	 cl, 1
  00042	74 18		 je	 SHORT $LN19@override

; 568  :     {
; 569  :      (void)LOCAL_ERR(X(1),
; 570  :      "arg 1 of of override/3 should be integer");

  00044	8b 54 24 10	 mov	 edx, DWORD PTR _wam$[esp+4]
  00048	52		 push	 edx
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CCEMHDOM@arg?51?5of?5of?5override?13?5should?5be@
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _local_error
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 571  :      return FALSE;

  00057	33 c0		 xor	 eax, eax
  00059	5b		 pop	 ebx

; 614  : }

  0005a	59		 pop	 ecx
  0005b	c3		 ret	 0
$LN19@override:

; 572  :     }
; 573  :   /* the one overriden */
; 574  :   PRED2ADR(X(2),P); /* X(2) ---> xval, containing the functor */

  0005c	8b 43 f8	 mov	 eax, DWORD PTR [ebx-8]
  0005f	8b c8		 mov	 ecx, eax
  00061	83 e1 03	 and	 ecx, 3
  00064	74 0c		 je	 SHORT $LN30@override
  00066	83 f9 01	 cmp	 ecx, 1
  00069	74 09		 je	 SHORT $LN31@override
  0006b	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00070	74 02		 je	 SHORT $LN31@override
$LN30@override:
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
$LN31@override:
  00074	55		 push	 ebp
  00075	8b 2d 68 00 00
	00		 mov	 ebp, DWORD PTR _g+104
  0007b	56		 push	 esi
  0007c	8b f0		 mov	 esi, eax
  0007e	81 e6 00 00 00
	ff		 and	 esi, -16777216		; ff000000H
  00084	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00089	81 c6 00 00 00
	01		 add	 esi, 16777216		; 01000000H
  0008f	57		 push	 edi
  00090	0b f0		 or	 esi, eax
  00092	56		 push	 esi
  00093	55		 push	 ebp
  00094	e8 00 00 00 00	 call	 _hget
  00099	8b f8		 mov	 edi, eax
  0009b	83 c4 08	 add	 esp, 8
  0009e	85 ff		 test	 edi, edi
  000a0	0f 84 9f 01 00
	00		 je	 $LN35@override

; 575  :   fun=xval;
; 576  :   if(IS_JCOMPRESSED(xval)) 

  000a6	a1 80 00 00 00	 mov	 eax, DWORD PTR _g+128
  000ab	56		 push	 esi
  000ac	50		 push	 eax
  000ad	89 74 24 20	 mov	 DWORD PTR _fun$[esp+24], esi
  000b1	e8 00 00 00 00	 call	 _hget
  000b6	83 c4 08	 add	 esp, 8
  000b9	39 05 80 00 00
	00		 cmp	 DWORD PTR _g+128, eax
  000bf	75 1b		 jne	 SHORT $LN15@override

; 577  :    {
; 578  :      (void)LOCAL_ERR(xval,
; 579  :      "unable to override, maybe used as a first goal in a clause");

  000c1	8b 4c 24 1c	 mov	 ecx, DWORD PTR _wam$[esp+16]
  000c5	51		 push	 ecx
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MEFBIODE@unable?5to?5override?0?5maybe?5used?5a@

; 606  :      }
; 607  :   }
; 608  :   else
; 609  :   {
; 610  :      (void)LOCAL_ERR(xval,"unable to override with itself");

  000cb	56		 push	 esi
  000cc	e8 00 00 00 00	 call	 _local_error
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp

; 611  :      return FALSE;

  000d7	33 c0		 xor	 eax, eax
  000d9	5b		 pop	 ebx

; 614  : }

  000da	59		 pop	 ecx
  000db	c3		 ret	 0
$LN15@override:

; 580  :      return FALSE;
; 581  :    }
; 582  :   /* the one which overrdes */
; 583  :   PRED2ADR(X(3),NewP);

  000dc	8b 43 f4	 mov	 eax, DWORD PTR [ebx-12]
  000df	8b c8		 mov	 ecx, eax
  000e1	83 e1 03	 and	 ecx, 3
  000e4	74 0c		 je	 SHORT $LN28@override
  000e6	83 f9 01	 cmp	 ecx, 1
  000e9	74 09		 je	 SHORT $LN29@override
  000eb	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  000f0	74 02		 je	 SHORT $LN29@override
$LN28@override:
  000f2	8b 00		 mov	 eax, DWORD PTR [eax]
$LN29@override:
  000f4	8b f0		 mov	 esi, eax
  000f6	81 e6 00 00 00
	ff		 and	 esi, -16777216		; ff000000H
  000fc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00101	81 c6 00 00 00
	01		 add	 esi, 16777216		; 01000000H
  00107	0b f0		 or	 esi, eax
  00109	56		 push	 esi
  0010a	55		 push	 ebp
  0010b	e8 00 00 00 00	 call	 _hget
  00110	8b d8		 mov	 ebx, eax
  00112	83 c4 08	 add	 esp, 8
  00115	85 db		 test	 ebx, ebx
  00117	0f 84 28 01 00
	00		 je	 $LN35@override

; 584  :   if(P!=NewP) 

  0011d	3b fb		 cmp	 edi, ebx
  0011f	0f 84 0d 01 00
	00		 je	 $LN11@override

; 585  :   {  bp_long ires=OUTPUT_INT(X(1));

  00125	8b 4c 24 10	 mov	 ecx, DWORD PTR tv258[esp+20]
  00129	8b c1		 mov	 eax, ecx
  0012b	c1 f8 02	 sar	 eax, 2

; 586  :      switch(ires)

  0012e	83 f8 03	 cmp	 eax, 3
  00131	0f 87 dd 00 00
	00		 ja	 $LN2@override
  00137	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN38@override[eax*4]
$LN8@override:

; 587  :      {
; 588  :        case 0: /* backtrackable: also flows to 1: */
; 589  :          VTRAIL_IT(P,GETREF(P));

  0013e	8b 74 24 1c	 mov	 esi, DWORD PTR _wam$[esp+16]
  00142	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00145	3b 46 38	 cmp	 eax, DWORD PTR [esi+56]
  00148	72 18		 jb	 SHORT $LN25@override
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  0014f	56		 push	 esi
  00150	6a 01		 push	 1
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 _overflow_by
  00158	6a 0e		 push	 14			; 0000000eH
  0015a	e8 00 00 00 00	 call	 _bp_halt
  0015f	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@override:
  00162	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  00165	8b 07		 mov	 eax, DWORD PTR [edi]
  00167	89 02		 mov	 DWORD PTR [edx], eax
  00169	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0016c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0016f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00172	bd 08 00 00 00	 mov	 ebp, 8
  00177	01 6e 2c	 add	 DWORD PTR [esi+44], ebp
  0017a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]

; 590  :          VTRAIL_IT(P+1,GETREF(P+1)); /* flows to next! */

  0017d	3b 46 38	 cmp	 eax, DWORD PTR [esi+56]
  00180	72 18		 jb	 SHORT $LN6@override
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GIDPBEIK@value?5trailing?$AA@
  00187	56		 push	 esi
  00188	6a 01		 push	 1
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _overflow_by
  00190	6a 0e		 push	 14			; 0000000eH
  00192	e8 00 00 00 00	 call	 _bp_halt
  00197	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@override:
  0019a	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0019d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001a0	89 08		 mov	 DWORD PTR [eax], ecx
  001a2	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  001a5	8d 57 05	 lea	 edx, DWORD PTR [edi+5]
  001a8	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001ab	01 6e 2c	 add	 DWORD PTR [esi+44], ebp
$LN26@override:

; 591  :        case 1: /* just do it, without backtracking */
; 592  :          SETOP(P,EXECUTE); /* insert jump to redefinition */

  001ae	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001b0	81 e1 11 fc ff
	ff		 and	 ecx, -1007		; fffffc11H
  001b6	83 c9 11	 or	 ecx, 17			; 00000011H

; 593  :          SETLABEL(P,NewP);

  001b9	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  001bc	89 0f		 mov	 DWORD PTR [edi], ecx
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp

; 612  :   }
; 613  :   return TRUE;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	5b		 pop	 ebx

; 614  : }

  001c7	59		 pop	 ecx
  001c8	c3		 ret	 0
$LN4@override:

; 594  :          break;
; 595  :        case 2: /* delete predicate, non-first calls will not reach it */
; 596  :                /* see: disable_static/1 */
; 597  :           HDELETE(g.predmark,fun);

  001c9	8b 54 24 18	 mov	 edx, DWORD PTR _fun$[esp+16]
  001cd	6a 00		 push	 0
  001cf	52		 push	 edx
  001d0	55		 push	 ebp
  001d1	e8 00 00 00 00	 call	 _hset

; 602  :           }
; 603  :        break;
; 604  :        default:         
; 605  :          (void)LOCAL_ERR(X(1),"bad option in override/3");

  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	5d		 pop	 ebp

; 612  :   }
; 613  :   return TRUE;

  001dc	b8 01 00 00 00	 mov	 eax, 1
  001e1	5b		 pop	 ebx

; 614  : }

  001e2	59		 pop	 ecx
  001e3	c3		 ret	 0
$LN3@override:

; 598  :        break;
; 599  :        case 3: /* replace non-first called P with NewP */
; 600  :           {
; 601  :             SETPRED(fun,(cell)NewP);

  001e4	8b 74 24 18	 mov	 esi, DWORD PTR _fun$[esp+16]
  001e8	53		 push	 ebx
  001e9	56		 push	 esi
  001ea	55		 push	 ebp
  001eb	e8 00 00 00 00	 call	 _hset
  001f0	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  001f7	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  001fd	50		 push	 eax
  001fe	56		 push	 esi
  001ff	51		 push	 ecx
  00200	53		 push	 ebx
  00201	e8 00 00 00 00	 call	 _hdef
  00206	83 c4 1c	 add	 esp, 28			; 0000001cH
  00209	5f		 pop	 edi
  0020a	5e		 pop	 esi
  0020b	5d		 pop	 ebp

; 612  :   }
; 613  :   return TRUE;

  0020c	b8 01 00 00 00	 mov	 eax, 1
  00211	5b		 pop	 ebx

; 614  : }

  00212	59		 pop	 ecx
  00213	c3		 ret	 0
$LN2@override:

; 602  :           }
; 603  :        break;
; 604  :        default:         
; 605  :          (void)LOCAL_ERR(X(1),"bad option in override/3");

  00214	8b 54 24 1c	 mov	 edx, DWORD PTR _wam$[esp+16]
  00218	52		 push	 edx
  00219	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OMAODBLO@bad?5option?5in?5override?13?$AA@
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 _local_error
  00224	83 c4 0c	 add	 esp, 12			; 0000000cH
  00227	5f		 pop	 edi
  00228	5e		 pop	 esi
  00229	5d		 pop	 ebp

; 612  :   }
; 613  :   return TRUE;

  0022a	b8 01 00 00 00	 mov	 eax, 1
  0022f	5b		 pop	 ebx

; 614  : }

  00230	59		 pop	 ecx
  00231	c3		 ret	 0
$LN11@override:

; 606  :      }
; 607  :   }
; 608  :   else
; 609  :   {
; 610  :      (void)LOCAL_ERR(xval,"unable to override with itself");

  00232	8b 44 24 1c	 mov	 eax, DWORD PTR _wam$[esp+16]
  00236	50		 push	 eax
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@CEIMMBFB@unable?5to?5override?5with?5itself?$AA@
  0023c	56		 push	 esi
  0023d	e8 00 00 00 00	 call	 _local_error
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@override:

; 611  :      return FALSE;

  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	5d		 pop	 ebp
  00248	33 c0		 xor	 eax, eax
  0024a	5b		 pop	 ebx

; 614  : }

  0024b	59		 pop	 ecx
  0024c	c3		 ret	 0
  0024d	8d 49 00	 npad	 3
$LN38@override:
  00250	00 00 00 00	 DD	 $LN8@override
  00254	00 00 00 00	 DD	 $LN26@override
  00258	00 00 00 00	 DD	 $LN4@override
  0025c	00 00 00 00	 DD	 $LN3@override
_override ENDP
_TEXT	ENDS
END
