; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\socket.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?done@?1??init_winsock@@9@9 DD 01H DUP (?)		; `init_winsock'::`2'::done
?state@?1??get_host@@9@9 DD 01H DUP (?)			; `get_host'::`2'::state
?state@?1??get_ip_addr@@9@9 DD 01H DUP (?)		; `get_ip_addr'::`2'::state
_BSS	ENDS
_DATA	SEGMENT
_eol	DB	0dH
	DB	0aH
	DB	00H
_DATA	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_max:BYTE
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
; File c:\a17\prolog\ptarau_prolog\src\socket.c
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _io_trace1
_TEXT	SEGMENT
_io_trace1 PROC						; COMDAT
; _mes$ = eax

; 61   :   TRACE_BELOW(0)

  00000	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000a	7f 17		 jg	 SHORT $LN1@io_trace1

; 62   :   fprintf(STD_err,"%s\n",mes);

  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00012	e8 00 00 00 00	 call	 ___iob_func
  00017	83 c0 40	 add	 eax, 64			; 00000040H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _fprintf
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@io_trace1:

; 63   : }

  00023	c3		 ret	 0
_io_trace1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@		; `string'
;	COMDAT ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
CONST	SEGMENT
??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@ DB '%s: %ld', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _io_trace_sn
_TEXT	SEGMENT
_io_trace_sn PROC					; COMDAT
; _mes$ = ecx
; _n$ = eax

; 66   :   TRACE_BELOW(0)

  00000	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000a	7f 18		 jg	 SHORT $LN1@io_trace_s

; 67   :   fprintf(STD_err,"%s: %ld\n",mes,(long)n);

  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  00013	e8 00 00 00 00	 call	 ___iob_func
  00018	83 c0 40	 add	 eax, 64			; 00000040H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _fprintf
  00021	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@io_trace_s:

; 68   : }

  00024	c3		 ret	 0
_io_trace_sn ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@ ; `string'
;	COMDAT ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@ DB '%s: %ld, %ld', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _io_trace_snn
_TEXT	SEGMENT
_io_trace_snn PROC					; COMDAT
; _mes$ = edx
; _n$ = ecx
; _m$ = eax

; 71   :   TRACE_BELOW(0)

  00000	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000a	7f 19		 jg	 SHORT $LN1@io_trace_s@2

; 72   :   fprintf(STD_err,"%s: %ld, %ld\n",mes,(long)n,(long)m);

  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  00014	e8 00 00 00 00	 call	 ___iob_func
  00019	83 c0 40	 add	 eax, 64			; 00000040H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _fprintf
  00022	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@io_trace_s@2:

; 73   : }

  00025	c3		 ret	 0
_io_trace_snn ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@		; `string'
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@ DB '%s: %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _io_trace_ss
_TEXT	SEGMENT
_io_trace_ss PROC					; COMDAT
; _mes$ = ecx
; _val$ = eax

; 76   :   TRACE_BELOW(0)

  00000	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000a	7f 18		 jg	 SHORT $LN1@io_trace_s@3

; 77   :   fprintf(STD_err,"%s: %s\n",mes,val);

  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00013	e8 00 00 00 00	 call	 ___iob_func
  00018	83 c0 40	 add	 eax, 64			; 00000040H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _fprintf
  00021	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@io_trace_s@3:

; 78   : }

  00024	c3		 ret	 0
_io_trace_ss ENDP
_TEXT	ENDS
EXTRN	_perror:PROC
; Function compile flags: /Ogtpy
;	COMDAT _perror0
_TEXT	SEGMENT
_perror0 PROC						; COMDAT
; _mes$ = ecx

; 81   :   TRACE_BELOW(1)

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00005	83 e0 fc	 and	 eax, -4			; fffffffcH
  00008	83 f8 04	 cmp	 eax, 4
  0000b	7f 07		 jg	 SHORT $LN1@perror0

; 82   :   perror(mes);

  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _perror
  00013	59		 pop	 ecx
$LN1@perror0:

; 83   : }

  00014	c3		 ret	 0
_perror0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
EXTRN	_printf:PROC
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _io_mes0
_TEXT	SEGMENT
_io_mes0 PROC						; COMDAT
; _mes$ = ecx

; 86   :   TRACE_BELOW(2)

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00005	83 e0 fc	 and	 eax, -4			; fffffffcH
  00008	83 f8 08	 cmp	 eax, 8
  0000b	7f 0e		 jg	 SHORT $LN1@io_mes0

; 87   :   printf("%s",mes);

  0000d	51		 push	 ecx
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00013	e8 00 00 00 00	 call	 _printf
  00018	83 c4 08	 add	 esp, 8
$LN1@io_mes0:

; 88   : }

  0001b	c3		 ret	 0
_io_mes0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@JBALDMDD@closing?5socket?$AA@		; `string'
PUBLIC	_close_socket
EXTRN	_closesocket@4:PROC
;	COMDAT ??_C@_0P@JBALDMDD@closing?5socket?$AA@
CONST	SEGMENT
??_C@_0P@JBALDMDD@closing?5socket?$AA@ DB 'closing socket', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _close_socket
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_close_socket PROC					; COMDAT

; 131  :   io_trace_sn("closing socket",sock);

  00000	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000a	56		 push	 esi
  0000b	8b 74 24 08	 mov	 esi, DWORD PTR _sock$[esp]
  0000f	7f 1c		 jg	 SHORT $LN3@close_sock
  00011	56		 push	 esi
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JBALDMDD@closing?5socket?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  0001c	e8 00 00 00 00	 call	 ___iob_func
  00021	83 c0 40	 add	 eax, 64			; 00000040H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _fprintf
  0002a	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@close_sock:

; 132  :   return closesocket(sock);

  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 _closesocket@4
  00033	5e		 pop	 esi

; 133  : }

  00034	c3		 ret	 0
_close_socket ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_init_winsock
EXTRN	_WSAStartup@8:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _init_winsock
_TEXT	SEGMENT
_wsadata$81614 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_init_winsock PROC					; COMDAT

; 138  : void init_winsock() {

  00000	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 90 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+404], eax

; 139  :   static bp_long done=0;
; 140  :   if(!done) {

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?done@?1??init_winsock@@9@9, 0
  0001b	75 18		 jne	 SHORT $LN1@init_winso

; 141  :     WSADATA            wsadata;
; 142  :     WSAStartup(0x0101,&wsadata);

  0001d	8d 04 24	 lea	 eax, DWORD PTR _wsadata$81614[esp+404]
  00020	50		 push	 eax
  00021	68 01 01 00 00	 push	 257			; 00000101H
  00026	e8 00 00 00 00	 call	 _WSAStartup@8

; 143  :     done=1;

  0002b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?done@?1??init_winsock@@9@9, 1
$LN1@init_winso:

; 144  :   }
; 145  : }

  00035	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  0003c	33 cc		 xor	 ecx, esp
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00049	c3		 ret	 0
_init_winsock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@GJJIIBPI@host?5not?5found?5by?5gethostname?$CI?$CJ?0@ ; `string'
PUBLIC	??_C@_09IPAEKDAI@localhost?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_get_host
EXTRN	_gethostname@8:PROC
_BSS	SEGMENT
?host_name@?1??get_host@@9@9 DB 0100H DUP (?)		; `get_host'::`2'::host_name
_BSS	ENDS
;	COMDAT ??_C@_0DD@GJJIIBPI@host?5not?5found?5by?5gethostname?$CI?$CJ?0@
CONST	SEGMENT
??_C@_0DD@GJJIIBPI@host?5not?5found?5by?5gethostname?$CI?$CJ?0@ DB 'host '
	DB	'not found by gethostname(), localhost assumed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost?$AA@
CONST	SEGMENT
??_C@_09IPAEKDAI@localhost?$AA@ DB 'localhost', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _get_host
_TEXT	SEGMENT
_wsadata$82131 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_get_host PROC						; COMDAT

; 176  : char *get_host() {

  00000	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 90 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+404], eax

; 177  :   static bp_long state=0; bp_long ok;
; 178  :   static char host_name[MAXHOSTNAMELEN];
; 179  :   if(0==state) {

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?state@?1??get_host@@9@9, 0
  0001b	75 7d		 jne	 SHORT $LN13@get_host

; 180  :     state=1;
; 181  : 	INIT_WINSOCK();

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?done@?1??init_winsock@@9@9, 0
  00024	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?state@?1??get_host@@9@9, 1
  0002e	75 18		 jne	 SHORT $LN5@get_host
  00030	8d 04 24	 lea	 eax, DWORD PTR _wsadata$82131[esp+404]
  00033	50		 push	 eax
  00034	68 01 01 00 00	 push	 257			; 00000101H
  00039	e8 00 00 00 00	 call	 _WSAStartup@8
  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?done@?1??init_winsock@@9@9, 1
$LN5@get_host:

; 182  :     ok=gethostname(host_name,MAXHOSTNAMELEN);

  00048	68 00 01 00 00	 push	 256			; 00000100H
  0004d	68 00 00 00 00	 push	 OFFSET ?host_name@?1??get_host@@9@9
  00052	e8 00 00 00 00	 call	 _gethostname@8

; 183  :     if(ok<0) {strcpy(host_name,"localhost");

  00057	85 c0		 test	 eax, eax
  00059	79 3f		 jns	 SHORT $LN13@get_host
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_09IPAEKDAI@localhost?$AA@
  00061	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ??_C@_09IPAEKDAI@localhost?$AA@+4
  00067	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_09IPAEKDAI@localhost?$AA@+8
  0006d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?host_name@?1??get_host@@9@9, ecx

; 184  :       perror0("host not found by gethostname(), localhost assumed");

  00073	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  00079	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0007c	89 15 04 00 00
	00		 mov	 DWORD PTR ?host_name@?1??get_host@@9@9+4, edx
  00082	66 a3 08 00 00
	00		 mov	 WORD PTR ?host_name@?1??get_host@@9@9+8, ax
  00088	83 f9 04	 cmp	 ecx, 4
  0008b	7f 0d		 jg	 SHORT $LN13@get_host
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GJJIIBPI@host?5not?5found?5by?5gethostname?$CI?$CJ?0@
  00092	e8 00 00 00 00	 call	 _perror
  00097	83 c4 04	 add	 esp, 4
$LN13@get_host:

; 185  :     }
; 186  :   }
; 187  :   return host_name;
; 188  : }

  0009a	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  000a1	33 cc		 xor	 ecx, esp
  000a3	b8 00 00 00 00	 mov	 eax, OFFSET ?host_name@?1??get_host@@9@9
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  000b3	c3		 ret	 0
_get_host ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41?$AA@		; `string'
PUBLIC	??_C@_0CF@INNLAJEE@ip?5addr?5not?5found?0?5127?40?40?41?5ass@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_host2ip
EXTRN	_inet_ntoa@4:PROC
EXTRN	_gethostbyname@4:PROC
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41?$AA@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41?$AA@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@INNLAJEE@ip?5addr?5not?5found?0?5127?40?40?41?5ass@
CONST	SEGMENT
??_C@_0CF@INNLAJEE@ip?5addr?5not?5found?0?5127?40?40?41?5ass@ DB 'ip addr'
	DB	' not found, 127.0.0.1 assumed', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _host2ip
_TEXT	SEGMENT
_wsadata$82148 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_hostname$ = 8						; size = 4
_host2ip PROC						; COMDAT

; 191  : char *host2ip(char *hostname) {

  00000	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 90 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+404], eax

; 192  :   char *ip_addr;
; 193  :   struct hostent *hostptr;
; 194  :   struct in_addr *hostnameptr;
; 195  :   INIT_WINSOCK();

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?done@?1??init_winsock@@9@9, 0
  0001b	56		 push	 esi
  0001c	8b b4 24 9c 01
	00 00		 mov	 esi, DWORD PTR _hostname$[esp+404]
  00023	75 19		 jne	 SHORT $LN5@host2ip
  00025	8d 44 24 04	 lea	 eax, DWORD PTR _wsadata$82148[esp+408]
  00029	50		 push	 eax
  0002a	68 01 01 00 00	 push	 257			; 00000101H
  0002f	e8 00 00 00 00	 call	 _WSAStartup@8
  00034	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?done@?1??init_winsock@@9@9, 1
$LN5@host2ip:

; 196  :   hostptr = gethostbyname(hostname);

  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 _gethostbyname@4
  00044	5e		 pop	 esi

; 197  :   if(NULL==hostptr) {

  00045	85 c0		 test	 eax, eax
  00047	75 35		 jne	 SHORT $LN2@host2ip

; 198  :       perror0("ip addr not found, 127.0.0.1 assumed");

  00049	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  0004f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00052	83 f9 04	 cmp	 ecx, 4
  00055	7f 0d		 jg	 SHORT $LN8@host2ip
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@INNLAJEE@ip?5addr?5not?5found?0?5127?40?40?41?5ass@
  0005c	e8 00 00 00 00	 call	 _perror
  00061	83 c4 04	 add	 esp, 4
$LN8@host2ip:

; 199  :       ip_addr="127.0.0.1";

  00064	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09PFCHIMEP@127?40?40?41?$AA@

; 204  :   }
; 205  :   return ip_addr;
; 206  : }

  00069	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00070	33 cc		 xor	 ecx, esp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  0007d	c3		 ret	 0
$LN2@host2ip:

; 200  :   }
; 201  :   else {
; 202  :      hostnameptr = (struct in_addr *) hostptr->h_addr_list[0];

  0007e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00081	8b 02		 mov	 eax, DWORD PTR [edx]

; 203  :      ip_addr=inet_ntoa(*hostnameptr);

  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _inet_ntoa@4

; 204  :   }
; 205  :   return ip_addr;
; 206  : }

  0008b	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00092	33 cc		 xor	 ecx, esp
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  0009f	c3		 ret	 0
_host2ip ENDP
_TEXT	ENDS
PUBLIC	_get_ip_addr
_BSS	SEGMENT
?ip_addr@?1??get_ip_addr@@9@9 DB 0100H DUP (?)		; `get_ip_addr'::`2'::ip_addr
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _get_ip_addr
_TEXT	SEGMENT
_get_ip_addr PROC					; COMDAT

; 209  :   static bp_long state=0;
; 210  :   static char ip_addr[MAXHOSTNAMELEN];
; 211  : 
; 212  :   if(0==state) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?state@?1??get_ip_addr@@9@9, 0
  00007	75 2b		 jne	 SHORT $LN6@get_ip_add

; 213  :     strcpy(ip_addr,host2ip(get_host()));

  00009	e8 00 00 00 00	 call	 _get_host
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _host2ip
  00014	ba 00 00 00 00	 mov	 edx, OFFSET ?ip_addr@?1??get_ip_addr@@9@9
  00019	83 c4 04	 add	 esp, 4
  0001c	2b d0		 sub	 edx, eax
  0001e	8b ff		 npad	 2
$LL4@get_ip_add:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00025	40		 inc	 eax
  00026	84 c9		 test	 cl, cl
  00028	75 f6		 jne	 SHORT $LL4@get_ip_add

; 214  :     state=1;

  0002a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?state@?1??get_ip_addr@@9@9, 1
$LN6@get_ip_add:

; 215  :   }
; 216  : 
; 217  :   return ip_addr;

  00034	b8 00 00 00 00	 mov	 eax, OFFSET ?ip_addr@?1??get_ip_addr@@9@9

; 218  : }

  00039	c3		 ret	 0
_get_ip_addr ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_peer_addr
EXTRN	_getpeername@12:PROC
_BSS	SEGMENT
?peer_addr@?1??0@@9@9 DB 0100H DUP (?)			; `peer_addr'::`2'::peer_addr
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _peer_addr
_TEXT	SEGMENT
_namelen$ = -24						; size = 4
_sa$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_socket$ = 8						; size = 4
_peer_addr PROC						; COMDAT

; 220  : char *peer_addr(bp_long socket) {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax

; 221  :   static char peer_addr[MAXHOSTNAMELEN];
; 222  :   struct sockaddr_in sa; unsigned int namelen;
; 223  :   namelen = sizeof (sa);
; 224  :   if (0!=getpeername(socket, (struct sockaddr *)&sa, &namelen))

  0000e	8b 54 24 1c	 mov	 edx, DWORD PTR _socket$[esp+20]
  00012	8d 04 24	 lea	 eax, DWORD PTR _namelen$[esp+24]
  00015	50		 push	 eax
  00016	8d 4c 24 08	 lea	 ecx, DWORD PTR _sa$[esp+28]
  0001a	51		 push	 ecx
  0001b	52		 push	 edx
  0001c	c7 44 24 0c 10
	00 00 00	 mov	 DWORD PTR _namelen$[esp+36], 16 ; 00000010H
  00024	e8 00 00 00 00	 call	 _getpeername@12
  00029	85 c0		 test	 eax, eax
  0002b	74 11		 je	 SHORT $LN1@peer_addr

; 225  :     return NULL;

  0002d	33 c0		 xor	 eax, eax

; 227  :   return peer_addr;
; 228  : }

  0002f	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00033	33 cc		 xor	 ecx, esp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	83 c4 18	 add	 esp, 24			; 00000018H
  0003d	c3		 ret	 0
$LN1@peer_addr:

; 226  :   strcpy(peer_addr, inet_ntoa(sa.sin_addr));

  0003e	8b 44 24 08	 mov	 eax, DWORD PTR _sa$[esp+28]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _inet_ntoa@4
  00048	ba 00 00 00 00	 mov	 edx, OFFSET ?peer_addr@?1??0@@9@9
  0004d	2b d0		 sub	 edx, eax
  0004f	90		 npad	 1
$LL4@peer_addr:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00055	40		 inc	 eax
  00056	84 c9		 test	 cl, cl
  00058	75 f6		 jne	 SHORT $LL4@peer_addr

; 227  :   return peer_addr;
; 228  : }

  0005a	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  0005e	33 cc		 xor	 ecx, esp
  00060	b8 00 00 00 00	 mov	 eax, OFFSET ?peer_addr@?1??0@@9@9
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	83 c4 18	 add	 esp, 24			; 00000018H
  0006d	c3		 ret	 0
_peer_addr ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_peer_port
EXTRN	_ntohs@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _peer_port
_TEXT	SEGMENT
_namelen$ = -24						; size = 4
_sa$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_socket$ = 8						; size = 4
_peer_port PROC						; COMDAT

; 230  : bp_long peer_port(bp_long socket) {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax

; 231  :   struct sockaddr_in sa; unsigned int namelen; bp_long res;
; 232  :   namelen = sizeof (sa);
; 233  :   if (0!=getpeername(socket, (struct sockaddr *)&sa, &namelen))

  0000e	8b 54 24 1c	 mov	 edx, DWORD PTR _socket$[esp+20]
  00012	8d 04 24	 lea	 eax, DWORD PTR _namelen$[esp+24]
  00015	50		 push	 eax
  00016	8d 4c 24 08	 lea	 ecx, DWORD PTR _sa$[esp+28]
  0001a	51		 push	 ecx
  0001b	52		 push	 edx
  0001c	c7 44 24 0c 10
	00 00 00	 mov	 DWORD PTR _namelen$[esp+36], 16 ; 00000010H
  00024	e8 00 00 00 00	 call	 _getpeername@12
  00029	85 c0		 test	 eax, eax
  0002b	74 12		 je	 SHORT $LN1@peer_port

; 234  :     return -1;

  0002d	83 c8 ff	 or	 eax, -1

; 236  :   /*fprintf(STD_err,"!!!RES:%d\n",res);*/
; 237  :   return res;
; 238  : }

  00030	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00034	33 cc		 xor	 ecx, esp
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	83 c4 18	 add	 esp, 24			; 00000018H
  0003e	c3		 ret	 0
$LN1@peer_port:

; 235  :   res=ntohs(sa.sin_port);

  0003f	8b 44 24 06	 mov	 eax, DWORD PTR _sa$[esp+26]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _ntohs@4

; 236  :   /*fprintf(STD_err,"!!!RES:%d\n",res);*/
; 237  :   return res;
; 238  : }

  00049	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  0004d	33 cc		 xor	 ecx, esp
  0004f	0f b7 c0	 movzx	 eax, ax
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	c3		 ret	 0
_peer_port ENDP
_TEXT	ENDS
EXTRN	_recv@16:PROC
; Function compile flags: /Ogtpy
;	COMDAT _sock_gets
_TEXT	SEGMENT
_last_read$ = -1					; size = 1
_sockfd$ = 8						; size = 4
_str$ = 12						; size = 4
_sock_gets PROC						; COMDAT
; _count$ = ebx

; 271  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _sockfd$[esp+4]

; 274  :   char last_read = (char)-1;

  00006	0c ff		 or	 al, -1
  00008	56		 push	 esi
  00009	8b 74 24 14	 mov	 esi, DWORD PTR _str$[esp+8]
  0000d	57		 push	 edi
  0000e	88 44 24 0f	 mov	 BYTE PTR _last_read$[esp+16], al

; 275  : 
; 276  :   while (!AT_EOL(last_read)) {

  00012	38 05 01 00 00
	00		 cmp	 BYTE PTR _eol+1, al
  00018	74 45		 je	 SHORT $LN13@sock_gets

; 272  :   bp_long bytes_read;
; 273  :   char *current_position = str;

  0001a	33 ff		 xor	 edi, edi
  0001c	8d 64 24 00	 npad	 4
$LL6@sock_gets:

; 275  : 
; 276  :   while (!AT_EOL(last_read)) {

  00020	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR _eol+2
  00026	74 37		 je	 SHORT $LN13@sock_gets

; 277  : #if 0
; 278  :     fprintf(STD_err,"sock_gets:last_read>>%d<<\n",last_read);
; 279  : #endif
; 280  : #if VCC>0
; 281  :     bytes_read = recv(sockfd, &last_read, 1, 0);

  00028	6a 00		 push	 0
  0002a	6a 01		 push	 1
  0002c	8d 44 24 17	 lea	 eax, DWORD PTR _last_read$[esp+24]
  00030	50		 push	 eax
  00031	55		 push	 ebp
  00032	e8 00 00 00 00	 call	 _recv@16

; 282  : #else
; 283  :     bytes_read = read(sockfd, &last_read, 1);
; 284  : #endif
; 285  :     if (bytes_read <= 0) {

  00037	85 c0		 test	 eax, eax
  00039	7e 4b		 jle	 SHORT $LN10@sock_gets

; 288  :     }
; 289  :     if ( (current_position-str < (bp_long)count) && !AT_EOL(last_read)) {

  0003b	8a 44 24 0f	 mov	 al, BYTE PTR _last_read$[esp+16]
  0003f	3b fb		 cmp	 edi, ebx
  00041	7d 14		 jge	 SHORT $LN12@sock_gets
  00043	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR _eol+1
  00049	74 14		 je	 SHORT $LN13@sock_gets
  0004b	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR _eol+2
  00051	74 04		 je	 SHORT $LN12@sock_gets

; 290  :       *current_position = last_read;

  00053	88 06		 mov	 BYTE PTR [esi], al

; 291  :       current_position++;

  00055	46		 inc	 esi
  00056	47		 inc	 edi
$LN12@sock_gets:

; 275  : 
; 276  :   while (!AT_EOL(last_read)) {

  00057	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR _eol+1
  0005d	75 c1		 jne	 SHORT $LL6@sock_gets
$LN13@sock_gets:

; 292  :     }
; 293  :   }
; 294  :   /* cleans up possible end of line chars */
; 295  :   if (count > 0) {

  0005f	85 db		 test	 ebx, ebx
  00061	74 03		 je	 SHORT $LN2@sock_gets

; 296  :     *current_position = 0;

  00063	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN2@sock_gets:

; 297  :   }
; 298  :   if(current_position>str && *(current_position-1)==eol[0]) {

  00066	8b 4c 24 18	 mov	 ecx, DWORD PTR _str$[esp+12]
  0006a	3b f1		 cmp	 esi, ecx
  0006c	76 0f		 jbe	 SHORT $LN1@sock_gets
  0006e	8a 56 ff	 mov	 dl, BYTE PTR [esi-1]
  00071	3a 15 00 00 00
	00		 cmp	 dl, BYTE PTR _eol
  00077	75 04		 jne	 SHORT $LN1@sock_gets

; 299  : 	   *(current_position-1)=0;

  00079	c6 46 ff 00	 mov	 BYTE PTR [esi-1], 0
$LN1@sock_gets:
  0007d	5f		 pop	 edi

; 300  :   }
; 301  : #if 0
; 302  :   fprintf(STD_err,"sock_read TRACE [%d]>>%s<<\n",current_position-str,str);
; 303  : #endif
; 304  :   return current_position-str;

  0007e	8b c6		 mov	 eax, esi
  00080	5e		 pop	 esi
  00081	2b c1		 sub	 eax, ecx
  00083	5d		 pop	 ebp

; 305  : }

  00084	59		 pop	 ecx
  00085	c3		 ret	 0
$LN10@sock_gets:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 286  :       /* The other side may have closed unexpectedly */
; 287  :       return -1; /* Is this effective on other platforms than linux? */

  00088	83 c8 ff	 or	 eax, -1
  0008b	5d		 pop	 ebp

; 305  : }

  0008c	59		 pop	 ecx
  0008d	c3		 ret	 0
_sock_gets ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CPAMKJDE@sock_readln?5end?3?5Reading?$AA@ ; `string'
PUBLIC	??_C@_0BL@PANDBNBF@sock_readln?5start?3?5Reading?$AA@ ; `string'
PUBLIC	_sock_readln
;	COMDAT ??_C@_0BJ@CPAMKJDE@sock_readln?5end?3?5Reading?$AA@
CONST	SEGMENT
??_C@_0BJ@CPAMKJDE@sock_readln?5end?3?5Reading?$AA@ DB 'sock_readln end: '
	DB	'Reading', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PANDBNBF@sock_readln?5start?3?5Reading?$AA@
CONST	SEGMENT
??_C@_0BL@PANDBNBF@sock_readln?5start?3?5Reading?$AA@ DB 'sock_readln sta'
	DB	'rt: Reading', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock_readln
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_buf$ = 12						; size = 4
_limit$ = 16						; size = 4
_sock_readln PROC					; COMDAT

; 310  : bp_long sock_readln(bp_long sock,char *buf,cell limit) {

  00000	53		 push	 ebx

; 311  :    bp_long ok;
; 312  :    if(0==limit) limit=MAXBUF;

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _limit$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	85 db		 test	 ebx, ebx
  00009	75 08		 jne	 SHORT $LN3@sock_readl
  0000b	8b 1d 1c 00 00
	00		 mov	 ebx, DWORD PTR _max+28
  00011	eb 0b		 jmp	 SHORT $LN1@sock_readl
$LN3@sock_readl:

; 313  :    else if(limit>MAXBUF) limit=MAXBUF;

  00013	a1 1c 00 00 00	 mov	 eax, DWORD PTR _max+28
  00018	3b d8		 cmp	 ebx, eax
  0001a	76 02		 jbe	 SHORT $LN1@sock_readl
  0001c	8b d8		 mov	 ebx, eax
$LN1@sock_readl:

; 314  : 
; 315  :    buf[0]='\0';

  0001e	8b 74 24 14	 mov	 esi, DWORD PTR _buf$[esp+8]
  00022	c6 06 00	 mov	 BYTE PTR [esi], 0

; 316  :    io_trace_ss("sock_readln start: Reading",buf);

  00025	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0002f	7f 1c		 jg	 SHORT $LN6@sock_readl
  00031	56		 push	 esi
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PANDBNBF@sock_readln?5start?3?5Reading?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  0003c	e8 00 00 00 00	 call	 ___iob_func
  00041	83 c0 40	 add	 eax, 64			; 00000040H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _fprintf
  0004a	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@sock_readl:

; 317  :    ok=sock_gets(sock,buf,limit)>=0;

  0004d	8b 44 24 10	 mov	 eax, DWORD PTR _sock$[esp+8]
  00051	56		 push	 esi
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _sock_gets
  00058	33 c9		 xor	 ecx, ecx
  0005a	83 c4 08	 add	 esp, 8
  0005d	85 c0		 test	 eax, eax
  0005f	0f 99 c1	 setns	 cl

; 318  :    io_trace_ss("sock_readln end: Reading",buf);

  00062	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0006c	8b f9		 mov	 edi, ecx
  0006e	7f 1c		 jg	 SHORT $LN12@sock_readl
  00070	56		 push	 esi
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CPAMKJDE@sock_readln?5end?3?5Reading?$AA@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  0007b	e8 00 00 00 00	 call	 ___iob_func
  00080	83 c0 40	 add	 eax, 64			; 00000040H
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _fprintf
  00089	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@sock_readl:

; 319  :    /*
; 320  :    {bp_long i,len;
; 321  :      len=strlen(buf);
; 322  :      for(i=(len>=3)?(len-3):0;i<len;i++) {
; 323  :        if('.'==buf[i]) buf[i]=' ';
; 324  :      }
; 325  :    }
; 326  :    */
; 327  :    return ok;

  0008c	8b c7		 mov	 eax, edi
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 328  : }

  00091	c3		 ret	 0
_sock_readln ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CGJGEHJG@sock_read0?0?5sock?0?5this?$CB?$CB?$AA@ ; `string'
PUBLIC	_sock_read0
EXTRN	__errno:PROC
;	COMDAT ??_C@_0BJ@CGJGEHJG@sock_read0?0?5sock?0?5this?$CB?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@CGJGEHJG@sock_read0?0?5sock?0?5this?$CB?$CB?$AA@ DB 'sock_read0'
	DB	', sock, this!!', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock_read0
_TEXT	SEGMENT
_bytes_read$ = -4					; size = 4
_sockfd$ = 8						; size = 4
_buf$ = 12						; size = 4
_count$ = 16						; size = 4
_sock_read0 PROC					; COMDAT

; 334  : {

  00000	51		 push	 ecx

; 335  :   size_t bytes_read = 0;

  00001	33 c0		 xor	 eax, eax
  00003	89 04 24	 mov	 DWORD PTR _bytes_read$[esp+4], eax

; 336  :   bp_long this_read;
; 337  : 
; 338  :   while (bytes_read < count) {

  00006	39 44 24 10	 cmp	 DWORD PTR _count$[esp], eax
  0000a	76 71		 jbe	 SHORT $LN15@sock_read0
  0000c	53		 push	 ebx
  0000d	55		 push	 ebp
  0000e	8b 6c 24 14	 mov	 ebp, DWORD PTR _buf$[esp+8]
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 7c 24 18	 mov	 edi, DWORD PTR _sockfd$[esp+16]
$LL7@sock_read0:
  00018	8b 5c 24 20	 mov	 ebx, DWORD PTR _count$[esp+16]
  0001c	2b d8		 sub	 ebx, eax
  0001e	8b ff		 npad	 2
$LL5@sock_read0:

; 339  :     do {
; 340  : #if VCC>0
; 341  :       this_read = recv(sockfd, buf, count - bytes_read,0);

  00020	6a 00		 push	 0
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 _recv@16

; 342  : #else
; 343  :       this_read = read(sockfd, buf, count - bytes_read);
; 344  : #endif
; 345  :       io_trace_snn("sock_read0, sock, this!!",sockfd,this_read);

  0002a	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00034	8b f0		 mov	 esi, eax
  00036	7f 1d		 jg	 SHORT $LN4@sock_read0
  00038	56		 push	 esi
  00039	57		 push	 edi
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CGJGEHJG@sock_read0?0?5sock?0?5this?$CB?$CB?$AA@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  00044	e8 00 00 00 00	 call	 ___iob_func
  00049	83 c0 40	 add	 eax, 64			; 00000040H
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _fprintf
  00052	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@sock_read0:

; 346  :     }
; 347  :     while ( (this_read < 0) && (errno == EINTR) ); /* end do */

  00055	85 f6		 test	 esi, esi
  00057	79 0c		 jns	 SHORT $LN25@sock_read0
  00059	e8 00 00 00 00	 call	 __errno
  0005e	83 38 04	 cmp	 DWORD PTR [eax], 4
  00061	74 bd		 je	 SHORT $LL5@sock_read0

; 348  : 
; 349  :     if (this_read <= 0) break;

  00063	85 f6		 test	 esi, esi
$LN25@sock_read0:

; 350  : 
; 351  :     bytes_read += this_read;

  00065	8b 44 24 10	 mov	 eax, DWORD PTR _bytes_read$[esp+20]

; 348  : 
; 349  :     if (this_read <= 0) break;

  00069	7e 0e		 jle	 SHORT $LN21@sock_read0

; 350  : 
; 351  :     bytes_read += this_read;

  0006b	03 c6		 add	 eax, esi

; 352  :     buf += this_read;

  0006d	03 ee		 add	 ebp, esi
  0006f	89 44 24 10	 mov	 DWORD PTR _bytes_read$[esp+20], eax
  00073	3b 44 24 20	 cmp	 eax, DWORD PTR _count$[esp+16]
  00077	72 9f		 jb	 SHORT $LL7@sock_read0
$LN21@sock_read0:
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	5b		 pop	 ebx
$LN15@sock_read0:

; 353  :   }
; 354  :   return bytes_read;
; 355  : }

  0007d	59		 pop	 ecx
  0007e	c3		 ret	 0
_sock_read0 ENDP
_TEXT	ENDS
EXTRN	_ntohl@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _get_charno
_TEXT	SEGMENT
_get_charno PROC					; COMDAT
; _magic$ = eax

; 367  :   return ntohl(*(ADDR_T *) magic);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 _ntohl@4

; 368  : }

  00008	c3		 ret	 0
_get_charno ENDP
_TEXT	ENDS
EXTRN	_htonl@4:PROC
; Function compile flags: /Ogtpy
;	COMDAT _set_charno
_TEXT	SEGMENT
_magic$ = 8						; size = 4
_set_charno PROC					; COMDAT
; _l$ = eax

; 371  :   ADDR_T *addr=(ADDR_T *)magic;
; 372  :   *addr=htonl(l);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 _htonl@4
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _magic$[esp-4]
  0000a	89 01		 mov	 DWORD PTR [ecx], eax

; 373  : }

  0000c	c3		 ret	 0
_set_charno ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@IPGEICEK@sock_read?3?5Reading?$AA@	; `string'
PUBLIC	??_C@_0BL@FIJKDNBC@sock_read?3?5buffer?5overflow?$AA@ ; `string'
PUBLIC	_sock_read
;	COMDAT ??_C@_0BD@IPGEICEK@sock_read?3?5Reading?$AA@
CONST	SEGMENT
??_C@_0BD@IPGEICEK@sock_read?3?5Reading?$AA@ DB 'sock_read: Reading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FIJKDNBC@sock_read?3?5buffer?5overflow?$AA@
CONST	SEGMENT
??_C@_0BL@FIJKDNBC@sock_read?3?5buffer?5overflow?$AA@ DB 'sock_read: buff'
	DB	'er overflow', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock_read
_TEXT	SEGMENT
_sockfd$ = 8						; size = 4
_buf$ = 12						; size = 4
_magic$81745 = 16					; size = 4
_limit$ = 16						; size = 4
_sock_read PROC						; COMDAT

; 376  :   bp_long count; ADDR_T l;
; 377  : 
; 378  :   if(0==limit) { /* size is the firs bp_long in data */

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _limit$[esp-4]
  00004	57		 push	 edi
  00005	8b 7c 24 08	 mov	 edi, DWORD PTR _sockfd$[esp]
  00009	85 c0		 test	 eax, eax
  0000b	75 1f		 jne	 SHORT $LN5@sock_read

; 379  :     char magic[USIZE()];
; 380  :     count=sock_read0(sockfd, magic, USIZE());

  0000d	6a 04		 push	 4
  0000f	8d 44 24 14	 lea	 eax, DWORD PTR _magic$81745[esp+4]
  00013	50		 push	 eax
  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 _sock_read0
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 381  :     if(count!=USIZE()) return 0;

  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 2d		 jne	 SHORT $LN10@sock_read

; 382  :     l=get_charno(magic);

  00022	8b 4c 24 10	 mov	 ecx, DWORD PTR _magic$81745[esp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _ntohl@4
$LN5@sock_read:

; 383  :   }
; 384  :   else /* size is given by user */
; 385  :     l=(ADDR_T)limit;
; 386  : 
; 387  :   if(l>=MAXBUF) {

  0002c	3b 05 1c 00 00
	00		 cmp	 eax, DWORD PTR _max+28
  00032	72 1f		 jb	 SHORT $LN2@sock_read

; 388  : 	 perror0("sock_read: buffer overflow");

  00034	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  0003a	83 e2 fc	 and	 edx, -4			; fffffffcH
  0003d	83 fa 04	 cmp	 edx, 4
  00040	7f 0d		 jg	 SHORT $LN10@sock_read
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FIJKDNBC@sock_read?3?5buffer?5overflow?$AA@
  00047	e8 00 00 00 00	 call	 _perror
  0004c	83 c4 04	 add	 esp, 4
$LN10@sock_read:

; 389  : 	 return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	5f		 pop	 edi

; 397  : }

  00052	c3		 ret	 0
$LN2@sock_read:
  00053	56		 push	 esi

; 390  :      /* in fact, this means max.SBUF, a BinProlog limit */
; 391  :   }
; 392  :   buf[0]='\0';

  00054	8b 74 24 10	 mov	 esi, DWORD PTR _buf$[esp+4]

; 393  :   count=sock_read0(sockfd, buf, l);

  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	57		 push	 edi
  0005b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0005e	e8 00 00 00 00	 call	 _sock_read0
  00063	8b f8		 mov	 edi, eax
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 394  :   if(count>=0) buf[count]='\0';

  00068	85 ff		 test	 edi, edi
  0006a	78 04		 js	 SHORT $LN1@sock_read
  0006c	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
$LN1@sock_read:

; 395  :   io_trace_ss("sock_read: Reading",buf);

  00070	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0007a	7f 1c		 jg	 SHORT $LN13@sock_read
  0007c	56		 push	 esi
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IPGEICEK@sock_read?3?5Reading?$AA@
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00087	e8 00 00 00 00	 call	 ___iob_func
  0008c	83 c0 40	 add	 eax, 64			; 00000040H
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _fprintf
  00095	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@sock_read:

; 396  :   return count;

  00098	5e		 pop	 esi
  00099	8b c7		 mov	 eax, edi
  0009b	5f		 pop	 edi

; 397  : }

  0009c	c3		 ret	 0
_sock_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@PBADLBHA@sock2file?3?5Read?5from?0?5bytes?3?$AA@ ; `string'
PUBLIC	??_C@_0CK@JJKCKMFH@sock2file?3?5Try?5reading?5sock?0?5fil@ ; `string'
PUBLIC	_sock2file
EXTRN	_ferror:PROC
EXTRN	_fwrite:PROC
;	COMDAT ??_C@_0BN@PBADLBHA@sock2file?3?5Read?5from?0?5bytes?3?$AA@
CONST	SEGMENT
??_C@_0BN@PBADLBHA@sock2file?3?5Read?5from?0?5bytes?3?$AA@ DB 'sock2file:'
	DB	' Read from, bytes:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JJKCKMFH@sock2file?3?5Try?5reading?5sock?0?5fil@
CONST	SEGMENT
??_C@_0CK@JJKCKMFH@sock2file?3?5Try?5reading?5sock?0?5fil@ DB 'sock2file:'
	DB	' Try reading sock, file stream ', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock2file
_TEXT	SEGMENT
_magic$ = -4						; size = 4
_sockfd$ = 8						; size = 4
_to$ = 12						; size = 4
_buf$ = 16						; size = 4
_sock2file PROC						; COMDAT

; 399  : bp_long sock2file(bp_long sockfd, FILE *to, char *buf) {

  00000	51		 push	 ecx

; 400  :   bp_long ok; ADDR_T l;
; 401  :   char magic[USIZE()];
; 402  :   io_trace_snn("sock2file: Try reading sock, file stream ",sockfd,(bp_long)to);

  00001	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000b	55		 push	 ebp
  0000c	8b 6c 24 0c	 mov	 ebp, DWORD PTR _sockfd$[esp+4]
  00010	7f 21		 jg	 SHORT $LN22@sock2file
  00012	8b 44 24 10	 mov	 eax, DWORD PTR _to$[esp+4]
  00016	50		 push	 eax
  00017	55		 push	 ebp
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JJKCKMFH@sock2file?3?5Try?5reading?5sock?0?5fil@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  00022	e8 00 00 00 00	 call	 ___iob_func
  00027	83 c0 40	 add	 eax, 64			; 00000040H
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _fprintf
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$LN22@sock2file:

; 403  :   ok=sock_read0(sockfd, magic, USIZE());

  00033	6a 04		 push	 4
  00035	8d 4c 24 08	 lea	 ecx, DWORD PTR _magic$[esp+12]
  00039	51		 push	 ecx
  0003a	55		 push	 ebp
  0003b	e8 00 00 00 00	 call	 _sock_read0
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 404  :   if(ok!=USIZE()) return 0;

  00043	83 f8 04	 cmp	 eax, 4
  00046	74 05		 je	 SHORT $LN4@sock2file
  00048	33 c0		 xor	 eax, eax
  0004a	5d		 pop	 ebp

; 415  : }

  0004b	59		 pop	 ecx
  0004c	c3		 ret	 0
$LN4@sock2file:

; 405  :   l=get_charno(magic);

  0004d	8b 54 24 04	 mov	 edx, DWORD PTR _magic$[esp+8]
  00051	53		 push	 ebx
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 _ntohl@4
  0005a	8b f8		 mov	 edi, eax

; 406  :   while(l>0) {

  0005c	85 ff		 test	 edi, edi
  0005e	74 64		 je	 SHORT $LN21@sock2file
  00060	8b 5c 24 20	 mov	 ebx, DWORD PTR _buf$[esp+16]
$LL3@sock2file:

; 407  :     ok=(l<MAXBUF)?l:MAXBUF;

  00064	a1 1c 00 00 00	 mov	 eax, DWORD PTR _max+28
  00069	3b f8		 cmp	 edi, eax
  0006b	73 02		 jae	 SHORT $LN7@sock2file
  0006d	8b c7		 mov	 eax, edi
$LN7@sock2file:

; 408  :     ok=sock_read0(sockfd, buf, ok);

  0006f	50		 push	 eax
  00070	53		 push	 ebx
  00071	55		 push	 ebp
  00072	e8 00 00 00 00	 call	 _sock_read0
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  :     if(ok<0) return 0;

  0007a	85 c0		 test	 eax, eax
  0007c	78 62		 js	 SHORT $LN24@sock2file

; 410  :     l-=ok;
; 411  :     ok=fwrite(buf, 1, ok, to);

  0007e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _to$[esp+16]
  00082	51		 push	 ecx
  00083	50		 push	 eax
  00084	6a 01		 push	 1
  00086	53		 push	 ebx
  00087	2b f8		 sub	 edi, eax
  00089	e8 00 00 00 00	 call	 _fwrite
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 412  :     io_trace_snn("sock2file: Read from, bytes:",sockfd,ok);

  00091	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0009b	8b f0		 mov	 esi, eax
  0009d	7f 1d		 jg	 SHORT $LN16@sock2file
  0009f	56		 push	 esi
  000a0	55		 push	 ebp
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PBADLBHA@sock2file?3?5Read?5from?0?5bytes?3?$AA@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000ab	e8 00 00 00 00	 call	 ___iob_func
  000b0	83 c0 40	 add	 eax, 64			; 00000040H
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _fprintf
  000b9	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@sock2file:

; 406  :   while(l>0) {

  000bc	85 ff		 test	 edi, edi
  000be	75 a4		 jne	 SHORT $LL3@sock2file

; 413  :   }
; 414  :   return ok>=0 && !ferror(to);

  000c0	85 f6		 test	 esi, esi
  000c2	78 1c		 js	 SHORT $LN24@sock2file
$LN21@sock2file:
  000c4	8b 54 24 1c	 mov	 edx, DWORD PTR _to$[esp+16]
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 _ferror
  000ce	83 c4 04	 add	 esp, 4
  000d1	85 c0		 test	 eax, eax
  000d3	75 0b		 jne	 SHORT $LN24@sock2file
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	5d		 pop	 ebp

; 415  : }

  000de	59		 pop	 ecx
  000df	c3		 ret	 0
$LN24@sock2file:
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 413  :   }
; 414  :   return ok>=0 && !ferror(to);

  000e3	33 c0		 xor	 eax, eax
  000e5	5d		 pop	 ebp

; 415  : }

  000e6	59		 pop	 ecx
  000e7	c3		 ret	 0
_sock2file ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@GEKMMKBN@sock_write0?3?5written?0?5sock?0?5coun@ ; `string'
PUBLIC	??_C@_0CK@NNPCDAHC@sock_write0?3?5trying?5to?5write?0?5so@ ; `string'
PUBLIC	_sock_write0
EXTRN	_send@16:PROC
;	COMDAT ??_C@_0CC@GEKMMKBN@sock_write0?3?5written?0?5sock?0?5coun@
CONST	SEGMENT
??_C@_0CC@GEKMMKBN@sock_write0?3?5written?0?5sock?0?5coun@ DB 'sock_write'
	DB	'0: written, sock, count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNPCDAHC@sock_write0?3?5trying?5to?5write?0?5so@
CONST	SEGMENT
??_C@_0CK@NNPCDAHC@sock_write0?3?5trying?5to?5write?0?5so@ DB 'sock_write'
	DB	'0: trying to write, sock, count', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock_write0
_TEXT	SEGMENT
_bytes_sent$ = -4					; size = 4
_sockfd$ = 8						; size = 4
_buf$ = 12						; size = 4
_count$ = 16						; size = 4
_sock_write0 PROC					; COMDAT

; 423  : {

  00000	51		 push	 ecx

; 424  :   size_t bytes_sent = 0;
; 425  :   bp_long this_write;
; 426  : 
; 427  :   io_trace_snn("sock_write0: trying to write, sock, count",sockfd,count);

  00001	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0000b	53		 push	 ebx
  0000c	55		 push	 ebp
  0000d	8b 6c 24 10	 mov	 ebp, DWORD PTR _sockfd$[esp+8]
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _bytes_sent$[esp+20], 0
  0001b	7f 21		 jg	 SHORT $LN23@sock_write
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR _count$[esp+16]
  00021	50		 push	 eax
  00022	55		 push	 ebp
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NNPCDAHC@sock_write0?3?5trying?5to?5write?0?5so@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  0002d	e8 00 00 00 00	 call	 ___iob_func
  00032	83 c0 40	 add	 eax, 64			; 00000040H
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _fprintf
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$LN23@sock_write:

; 428  : 
; 429  :   while (bytes_sent < count) {

  0003e	83 7c 24 20 00	 cmp	 DWORD PTR _count$[esp+16], 0
  00043	76 43		 jbe	 SHORT $LN6@sock_write
  00045	8b 5c 24 1c	 mov	 ebx, DWORD PTR _buf$[esp+16]
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL7@sock_write:
  00050	8b 7c 24 20	 mov	 edi, DWORD PTR _count$[esp+16]
  00054	2b 7c 24 10	 sub	 edi, DWORD PTR _bytes_sent$[esp+20]
$LL5@sock_write:

; 430  :     do
; 431  : #if VCC>0
; 432  :       this_write = send(sockfd, buf, count - bytes_sent,0);

  00058	6a 00		 push	 0
  0005a	57		 push	 edi
  0005b	53		 push	 ebx
  0005c	55		 push	 ebp
  0005d	e8 00 00 00 00	 call	 _send@16
  00062	8b f0		 mov	 esi, eax

; 433  : #else
; 434  :       this_write = write(sockfd, buf, count - bytes_sent);
; 435  : #endif
; 436  :     while ( (this_write < 0) && (errno == EINTR) );

  00064	85 f6		 test	 esi, esi
  00066	79 0c		 jns	 SHORT $LN26@sock_write
  00068	e8 00 00 00 00	 call	 __errno
  0006d	83 38 04	 cmp	 DWORD PTR [eax], 4
  00070	74 e6		 je	 SHORT $LL5@sock_write

; 437  :     if (this_write <= 0) {

  00072	85 f6		 test	 esi, esi
$LN26@sock_write:
  00074	7e 49		 jle	 SHORT $LN21@sock_write

; 440  :     }
; 441  :     bytes_sent += this_write;

  00076	8b 44 24 10	 mov	 eax, DWORD PTR _bytes_sent$[esp+20]
  0007a	03 c6		 add	 eax, esi

; 442  :     buf += this_write;

  0007c	03 de		 add	 ebx, esi
  0007e	89 44 24 10	 mov	 DWORD PTR _bytes_sent$[esp+20], eax
  00082	3b 44 24 20	 cmp	 eax, DWORD PTR _count$[esp+16]
  00086	72 c8		 jb	 SHORT $LL7@sock_write
$LN6@sock_write:

; 443  :   }
; 444  :   io_trace_snn("sock_write0: written, sock, count",sockfd,bytes_sent);

  00088	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00092	7f 21		 jg	 SHORT $LN16@sock_write
  00094	8b 54 24 10	 mov	 edx, DWORD PTR _bytes_sent$[esp+20]
  00098	52		 push	 edx
  00099	55		 push	 ebp
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GEKMMKBN@sock_write0?3?5written?0?5sock?0?5coun@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000a4	e8 00 00 00 00	 call	 ___iob_func
  000a9	83 c0 40	 add	 eax, 64			; 00000040H
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _fprintf
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@sock_write:

; 445  :   return count;

  000b5	8b 44 24 20	 mov	 eax, DWORD PTR _count$[esp+16]
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5d		 pop	 ebp
  000bc	5b		 pop	 ebx

; 446  : }

  000bd	59		 pop	 ecx
  000be	c3		 ret	 0
$LN21@sock_write:

; 438  :       io_trace_snn("sock_write0: written, sock, count",sockfd,bytes_sent);

  000bf	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000c9	7f 21		 jg	 SHORT $LN13@sock_write
  000cb	8b 4c 24 10	 mov	 ecx, DWORD PTR _bytes_sent$[esp+20]
  000cf	51		 push	 ecx
  000d0	55		 push	 ebp
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GEKMMKBN@sock_write0?3?5written?0?5sock?0?5coun@
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000db	e8 00 00 00 00	 call	 ___iob_func
  000e0	83 c0 40	 add	 eax, 64			; 00000040H
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _fprintf
  000e9	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@sock_write:

; 439  :       return this_write;

  000ec	5f		 pop	 edi
  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi
  000f0	5d		 pop	 ebp
  000f1	5b		 pop	 ebx

; 446  : }

  000f2	59		 pop	 ecx
  000f3	c3		 ret	 0
_sock_write0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@HOOCNMHO@sock_write?3?5written?$AA@	; `string'
PUBLIC	_sock_write
;	COMDAT ??_C@_0BE@HOOCNMHO@sock_write?3?5written?$AA@
CONST	SEGMENT
??_C@_0BE@HOOCNMHO@sock_write?3?5written?$AA@ DB 'sock_write: written', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _sock_write
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_buf$ = 12						; size = 4
_magic$ = 16						; size = 4
_option$ = 16						; size = 4
_sock_write PROC					; COMDAT

; 468  : bp_long sock_write(bp_long sock, char *buf,bp_long option) {

  00000	53		 push	 ebx

; 469  :    bp_long ok;
; 470  :    ADDR_T l;
; 471  :    char magic[USIZE()];
; 472  :    if(0==option) {

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _buf$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 14	 mov	 esi, DWORD PTR _option$[esp+4]
  0000a	57		 push	 edi
  0000b	85 f6		 test	 esi, esi
  0000d	75 10		 jne	 SHORT $LN4@sock_write@2

; 473  :    l=strlen(buf);

  0000f	8b c3		 mov	 eax, ebx
  00011	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL12@sock_write@2:
  00014	8a 08		 mov	 cl, BYTE PTR [eax]
  00016	40		 inc	 eax
  00017	84 c9		 test	 cl, cl
  00019	75 f9		 jne	 SHORT $LL12@sock_write@2
  0001b	2b c2		 sub	 eax, edx
  0001d	8b f0		 mov	 esi, eax
$LN4@sock_write@2:

; 474  :    }
; 475  :    else {
; 476  :    l=option;
; 477  :    }
; 478  :    set_charno(magic,l);

  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _htonl@4

; 479  :    ok=sock_write0(sock,magic,USIZE());

  00025	8b 7c 24 10	 mov	 edi, DWORD PTR _sock$[esp+8]
  00029	89 44 24 18	 mov	 DWORD PTR _magic$[esp+8], eax
  0002d	6a 04		 push	 4
  0002f	8d 44 24 1c	 lea	 eax, DWORD PTR _magic$[esp+12]
  00033	50		 push	 eax
  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 _sock_write0
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 480  :    //io_trace_snn("sock_write, l, USIZE ",l,USIZE());
; 481  :    if(ok!=USIZE()) return 0;

  0003d	83 f8 04	 cmp	 eax, 4
  00040	74 06		 je	 SHORT $LN2@sock_write@2
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	33 c0		 xor	 eax, eax
  00046	5b		 pop	 ebx

; 487  : }

  00047	c3		 ret	 0
$LN2@sock_write@2:

; 482  :    ok=sock_write0(sock,buf,l);

  00048	56		 push	 esi
  00049	53		 push	 ebx
  0004a	57		 push	 edi
  0004b	e8 00 00 00 00	 call	 _sock_write0
  00050	8b f0		 mov	 esi, eax
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 483  :    //io_trace_ssnn("sock_write, buffer, socket, l ",buf,sock,l);
; 484  :    if(ok>=0) io_trace_ss("sock_write: written",buf);

  00055	85 f6		 test	 esi, esi
  00057	78 28		 js	 SHORT $LN9@sock_write@2
  00059	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00063	7f 1c		 jg	 SHORT $LN9@sock_write@2
  00065	53		 push	 ebx
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HOOCNMHO@sock_write?3?5written?$AA@
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00070	e8 00 00 00 00	 call	 ___iob_func
  00075	83 c0 40	 add	 eax, 64			; 00000040H
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _fprintf
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@sock_write@2:

; 485  :    buf[0]='\0';
; 486  :    return ok>=0;

  00081	33 c0		 xor	 eax, eax
  00083	5f		 pop	 edi
  00084	85 f6		 test	 esi, esi
  00086	5e		 pop	 esi
  00087	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0008a	0f 99 c0	 setns	 al
  0008d	5b		 pop	 ebx

; 487  : }

  0008e	c3		 ret	 0
_sock_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@EIJHCAK@file2sock?3?5bad?5file?5stream?0?5code@ ; `string'
PUBLIC	??_C@_0CK@KLEMPDAI@file2sock?3?5written?5from?5file?5str@ ; `string'
PUBLIC	??_C@_0BM@JBNJGB@file2sock?3?5read?5from?0?5chars?$AA@ ; `string'
PUBLIC	_file2sock
EXTRN	_fread:PROC
EXTRN	_fsize:PROC
;	COMDAT ??_C@_0CB@EIJHCAK@file2sock?3?5bad?5file?5stream?0?5code@
CONST	SEGMENT
??_C@_0CB@EIJHCAK@file2sock?3?5bad?5file?5stream?0?5code@ DB 'file2sock: '
	DB	'bad file stream, code', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KLEMPDAI@file2sock?3?5written?5from?5file?5str@
CONST	SEGMENT
??_C@_0CK@KLEMPDAI@file2sock?3?5written?5from?5file?5str@ DB 'file2sock: '
	DB	'written from file stream, sock', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JBNJGB@file2sock?3?5read?5from?0?5chars?$AA@
CONST	SEGMENT
??_C@_0BM@JBNJGB@file2sock?3?5read?5from?0?5chars?$AA@ DB 'file2sock: rea'
	DB	'd from, chars', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _file2sock
_TEXT	SEGMENT
_magic$ = -4						; size = 4
_from$ = 8						; size = 4
_sock$ = 12						; size = 4
_buf$ = 16						; size = 4
_file2sock PROC						; COMDAT

; 489  : bp_long file2sock(FILE *from, bp_long sock,char *buf) {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 490  :    bp_long ok; ADDR_T l; ADDR_T s;
; 491  :    char magic[USIZE()];
; 492  :    s=fsize(from);

  00004	8b 7c 24 14	 mov	 edi, DWORD PTR _from$[esp+12]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 _fsize
  0000e	83 c4 04	 add	 esp, 4
  00011	8b e8		 mov	 ebp, eax

; 493  :    set_charno(magic,s);

  00013	55		 push	 ebp
  00014	e8 00 00 00 00	 call	 _htonl@4

; 494  :    ok=sock_write0(sock,magic,USIZE());

  00019	8b 4c 24 18	 mov	 ecx, DWORD PTR _sock$[esp+12]
  0001d	89 44 24 0c	 mov	 DWORD PTR _magic$[esp+16], eax
  00021	6a 04		 push	 4
  00023	8d 44 24 10	 lea	 eax, DWORD PTR _magic$[esp+20]
  00027	50		 push	 eax
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _sock_write0
  0002e	8b f0		 mov	 esi, eax
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  :    if(ok!=USIZE()) return 0;

  00033	83 fe 04	 cmp	 esi, 4
  00036	74 07		 je	 SHORT $LN19@file2sock
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	33 c0		 xor	 eax, eax
  0003c	5d		 pop	 ebp

; 510  : }

  0003d	59		 pop	 ecx
  0003e	c3		 ret	 0
$LN19@file2sock:
  0003f	53		 push	 ebx

; 496  :    while(s>0) {

  00040	85 ed		 test	 ebp, ebp
  00042	0f 84 9d 00 00
	00		 je	 $LN3@file2sock
  00048	8b 5c 24 20	 mov	 ebx, DWORD PTR _buf$[esp+16]
  0004c	8d 64 24 00	 npad	 4
$LL4@file2sock:

; 497  :      l=fread(buf,1,MAXBUF,from);

  00050	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR _max+28
  00056	57		 push	 edi
  00057	52		 push	 edx
  00058	6a 01		 push	 1
  0005a	53		 push	 ebx
  0005b	e8 00 00 00 00	 call	 _fread
  00060	8b f0		 mov	 esi, eax
  00062	83 c4 10	 add	 esp, 16			; 00000010H

; 498  :      if(l<=0) {

  00065	85 f6		 test	 esi, esi
  00067	0f 84 85 00 00
	00		 je	 $LN20@file2sock

; 501  :      }
; 502  :      io_trace_snn("file2sock: read from, chars",(bp_long)from,l);

  0006d	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00077	7f 1d		 jg	 SHORT $LN13@file2sock
  00079	56		 push	 esi
  0007a	57		 push	 edi
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JBNJGB@file2sock?3?5read?5from?0?5chars?$AA@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  00085	e8 00 00 00 00	 call	 ___iob_func
  0008a	83 c0 40	 add	 eax, 64			; 00000040H
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _fprintf
  00093	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@file2sock:

; 503  :      s-=l;
; 504  :      ok=sock_write0(sock,buf,l);

  00096	8b 44 24 1c	 mov	 eax, DWORD PTR _sock$[esp+16]
  0009a	56		 push	 esi
  0009b	53		 push	 ebx
  0009c	50		 push	 eax
  0009d	2b ee		 sub	 ebp, esi
  0009f	e8 00 00 00 00	 call	 _sock_write0
  000a4	8b f0		 mov	 esi, eax
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 505  :      if(ok>=0) io_trace_snn("file2sock: written from file stream, sock",

  000a9	85 f6		 test	 esi, esi
  000ab	78 2d		 js	 SHORT $LN16@file2sock

; 506  :                              (bp_long)from,sock);

  000ad	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000b7	7f 21		 jg	 SHORT $LN16@file2sock
  000b9	8b 4c 24 1c	 mov	 ecx, DWORD PTR _sock$[esp+16]
  000bd	51		 push	 ecx
  000be	57		 push	 edi
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KLEMPDAI@file2sock?3?5written?5from?5file?5str@
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000c9	e8 00 00 00 00	 call	 ___iob_func
  000ce	83 c0 40	 add	 eax, 64			; 00000040H
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _fprintf
  000d7	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@file2sock:

; 507  :      buf[0]='\0';

  000da	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000dd	85 ed		 test	 ebp, ebp
  000df	0f 85 6b ff ff
	ff		 jne	 $LL4@file2sock
$LN3@file2sock:
  000e5	5b		 pop	 ebx

; 508  :    }
; 509  :    return ok>=0;

  000e6	33 c0		 xor	 eax, eax
  000e8	5f		 pop	 edi
  000e9	85 f6		 test	 esi, esi
  000eb	5e		 pop	 esi
  000ec	0f 99 c0	 setns	 al
  000ef	5d		 pop	 ebp

; 510  : }

  000f0	59		 pop	 ecx
  000f1	c3		 ret	 0
$LN20@file2sock:

; 499  :        io_trace_snn("file2sock: bad file stream, code",(bp_long)from,l);

  000f2	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000fc	7f 1d		 jg	 SHORT $LN10@file2sock
  000fe	56		 push	 esi
  000ff	57		 push	 edi
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EIJHCAK@file2sock?3?5bad?5file?5stream?0?5code@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  0010a	e8 00 00 00 00	 call	 ___iob_func
  0010f	83 c0 40	 add	 eax, 64			; 00000040H
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _fprintf
  00118	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@file2sock:

; 500  :        return 0;

  0011b	5b		 pop	 ebx
  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	33 c0		 xor	 eax, eax
  00120	5d		 pop	 ebp

; 510  : }

  00121	59		 pop	 ecx
  00122	c3		 ret	 0
_file2sock ENDP
_TEXT	ENDS
PUBLIC	_sock_writeln
; Function compile flags: /Ogtpy
;	COMDAT _sock_writeln
_TEXT	SEGMENT
_sock$ = 8						; size = 4
_buf$ = 12						; size = 4
_option$ = 16						; size = 4
_sock_writeln PROC					; COMDAT

; 518  : bp_long sock_writeln(bp_long sock,char *buf,bp_long option) {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 519  :    bp_long ok;
; 520  :    bp_long l=strlen(buf);

  00002	8b 6c 24 10	 mov	 ebp, DWORD PTR _buf$[esp+4]
  00006	8b c5		 mov	 eax, ebp
  00008	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@sock_write@3:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL5@sock_write@3
  00017	2b c2		 sub	 eax, edx
  00019	8b d8		 mov	 ebx, eax

; 521  :    if(0==l || (l>0 && buf[l-1]!=eol[0] && buf[l-1]!=eol[1]))

  0001b	74 18		 je	 SHORT $LN9@sock_write@3
  0001d	85 db		 test	 ebx, ebx
  0001f	7e 5c		 jle	 SHORT $LN2@sock_write@3
  00021	8a 44 2b ff	 mov	 al, BYTE PTR [ebx+ebp-1]
  00025	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR _eol
  0002b	74 50		 je	 SHORT $LN2@sock_write@3
  0002d	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR _eol+1
  00033	74 48		 je	 SHORT $LN2@sock_write@3
$LN9@sock_write@3:

; 522  :      {
; 523  :        strcat(buf,eol);

  00035	b8 00 00 00 00	 mov	 eax, OFFSET _eol
  0003a	8b d0		 mov	 edx, eax
  0003c	8d 64 24 00	 npad	 4
$LL6@sock_write@3:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL6@sock_write@3
  00047	56		 push	 esi
  00048	57		 push	 edi
  00049	2b c2		 sub	 eax, edx
  0004b	8d 7d ff	 lea	 edi, DWORD PTR [ebp-1]
  0004e	8b ff		 npad	 2
$LL7@sock_write@3:
  00050	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00053	47		 inc	 edi
  00054	84 c9		 test	 cl, cl
  00056	75 f8		 jne	 SHORT $LL7@sock_write@3
  00058	8b c8		 mov	 ecx, eax
  0005a	c1 e9 02	 shr	 ecx, 2
  0005d	8b f2		 mov	 esi, edx
  0005f	f3 a5		 rep movsd
  00061	8b c8		 mov	 ecx, eax
  00063	83 e1 03	 and	 ecx, 3
  00066	f3 a4		 rep movsb

; 524  :        l+=strlen(eol);

  00068	b8 00 00 00 00	 mov	 eax, OFFSET _eol
  0006d	5f		 pop	 edi
  0006e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00071	5e		 pop	 esi
$LL8@sock_write@3:
  00072	8a 08		 mov	 cl, BYTE PTR [eax]
  00074	40		 inc	 eax
  00075	84 c9		 test	 cl, cl
  00077	75 f9		 jne	 SHORT $LL8@sock_write@3
  00079	2b c2		 sub	 eax, edx
  0007b	03 d8		 add	 ebx, eax
$LN2@sock_write@3:

; 525  :      }
; 526  :    ok=sock_write0(sock, buf,l);

  0007d	8b 44 24 0c	 mov	 eax, DWORD PTR _sock$[esp+4]
  00081	53		 push	 ebx
  00082	55		 push	 ebp
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _sock_write0
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 527  :    buf[0]='\0';
; 528  :    return ok>=0;

  0008c	33 c9		 xor	 ecx, ecx
  0008e	85 c0		 test	 eax, eax
  00090	0f 99 c1	 setns	 cl
  00093	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  00097	5d		 pop	 ebp
  00098	5b		 pop	 ebx
  00099	8b c1		 mov	 eax, ecx

; 529  : }

  0009b	c3		 ret	 0
_sock_writeln ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@DFDDJBJC@?5?5new_client?5socket?$AA@	; `string'
PUBLIC	??_C@_0BM@LLPBOCCK@Exiting?5new_client?5for?5host?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAMLNOO@Cannot?5set?5TCP_NODELAY?$AA@	; `string'
PUBLIC	??_C@_0BF@ICFEAKEP@Cannot?5set?5KEEPALIVE?$AA@	; `string'
PUBLIC	??_C@_0BK@LEHOMCBC@Connection?5attempt?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BI@BAFIBIJ@Unable?5to?5create?5socket?$AA@ ; `string'
PUBLIC	??_C@_0BO@KDEAKEDI@host?5assumed?5valid?5IP?5address?$AA@ ; `string'
PUBLIC	??_C@_0BM@KMOACAHG@no?5localhost?5neither?0?5error?$AA@ ; `string'
PUBLIC	??_C@_0BD@GMPDPAKG@Host?5found?5by?5name?$AA@	; `string'
PUBLIC	??_C@_0BI@NNJEHFFG@gethostby?4?4?4?$CI?$CJ?5got?5addr?$AA@ ; `string'
PUBLIC	??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0L@KBNNJDAE@errorcode?3?$AA@		; `string'
PUBLIC	??_C@_0CN@GNBLJIP@Neither?5an?5IP?5address?5nor?5host?5f@ ; `string'
PUBLIC	??_C@_05FFPGNEKC@got?5l?$AA@			; `string'
PUBLIC	??_C@_0BJ@LPKHELOA@?5?5new_client?5server?5port?$AA@ ; `string'
PUBLIC	??_C@_0BN@PMGGPDKD@Entering?5new_client?5for?5host?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_new_client0
EXTRN	_setsockopt@20:PROC
EXTRN	_connect@12:PROC
EXTRN	_socket@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_sprintf:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	_inet_addr@4:PROC
EXTRN	_memcpy:PROC
_BSS	SEGMENT
?l@?2??new_client0@@9@9 DD 01H DUP (?)			; `new_client0'::`3'::l
_BSS	ENDS
;	COMDAT ??_C@_0BE@DFDDJBJC@?5?5new_client?5socket?$AA@
CONST	SEGMENT
??_C@_0BE@DFDDJBJC@?5?5new_client?5socket?$AA@ DB '  new_client socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LLPBOCCK@Exiting?5new_client?5for?5host?$AA@
CONST	SEGMENT
??_C@_0BM@LLPBOCCK@Exiting?5new_client?5for?5host?$AA@ DB 'Exiting new_cl'
	DB	'ient for host', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAMLNOO@Cannot?5set?5TCP_NODELAY?$AA@
CONST	SEGMENT
??_C@_0BH@LAMLNOO@Cannot?5set?5TCP_NODELAY?$AA@ DB 'Cannot set TCP_NODELA'
	DB	'Y', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ICFEAKEP@Cannot?5set?5KEEPALIVE?$AA@
CONST	SEGMENT
??_C@_0BF@ICFEAKEP@Cannot?5set?5KEEPALIVE?$AA@ DB 'Cannot set KEEPALIVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LEHOMCBC@Connection?5attempt?5failed?$AA@
CONST	SEGMENT
??_C@_0BK@LEHOMCBC@Connection?5attempt?5failed?$AA@ DB 'Connection attemp'
	DB	't failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BAFIBIJ@Unable?5to?5create?5socket?$AA@
CONST	SEGMENT
??_C@_0BI@BAFIBIJ@Unable?5to?5create?5socket?$AA@ DB 'Unable to create so'
	DB	'cket', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KDEAKEDI@host?5assumed?5valid?5IP?5address?$AA@
CONST	SEGMENT
??_C@_0BO@KDEAKEDI@host?5assumed?5valid?5IP?5address?$AA@ DB 'host assume'
	DB	'd valid IP address', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KMOACAHG@no?5localhost?5neither?0?5error?$AA@
CONST	SEGMENT
??_C@_0BM@KMOACAHG@no?5localhost?5neither?0?5error?$AA@ DB 'no localhost '
	DB	'neither, error', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMPDPAKG@Host?5found?5by?5name?$AA@
CONST	SEGMENT
??_C@_0BD@GMPDPAKG@Host?5found?5by?5name?$AA@ DB 'Host found by name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NNJEHFFG@gethostby?4?4?4?$CI?$CJ?5got?5addr?$AA@
CONST	SEGMENT
??_C@_0BI@NNJEHFFG@gethostby?4?4?4?$CI?$CJ?5got?5addr?$AA@ DB 'gethostby.'
	DB	'..() got addr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@
CONST	SEGMENT
??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@ DB '%u.%u.%u.%u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBNNJDAE@errorcode?3?$AA@
CONST	SEGMENT
??_C@_0L@KBNNJDAE@errorcode?3?$AA@ DB 'errorcode:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GNBLJIP@Neither?5an?5IP?5address?5nor?5host?5f@
CONST	SEGMENT
??_C@_0CN@GNBLJIP@Neither?5an?5IP?5address?5nor?5host?5f@ DB 'Neither an '
	DB	'IP address nor host found by name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FFPGNEKC@got?5l?$AA@
CONST	SEGMENT
??_C@_05FFPGNEKC@got?5l?$AA@ DB 'got l', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPKHELOA@?5?5new_client?5server?5port?$AA@
CONST	SEGMENT
??_C@_0BJ@LPKHELOA@?5?5new_client?5server?5port?$AA@ DB '  new_client ser'
	DB	'ver port', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PMGGPDKD@Entering?5new_client?5for?5host?$AA@
CONST	SEGMENT
??_C@_0BN@PMGGPDKD@Entering?5new_client?5for?5host?$AA@ DB 'Entering new_'
	DB	'client for host', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _new_client0
_TEXT	SEGMENT
_hp$ = -424						; size = 4
_on$ = -424						; size = 4
_peeraddr_in$ = -420					; size = 16
_wsadata$82329 = -404					; size = 400
_buf$81882 = -404					; size = 256
__$ArrayPad$ = -4					; size = 4
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_new_client0 PROC					; COMDAT

; 545  : bp_long new_client0(char *host, bp_long port) /* starts client */ {

  00000	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 a4 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+424], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	56		 push	 esi

; 546  : 
; 547  :     bp_long  s;                       /* socket file descriptor */
; 548  : #if 0==VCC
; 549  :     struct hostent *gethostbyname();
; 550  : #endif
; 551  :     struct hostent *hp;
; 552  :     struct sockaddr_in peeraddr_in;
; 553  :     bp_long  on = 1;
; 554  : 
; 555  :     io_trace_ss(
; 556  :         "Entering new_client for host", host);

  00017	bd fc ff ff ff	 mov	 ebp, -4			; fffffffcH
  0001c	be 01 00 00 00	 mov	 esi, 1
  00021	57		 push	 edi
  00022	8b bc 24 bc 01
	00 00		 mov	 edi, DWORD PTR _host$[esp+436]
  00029	89 74 24 10	 mov	 DWORD PTR _on$[esp+440], esi
  0002d	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  00033	7f 22		 jg	 SHORT $LN63@new_client
  00035	57		 push	 edi
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PMGGPDKD@Entering?5new_client?5for?5host?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00040	e8 00 00 00 00	 call	 ___iob_func
  00045	83 c0 40	 add	 eax, 64			; 00000040H
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _fprintf
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 557  :     io_trace_sn(
; 558  :         "  new_client server port", port);

  00051	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
$LN63@new_client:
  00057	8b 9c 24 c0 01
	00 00		 mov	 ebx, DWORD PTR _port$[esp+436]
  0005e	7f 1c		 jg	 SHORT $LN60@new_client
  00060	53		 push	 ebx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LPKHELOA@?5?5new_client?5server?5port?$AA@
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  0006b	e8 00 00 00 00	 call	 ___iob_func
  00070	83 c0 40	 add	 eax, 64			; 00000040H
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _fprintf
  00079	83 c4 10	 add	 esp, 16			; 00000010H
$LN60@new_client:

; 559  : 
; 560  : 
; 561  :     INIT_WINSOCK();

  0007c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?done@?1??init_winsock@@9@9, 0
  00083	75 15		 jne	 SHORT $LN19@new_client
  00085	8d 44 24 24	 lea	 eax, DWORD PTR _wsadata$82329[esp+440]
  00089	50		 push	 eax
  0008a	68 01 01 00 00	 push	 257			; 00000101H
  0008f	e8 00 00 00 00	 call	 _WSAStartup@8
  00094	89 35 00 00 00
	00		 mov	 DWORD PTR ?done@?1??init_winsock@@9@9, esi
$LN19@new_client:

; 562  : 
; 563  :     /* Find information for the remote host */
; 564  : 
; 565  : #if VCC>0
; 566  :     { static cell l; char *h=(char *)&l;
; 567  : 
; 568  :       l=inet_addr(host);

  0009a	57		 push	 edi
  0009b	e8 00 00 00 00	 call	 _inet_addr@4
  000a0	a3 00 00 00 00	 mov	 DWORD PTR ?l@?2??new_client0@@9@9, eax

; 569  :       io_trace_sn("got l",l);

  000a5	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  000ab	7f 21		 jg	 SHORT $LN22@new_client
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_05FFPGNEKC@got?5l?$AA@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  000b8	e8 00 00 00 00	 call	 ___iob_func
  000bd	83 c0 40	 add	 eax, 64			; 00000040H
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _fprintf
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?l@?2??new_client0@@9@9
  000cb	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@new_client:

; 570  : 
; 571  :       if ((bp_long)l<0 && (hp = gethostbyname(host) ) == NULL) {

  000ce	85 c0		 test	 eax, eax
  000d0	79 61		 jns	 SHORT $LN56@new_client
  000d2	57		 push	 edi
  000d3	e8 00 00 00 00	 call	 _gethostbyname@4
  000d8	8b f0		 mov	 esi, eax
  000da	85 f6		 test	 esi, esi
  000dc	75 5b		 jne	 SHORT $LN57@new_client

; 572  :         io_trace_ss(
; 573  :         "Neither an IP address nor host found by name", host);

  000de	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  000e4	7f 1c		 jg	 SHORT $LN61@new_client
  000e6	57		 push	 edi
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GNBLJIP@Neither?5an?5IP?5address?5nor?5host?5f@
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  000f1	e8 00 00 00 00	 call	 ___iob_func
  000f6	83 c0 40	 add	 eax, 64			; 00000040H
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 _fprintf
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN61@new_client:

; 574  :         io_trace_sn("errorcode:", WSAGetLastError());

  00102	e8 00 00 00 00	 call	 _WSAGetLastError@0
  00107	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  0010d	7f 1c		 jg	 SHORT $LN28@new_client
  0010f	50		 push	 eax
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KBNNJDAE@errorcode?3?$AA@
$LN65@new_client:
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  0011a	e8 00 00 00 00	 call	 ___iob_func
  0011f	83 c0 40	 add	 eax, 64			; 00000040H
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _fprintf
  00128	83 c4 10	 add	 esp, 16			; 00000010H
$LN28@new_client:

; 575  :         return -1;

  0012b	83 c8 ff	 or	 eax, -1
  0012e	e9 43 02 00 00	 jmp	 $LN11@new_client
$LN56@new_client:
  00133	8b 74 24 10	 mov	 esi, DWORD PTR _hp$[esp+440]
  00137	eb 05		 jmp	 SHORT $LN10@new_client
$LN57@new_client:
  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?l@?2??new_client0@@9@9
$LN10@new_client:

; 576  :       }
; 577  : 
; 578  :       TRACE_BELOW(0)

  0013e	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  00144	7f 57		 jg	 SHORT $LN31@new_client

; 579  :       {  char buf[256];
; 580  :          sprintf(buf,"%u.%u.%u.%u",h[0],h[1],h[2],h[3]);

  00146	0f be 0d 03 00
	00 00		 movsx	 ecx, BYTE PTR ?l@?2??new_client0@@9@9+3
  0014d	0f be 15 02 00
	00 00		 movsx	 edx, BYTE PTR ?l@?2??new_client0@@9@9+2
  00154	51		 push	 ecx
  00155	52		 push	 edx
  00156	0f be cc	 movsx	 ecx, ah
  00159	0f be d0	 movsx	 edx, al
  0015c	51		 push	 ecx
  0015d	52		 push	 edx
  0015e	8d 44 24 34	 lea	 eax, DWORD PTR _buf$81882[esp+456]
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _sprintf
  0016d	83 c4 18	 add	 esp, 24			; 00000018H

; 581  :          io_trace_ss("gethostby...() got addr",buf);

  00170	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  00176	7f 20		 jg	 SHORT $LN58@new_client
  00178	8d 4c 24 24	 lea	 ecx, DWORD PTR _buf$81882[esp+440]
  0017c	51		 push	 ecx
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NNJEHFFG@gethostby?4?4?4?$CI?$CJ?5got?5addr?$AA@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00187	e8 00 00 00 00	 call	 ___iob_func
  0018c	83 c0 40	 add	 eax, 64			; 00000040H
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _fprintf
  00195	83 c4 10	 add	 esp, 16			; 00000010H
$LN58@new_client:
  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR ?l@?2??new_client0@@9@9
$LN31@new_client:

; 582  :       }
; 583  : 
; 584  :       if((bp_long)l<0) {

  0019d	85 c0		 test	 eax, eax
  0019f	79 10		 jns	 SHORT $LN8@new_client

; 585  :          io_trace_ss("Host found by name", host);

  001a1	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  001a7	7f 78		 jg	 SHORT $LN62@new_client
  001a9	57		 push	 edi
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GMPDPAKG@Host?5found?5by?5name?$AA@

; 586  :       }
; 587  :       else {

  001af	eb 5a		 jmp	 SHORT $LN64@new_client
$LN8@new_client:

; 588  :         /*try out if this host makes sense anyway ...
; 589  :         by cloning a valid "localhost" based hostent hp */
; 590  : 
; 591  :         if((hp = gethostbyname("localhost") ) == NULL) {

  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_09IPAEKDAI@localhost?$AA@
  001b6	e8 00 00 00 00	 call	 _gethostbyname@4
  001bb	8b f0		 mov	 esi, eax
  001bd	85 f6		 test	 esi, esi
  001bf	75 1c		 jne	 SHORT $LN6@new_client

; 592  :           io_trace_sn("no localhost neither, error",WSAGetLastError());

  001c1	e8 00 00 00 00	 call	 _WSAGetLastError@0
  001c6	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  001cc	0f 8f 59 ff ff
	ff		 jg	 $LN28@new_client
  001d2	50		 push	 eax
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KMOACAHG@no?5localhost?5neither?0?5error?$AA@

; 593  :           return -1;

  001d8	e9 38 ff ff ff	 jmp	 $LN65@new_client
$LN6@new_client:

; 594  :          }
; 595  : 
; 596  :          hp->h_addr=host;

  001dd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]

; 597  :          hp->h_length=strlen(host);

  001e0	8b c7		 mov	 eax, edi
  001e2	89 3a		 mov	 DWORD PTR [edx], edi
  001e4	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL55@new_client:
  001e7	8a 08		 mov	 cl, BYTE PTR [eax]
  001e9	40		 inc	 eax
  001ea	84 c9		 test	 cl, cl
  001ec	75 f9		 jne	 SHORT $LL55@new_client
  001ee	2b c2		 sub	 eax, edx
  001f0	66 89 46 0a	 mov	 WORD PTR [esi+10], ax

; 598  :          *hp->h_addr_list=h;

  001f4	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  001f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ?l@?2??new_client0@@9@9

; 599  : 
; 600  :          io_trace_ss("host assumed valid IP address", host);

  001fd	85 2d 24 00 00
	00		 test	 DWORD PTR _max+36, ebp
  00203	7f 1c		 jg	 SHORT $LN62@new_client
  00205	57		 push	 edi
  00206	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KDEAKEDI@host?5assumed?5valid?5IP?5address?$AA@
$LN64@new_client:
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
  00210	e8 00 00 00 00	 call	 ___iob_func
  00215	83 c0 40	 add	 eax, 64			; 00000040H
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _fprintf
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
$LN62@new_client:

; 601  :       }
; 602  :     }
; 603  : #else
; 604  :     if ((hp = gethostbyname(host) ) == NULL) {
; 605  :         ADDR_T addr=inet_addr(host);
; 606  :         if(addr<0) {
; 607  :           io_trace_ss(
; 608  :             "Bad IP address or host name in gethostbyname", host);
; 609  :           return -1;
; 610  :         }
; 611  :         io_trace_sn("gethostbyname() did not work but got addr",addr);
; 612  : 
; 613  :         if ((hp = gethostbyaddr((char *)&addr,sizeof(addr),AF_INET) )
; 614  :            == NULL) {
; 615  :              io_trace_ss("Host not found by gethostbyaddr", host);
; 616  :              return -1;
; 617  :         }
; 618  :         io_trace_sn("gethostbyaddr() got addr",addr);
; 619  :     }
; 620  : #endif
; 621  : 
; 622  :     /* clear out the address structure */
; 623  : 
; 624  :     memset((char *)&peeraddr_in, 0, sizeof(peeraddr_in));

  00221	33 c0		 xor	 eax, eax
  00223	89 44 24 14	 mov	 DWORD PTR _peeraddr_in$[esp+440], eax
  00227	89 44 24 18	 mov	 DWORD PTR _peeraddr_in$[esp+444], eax
  0022b	89 44 24 1c	 mov	 DWORD PTR _peeraddr_in$[esp+448], eax
  0022f	89 44 24 20	 mov	 DWORD PTR _peeraddr_in$[esp+452], eax

; 625  : 
; 626  :     /* Set up peer address for connect */
; 627  : 
; 628  :     peeraddr_in.sin_family = AF_INET;

  00233	b9 02 00 00 00	 mov	 ecx, 2
  00238	66 89 4c 24 14	 mov	 WORD PTR _peeraddr_in$[esp+440], cx

; 629  : 
; 630  :     memcpy((char *)&peeraddr_in.sin_addr, hp->h_addr, hp->h_length);

  0023d	0f bf 56 0a	 movsx	 edx, WORD PTR [esi+10]
  00241	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00244	8b 08		 mov	 ecx, DWORD PTR [eax]
  00246	52		 push	 edx
  00247	51		 push	 ecx
  00248	8d 54 24 20	 lea	 edx, DWORD PTR _peeraddr_in$[esp+452]
  0024c	52		 push	 edx
  0024d	e8 00 00 00 00	 call	 _memcpy
  00252	83 c4 0c	 add	 esp, 12			; 0000000cH

; 631  : 
; 632  :     peeraddr_in.sin_port = htons((short)port);

  00255	53		 push	 ebx
  00256	e8 00 00 00 00	 call	 _htons@4

; 633  : 
; 634  :     /* Create the socket */
; 635  : 
; 636  :     if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0)

  0025b	6a 00		 push	 0
  0025d	6a 01		 push	 1
  0025f	6a 02		 push	 2
  00261	66 89 44 24 22	 mov	 WORD PTR _peeraddr_in$[esp+454], ax
  00266	e8 00 00 00 00	 call	 _socket@12
  0026b	8b f0		 mov	 esi, eax
  0026d	85 f6		 test	 esi, esi
  0026f	79 25		 jns	 SHORT $LN5@new_client

; 637  :     {
; 638  :         perror0("Unable to create socket");

  00271	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00276	23 c5		 and	 eax, ebp
  00278	83 f8 04	 cmp	 eax, 4
  0027b	0f 8f aa fe ff
	ff		 jg	 $LN28@new_client
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BAFIBIJ@Unable?5to?5create?5socket?$AA@
  00286	e8 00 00 00 00	 call	 _perror
  0028b	83 c4 04	 add	 esp, 4
  0028e	83 c8 ff	 or	 eax, -1
  00291	e9 e0 00 00 00	 jmp	 $LN11@new_client
$LN5@new_client:

; 639  :         return -1;
; 640  :     }
; 641  : 
; 642  :     if(connect(s, (struct sockaddr *)&peeraddr_in,
; 643  :                       sizeof(peeraddr_in)) < 0)    {

  00296	6a 10		 push	 16			; 00000010H
  00298	8d 4c 24 18	 lea	 ecx, DWORD PTR _peeraddr_in$[esp+444]
  0029c	51		 push	 ecx
  0029d	56		 push	 esi
  0029e	e8 00 00 00 00	 call	 _connect@12
  002a3	85 c0		 test	 eax, eax
  002a5	79 37		 jns	 SHORT $LN4@new_client

; 644  :         if(errno != ECONNREFUSED)

  002a7	e8 00 00 00 00	 call	 __errno
  002ac	81 38 4d 27 00
	00		 cmp	 DWORD PTR [eax], 10061	; 0000274dH
  002b2	0f 84 73 fe ff
	ff		 je	 $LN28@new_client

; 645  :         {
; 646  :             perror0("Connection attempt failed");

  002b8	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  002be	23 d5		 and	 edx, ebp
  002c0	83 fa 04	 cmp	 edx, 4
  002c3	0f 8f 62 fe ff
	ff		 jg	 $LN28@new_client
  002c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LEHOMCBC@Connection?5attempt?5failed?$AA@
  002ce	e8 00 00 00 00	 call	 _perror
  002d3	83 c4 04	 add	 esp, 4
  002d6	83 c8 ff	 or	 eax, -1
  002d9	e9 98 00 00 00	 jmp	 $LN11@new_client
$LN4@new_client:

; 647  :         }
; 648  :         return -1;
; 649  :     }
; 650  : 
; 651  : 
; 652  : #if defined SO_KEEPALIVE
; 653  :     if (setsockopt(s, TOP_PROTOCOL, SO_KEEPALIVE,
; 654  :                (char *)&on, sizeof(on)) < 0)   {

  002de	6a 04		 push	 4
  002e0	8d 44 24 14	 lea	 eax, DWORD PTR _on$[esp+444]
  002e4	50		 push	 eax
  002e5	6a 08		 push	 8
  002e7	68 ff ff 00 00	 push	 65535			; 0000ffffH
  002ec	56		 push	 esi
  002ed	e8 00 00 00 00	 call	 _setsockopt@20
  002f2	85 c0		 test	 eax, eax
  002f4	79 23		 jns	 SHORT $LN2@new_client

; 655  :         perror0("Cannot set KEEPALIVE");

  002f6	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  002fc	23 cd		 and	 ecx, ebp
  002fe	83 f9 04	 cmp	 ecx, 4
  00301	0f 8f 24 fe ff
	ff		 jg	 $LN28@new_client
  00307	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ICFEAKEP@Cannot?5set?5KEEPALIVE?$AA@
  0030c	e8 00 00 00 00	 call	 _perror
  00311	83 c4 04	 add	 esp, 4
  00314	83 c8 ff	 or	 eax, -1
  00317	eb 5d		 jmp	 SHORT $LN11@new_client
$LN2@new_client:

; 656  :         return -1;
; 657  :     }
; 658  : #endif
; 659  : 
; 660  : 
; 661  : 
; 662  : #if defined TCP_NODELAY
; 663  :     if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
; 664  :                (char *)&on, sizeof(on)) < 0)   {

  00319	6a 04		 push	 4
  0031b	8d 54 24 14	 lea	 edx, DWORD PTR _on$[esp+444]
  0031f	52		 push	 edx
  00320	6a 01		 push	 1
  00322	6a 06		 push	 6
  00324	56		 push	 esi
  00325	e8 00 00 00 00	 call	 _setsockopt@20
  0032a	85 c0		 test	 eax, eax
  0032c	79 22		 jns	 SHORT $LN1@new_client

; 665  :         perror0("Cannot set TCP_NODELAY");

  0032e	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00333	23 c5		 and	 eax, ebp
  00335	83 f8 04	 cmp	 eax, 4
  00338	0f 8f ed fd ff
	ff		 jg	 $LN28@new_client
  0033e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LAMLNOO@Cannot?5set?5TCP_NODELAY?$AA@
  00343	e8 00 00 00 00	 call	 _perror
  00348	83 c4 04	 add	 esp, 4
  0034b	83 c8 ff	 or	 eax, -1
  0034e	eb 26		 jmp	 SHORT $LN11@new_client
$LN1@new_client:

; 666  :         return -1;
; 667  :     }
; 668  : #endif
; 669  : 
; 670  : 
; 671  :     io_trace_ss(
; 672  :         "Exiting new_client for host", host);

  00350	8b c7		 mov	 eax, edi
  00352	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BM@LLPBOCCK@Exiting?5new_client?5for?5host?$AA@
  00357	e8 00 00 00 00	 call	 _io_trace_ss

; 673  :     io_trace_sn(
; 674  :         "  new_client server port", port);

  0035c	8b c3		 mov	 eax, ebx
  0035e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BJ@LPKHELOA@?5?5new_client?5server?5port?$AA@
  00363	e8 00 00 00 00	 call	 _io_trace_sn

; 675  :     io_trace_sn(
; 676  :         "  new_client socket", s);

  00368	8b c6		 mov	 eax, esi
  0036a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BE@DFDDJBJC@?5?5new_client?5socket?$AA@
  0036f	e8 00 00 00 00	 call	 _io_trace_sn

; 677  : 
; 678  :     return s;

  00374	8b c6		 mov	 eax, esi
$LN11@new_client:

; 679  : }

  00376	8b 8c 24 b4 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+440]
  0037d	5f		 pop	 edi
  0037e	5e		 pop	 esi
  0037f	5d		 pop	 ebp
  00380	5b		 pop	 ebx
  00381	33 cc		 xor	 ecx, esp
  00383	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00388	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  0038e	c3		 ret	 0
_new_client0 ENDP
_TEXT	ENDS
EXTRN	_unix_sleep:PROC
; Function compile flags: /Ogtpy
;	COMDAT _sock_sleep
_TEXT	SEGMENT
_sock_sleep PROC					; COMDAT
; _secs$ = eax

; 682  : #ifndef STANDALONE_SOCKET_STUFF
; 683  :         unix_sleep(secs);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 _unix_sleep
  00006	59		 pop	 ecx

; 684  : #else
; 685  : #if VCC>0
; 686  :         _sleep((secs)*1000);
; 687  : #else
; 688  :         sleep(secs);
; 689  : #endif
; 690  : #endif
; 691  : }

  00007	c3		 ret	 0
_sock_sleep ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PFOIADOL@?$CFs?5?$CFs?3?$CFd?6?$CFs?$CFd?5?$CFs?$CFd?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@BABHCKKO@?$CK?$CK?$CK?5error?5opening?5socket?5to?$AA@ ; `string'
PUBLIC	??_C@_0CK@JEJPHPEA@no?5answer?5or?5no?5available?5socket@ ; `string'
PUBLIC	??_C@_08HHEDKDJO@waiting?$DN?$AA@		; `string'
PUBLIC	??_C@_07GELLIBDG@seconds?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_new_client
;	COMDAT ??_C@_0BH@PFOIADOL@?$CFs?5?$CFs?3?$CFd?6?$CFs?$CFd?5?$CFs?$CFd?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@PFOIADOL@?$CFs?5?$CFs?3?$CFd?6?$CFs?$CFd?5?$CFs?$CFd?5?$CFs?6?$AA@ DB '%'
	DB	's %s:%d', 0aH, '%s%d %s%d %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BABHCKKO@?$CK?$CK?$CK?5error?5opening?5socket?5to?$AA@
CONST	SEGMENT
??_C@_0BM@BABHCKKO@?$CK?$CK?$CK?5error?5opening?5socket?5to?$AA@ DB '*** '
	DB	'error opening socket to', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JEJPHPEA@no?5answer?5or?5no?5available?5socket@
CONST	SEGMENT
??_C@_0CK@JEJPHPEA@no?5answer?5or?5no?5available?5socket@ DB 'no answer o'
	DB	'r no available sockets, retry=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHEDKDJO@waiting?$DN?$AA@
CONST	SEGMENT
??_C@_08HHEDKDJO@waiting?$DN?$AA@ DB 'waiting=', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GELLIBDG@seconds?$AA@
CONST	SEGMENT
??_C@_07GELLIBDG@seconds?$AA@ DB 'seconds', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _new_client
_TEXT	SEGMENT
_sock$ = -136						; size = 4
_buf$81926 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_host$ = 8						; size = 4
_port$ = 12						; size = 4
_new_client PROC					; COMDAT

; 693  : bp_long new_client(char *host, bp_long port) {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 84 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+136], eax
  00014	53		 push	 ebx

; 694  :    bp_long sock= -1;
; 695  :    int i;
; 696  :    for(i=0; i<MAX_CLIENT_TRY; i++) {

  00015	8b 9c 24 94 00
	00 00		 mov	 ebx, DWORD PTR _port$[esp+136]
  0001c	55		 push	 ebp
  0001d	8b ac 24 94 00
	00 00		 mov	 ebp, DWORD PTR _host$[esp+140]
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	33 ff		 xor	 edi, edi
  00028	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0002b	eb 03 8d 49 00	 npad	 5
$LL4@new_client@2:

; 697  :      sock =new_client0(host,port);

  00030	53		 push	 ebx
  00031	55		 push	 ebp
  00032	e8 00 00 00 00	 call	 _new_client0
  00037	83 c4 08	 add	 esp, 8
  0003a	89 44 24 10	 mov	 DWORD PTR _sock$[esp+152], eax

; 698  :      if(sock>0) break;

  0003e	85 c0		 test	 eax, eax
  00040	7f 5c		 jg	 SHORT $LN13@new_client@2

; 699  :      sock_sleep(1<<i);

  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 _unix_sleep

; 700  :      { char buf[128];
; 701  :        sprintf(buf,
; 702  :          "%s %s:%d\n%s%d %s%d %s\n",
; 703  :          "*** error opening socket to",host,(int)port,
; 704  :          "no answer or no available sockets, retry=",
; 705  :          i,"waiting=",1<<i,"seconds");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_07GELLIBDG@seconds?$AA@
  0004d	56		 push	 esi
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_08HHEDKDJO@waiting?$DN?$AA@
  00053	57		 push	 edi
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JEJPHPEA@no?5answer?5or?5no?5available?5socket@
  00059	53		 push	 ebx
  0005a	55		 push	 ebp
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BABHCKKO@?$CK?$CK?$CK?5error?5opening?5socket?5to?$AA@
  00060	8d 44 24 38	 lea	 eax, DWORD PTR _buf$81926[esp+188]
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PFOIADOL@?$CFs?5?$CFs?3?$CFd?6?$CFs?$CFd?5?$CFs?$CFd?5?$CFs?6?$AA@
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _sprintf

; 706  :        io_mes0(buf);

  0006f	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  00075	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00078	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007b	83 f9 08	 cmp	 ecx, 8
  0007e	7f 12		 jg	 SHORT $LN3@new_client@2
  00080	8d 54 24 14	 lea	 edx, DWORD PTR _buf$81926[esp+152]
  00084	52		 push	 edx
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0008a	e8 00 00 00 00	 call	 _printf
  0008f	83 c4 08	 add	 esp, 8
$LN3@new_client@2:

; 694  :    bp_long sock= -1;
; 695  :    int i;
; 696  :    for(i=0; i<MAX_CLIENT_TRY; i++) {

  00092	47		 inc	 edi
  00093	d1 c6		 rol	 esi, 1
  00095	83 ff 02	 cmp	 edi, 2
  00098	7c 96		 jl	 SHORT $LL4@new_client@2

; 707  :      }
; 708  :    }
; 709  :    return sock;

  0009a	8b 44 24 10	 mov	 eax, DWORD PTR _sock$[esp+152]
$LN13@new_client@2:

; 710  : }

  0009e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx
  000a9	33 cc		 xor	 ecx, esp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  000b6	c3		 ret	 0
_new_client ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KALLHKCF@New?5server?5on?5port?$AA@	; `string'
PUBLIC	??_C@_0BM@CJEFNLF@Unable?5to?5listen?5on?5socket?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@KOJJJLME@Unable?5to?5bind?5stream?5socket?0?5on@ ; `string'
PUBLIC	??_C@_0CD@KHCCIEJP@Socket?5number?5not?5expected?5to?5be@ ; `string'
PUBLIC	??_C@_0BL@GBIFAPCI@Open?5Stream?5Socket?5failed?$CB?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_new_server
EXTRN	_listen@8:PROC
EXTRN	_bind@12:PROC
;	COMDAT ??_C@_0BD@KALLHKCF@New?5server?5on?5port?$AA@
CONST	SEGMENT
??_C@_0BD@KALLHKCF@New?5server?5on?5port?$AA@ DB 'New server on port', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CJEFNLF@Unable?5to?5listen?5on?5socket?6?$AA@
CONST	SEGMENT
??_C@_0BM@CJEFNLF@Unable?5to?5listen?5on?5socket?6?$AA@ DB 'Unable to lis'
	DB	'ten on socket', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KOJJJLME@Unable?5to?5bind?5stream?5socket?0?5on@
CONST	SEGMENT
??_C@_0CG@KOJJJLME@Unable?5to?5bind?5stream?5socket?0?5on@ DB 'Unable to '
	DB	'bind stream socket, on port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KHCCIEJP@Socket?5number?5not?5expected?5to?5be@
CONST	SEGMENT
??_C@_0CD@KHCCIEJP@Socket?5number?5not?5expected?5to?5be@ DB 'Socket numb'
	DB	'er not expected to be 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GBIFAPCI@Open?5Stream?5Socket?5failed?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@GBIFAPCI@Open?5Stream?5Socket?5failed?$CB?$AA@ DB 'Open Stream '
	DB	'Socket failed!', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _new_server
_TEXT	SEGMENT
_server$ = -420						; size = 16
_wsadata$82418 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_port$ = 8						; size = 4
_new_server PROC					; COMDAT

; 729  : {

  00000	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 a0 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+420], eax

; 730  :     bp_long sock;
; 731  :     struct sockaddr_in server;
; 732  :     bp_long on=1;
; 733  : 
; 734  :     /* Create socket */
; 735  : 
; 736  :     INIT_WINSOCK();

  00014	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?done@?1??init_winsock@@9@9, 0
  0001b	75 19		 jne	 SHORT $LN7@new_server
  0001d	8d 44 24 10	 lea	 eax, DWORD PTR _wsadata$82418[esp+420]
  00021	50		 push	 eax
  00022	68 01 01 00 00	 push	 257			; 00000101H
  00027	e8 00 00 00 00	 call	 _WSAStartup@8
  0002c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?done@?1??init_winsock@@9@9, 1
$LN7@new_server:

; 737  : 
; 738  :     if ((sock = socket (AF_INET, SOCK_STREAM, 0)) < 0)

  00036	56		 push	 esi
  00037	6a 00		 push	 0
  00039	6a 01		 push	 1
  0003b	6a 02		 push	 2
  0003d	e8 00 00 00 00	 call	 _socket@12
  00042	8b f0		 mov	 esi, eax
  00044	85 f6		 test	 esi, esi
  00046	79 3f		 jns	 SHORT $LN20@new_server

; 739  :     {
; 740  :         io_trace1("Open Stream Socket failed!");

  00048	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00052	7f 1b		 jg	 SHORT $LN10@new_server
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GBIFAPCI@Open?5Stream?5Socket?5failed?$CB?$AA@
$LN21@new_server:
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0005e	e8 00 00 00 00	 call	 ___iob_func
  00063	83 c0 40	 add	 eax, 64			; 00000040H
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _fprintf
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@new_server:

; 741  :         return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	5e		 pop	 esi

; 779  : 
; 780  :     return sock;
; 781  : }

  00072	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+420]
  00079	33 cc		 xor	 ecx, esp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  00086	c3		 ret	 0
$LN20@new_server:

; 742  :     }
; 743  : 
; 744  :     if(0==sock) {

  00087	75 13		 jne	 SHORT $LN3@new_server

; 745  :       io_trace1("Socket number not expected to be 0");

  00089	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  00093	7f da		 jg	 SHORT $LN10@new_server
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KHCCIEJP@Socket?5number?5not?5expected?5to?5be@

; 746  :       return 0;

  0009a	eb bd		 jmp	 SHORT $LN21@new_server
$LN3@new_server:

; 747  :     }
; 748  : 
; 749  : #if VCC==0
; 750  :     if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
; 751  :         (char *)&on, sizeof(on)) < 0)    {
; 752  :         io_trace1("Set SO_REUSEADDR failed!");
; 753  :         return 0;
; 754  :     }
; 755  : #endif
; 756  : 
; 757  :     memset ((char *) &server, 0, sizeof (server));

  0009c	33 c0		 xor	 eax, eax
  0009e	57		 push	 edi

; 758  : 
; 759  :     server.sin_family = AF_INET;
; 760  :     server.sin_port = htons((short)port);

  0009f	8b bc 24 b0 01
	00 00		 mov	 edi, DWORD PTR _port$[esp+424]
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	89 44 24 08	 mov	 DWORD PTR _server$[esp+428], eax
  000af	57		 push	 edi
  000b0	89 44 24 10	 mov	 DWORD PTR _server$[esp+436], eax
  000b4	89 44 24 14	 mov	 DWORD PTR _server$[esp+440], eax
  000b8	89 44 24 18	 mov	 DWORD PTR _server$[esp+444], eax
  000bc	66 89 4c 24 0c	 mov	 WORD PTR _server$[esp+432], cx
  000c1	e8 00 00 00 00	 call	 _htons@4

; 761  :     server.sin_addr.s_addr = htonl(INADDR_ANY);

  000c6	6a 00		 push	 0
  000c8	66 89 44 24 0e	 mov	 WORD PTR _server$[esp+434], ax
  000cd	e8 00 00 00 00	 call	 _htonl@4

; 762  : 
; 763  : 
; 764  :     if (bind (sock, (struct sockaddr *)&server, sizeof (server)) < 0)

  000d2	6a 10		 push	 16			; 00000010H
  000d4	8d 54 24 0c	 lea	 edx, DWORD PTR _server$[esp+432]
  000d8	52		 push	 edx
  000d9	56		 push	 esi
  000da	89 44 24 18	 mov	 DWORD PTR _server$[esp+444], eax
  000de	e8 00 00 00 00	 call	 _bind@12
  000e3	85 c0		 test	 eax, eax
  000e5	79 42		 jns	 SHORT $LN2@new_server

; 765  :     {
; 766  :         io_trace_snn("Unable to bind stream socket, on port",sock,port);

  000e7	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000f1	7f 1d		 jg	 SHORT $LN16@new_server
  000f3	57		 push	 edi
  000f4	56		 push	 esi
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KOJJJLME@Unable?5to?5bind?5stream?5socket?0?5on@
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000ff	e8 00 00 00 00	 call	 ___iob_func
  00104	83 c0 40	 add	 eax, 64			; 00000040H
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _fprintf
  0010d	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@new_server:

; 767  :         return 0;

  00110	5f		 pop	 edi
  00111	33 c0		 xor	 eax, eax
  00113	5e		 pop	 esi

; 779  : 
; 780  :     return sock;
; 781  : }

  00114	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+420]
  0011b	33 cc		 xor	 ecx, esp
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  00128	c3		 ret	 0
$LN2@new_server:

; 768  :     }
; 769  : 
; 770  :     /* listen on the socket */
; 771  : 
; 772  :     if (listen(sock, MAX_WAITING_CLIENTS) < 0)

  00129	68 00 04 00 00	 push	 1024			; 00000400H
  0012e	56		 push	 esi
  0012f	e8 00 00 00 00	 call	 _listen@8
  00134	85 c0		 test	 eax, eax
  00136	79 23		 jns	 SHORT $LN1@new_server

; 773  :     {
; 774  :           io_trace1("Unable to listen on socket\n");

  00138	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@CJEFNLF@Unable?5to?5listen?5on?5socket?6?$AA@
  0013d	e8 00 00 00 00	 call	 _io_trace1
  00142	5f		 pop	 edi

; 775  :           return 0;

  00143	33 c0		 xor	 eax, eax
  00145	5e		 pop	 esi

; 779  : 
; 780  :     return sock;
; 781  : }

  00146	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+420]
  0014d	33 cc		 xor	 ecx, esp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  0015a	c3		 ret	 0
$LN1@new_server:

; 776  :     }
; 777  : 
; 778  :     io_trace_sn("New server on port",port);

  0015b	8b c7		 mov	 eax, edi
  0015d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@KALLHKCF@New?5server?5on?5port?$AA@
  00162	e8 00 00 00 00	 call	 _io_trace_sn

; 779  : 
; 780  :     return sock;
; 781  : }

  00167	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+428]
  0016e	5f		 pop	 edi
  0016f	8b c6		 mov	 eax, esi
  00171	5e		 pop	 esi
  00172	33 cc		 xor	 ecx, esp
  00174	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00179	81 c4 a4 01 00
	00		 add	 esp, 420		; 000001a4H
  0017f	c3		 ret	 0
_new_server ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PBLAGILN@timeout?5?$CIsecs?$CJ?0?5on?5socket?$AA@ ; `string'
PUBLIC	??_C@_0BA@LJDAAAN@error?5on?5select?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_wait_on_socket
EXTRN	_select@20:PROC
;	COMDAT ??_C@_0BK@PBLAGILN@timeout?5?$CIsecs?$CJ?0?5on?5socket?$AA@
CONST	SEGMENT
??_C@_0BK@PBLAGILN@timeout?5?$CIsecs?$CJ?0?5on?5socket?$AA@ DB 'timeout ('
	DB	'secs), on socket', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LJDAAAN@error?5on?5select?$AA@
CONST	SEGMENT
??_C@_0BA@LJDAAAN@error?5on?5select?$AA@ DB 'error on select', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _wait_on_socket
_TEXT	SEGMENT
_timeout$ = -272					; size = 8
_read_fd$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_t$ = 12						; size = 4
_wait_on_socket PROC					; COMDAT

; 790  : bp_long wait_on_socket(bp_long sock,bp_long t) {

  00000	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+272], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi

; 791  :       bp_long sd=0;
; 792  :       fd_set read_fd;
; 793  :       struct timeval timeout;
; 794  :       timeout.tv_sec = t;
; 795  :       timeout.tv_usec= 0;
; 796  : 
; 797  :       FD_ZERO(&read_fd);
; 798  :       FD_SET(sock, &read_fd);

  00016	8b 9c 24 1c 01
	00 00		 mov	 ebx, DWORD PTR _sock$[esp+276]
  0001d	57		 push	 edi
  0001e	8b bc 24 24 01
	00 00		 mov	 edi, DWORD PTR _t$[esp+280]

; 799  : 
; 800  :       if ((sd=select(FD_SETSIZE, &read_fd, NULL, NULL,
; 801  :            (t>0)?(&timeout):NULL)) < 0) {

  00025	33 c0		 xor	 eax, eax
  00027	85 ff		 test	 edi, edi
  00029	0f 9e c0	 setle	 al
  0002c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _timeout$[esp+284]
  00030	8d 54 24 14	 lea	 edx, DWORD PTR _read_fd$[esp+284]
  00034	89 7c 24 0c	 mov	 DWORD PTR _timeout$[esp+284], edi
  00038	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _timeout$[esp+288], 0
  00040	89 5c 24 18	 mov	 DWORD PTR _read_fd$[esp+288], ebx
  00044	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR _read_fd$[esp+284], 1
  0004c	48		 dec	 eax
  0004d	23 c1		 and	 eax, ecx
  0004f	50		 push	 eax
  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	52		 push	 edx
  00055	6a 40		 push	 64			; 00000040H
  00057	e8 00 00 00 00	 call	 _select@20
  0005c	8b f0		 mov	 esi, eax
  0005e	85 f6		 test	 esi, esi
  00060	79 42		 jns	 SHORT $LN18@wait_on_so

; 802  :            io_trace_sn("error on select",sd);

  00062	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0006c	7f 1c		 jg	 SHORT $LN10@wait_on_so
  0006e	56		 push	 esi
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LJDAAAN@error?5on?5select?$AA@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  00079	e8 00 00 00 00	 call	 ___iob_func
  0007e	83 c0 40	 add	 eax, 64			; 00000040H
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _fprintf
  00087	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@wait_on_so:

; 803  :            sd=0;

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	33 c0		 xor	 eax, eax
  0008e	5b		 pop	 ebx

; 810  : }

  0008f	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  00096	33 cc		 xor	 ecx, esp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  000a3	c3		 ret	 0
$LN18@wait_on_so:

; 804  :       }
; 805  :       else if(0==sd) {

  000a4	75 2b		 jne	 SHORT $LN13@wait_on_so

; 806  :            io_trace_snn("timeout (secs), on socket",t,sock);

  000a6	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000b0	7f 1f		 jg	 SHORT $LN13@wait_on_so
  000b2	53		 push	 ebx
  000b3	57		 push	 edi
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PBLAGILN@timeout?5?$CIsecs?$CJ?0?5on?5socket?$AA@
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JNOMPAHH@?$CFs?3?5?$CFld?0?5?$CFld?6?$AA@
  000be	e8 00 00 00 00	 call	 ___iob_func
  000c3	83 c0 40	 add	 eax, 64			; 00000040H
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _fprintf
  000cc	83 c4 14	 add	 esp, 20			; 00000014H

; 807  :            /*sd=0;*/
; 808  :       }
; 809  :       return sd;

  000cf	8b c6		 mov	 eax, esi
$LN13@wait_on_so:

; 810  : }

  000d1	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+284]
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	33 cc		 xor	 ecx, esp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  000e8	c3		 ret	 0
_wait_on_socket ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NDHCAHIO@Set?5TCP_NODELAY?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BI@DFIKPCIA@Set?5SO_KEEPALIVE?5failed?$AA@ ; `string'
PUBLIC	??_C@_0O@BMGFIIHF@Accept?5failed?$AA@		; `string'
PUBLIC	??_C@_0BK@PMHHIODI@Ready?5to?5accept?5on?5socket?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_new_service
EXTRN	_accept@12:PROC
;	COMDAT ??_C@_0BH@NDHCAHIO@Set?5TCP_NODELAY?5failed?$AA@
CONST	SEGMENT
??_C@_0BH@NDHCAHIO@Set?5TCP_NODELAY?5failed?$AA@ DB 'Set TCP_NODELAY fail'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFIKPCIA@Set?5SO_KEEPALIVE?5failed?$AA@
CONST	SEGMENT
??_C@_0BI@DFIKPCIA@Set?5SO_KEEPALIVE?5failed?$AA@ DB 'Set SO_KEEPALIVE fa'
	DB	'iled', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BMGFIIHF@Accept?5failed?$AA@
CONST	SEGMENT
??_C@_0O@BMGFIIHF@Accept?5failed?$AA@ DB 'Accept failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PMHHIODI@Ready?5to?5accept?5on?5socket?$AA@
CONST	SEGMENT
??_C@_0BK@PMHHIODI@Ready?5to?5accept?5on?5socket?$AA@ DB 'Ready to accept'
	DB	' on socket', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _new_service
_TEXT	SEGMENT
_on$ = -28						; size = 4
_addrlen$ = -24						; size = 4
_peeraddr$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_sock$ = 8						; size = 4
_t$ = 12						; size = 4
_new_service PROC					; COMDAT

; 816  : bp_long new_service(bp_long sock,bp_long t) {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax

; 817  :       bp_long sd=0;
; 818  :       bp_long on=1;
; 819  :       struct sockaddr_in peeraddr;
; 820  :       unsigned int addrlen=sizeof(peeraddr);
; 821  : 
; 822  :       sd=wait_on_socket(sock,t);

  0000e	8b 44 24 24	 mov	 eax, DWORD PTR _t$[esp+24]
  00012	56		 push	 esi
  00013	8b 74 24 24	 mov	 esi, DWORD PTR _sock$[esp+28]
  00017	50		 push	 eax
  00018	56		 push	 esi
  00019	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR _on$[esp+40], 1
  00021	c7 44 24 10 10
	00 00 00	 mov	 DWORD PTR _addrlen$[esp+40], 16 ; 00000010H
  00029	e8 00 00 00 00	 call	 _wait_on_socket
  0002e	83 c4 08	 add	 esp, 8

; 823  :       if(!sd) return 0;

  00031	85 c0		 test	 eax, eax
  00033	74 58		 je	 SHORT $LN10@new_servic

; 824  : 
; 825  :       io_trace_sn("Ready to accept on socket",sock);

  00035	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  0003f	7f 1c		 jg	 SHORT $LN7@new_servic
  00041	56		 push	 esi
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PMHHIODI@Ready?5to?5accept?5on?5socket?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  0004c	e8 00 00 00 00	 call	 ___iob_func
  00051	83 c0 40	 add	 eax, 64			; 00000040H
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _fprintf
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@new_servic:

; 826  : 
; 827  :       if ((sd = accept(sock, (struct sockaddr *)&peeraddr,
; 828  :                                                  &addrlen)) < 0) {

  0005d	8d 4c 24 08	 lea	 ecx, DWORD PTR _addrlen$[esp+32]
  00061	51		 push	 ecx
  00062	8d 54 24 10	 lea	 edx, DWORD PTR _peeraddr$[esp+36]
  00066	52		 push	 edx
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 _accept@12
  0006d	8b f0		 mov	 esi, eax
  0006f	85 f6		 test	 esi, esi
  00071	79 2c		 jns	 SHORT $LN3@new_servic

; 829  :            perror0("Accept failed");

  00073	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00078	83 e0 fc	 and	 eax, -4			; fffffffcH
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	7f 0d		 jg	 SHORT $LN10@new_servic
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BMGFIIHF@Accept?5failed?$AA@
  00085	e8 00 00 00 00	 call	 _perror
  0008a	83 c4 04	 add	 esp, 4
$LN10@new_servic:

; 830  :            return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	5e		 pop	 esi

; 851  :       }
; 852  : #endif
; 853  : 
; 854  : 
; 855  : #if 0
; 856  :       io_mes_sns("peer socket socket from port, host ",
; 857  :         peer_port(sd),peer_addr(sd) );
; 858  : #endif
; 859  : 
; 860  :       return sd;
; 861  : }

  00090	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00094	33 cc		 xor	 ecx, esp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009e	c3		 ret	 0
$LN3@new_servic:

; 831  :       }
; 832  : 
; 833  : 
; 834  : #if defined SO_KEEPALIVE
; 835  :       if (setsockopt(sd, TOP_PROTOCOL, SO_KEEPALIVE,
; 836  :                         (char *)&on, sizeof(on)) < 0) {

  0009f	6a 04		 push	 4
  000a1	8d 4c 24 08	 lea	 ecx, DWORD PTR _on$[esp+36]
  000a5	51		 push	 ecx
  000a6	6a 08		 push	 8
  000a8	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 _setsockopt@20
  000b3	85 c0		 test	 eax, eax
  000b5	79 5b		 jns	 SHORT $LN2@new_servic

; 837  :            close_socket(sd);

  000b7	f7 05 24 00 00
	00 fc ff ff ff	 test	 DWORD PTR _max+36, -4	; fffffffcH
  000c1	7f 1c		 jg	 SHORT $LN15@new_servic
  000c3	56		 push	 esi
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JBALDMDD@closing?5socket?$AA@
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_08DFBACGFN@?$CFs?3?5?$CFld?6?$AA@
  000ce	e8 00 00 00 00	 call	 ___iob_func
  000d3	83 c0 40	 add	 eax, 64			; 00000040H
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _fprintf
  000dc	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@new_servic:
  000df	56		 push	 esi
  000e0	e8 00 00 00 00	 call	 _closesocket@4

; 838  :            perror0("Set SO_KEEPALIVE failed");

  000e5	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  000eb	83 e2 fc	 and	 edx, -4			; fffffffcH
  000ee	83 fa 04	 cmp	 edx, 4
  000f1	7f 9a		 jg	 SHORT $LN10@new_servic
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DFIKPCIA@Set?5SO_KEEPALIVE?5failed?$AA@
  000f8	e8 00 00 00 00	 call	 _perror
  000fd	83 c4 04	 add	 esp, 4

; 839  :            return 0;

  00100	33 c0		 xor	 eax, eax
  00102	5e		 pop	 esi

; 851  :       }
; 852  : #endif
; 853  : 
; 854  : 
; 855  : #if 0
; 856  :       io_mes_sns("peer socket socket from port, host ",
; 857  :         peer_port(sd),peer_addr(sd) );
; 858  : #endif
; 859  : 
; 860  :       return sd;
; 861  : }

  00103	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00107	33 cc		 xor	 ecx, esp
  00109	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00111	c3		 ret	 0
$LN2@new_servic:

; 840  :       }
; 841  : #endif
; 842  : 
; 843  : 
; 844  : 
; 845  : #if defined TCP_NODELAY
; 846  :        if (setsockopt(sd, IPPROTO_TCP, TCP_NODELAY,
; 847  :                         (char *)&on, sizeof(on)) < 0) {

  00112	6a 04		 push	 4
  00114	8d 44 24 08	 lea	 eax, DWORD PTR _on$[esp+36]
  00118	50		 push	 eax
  00119	6a 01		 push	 1
  0011b	6a 06		 push	 6
  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 _setsockopt@20
  00123	85 c0		 test	 eax, eax
  00125	79 3a		 jns	 SHORT $LN1@new_servic

; 848  :            close_socket(sd);

  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 _close_socket

; 849  :            perror0("Set TCP_NODELAY failed");

  0012d	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  00133	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00136	83 c4 04	 add	 esp, 4
  00139	83 f9 04	 cmp	 ecx, 4
  0013c	0f 8f 4b ff ff
	ff		 jg	 $LN10@new_servic
  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NDHCAHIO@Set?5TCP_NODELAY?5failed?$AA@
  00147	e8 00 00 00 00	 call	 _perror
  0014c	83 c4 04	 add	 esp, 4

; 850  :            return 0;

  0014f	33 c0		 xor	 eax, eax
  00151	5e		 pop	 esi

; 851  :       }
; 852  : #endif
; 853  : 
; 854  : 
; 855  : #if 0
; 856  :       io_mes_sns("peer socket socket from port, host ",
; 857  :         peer_port(sd),peer_addr(sd) );
; 858  : #endif
; 859  : 
; 860  :       return sd;
; 861  : }

  00152	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00156	33 cc		 xor	 ecx, esp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00160	c3		 ret	 0
$LN1@new_servic:
  00161	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00165	8b c6		 mov	 eax, esi
  00167	5e		 pop	 esi
  00168	33 cc		 xor	 ecx, esp
  0016a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00172	c3		 ret	 0
_new_service ENDP
_TEXT	ENDS
END
