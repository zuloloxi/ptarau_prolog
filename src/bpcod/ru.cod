; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\ru.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BL@ENDCLDLC@No?5definition?5for?3?5?$CFs?1?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_09NFABFJEF@BinProlog?$AA@			; `string'
PUBLIC	_max
_DATA	SEGMENT
COMM	_g:BYTE:01c0H
_DATA	ENDS
_BSS	SEGMENT
?ctr@?1??bp_interrupt_handler@@9@9 DD 01H DUP (?)	; `bp_interrupt_handler'::`2'::ctr
?last_interrupt_time@?1??bp_interrupt_handler@@9@9 DD 01H DUP (?) ; `bp_interrupt_handler'::`2'::last_interrupt_time
_BSS	ENDS
;	COMDAT ??_C@_0BL@ENDCLDLC@No?5definition?5for?3?5?$CFs?1?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@ENDCLDLC@No?5definition?5for?3?5?$CFs?1?$CFd?4?6?$AA@ DB 'No de'
	DB	'finition for: %s/%d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFABFJEF@BinProlog?$AA@
CONST	SEGMENT
??_C@_09NFABFJEF@BinProlog?$AA@ DB 'BinProlog', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_max	DD	01fffc0H
	DD	040000H
	DD	040000H
	DD	040000H
	DD	040000H
	DD	040000H
	DD	040000H
	DD	040000H
	DD	01400000H
	DD	09H
	DD	05H
	DD	0c9H
	DD	09H
	DD	01H
?name@?1??bp_version@@9@9 DD FLAT:??_C@_09NFABFJEF@BinProlog?$AA@ ; `bp_version'::`2'::name
?format_mes@?1??init_const_instr@@9@9 DD FLAT:??_C@_0BL@ENDCLDLC@No?5definition?5for?3?5?$CFs?1?$CFd?4?6?$AA@ ; `init_const_instr'::`2'::format_mes
_DATA	ENDS
PUBLIC	_quietmes
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\ru.c
;	COMDAT _quietmes
_TEXT	SEGMENT
_format$ = 8						; size = 4
_mes$ = 12						; size = 4
_quietmes PROC						; COMDAT

; 80   :   if(QLEVEL()<5) fprintf(STD_err,format,mes);

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00005	83 e0 fc	 and	 eax, -4			; fffffffcH
  00008	83 f8 14	 cmp	 eax, 20			; 00000014H
  0000b	7d 1b		 jge	 SHORT $LN1@quietmes
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _mes$[esp-4]
  00011	8b 54 24 04	 mov	 edx, DWORD PTR _format$[esp-4]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ___iob_func
  0001c	83 c0 40	 add	 eax, 64			; 00000040H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@quietmes:

; 81   : }

  00028	c3		 ret	 0
_quietmes ENDP
_TEXT	ENDS
PUBLIC	_debugmes
; Function compile flags: /Ogtpy
;	COMDAT _debugmes
_TEXT	SEGMENT
_format$ = 8						; size = 4
_mes$ = 12						; size = 4
_debugmes PROC						; COMDAT

; 86   :   if(QLEVEL()<1) fprintf(STD_err,format,mes);

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00005	83 e0 fc	 and	 eax, -4			; fffffffcH
  00008	83 f8 04	 cmp	 eax, 4
  0000b	7d 1b		 jge	 SHORT $LN1@debugmes
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _mes$[esp-4]
  00011	8b 54 24 04	 mov	 edx, DWORD PTR _format$[esp-4]
  00015	51		 push	 ecx
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ___iob_func
  0001c	83 c0 40	 add	 eax, 64			; 00000040H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@debugmes:

; 87   : }

  00028	c3		 ret	 0
_debugmes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FJBEBFDD@?$CFs?0?5?$CD?$CFd?4?$CF02d?$AA@ ; `string'
PUBLIC	_bp_version
EXTRN	_sprintf:PROC
_BSS	SEGMENT
?mes@?1??bp_version@@9@9 DB 020H DUP (?)		; `bp_version'::`2'::mes
_BSS	ENDS
;	COMDAT ??_C@_0N@FJBEBFDD@?$CFs?0?5?$CD?$CFd?4?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@FJBEBFDD@?$CFs?0?5?$CD?$CFd?4?$CF02d?$AA@ DB '%s, #%d.%02d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bp_version
_TEXT	SEGMENT
_bp_version PROC					; COMDAT

; 91   :   static char mes[32];
; 92   :   static char* name="BinProlog";
; 93   :   sprintf(mes,"%s, #%d.%02d",name,VERSION/100, VERSION % 100);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?name@?1??bp_version@@9@9
  00005	6a 00		 push	 0
  00007	6a 0c		 push	 12			; 0000000cH
  00009	50		 push	 eax
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJBEBFDD@?$CFs?0?5?$CD?$CFd?4?$CF02d?$AA@
  0000f	68 00 00 00 00	 push	 OFFSET ?mes@?1??bp_version@@9@9
  00014	e8 00 00 00 00	 call	 _sprintf
  00019	83 c4 14	 add	 esp, 20			; 00000014H

; 94   :   return mes;

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ?mes@?1??bp_version@@9@9

; 95   : }

  00021	c3		 ret	 0
_bp_version ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@KMHMJNFB@?6?$CFs?5?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?6Detected?5@ ; `string'
PUBLIC	??_C@_0CF@JOHHIFCH@Copyright?5?$CIC?$CJ?5Paul?5Tarau?51992?920@ ; `string'
PUBLIC	??_C@_0CH@ILAFFCBC@Open?9sourced?5under?5GPL?5v?43?5licen@ ; `string'
PUBLIC	??_C@_0CJ@NHJGDNMO@http?3?1?1www?4gnu?4org?1licenses?1gpl?9@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BI@PDDEFJKG@?$CIwith?5heap?5GC?5enabled?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@GHOKLKNP@?$CIwith?5Windows?5threads?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_07FLPJLDFI@32?5bits?$AA@			; `string'
PUBLIC	??_C@_0BM@PPJNGGNJ@type?5bp?5?9p10?5to?5detect?5host?$AA@ ; `string'
PUBLIC	??_C@_0L@HIPLANPJ@undetected?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BG@HMLIKMNH@?$CIC?9ified?5standalone?$CJ?6?$AA@ ; `string'
PUBLIC	_startup_mes
EXTRN	_c_interface:DWORD
EXTRN	_get_ip_addr:PROC
EXTRN	_get_host:PROC
_BSS	SEGMENT
?mes@?1??startup_mes@@9@9 DB 0200H DUP (?)		; `startup_mes'::`2'::mes
_BSS	ENDS
;	COMDAT ??_C@_0DC@KMHMJNFB@?6?$CFs?5?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?6Detected?5@
CONST	SEGMENT
??_C@_0DC@KMHMJNFB@?6?$CFs?5?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?6Detected?5@ DB 0aH
	DB	'%s %s%s%s%s%s%s%s%s%s', 0aH, 'Detected hostname: %s (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JOHHIFCH@Copyright?5?$CIC?$CJ?5Paul?5Tarau?51992?920@
CONST	SEGMENT
??_C@_0CF@JOHHIFCH@Copyright?5?$CIC?$CJ?5Paul?5Tarau?51992?920@ DB 'Copyr'
	DB	'ight (C) Paul Tarau 1992-2012.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ILAFFCBC@Open?9sourced?5under?5GPL?5v?43?5licen@
CONST	SEGMENT
??_C@_0CH@ILAFFCBC@Open?9sourced?5under?5GPL?5v?43?5licen@ DB 'Open-sourc'
	DB	'ed under GPL v.3 licence at', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NHJGDNMO@http?3?1?1www?4gnu?4org?1licenses?1gpl?9@
CONST	SEGMENT
??_C@_0CJ@NHJGDNMO@http?3?1?1www?4gnu?4org?1licenses?1gpl?9@ DB 'http://w'
	DB	'ww.gnu.org/licenses/gpl-3.0.txt.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PDDEFJKG@?$CIwith?5heap?5GC?5enabled?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0BI@PDDEFJKG@?$CIwith?5heap?5GC?5enabled?$CJ?5?$AA@ DB '(with heap '
	DB	'GC enabled) ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GHOKLKNP@?$CIwith?5Windows?5threads?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0BI@GHOKLKNP@?$CIwith?5Windows?5threads?$CJ?5?$AA@ DB '(with Window'
	DB	's threads) ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FLPJLDFI@32?5bits?$AA@
CONST	SEGMENT
??_C@_07FLPJLDFI@32?5bits?$AA@ DB '32 bits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPJNGGNJ@type?5bp?5?9p10?5to?5detect?5host?$AA@
CONST	SEGMENT
??_C@_0BM@PPJNGGNJ@type?5bp?5?9p10?5to?5detect?5host?$AA@ DB 'type bp -p1'
	DB	'0 to detect host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HIPLANPJ@undetected?$AA@
CONST	SEGMENT
??_C@_0L@HIPLANPJ@undetected?$AA@ DB 'undetected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HMLIKMNH@?$CIC?9ified?5standalone?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BG@HMLIKMNH@?$CIC?9ified?5standalone?$CJ?6?$AA@ DB '(C-ified stand'
	DB	'alone)', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _startup_mes
_TEXT	SEGMENT
_startup_mes PROC					; COMDAT

; 99   :           gc,th,x86,host,ip;
; 100  :      static char mes[512];
; 101  : 
; 102  : 
; 103  : copyright="Copyright (C) Paul Tarau 1992-2012.\n";
; 104  : ftp=  "Open-sourced under GPL v.3 licence at\n";
; 105  : email="http://www.gnu.org/licenses/gpl-3.0.txt.";
; 106  : chat="\n";
; 107  :      c_ified = (g.inC ? "(C-ified standalone)\n" : "") ;

  00000	83 3d d4 00 00
	00 00		 cmp	 DWORD PTR _g+212, 0
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0BG@HMLIKMNH@?$CIC?9ified?5standalone?$CJ?6?$AA@
  0000f	75 05		 jne	 SHORT $LN6@startup_me
  00011	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN6@startup_me:

; 108  : 
; 109  : 
; 110  : #if GC==0
; 111  :      gc="";
; 112  : #else
; 113  :      gc="(with heap GC enabled) ";
; 114  : #endif
; 115  : 
; 116  : #if THREADS==0
; 117  :      th="";
; 118  : #else
; 119  : #if VCC>0
; 120  : 	 th="(with Windows threads) ";
; 121  : #else
; 122  : 	 th="(with POSIX threads) ";
; 123  : #endif
; 124  : #endif
; 125  : 
; 126  : 	 x86 = (8 == sizeof(long)) ? "(64 bits)" : "32 bits";
; 127  : 
; 128  :      if(10==OUTPUT_INT(max.PORT)) {

  00016	a1 34 00 00 00	 mov	 eax, DWORD PTR _max+52
  0001b	83 e0 fc	 and	 eax, -4			; fffffffcH
  0001e	83 f8 28	 cmp	 eax, 40			; 00000028H
  00021	75 10		 jne	 SHORT $LN2@startup_me

; 129  :        host=get_host();

  00023	e8 00 00 00 00	 call	 _get_host
  00028	8b f0		 mov	 esi, eax

; 130  : 	   ip=get_ip_addr();

  0002a	e8 00 00 00 00	 call	 _get_ip_addr
  0002f	8b f8		 mov	 edi, eax

; 131  : 	 }
; 132  : 	 else {

  00031	eb 0a		 jmp	 SHORT $LN1@startup_me
$LN2@startup_me:

; 133  : 	   host="undetected";

  00033	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0L@HIPLANPJ@undetected?$AA@

; 134  : 	   ip="type bp -p10 to detect host";

  00038	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0BM@PPJNGGNJ@type?5bp?5?9p10?5to?5detect?5host?$AA@
$LN1@startup_me:

; 135  : 	 };
; 136  :      sprintf(mes,
; 137  :            "\n%s %s%s%s%s%s%s%s%s%s\nDetected hostname: %s (%s)",
; 138  :       bp_version(),
; 139  :       copyright,
; 140  :       ftp,
; 141  :       email,
; 142  :       chat,
; 143  :       c_ified,gc,th,x86,
; 144  :       c_interface,
; 145  :       host,
; 146  :       ip
; 147  :      );

  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?name@?1??bp_version@@9@9
  00043	6a 00		 push	 0
  00045	6a 0c		 push	 12			; 0000000cH
  00047	51		 push	 ecx
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJBEBFDD@?$CFs?0?5?$CD?$CFd?4?$CF02d?$AA@
  0004d	68 00 00 00 00	 push	 OFFSET ?mes@?1??bp_version@@9@9
  00052	e8 00 00 00 00	 call	 _sprintf
  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _c_interface
  0005d	57		 push	 edi
  0005e	56		 push	 esi
  0005f	52		 push	 edx
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_07FLPJLDFI@32?5bits?$AA@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GHOKLKNP@?$CIwith?5Windows?5threads?$CJ?5?$AA@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@PDDEFJKG@?$CIwith?5heap?5GC?5enabled?$CJ?5?$AA@
  0006f	53		 push	 ebx
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NHJGDNMO@http?3?1?1www?4gnu?4org?1licenses?1gpl?9@
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@ILAFFCBC@Open?9sourced?5under?5GPL?5v?43?5licen@
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JOHHIFCH@Copyright?5?$CIC?$CJ?5Paul?5Tarau?51992?920@
  00084	68 00 00 00 00	 push	 OFFSET ?mes@?1??bp_version@@9@9
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KMHMJNFB@?6?$CFs?5?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?$CFs?6Detected?5@
  0008e	68 00 00 00 00	 push	 OFFSET ?mes@?1??startup_mes@@9@9
  00093	e8 00 00 00 00	 call	 _sprintf
  00098	83 c4 4c	 add	 esp, 76			; 0000004cH
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi

; 148  :       return mes;

  0009d	b8 00 00 00 00	 mov	 eax, OFFSET ?mes@?1??startup_mes@@9@9
  000a2	5b		 pop	 ebx

; 149  : }

  000a3	c3		 ret	 0
_startup_mes ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtpy
; File c:\a15\ms_vs10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	_cputime
EXTRN	_clock:PROC
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\ru.c
;	COMDAT _cputime
_TEXT	SEGMENT
_cputime PROC						; COMDAT

; 157  : 
; 158  :   bp_long t=clock(),s=CLOCKS_PER_SEC;

  00000	e8 00 00 00 00	 call	 _clock

; 159  : 
; 160  :   if (s<0) t=0;
; 161  : 
; 162  :   else if(s<1000) t=(t*100)/(s/10);
; 163  : 
; 164  :   else t=100*t/(s/10);

  00005	6b c0 64	 imul	 eax, 100		; 00000064H
  00008	8b c8		 mov	 ecx, eax
  0000a	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0000f	f7 e9		 imul	 ecx
  00011	c1 fa 05	 sar	 edx, 5
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	03 c2		 add	 eax, edx

; 165  : 
; 166  :   return t;
; 167  : 
; 168  : }

  0001b	c3		 ret	 0
_cputime ENDP
_TEXT	ENDS
PUBLIC	_realtime
_BSS	SEGMENT
?startval@?1??realtime@@9@9 DD 01H DUP (?)		; `realtime'::`2'::startval
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _realtime
_TEXT	SEGMENT
$T7379 = -8						; size = 8
_todo$ = 8						; size = 4
_realtime PROC						; COMDAT

; 176  : #if 0
; 177  :   return cputime();
; 178  : #else
; 179  :   /* Solaris,HP,DEC.MIPS probably fine for all Unixes */
; 180  : 
; 181  :   static no startval; no rtime;
; 182  : 
; 183  :   if(0==todo) { /* use this to initialize time */

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _todo$[esp-4]
  00004	83 ec 08	 sub	 esp, 8
  00007	85 c0		 test	 eax, eax
  00009	75 17		 jne	 SHORT $LN6@realtime

; 184  :     startval=GET_RTIME();

  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __time64
  00011	83 c4 04	 add	 esp, 4
  00014	2d 80 f0 05 2f	 sub	 eax, 788918400		; 2f05f080H
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?startval@?1??realtime@@9@9, eax

; 199  : #endif
; 200  : }

  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
$LN6@realtime:

; 185  :     rtime=startval;
; 186  :   }
; 187  :   else if(1==todo) { /* gets last measured time */

  00022	83 f8 01	 cmp	 eax, 1
  00025	75 09		 jne	 SHORT $LN4@realtime

; 195  :   }
; 196  : 
; 197  :   /*fprintf(STD_err,"realtime(%d)=%d\n",todo,rtime);*/
; 198  :   return rtime;

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?startval@?1??realtime@@9@9

; 199  : #endif
; 200  : }

  0002c	83 c4 08	 add	 esp, 8
  0002f	c3		 ret	 0
$LN4@realtime:

; 188  :     rtime=startval;
; 189  :   }
; 190  :   else if(2==todo) { /* use for time past since start */
; 191  :     rtime=GET_RTIME()-startval;

  00030	6a 00		 push	 0
  00032	83 f8 02	 cmp	 eax, 2
  00035	75 1b		 jne	 SHORT $LN2@realtime
  00037	e8 00 00 00 00	 call	 __time64
  0003c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?startval@?1??realtime@@9@9

; 192  :   }
; 193  :   else {
; 194  :     rtime=GET_RTIME(); /* plain current time */

  00042	83 c4 04	 add	 esp, 4
  00045	89 54 24 04	 mov	 DWORD PTR $T7379[esp+12], edx
  00049	2d 80 f0 05 2f	 sub	 eax, 788918400		; 2f05f080H

; 199  : #endif
; 200  : }

  0004e	83 c4 08	 add	 esp, 8
  00051	c3		 ret	 0
$LN2@realtime:

; 192  :   }
; 193  :   else {
; 194  :     rtime=GET_RTIME(); /* plain current time */

  00052	e8 00 00 00 00	 call	 __time64
  00057	83 c4 04	 add	 esp, 4
  0005a	2d 80 f0 05 2f	 sub	 eax, 788918400		; 2f05f080H

; 199  : #endif
; 200  : }

  0005f	83 c4 08	 add	 esp, 8
  00062	c3		 ret	 0
_realtime ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0DA@FDAAKDLL@?6Prolog?5execution?5?$CFs?$CI?$CFld?$CJ?4?5CPU?5t@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_bp_exit_mes
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FDAAKDLL@?6Prolog?5execution?5?$CFs?$CI?$CFld?$CJ?4?5CPU?5t@
CONST	SEGMENT
??_C@_0DA@FDAAKDLL@?6Prolog?5execution?5?$CFs?$CI?$CFld?$CJ?4?5CPU?5t@ DB 0aH
	DB	'Prolog execution %s(%ld). CPU time = %ld.%lds', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bp_exit_mes
_TEXT	SEGMENT
_buf$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_mes$ = 8						; size = 4
_i$ = 12						; size = 4
_bp_exit_mes PROC					; COMDAT

; 204  : void bp_exit_mes(string mes, bp_long i) {

  00000	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 00 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+260], eax
  00014	56		 push	 esi
  00015	8b b4 24 0c 01
	00 00		 mov	 esi, DWORD PTR _mes$[esp+260]

; 205  :   bp_long t=cputime()-g.stime; char buf[255];

  0001c	e8 00 00 00 00	 call	 _clock
  00021	6b c0 64	 imul	 eax, 100		; 00000064H
  00024	8b c8		 mov	 ecx, eax
  00026	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0002b	f7 e9		 imul	 ecx
  0002d	c1 fa 05	 sar	 edx, 5
  00030	8b ca		 mov	 ecx, edx
  00032	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00035	03 ca		 add	 ecx, edx
  00037	2b 0d 20 01 00
	00		 sub	 ecx, DWORD PTR _g+288

; 206  :   sprintf(buf,
; 207  :  "\nProlog execution %s(%ld). CPU time = %ld.%lds\n",mes,i,t/1000,t%1000);

  0003d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00042	f7 e9		 imul	 ecx
  00044	c1 fa 06	 sar	 edx, 6
  00047	8b c2		 mov	 eax, edx
  00049	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004c	03 c2		 add	 eax, edx
  0004e	8b d0		 mov	 edx, eax
  00050	69 d2 e8 03 00
	00		 imul	 edx, 1000		; 000003e8H
  00056	2b ca		 sub	 ecx, edx
  00058	51		 push	 ecx
  00059	50		 push	 eax
  0005a	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR _i$[esp+268]
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	8d 4c 24 14	 lea	 ecx, DWORD PTR _buf$[esp+280]
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FDAAKDLL@?6Prolog?5execution?5?$CFs?$CI?$CFld?$CJ?4?5CPU?5t@
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 _sprintf

; 208  :   quietmes("%s\n",buf);

  00072	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  00078	83 c4 18	 add	 esp, 24			; 00000018H
  0007b	83 e2 fc	 and	 edx, -4			; fffffffcH
  0007e	5e		 pop	 esi
  0007f	83 fa 14	 cmp	 edx, 20			; 00000014H
  00082	7d 1a		 jge	 SHORT $LN9@bp_exit_me
  00084	8d 04 24	 lea	 eax, DWORD PTR _buf$[esp+260]
  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0008d	e8 00 00 00 00	 call	 ___iob_func
  00092	83 c0 40	 add	 eax, 64			; 00000040H
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _fprintf
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@bp_exit_me:

; 209  : }

  0009e	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+260]
  000a5	33 cc		 xor	 ecx, esp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  000b2	c3		 ret	 0
_bp_exit_mes ENDP
_TEXT	ENDS
PUBLIC	_bp_exit
EXTRN	_exit:PROC
EXTRN	_release_mutexes:PROC
; Function compile flags: /Ogtpy
;	COMDAT _bp_exit
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_i$ = 12						; size = 4
_bp_exit PROC						; COMDAT

; 211  : void bp_exit(string mes, bp_long i) {

  00000	56		 push	 esi

; 212  :   release_mutexes();

  00001	e8 00 00 00 00	 call	 _release_mutexes

; 213  :   bp_exit_mes(mes,i);

  00006	8b 74 24 0c	 mov	 esi, DWORD PTR _i$[esp]
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR _mes$[esp]
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _bp_exit_mes
  00015	83 c4 08	 add	 esp, 8

; 214  :   exit(i);

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _exit
  0001e	5e		 pop	 esi
$LN3@bp_exit:
_bp_exit ENDP
_TEXT	ENDS
PUBLIC	??_C@_06OOHAPEBD@halted?$AA@			; `string'
PUBLIC	_bp_halt
;	COMDAT ??_C@_06OOHAPEBD@halted?$AA@
CONST	SEGMENT
??_C@_06OOHAPEBD@halted?$AA@ DB 'halted', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bp_halt
_TEXT	SEGMENT
_i$ = 8							; size = 4
_bp_halt PROC						; COMDAT

; 218  :   bp_exit("halted",i);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  0000a	e8 00 00 00 00	 call	 _bp_exit
$LN3@bp_halt:
  0000f	cc		 int	 3
_bp_halt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@ ; `string'
PUBLIC	_warnmes
;	COMDAT ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
CONST	SEGMENT
??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@ DB 'w'
	DB	'arning: *** %s ***', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _warnmes
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_warnmes PROC						; COMDAT

; 223  :   fprintf(STD_err,"warning: *** %s ***\n",mes);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  0000a	e8 00 00 00 00	 call	 ___iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fprintf
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  : }

  0001b	c3		 ret	 0
_warnmes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GEPHBMGF@fatal?5error?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@ ; `string'
PUBLIC	_fatal_error
;	COMDAT ??_C@_0BJ@GEPHBMGF@fatal?5error?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GEPHBMGF@fatal?5error?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@ DB 'f'
	DB	'atal error: *** %s ***', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _fatal_error
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_fatal_error PROC					; COMDAT

; 228  :   fprintf(STD_err,"fatal error: *** %s ***\n",mes);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	50		 push	 eax
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GEPHBMGF@fatal?5error?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  0000a	e8 00 00 00 00	 call	 ___iob_func
  0000f	83 c0 40	 add	 eax, 64			; 00000040H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fprintf
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  :   bp_halt(1);

  0001b	6a 01		 push	 1
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  00022	e8 00 00 00 00	 call	 _bp_exit
$LN6@fatal_erro:
  00027	cc		 int	 3
_fatal_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@NLNDKHKA@?$CFs?1?$CFld?5?$DP?$DP?$DP?5?$AA@ ; `string'
PUBLIC	??_C@_08BPALLFCG@?$CFld?5?$DP?$DP?$DP?5?$AA@	; `string'
PUBLIC	??_C@_0O@GIGKMOLP@mem?$FL?$CFlu?$FN?5?$DP?$DP?$DP?5?$AA@ ; `string'
PUBLIC	??_C@_09FCJHBEDL@_?$CFld?5?$DP?$DP?$DP?5?$AA@	; `string'
PUBLIC	_local_error
EXTRN	_atomtable:DWORD
;	COMDAT ??_C@_0M@NLNDKHKA@?$CFs?1?$CFld?5?$DP?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_0M@NLNDKHKA@?$CFs?1?$CFld?5?$DP?$DP?$DP?5?$AA@ DB '%s/%ld ??? ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPALLFCG@?$CFld?5?$DP?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_08BPALLFCG@?$CFld?5?$DP?$DP?$DP?5?$AA@ DB '%ld ??? ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GIGKMOLP@mem?$FL?$CFlu?$FN?5?$DP?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_0O@GIGKMOLP@mem?$FL?$CFlu?$FN?5?$DP?$DP?$DP?5?$AA@ DB 'mem[%lu] ???'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCJHBEDL@_?$CFld?5?$DP?$DP?$DP?5?$AA@
CONST	SEGMENT
??_C@_09FCJHBEDL@_?$CFld?5?$DP?$DP?$DP?5?$AA@ DB '_%ld ??? ', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _local_error
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_Msg$ = 12						; size = 4
_wam$ = 16						; size = 4
_local_error PROC					; COMDAT

; 234  : if(QLEVEL()<3) {

  00000	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00005	83 e0 fc	 and	 eax, -4			; fffffffcH
  00008	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0000b	0f 8d 95 00 00
	00		 jge	 $LN12@local_erro

; 235  : #if TRACE>1
; 236  :   extern string smartref(cell x, register stack wam);
; 237  :   fprintf(STD_err,"%s ??? ",smartref(xval,wam));
; 238  : #else
; 239  :   if(VAR(xval))

  00011	8b 44 24 04	 mov	 eax, DWORD PTR _xval$[esp-4]
  00015	8b c8		 mov	 ecx, eax
  00017	83 e1 03	 and	 ecx, 3
  0001a	75 20		 jne	 SHORT $LN6@local_erro

; 240  :     {  bp_long a=(term *)xval-wam[HeapStk].base;

  0001c	8b 54 24 0c	 mov	 edx, DWORD PTR _wam$[esp-4]
  00020	8b c8		 mov	 ecx, eax
  00022	2b 4a 10	 sub	 ecx, DWORD PTR [edx+16]
  00025	c1 f9 02	 sar	 ecx, 2

; 241  :        if(a>=0)

  00028	85 c9		 test	 ecx, ecx
  0002a	78 08		 js	 SHORT $LN5@local_erro

; 242  :          fprintf(STD_err,"_%ld ??? ",a);

  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_09FCJHBEDL@_?$CFld?5?$DP?$DP?$DP?5?$AA@

; 243  :        else

  00032	eb 16		 jmp	 SHORT $LN13@local_erro
$LN5@local_erro:

; 244  :          fprintf(STD_err, "mem[%lu] ??? ",xval);

  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GIGKMOLP@mem?$FL?$CFlu?$FN?5?$DP?$DP?$DP?5?$AA@

; 245  :     }
; 246  :   else if(INTEGER(xval)) fprintf(STD_err,"%ld ??? ",OUTPUT_INT(xval));

  0003a	eb 0e		 jmp	 SHORT $LN13@local_erro
$LN6@local_erro:
  0003c	83 f9 01	 cmp	 ecx, 1
  0003f	75 1c		 jne	 SHORT $LN2@local_erro
  00041	c1 f8 02	 sar	 eax, 2
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_08BPALLFCG@?$CFld?5?$DP?$DP?$DP?5?$AA@
$LN13@local_erro:
  0004a	e8 00 00 00 00	 call	 ___iob_func
  0004f	83 c0 40	 add	 eax, 64			; 00000040H
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 _fprintf
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	eb 2e		 jmp	 SHORT $LN1@local_erro
$LN2@local_erro:

; 247  :   else fprintf(STD_err,"%s/%ld ??? ",NAME(xval),GETARITY(xval));

  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  00063	8b c8		 mov	 ecx, eax
  00065	c1 e8 02	 shr	 eax, 2
  00068	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0006b	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00070	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00073	51		 push	 ecx
  00074	50		 push	 eax
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NLNDKHKA@?$CFs?1?$CFld?5?$DP?$DP?$DP?5?$AA@
  0007a	e8 00 00 00 00	 call	 ___iob_func
  0007f	83 c0 40	 add	 eax, 64			; 00000040H
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _fprintf
  00088	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@local_erro:

; 248  : #endif
; 249  :   warnmes(Msg);

  0008b	8b 4c 24 08	 mov	 ecx, DWORD PTR _Msg$[esp-4]
  0008f	51		 push	 ecx
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00095	e8 00 00 00 00	 call	 ___iob_func
  0009a	83 c0 40	 add	 eax, 64			; 00000040H
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _fprintf
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@local_erro:

; 250  : }
; 251  :   return NULL;

  000a6	33 c0		 xor	 eax, eax

; 252  : }

  000a8	c3		 ret	 0
_local_error ENDP
_TEXT	ENDS
PUBLIC	_link_halt
; Function compile flags: /Ogtpy
;	COMDAT _link_halt
_TEXT	SEGMENT
_link_halt PROC						; COMDAT

; 256  :   if(OUTPUT_INT(g.linking)) bp_halt(3);

  00000	f7 05 f4 00 00
	00 fc ff ff ff	 test	 DWORD PTR _g+244, -4	; fffffffcH
  0000a	74 0c		 je	 SHORT $LN1@link_halt
  0000c	6a 03		 push	 3
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  00013	e8 00 00 00 00	 call	 _bp_exit
$LN1@link_halt:

; 257  : }

  00018	c3		 ret	 0
$LN7@link_halt:
_link_halt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@NLCPHGMA@?$CK?$CK?$CK?5?$CFs?5overflow?5by?5?$CFld?5bytes?5?$CIsa@ ; `string'
PUBLIC	_overflow_by
;	COMDAT ??_C@_0ED@NLCPHGMA@?$CK?$CK?$CK?5?$CFs?5overflow?5by?5?$CFld?5bytes?5?$CIsa@
CONST	SEGMENT
??_C@_0ED@NLCPHGMA@?$CK?$CK?$CK?5?$CFs?5overflow?5by?5?$CFld?5bytes?5?$CIsa@ DB '*'
	DB	'** %s overflow by %ld bytes (safety left: %ld bytes)', 0aH, 'c'
	DB	'ulprit=>%s', 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _overflow_by
_TEXT	SEGMENT
_Top$ = 8						; size = 4
_LimitNo$ = 12						; size = 4
_wam$ = 16						; size = 4
_culprit$ = 20						; size = 4
_overflow_by PROC					; COMDAT

; 261  : { bp_long delta=((char *)Top-(char *)wam[LimitNo].margin);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _LimitNo$[esp-4]
  00004	8b 4c 24 0c	 mov	 ecx, DWORD PTR _wam$[esp-4]

; 262  :   if(QLEVEL()<6)

  00008	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  0000e	8d 04 c0	 lea	 eax, DWORD PTR [eax+eax*8]
  00011	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00014	8b 44 24 04	 mov	 eax, DWORD PTR _Top$[esp-4]
  00018	2b 41 14	 sub	 eax, DWORD PTR [ecx+20]
  0001b	83 e2 fc	 and	 edx, -4			; fffffffcH
  0001e	83 fa 18	 cmp	 edx, 24			; 00000018H
  00021	7d 2a		 jge	 SHORT $LN1@overflow_b

; 263  :   {
; 264  :     fprintf(STD_err,
; 265  :     "*** %s overflow by %ld bytes (safety left: %ld bytes)\nculprit=>%s\n",
; 266  :          wam[LimitNo].name,
; 267  :          delta, wam[LimitNo].over*sizeof(term)-delta,culprit);

  00023	8b 54 24 10	 mov	 edx, DWORD PTR _culprit$[esp-4]
  00027	52		 push	 edx
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002b	03 d2		 add	 edx, edx
  0002d	03 d2		 add	 edx, edx
  0002f	2b d0		 sub	 edx, eax
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@NLCPHGMA@?$CK?$CK?$CK?5?$CFs?5overflow?5by?5?$CFld?5bytes?5?$CIsa@
  0003c	e8 00 00 00 00	 call	 ___iob_func
  00041	83 c0 40	 add	 eax, 64			; 00000040H
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _fprintf
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@overflow_b:

; 268  :    }
; 269  :    link_halt();

  0004d	f7 05 f4 00 00
	00 fc ff ff ff	 test	 DWORD PTR _g+244, -4	; fffffffcH
  00057	74 0c		 je	 SHORT $LN4@overflow_b
  00059	6a 03		 push	 3
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  00060	e8 00 00 00 00	 call	 _bp_exit
$LN4@overflow_b:

; 270  : }

  00065	c3		 ret	 0
$LN11@overflow_b:
_overflow_by ENDP
_TEXT	ENDS
EXTRN	_hdef:PROC
EXTRN	_new_func:PROC
; Function compile flags: /Ogtpy
;	COMDAT _hdef_string
_TEXT	SEGMENT
_k1$ = 8						; size = 4
_k2$ = 12						; size = 4
_hdef_string PROC					; COMDAT
; _val$ = ecx

; 276  :   return hdef(INPUT_STRING(k1),INPUT_STRING(k2),INPUT_STRING(val),g.timestamp);

  00000	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _new_func
  00010	8b 54 24 14	 mov	 edx, DWORD PTR _k2$[esp+8]
  00014	83 c4 08	 add	 esp, 8
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _new_func
  00020	83 c4 08	 add	 esp, 8
  00023	50		 push	 eax
  00024	8b 44 24 10	 mov	 eax, DWORD PTR _k1$[esp+8]
  00028	6a 00		 push	 0
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _new_func
  00030	83 c4 08	 add	 esp, 8
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _hdef
  00039	83 c4 10	 add	 esp, 16			; 00000010H

; 277  : }

  0003c	c3		 ret	 0
_hdef_string ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _hdef_int
_TEXT	SEGMENT
_k1$ = 8						; size = 4
_k2$ = 12						; size = 4
_hdef_int PROC						; COMDAT
; _val$ = ecx

; 281  :   return hdef(INPUT_STRING(k1),INPUT_STRING(k2),INPUT_INT(val),g.timestamp);

  00000	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00007	50		 push	 eax
  00008	8b 44 24 0c	 mov	 eax, DWORD PTR _k2$[esp]
  0000c	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  00013	83 ca 01	 or	 edx, 1
  00016	52		 push	 edx
  00017	6a 00		 push	 0
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _new_func
  0001f	8b 4c 24 14	 mov	 ecx, DWORD PTR _k1$[esp+12]
  00023	83 c4 08	 add	 esp, 8
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 _new_func
  0002f	83 c4 08	 add	 esp, 8
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _hdef
  00038	83 c4 10	 add	 esp, 16			; 00000010H

; 282  : }

  0003b	c3		 ret	 0
_hdef_int ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _hdef_ptr
_TEXT	SEGMENT
_hdef_ptr PROC						; COMDAT
; _k2$ = edx
; _val$ = ecx

; 286  : #if 0
; 287  :   fprintf(STD_err,"hdef_ptr: g.bp_state=%ld\n",g.bp_state);
; 288  :   fprintf(STD_err,"hdef_ptr: g.true=%ld\n",g.true);
; 289  : #endif
; 290  :   return hdef(g.bp_state,INPUT_STRING(k2),PTR2INT(val),g.timestamp);

  00000	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00007	50		 push	 eax
  00008	41		 inc	 ecx
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 _new_func
  00012	83 c4 08	 add	 esp, 8
  00015	50		 push	 eax
  00016	a1 c4 00 00 00	 mov	 eax, DWORD PTR _g+196
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _hdef
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 291  : }

  00024	c3		 ret	 0
_hdef_ptr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BBNIBFMC@trim_depth?$AA@		; `string'
PUBLIC	??_C@_0M@CPLGDEHI@trim_detail?$AA@		; `string'
PUBLIC	??_C@_0P@KEBCNBOI@term_expansion?$AA@		; `string'
PUBLIC	??_C@_07HHBFGMHA@portray?$AA@			; `string'
PUBLIC	??_C@_0P@DCFGKAFG@portray_clause?$AA@		; `string'
PUBLIC	??_C@_06PIHEDKDA@bu_ctr?$AA@			; `string'
PUBLIC	??_C@_03NLPDLCGC@bu1?$AA@			; `string'
PUBLIC	??_C@_03MCOIIDCD@bu0?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_09IAMNGIKI@noname?4pl?$AA@		; `string'
PUBLIC	??_C@_08OBBAIKIA@dconsult?$AA@			; `string'
PUBLIC	??_C@_08MFJBPPJC@mcompile?$AA@			; `string'
PUBLIC	??_C@_03IJLIBDBM@mem?$AA@			; `string'
PUBLIC	??_C@_02JNAHGKBG@pl?$AA@			; `string'
PUBLIC	??_C@_03JEELCJ@pro?$AA@				; `string'
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_03LBBFAMDL@wam?$AA@			; `string'
PUBLIC	??_C@_02GENCEAFF@bp?$AA@			; `string'
PUBLIC	??_C@_01PAPGNFGE@c?$AA@				; `string'
PUBLIC	??_C@_06LKANLBLF@$float?$AA@			; `string'
PUBLIC	??_C@_0L@CFHHMECD@bp_virtual?$AA@		; `string'
PUBLIC	??_C@_08FLKCLMNF@bp_state?$AA@			; `string'
PUBLIC	??_C@_0M@HLNLMILD@closed_file?$AA@		; `string'
PUBLIC	??_C@_04CCHAHKJA@user?$AA@			; `string'
PUBLIC	??_C@_09NLKOLKMM@postfixop?$AA@			; `string'
PUBLIC	??_C@_07GEACIFN@infixop?$AA@			; `string'
PUBLIC	??_C@_08FGBOFJMI@prefixop?$AA@			; `string'
PUBLIC	??_C@_02GIDJLJBD@yf?$AA@			; `string'
PUBLIC	??_C@_02GJPLNDCE@xf?$AA@			; `string'
PUBLIC	??_C@_02LCBJFDMA@fy?$AA@			; `string'
PUBLIC	??_C@_02KLACGCIB@fx?$AA@			; `string'
PUBLIC	??_C@_03GDDAILJJ@yfx?$AA@			; `string'
PUBLIC	??_C@_03MCJHNNLN@xfy?$AA@			; `string'
PUBLIC	??_C@_03NLIMOMPM@xfx?$AA@			; `string'
PUBLIC	??_C@_06CHALDMIE@opmark?$AA@			; `string'
PUBLIC	??_C@_0M@FGPAFDDD@end_of_file?$AA@		; `string'
PUBLIC	??_C@_0O@NBHEBFFJ@jcompressmark?$AA@		; `string'
PUBLIC	??_C@_08CMNGBDCP@tellmark?$AA@			; `string'
PUBLIC	??_C@_07KPBGGIG@seemark?$AA@			; `string'
PUBLIC	??_C@_06BMDKEIBD@ucount?$AA@			; `string'
PUBLIC	??_C@_08HOIPLNKP@predmark?$AA@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
PUBLIC	??_C@_01NEMOKFLO@?$DN?$AA@			; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	??_C@_06KGMALCLE@$empty?$AA@			; `string'
PUBLIC	??_C@_03JBIPMCLC@int?$AA@			; `string'
PUBLIC	??_C@_03MEPDGFMA@var?$AA@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
;	COMDAT ??_C@_0L@BBNIBFMC@trim_depth?$AA@
CONST	SEGMENT
??_C@_0L@BBNIBFMC@trim_depth?$AA@ DB 'trim_depth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPLGDEHI@trim_detail?$AA@
CONST	SEGMENT
??_C@_0M@CPLGDEHI@trim_detail?$AA@ DB 'trim_detail', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEBCNBOI@term_expansion?$AA@
CONST	SEGMENT
??_C@_0P@KEBCNBOI@term_expansion?$AA@ DB 'term_expansion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHBFGMHA@portray?$AA@
CONST	SEGMENT
??_C@_07HHBFGMHA@portray?$AA@ DB 'portray', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DCFGKAFG@portray_clause?$AA@
CONST	SEGMENT
??_C@_0P@DCFGKAFG@portray_clause?$AA@ DB 'portray_clause', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIHEDKDA@bu_ctr?$AA@
CONST	SEGMENT
??_C@_06PIHEDKDA@bu_ctr?$AA@ DB 'bu_ctr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLPDLCGC@bu1?$AA@
CONST	SEGMENT
??_C@_03NLPDLCGC@bu1?$AA@ DB 'bu1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCOIIDCD@bu0?$AA@
CONST	SEGMENT
??_C@_03MCOIIDCD@bu0?$AA@ DB 'bu0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAMNGIKI@noname?4pl?$AA@
CONST	SEGMENT
??_C@_09IAMNGIKI@noname?4pl?$AA@ DB 'noname.pl', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBBAIKIA@dconsult?$AA@
CONST	SEGMENT
??_C@_08OBBAIKIA@dconsult?$AA@ DB 'dconsult', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFJBPPJC@mcompile?$AA@
CONST	SEGMENT
??_C@_08MFJBPPJC@mcompile?$AA@ DB 'mcompile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJLIBDBM@mem?$AA@
CONST	SEGMENT
??_C@_03IJLIBDBM@mem?$AA@ DB 'mem', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNAHGKBG@pl?$AA@
CONST	SEGMENT
??_C@_02JNAHGKBG@pl?$AA@ DB 'pl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JEELCJ@pro?$AA@
CONST	SEGMENT
??_C@_03JEELCJ@pro?$AA@ DB 'pro', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBBFAMDL@wam?$AA@
CONST	SEGMENT
??_C@_03LBBFAMDL@wam?$AA@ DB 'wam', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GENCEAFF@bp?$AA@
CONST	SEGMENT
??_C@_02GENCEAFF@bp?$AA@ DB 'bp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT
??_C@_01PAPGNFGE@c?$AA@ DB 'c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LKANLBLF@$float?$AA@
CONST	SEGMENT
??_C@_06LKANLBLF@$float?$AA@ DB '$float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFHHMECD@bp_virtual?$AA@
CONST	SEGMENT
??_C@_0L@CFHHMECD@bp_virtual?$AA@ DB 'bp_virtual', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLKCLMNF@bp_state?$AA@
CONST	SEGMENT
??_C@_08FLKCLMNF@bp_state?$AA@ DB 'bp_state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HLNLMILD@closed_file?$AA@
CONST	SEGMENT
??_C@_0M@HLNLMILD@closed_file?$AA@ DB 'closed_file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCHAHKJA@user?$AA@
CONST	SEGMENT
??_C@_04CCHAHKJA@user?$AA@ DB 'user', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLKOLKMM@postfixop?$AA@
CONST	SEGMENT
??_C@_09NLKOLKMM@postfixop?$AA@ DB 'postfixop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GEACIFN@infixop?$AA@
CONST	SEGMENT
??_C@_07GEACIFN@infixop?$AA@ DB 'infixop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGBOFJMI@prefixop?$AA@
CONST	SEGMENT
??_C@_08FGBOFJMI@prefixop?$AA@ DB 'prefixop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GIDJLJBD@yf?$AA@
CONST	SEGMENT
??_C@_02GIDJLJBD@yf?$AA@ DB 'yf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GJPLNDCE@xf?$AA@
CONST	SEGMENT
??_C@_02GJPLNDCE@xf?$AA@ DB 'xf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LCBJFDMA@fy?$AA@
CONST	SEGMENT
??_C@_02LCBJFDMA@fy?$AA@ DB 'fy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KLACGCIB@fx?$AA@
CONST	SEGMENT
??_C@_02KLACGCIB@fx?$AA@ DB 'fx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GDDAILJJ@yfx?$AA@
CONST	SEGMENT
??_C@_03GDDAILJJ@yfx?$AA@ DB 'yfx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCJHNNLN@xfy?$AA@
CONST	SEGMENT
??_C@_03MCJHNNLN@xfy?$AA@ DB 'xfy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLIMOMPM@xfx?$AA@
CONST	SEGMENT
??_C@_03NLIMOMPM@xfx?$AA@ DB 'xfx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHALDMIE@opmark?$AA@
CONST	SEGMENT
??_C@_06CHALDMIE@opmark?$AA@ DB 'opmark', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGPAFDDD@end_of_file?$AA@
CONST	SEGMENT
??_C@_0M@FGPAFDDD@end_of_file?$AA@ DB 'end_of_file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBHEBFFJ@jcompressmark?$AA@
CONST	SEGMENT
??_C@_0O@NBHEBFFJ@jcompressmark?$AA@ DB 'jcompressmark', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMNGBDCP@tellmark?$AA@
CONST	SEGMENT
??_C@_08CMNGBDCP@tellmark?$AA@ DB 'tellmark', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KPBGGIG@seemark?$AA@
CONST	SEGMENT
??_C@_07KPBGGIG@seemark?$AA@ DB 'seemark', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMDKEIBD@ucount?$AA@
CONST	SEGMENT
??_C@_06BMDKEIBD@ucount?$AA@ DB 'ucount', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HOIPLNKP@predmark?$AA@
CONST	SEGMENT
??_C@_08HOIPLNKP@predmark?$AA@ DB 'predmark', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN?$AA@ DB '=', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KGMALCLE@$empty?$AA@
CONST	SEGMENT
??_C@_06KGMALCLE@$empty?$AA@ DB '$empty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int?$AA@
CONST	SEGMENT
??_C@_03JBIPMCLC@int?$AA@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var?$AA@
CONST	SEGMENT
??_C@_03MEPDGFMA@var?$AA@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _make_constants
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_make_constants PROC					; COMDAT

; 305  :   g.NIL=INPUT_STRING("[]");

  00000	6a 00		 push	 0
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
  00007	e8 00 00 00 00	 call	 _new_func

; 306  :   g.DOT=new_func(".",2);

  0000c	6a 02		 push	 2
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00013	a3 20 00 00 00	 mov	 DWORD PTR _g+32, eax
  00018	e8 00 00 00 00	 call	 _new_func

; 307  :   g.DIF=new_func("-",2);

  0001d	6a 02		 push	 2
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_01JOAMLHOP@?9?$AA@
  00024	a3 24 00 00 00	 mov	 DWORD PTR _g+36, eax
  00029	e8 00 00 00 00	 call	 _new_func

; 308  :   g.DIV=new_func("/",2);

  0002e	6a 02		 push	 2
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
  00035	a3 28 00 00 00	 mov	 DWORD PTR _g+40, eax
  0003a	e8 00 00 00 00	 call	 _new_func

; 309  :   g.VAR=new_func("var",1);

  0003f	6a 01		 push	 1
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_03MEPDGFMA@var?$AA@
  00046	a3 2c 00 00 00	 mov	 DWORD PTR _g+44, eax
  0004b	e8 00 00 00 00	 call	 _new_func

; 310  :   g.INT=new_func("int",1);

  00050	6a 01		 push	 1
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_03JBIPMCLC@int?$AA@
  00057	a3 30 00 00 00	 mov	 DWORD PTR _g+48, eax
  0005c	e8 00 00 00 00	 call	 _new_func

; 311  :   g.empty=INPUT_STRING("$empty");

  00061	6a 00		 push	 0
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_06KGMALCLE@$empty?$AA@
  00068	a3 34 00 00 00	 mov	 DWORD PTR _g+52, eax
  0006d	e8 00 00 00 00	 call	 _new_func

; 312  :   g.query=g.empty;
; 313  :   g.answer=g.empty;
; 314  :   g.callback=g.empty;
; 315  : 
; 316  :   g.compare_vals[0]=INPUT_STRING("<");

  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
  00079	a3 38 00 00 00	 mov	 DWORD PTR _g+56, eax
  0007e	a3 e4 00 00 00	 mov	 DWORD PTR _g+228, eax
  00083	a3 e8 00 00 00	 mov	 DWORD PTR _g+232, eax
  00088	a3 ec 00 00 00	 mov	 DWORD PTR _g+236, eax
  0008d	e8 00 00 00 00	 call	 _new_func
  00092	83 c4 40	 add	 esp, 64			; 00000040H

; 317  :   g.compare_vals[1]=INPUT_STRING("=");

  00095	6a 00		 push	 0
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_01NEMOKFLO@?$DN?$AA@
  0009c	a3 04 01 00 00	 mov	 DWORD PTR _g+260, eax
  000a1	e8 00 00 00 00	 call	 _new_func

; 318  :   g.compare_vals[2]=INPUT_STRING(">");

  000a6	6a 00		 push	 0
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
  000ad	a3 08 01 00 00	 mov	 DWORD PTR _g+264, eax
  000b2	e8 00 00 00 00	 call	 _new_func

; 319  : 
; 320  :   g.predmark=INPUT_STRING("predmark");

  000b7	6a 00		 push	 0
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_08HOIPLNKP@predmark?$AA@
  000be	a3 0c 01 00 00	 mov	 DWORD PTR _g+268, eax
  000c3	e8 00 00 00 00	 call	 _new_func

; 321  :   g.ucount=INPUT_STRING("ucount");

  000c8	6a 00		 push	 0
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_06BMDKEIBD@ucount?$AA@
  000cf	a3 68 00 00 00	 mov	 DWORD PTR _g+104, eax
  000d4	e8 00 00 00 00	 call	 _new_func

; 322  :   g.seemark=INPUT_STRING("seemark");

  000d9	6a 00		 push	 0
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_07KPBGGIG@seemark?$AA@
  000e0	a3 6c 00 00 00	 mov	 DWORD PTR _g+108, eax
  000e5	e8 00 00 00 00	 call	 _new_func

; 323  :   g.tellmark=INPUT_STRING("tellmark");

  000ea	6a 00		 push	 0
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_08CMNGBDCP@tellmark?$AA@
  000f1	a3 70 00 00 00	 mov	 DWORD PTR _g+112, eax
  000f6	e8 00 00 00 00	 call	 _new_func

; 324  : 
; 325  : 
; 326  : #if JUMP_COMPRESS
; 327  :   g.jcompressmark=INPUT_STRING("jcompressmark");

  000fb	6a 00		 push	 0
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NBHEBFFJ@jcompressmark?$AA@
  00102	a3 74 00 00 00	 mov	 DWORD PTR _g+116, eax
  00107	e8 00 00 00 00	 call	 _new_func

; 328  : #endif
; 329  : 
; 330  :   g.end_of_file=INPUT_STRING("end_of_file");

  0010c	6a 00		 push	 0
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FGPAFDDD@end_of_file?$AA@
  00113	a3 80 00 00 00	 mov	 DWORD PTR _g+128, eax
  00118	e8 00 00 00 00	 call	 _new_func
  0011d	83 c4 40	 add	 esp, 64			; 00000040H

; 331  :   g.opmark=INPUT_STRING("opmark");

  00120	6a 00		 push	 0
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_06CHALDMIE@opmark?$AA@
  00127	a3 78 00 00 00	 mov	 DWORD PTR _g+120, eax
  0012c	e8 00 00 00 00	 call	 _new_func

; 332  : 
; 333  :   g.xfx=INPUT_STRING("xfx");

  00131	6a 00		 push	 0
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_03NLIMOMPM@xfx?$AA@
  00138	a3 7c 00 00 00	 mov	 DWORD PTR _g+124, eax
  0013d	e8 00 00 00 00	 call	 _new_func

; 334  :   g.xfy=INPUT_STRING("xfy");

  00142	6a 00		 push	 0
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_03MCJHNNLN@xfy?$AA@
  00149	a3 4c 00 00 00	 mov	 DWORD PTR _g+76, eax
  0014e	e8 00 00 00 00	 call	 _new_func
  00153	a3 50 00 00 00	 mov	 DWORD PTR _g+80, eax

; 335  :   g.yfx=INPUT_STRING("yfx");

  00158	6a 00		 push	 0
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_03GDDAILJJ@yfx?$AA@
  0015f	e8 00 00 00 00	 call	 _new_func

; 336  : 
; 337  :   g.fx=INPUT_STRING("fx");

  00164	6a 00		 push	 0
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_02KLACGCIB@fx?$AA@
  0016b	a3 54 00 00 00	 mov	 DWORD PTR _g+84, eax
  00170	e8 00 00 00 00	 call	 _new_func

; 338  :   g.fy=INPUT_STRING("fy");

  00175	6a 00		 push	 0
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_02LCBJFDMA@fy?$AA@
  0017c	a3 3c 00 00 00	 mov	 DWORD PTR _g+60, eax
  00181	e8 00 00 00 00	 call	 _new_func

; 339  :   g.xf=INPUT_STRING("xf");

  00186	6a 00		 push	 0
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_02GJPLNDCE@xf?$AA@
  0018d	a3 40 00 00 00	 mov	 DWORD PTR _g+64, eax
  00192	e8 00 00 00 00	 call	 _new_func

; 340  :   g.yf=INPUT_STRING("yf");

  00197	6a 00		 push	 0
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_02GIDJLJBD@yf?$AA@
  0019e	a3 44 00 00 00	 mov	 DWORD PTR _g+68, eax
  001a3	e8 00 00 00 00	 call	 _new_func
  001a8	83 c4 40	 add	 esp, 64			; 00000040H

; 341  : 
; 342  :   g.prefixop=INPUT_STRING("prefixop");

  001ab	6a 00		 push	 0
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_08FGBOFJMI@prefixop?$AA@
  001b2	a3 48 00 00 00	 mov	 DWORD PTR _g+72, eax
  001b7	e8 00 00 00 00	 call	 _new_func

; 343  :   g.infixop=INPUT_STRING("infixop");

  001bc	6a 00		 push	 0
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_07GEACIFN@infixop?$AA@
  001c3	a3 58 00 00 00	 mov	 DWORD PTR _g+88, eax
  001c8	e8 00 00 00 00	 call	 _new_func

; 344  :   g.postfixop=INPUT_STRING("postfixop");

  001cd	6a 00		 push	 0
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_09NLKOLKMM@postfixop?$AA@
  001d4	a3 5c 00 00 00	 mov	 DWORD PTR _g+92, eax
  001d9	e8 00 00 00 00	 call	 _new_func

; 345  : 
; 346  :   g.seefunc=g.tellfunc=g.user=INPUT_STRING("user");

  001de	6a 00		 push	 0
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_04CCHAHKJA@user?$AA@
  001e5	a3 60 00 00 00	 mov	 DWORD PTR _g+96, eax
  001ea	e8 00 00 00 00	 call	 _new_func

; 347  :   g.seefile=STD_in;
; 348  :   g.tellfile=STD_out;

  001ef	8b 0d 3c 01 00
	00		 mov	 ecx, DWORD PTR _g+316
  001f5	a3 84 00 00 00	 mov	 DWORD PTR _g+132, eax
  001fa	a3 90 00 00 00	 mov	 DWORD PTR _g+144, eax
  001ff	a3 8c 00 00 00	 mov	 DWORD PTR _g+140, eax
  00204	a1 38 01 00 00	 mov	 eax, DWORD PTR _g+312

; 349  :   g.closed_file=INPUT_STRING("closed_file");

  00209	6a 00		 push	 0
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HLNLMILD@closed_file?$AA@
  00210	a3 30 01 00 00	 mov	 DWORD PTR _g+304, eax
  00215	89 0d 34 01 00
	00		 mov	 DWORD PTR _g+308, ecx
  0021b	e8 00 00 00 00	 call	 _new_func

; 350  : 
; 351  :   g.bp_state=INPUT_STRING("bp_state");

  00220	6a 00		 push	 0
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00227	a3 88 00 00 00	 mov	 DWORD PTR _g+136, eax
  0022c	e8 00 00 00 00	 call	 _new_func

; 352  :   g.bp_virtual=INPUT_STRING("bp_virtual");

  00231	6a 00		 push	 0
  00233	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  00238	a3 c4 00 00 00	 mov	 DWORD PTR _g+196, eax
  0023d	e8 00 00 00 00	 call	 _new_func

; 353  : 
; 354  :   hdef(g.seemark,g.user,(cell)STD_in,g.timestamp);

  00242	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  00249	8b 0d 84 00 00
	00		 mov	 ecx, DWORD PTR _g+132
  0024f	52		 push	 edx
  00250	8b 15 70 00 00
	00		 mov	 edx, DWORD PTR _g+112
  00256	a3 dc 00 00 00	 mov	 DWORD PTR _g+220, eax
  0025b	a1 38 01 00 00	 mov	 eax, DWORD PTR _g+312
  00260	50		 push	 eax
  00261	51		 push	 ecx
  00262	52		 push	 edx
  00263	e8 00 00 00 00	 call	 _hdef

; 355  :   hdef(g.tellmark,g.user,(cell)STD_out,g.timestamp);

  00268	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  0026f	8b 0d 3c 01 00
	00		 mov	 ecx, DWORD PTR _g+316
  00275	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR _g+132
  0027b	83 c4 48	 add	 esp, 72			; 00000048H
  0027e	50		 push	 eax
  0027f	a1 74 00 00 00	 mov	 eax, DWORD PTR _g+116
  00284	51		 push	 ecx
  00285	52		 push	 edx
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 _hdef

; 356  : 
; 357  :   g.bp_float=new_func("$float",3);

  0028c	6a 03		 push	 3
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_06LKANLBLF@$float?$AA@
  00293	e8 00 00 00 00	 call	 _new_func

; 358  :   g.c=INPUT_STRING("c");

  00298	6a 00		 push	 0
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_01PAPGNFGE@c?$AA@
  0029f	a3 94 00 00 00	 mov	 DWORD PTR _g+148, eax
  002a4	e8 00 00 00 00	 call	 _new_func

; 359  :   g.bp=INPUT_STRING("bp");

  002a9	6a 00		 push	 0
  002ab	68 00 00 00 00	 push	 OFFSET ??_C@_02GENCEAFF@bp?$AA@
  002b0	a3 98 00 00 00	 mov	 DWORD PTR _g+152, eax
  002b5	e8 00 00 00 00	 call	 _new_func

; 360  :   g.wam=INPUT_STRING("wam");

  002ba	6a 00		 push	 0
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_03LBBFAMDL@wam?$AA@
  002c1	a3 9c 00 00 00	 mov	 DWORD PTR _g+156, eax
  002c6	e8 00 00 00 00	 call	 _new_func

; 361  :   g.h=INPUT_STRING("h");

  002cb	6a 00		 push	 0
  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_01BDACAMKP@h?$AA@
  002d2	a3 a0 00 00 00	 mov	 DWORD PTR _g+160, eax
  002d7	e8 00 00 00 00	 call	 _new_func

; 362  :   g.pro=INPUT_STRING("pro");

  002dc	6a 00		 push	 0
  002de	68 00 00 00 00	 push	 OFFSET ??_C@_03JEELCJ@pro?$AA@
  002e3	a3 a4 00 00 00	 mov	 DWORD PTR _g+164, eax
  002e8	e8 00 00 00 00	 call	 _new_func
  002ed	83 c4 40	 add	 esp, 64			; 00000040H

; 363  :   g.pl=INPUT_STRING("pl");

  002f0	6a 00		 push	 0
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_02JNAHGKBG@pl?$AA@
  002f7	a3 a8 00 00 00	 mov	 DWORD PTR _g+168, eax
  002fc	e8 00 00 00 00	 call	 _new_func

; 364  :   g.mem=INPUT_STRING("mem");

  00301	6a 00		 push	 0
  00303	68 00 00 00 00	 push	 OFFSET ??_C@_03IJLIBDBM@mem?$AA@
  00308	a3 ac 00 00 00	 mov	 DWORD PTR _g+172, eax
  0030d	e8 00 00 00 00	 call	 _new_func

; 365  : 
; 366  :   g.compile=INPUT_STRING("mcompile");

  00312	6a 00		 push	 0
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_08MFJBPPJC@mcompile?$AA@
  00319	a3 b0 00 00 00	 mov	 DWORD PTR _g+176, eax
  0031e	e8 00 00 00 00	 call	 _new_func

; 367  :   g.reconsult=INPUT_STRING("dconsult");

  00323	6a 00		 push	 0
  00325	68 00 00 00 00	 push	 OFFSET ??_C@_08OBBAIKIA@dconsult?$AA@
  0032a	a3 b4 00 00 00	 mov	 DWORD PTR _g+180, eax
  0032f	e8 00 00 00 00	 call	 _new_func

; 368  :   g.current_db=INPUT_STRING("user");

  00334	6a 00		 push	 0
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_04CCHAHKJA@user?$AA@
  0033b	a3 b8 00 00 00	 mov	 DWORD PTR _g+184, eax
  00340	e8 00 00 00 00	 call	 _new_func

; 369  :   g.current_user_file=INPUT_STRING("noname.pl");

  00345	6a 00		 push	 0
  00347	68 00 00 00 00	 push	 OFFSET ??_C@_09IAMNGIKI@noname?4pl?$AA@
  0034c	a3 bc 00 00 00	 mov	 DWORD PTR _g+188, eax
  00351	e8 00 00 00 00	 call	 _new_func

; 370  : 
; 371  :   g.source=g.pl;

  00356	8b 0d ac 00 00
	00		 mov	 ecx, DWORD PTR _g+172

; 372  :   g.target=g.mem;

  0035c	8b 15 b0 00 00
	00		 mov	 edx, DWORD PTR _g+176
  00362	a3 c0 00 00 00	 mov	 DWORD PTR _g+192, eax

; 373  :   g.implem=INPUT_INT(0);
; 374  : 
; 375  :   g.linking=INPUT_INT(1);
; 376  :   g.self=FALSE;
; 377  : 
; 378  :   g.gc=INPUT_INT(1);
; 379  : 
; 380  :   g.peval_io=INPUT_INT(0);
; 381  : 
; 382  :   /* see g.bbgc and g.bbhi in define_bb*/
; 383  : 
; 384  :   g.argc=argc;

  00367	8b 44 24 34	 mov	 eax, DWORD PTR _argc$[esp+44]
  0036b	89 0d c8 00 00
	00		 mov	 DWORD PTR _g+200, ecx

; 385  :   g.argv=argv;

  00371	8b 4c 24 38	 mov	 ecx, DWORD PTR _argv$[esp+44]

; 386  : 
; 387  :   g.true=INPUT_STRING("true");

  00375	6a 00		 push	 0
  00377	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true?$AA@
  0037c	89 15 cc 00 00
	00		 mov	 DWORD PTR _g+204, edx
  00382	c7 05 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g+208, 1
  0038c	c7 05 f4 00 00
	00 05 00 00 00	 mov	 DWORD PTR _g+244, 5
  00396	c7 05 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g+240, 0
  003a0	c7 05 f8 00 00
	00 05 00 00 00	 mov	 DWORD PTR _g+248, 5
  003aa	c7 05 d8 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g+216, 1
  003b4	a3 44 01 00 00	 mov	 DWORD PTR _g+324, eax
  003b9	89 0d 48 01 00
	00		 mov	 DWORD PTR _g+328, ecx
  003bf	e8 00 00 00 00	 call	 _new_func

; 388  : 
; 389  :   MAKE_BP_VALS();

  003c4	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  003cb	83 c4 38	 add	 esp, 56			; 00000038H
  003ce	52		 push	 edx
  003cf	6a 05		 push	 5
  003d1	6a 04		 push	 4
  003d3	68 00 00 00 00	 push	 OFFSET ??_C@_03MCOIIDCD@bu0?$AA@
  003d8	a3 64 00 00 00	 mov	 DWORD PTR _g+100, eax
  003dd	e8 00 00 00 00	 call	 _new_func
  003e2	83 c4 08	 add	 esp, 8
  003e5	50		 push	 eax
  003e6	6a 00		 push	 0
  003e8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  003ed	e8 00 00 00 00	 call	 _new_func
  003f2	83 c4 08	 add	 esp, 8
  003f5	50		 push	 eax
  003f6	e8 00 00 00 00	 call	 _hdef
  003fb	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00402	83 c4 10	 add	 esp, 16			; 00000010H
  00405	50		 push	 eax
  00406	6a 05		 push	 5
  00408	6a 02		 push	 2
  0040a	68 00 00 00 00	 push	 OFFSET ??_C@_03NLPDLCGC@bu1?$AA@
  0040f	e8 00 00 00 00	 call	 _new_func
  00414	83 c4 08	 add	 esp, 8
  00417	50		 push	 eax
  00418	6a 00		 push	 0
  0041a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  0041f	e8 00 00 00 00	 call	 _new_func
  00424	83 c4 08	 add	 esp, 8
  00427	50		 push	 eax
  00428	e8 00 00 00 00	 call	 _hdef
  0042d	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  00434	83 c4 10	 add	 esp, 16			; 00000010H
  00437	51		 push	 ecx
  00438	6a 05		 push	 5
  0043a	6a 02		 push	 2
  0043c	68 00 00 00 00	 push	 OFFSET ??_C@_06PIHEDKDA@bu_ctr?$AA@
  00441	e8 00 00 00 00	 call	 _new_func
  00446	83 c4 08	 add	 esp, 8
  00449	50		 push	 eax
  0044a	6a 00		 push	 0
  0044c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  00451	e8 00 00 00 00	 call	 _new_func
  00456	83 c4 08	 add	 esp, 8
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 _hdef
  0045f	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  00466	83 c4 10	 add	 esp, 16			; 00000010H
  00469	52		 push	 edx
  0046a	6a 09		 push	 9
  0046c	6a 01		 push	 1
  0046e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DCFGKAFG@portray_clause?$AA@
  00473	e8 00 00 00 00	 call	 _new_func
  00478	83 c4 08	 add	 esp, 8
  0047b	50		 push	 eax
  0047c	6a 00		 push	 0
  0047e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  00483	e8 00 00 00 00	 call	 _new_func
  00488	83 c4 08	 add	 esp, 8
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 _hdef
  00491	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  00498	83 c4 10	 add	 esp, 16			; 00000010H
  0049b	50		 push	 eax
  0049c	6a 09		 push	 9
  0049e	6a 01		 push	 1
  004a0	68 00 00 00 00	 push	 OFFSET ??_C@_07HHBFGMHA@portray?$AA@
  004a5	e8 00 00 00 00	 call	 _new_func
  004aa	83 c4 08	 add	 esp, 8
  004ad	50		 push	 eax
  004ae	6a 00		 push	 0
  004b0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  004b5	e8 00 00 00 00	 call	 _new_func
  004ba	83 c4 08	 add	 esp, 8
  004bd	50		 push	 eax
  004be	e8 00 00 00 00	 call	 _hdef
  004c3	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  004ca	83 c4 10	 add	 esp, 16			; 00000010H
  004cd	51		 push	 ecx
  004ce	6a 09		 push	 9
  004d0	6a 02		 push	 2
  004d2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KEBCNBOI@term_expansion?$AA@
  004d7	e8 00 00 00 00	 call	 _new_func
  004dc	83 c4 08	 add	 esp, 8
  004df	50		 push	 eax
  004e0	6a 00		 push	 0
  004e2	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  004e7	e8 00 00 00 00	 call	 _new_func
  004ec	83 c4 08	 add	 esp, 8
  004ef	50		 push	 eax
  004f0	e8 00 00 00 00	 call	 _hdef
  004f5	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  004fc	83 c4 10	 add	 esp, 16			; 00000010H
  004ff	52		 push	 edx
  00500	6a 09		 push	 9
  00502	6a 01		 push	 1
  00504	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CPLGDEHI@trim_detail?$AA@
  00509	e8 00 00 00 00	 call	 _new_func
  0050e	83 c4 08	 add	 esp, 8
  00511	50		 push	 eax
  00512	6a 00		 push	 0
  00514	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  00519	e8 00 00 00 00	 call	 _new_func
  0051e	83 c4 08	 add	 esp, 8
  00521	50		 push	 eax
  00522	e8 00 00 00 00	 call	 _hdef
  00527	0f b6 05 70 01
	00 00		 movzx	 eax, BYTE PTR _g+368
  0052e	83 c4 10	 add	 esp, 16			; 00000010H
  00531	50		 push	 eax
  00532	6a 09		 push	 9
  00534	6a 01		 push	 1
  00536	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BBNIBFMC@trim_depth?$AA@
  0053b	e8 00 00 00 00	 call	 _new_func
  00540	83 c4 08	 add	 esp, 8
  00543	50		 push	 eax
  00544	6a 00		 push	 0
  00546	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CFHHMECD@bp_virtual?$AA@
  0054b	e8 00 00 00 00	 call	 _new_func
  00550	83 c4 08	 add	 esp, 8
  00553	50		 push	 eax
  00554	e8 00 00 00 00	 call	 _hdef
  00559	83 c4 10	 add	 esp, 16			; 00000010H

; 390  : }

  0055c	c3		 ret	 0
_make_constants ENDP
_TEXT	ENDS
PUBLIC	??_C@_03NDFEINMN@x86?$AA@			; `string'
PUBLIC	??_C@_07NFPADACG@threads?$AA@			; `string'
PUBLIC	??_C@_08NFNNCLOG@wordsize?$AA@			; `string'
PUBLIC	??_C@_07HIMBLBFC@tagbits?$AA@			; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_08ENOJNMAG@gc_level?$AA@			; `string'
PUBLIC	??_C@_0M@MFJMKHKN@eager_deref?$AA@		; `string'
PUBLIC	??_C@_0BA@MMBBJBIN@struct_compress?$AA@		; `string'
PUBLIC	??_C@_0O@IHJMJJPN@jump_compress?$AA@		; `string'
PUBLIC	??_C@_0L@KEPNNIPB@trail_size?$AA@		; `string'
PUBLIC	??_C@_0L@NELPJPHD@stack_size?$AA@		; `string'
PUBLIC	??_C@_09HMPAINDI@heap_size?$AA@			; `string'
PUBLIC	??_C@_03BIIGCIG@inC?$AA@			; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_07GAILHCO@ip_addr?$AA@			; `string'
PUBLIC	??_C@_08EHKIGBEA@hostname?$AA@			; `string'
PUBLIC	??_C@_0M@NNBMPGOF@startup_mes?$AA@		; `string'
;	COMDAT ??_C@_03NDFEINMN@x86?$AA@
CONST	SEGMENT
??_C@_03NDFEINMN@x86?$AA@ DB 'x86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFPADACG@threads?$AA@
CONST	SEGMENT
??_C@_07NFPADACG@threads?$AA@ DB 'threads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NFNNCLOG@wordsize?$AA@
CONST	SEGMENT
??_C@_08NFNNCLOG@wordsize?$AA@ DB 'wordsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIMBLBFC@tagbits?$AA@
CONST	SEGMENT
??_C@_07HIMBLBFC@tagbits?$AA@ DB 'tagbits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENOJNMAG@gc_level?$AA@
CONST	SEGMENT
??_C@_08ENOJNMAG@gc_level?$AA@ DB 'gc_level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MFJMKHKN@eager_deref?$AA@
CONST	SEGMENT
??_C@_0M@MFJMKHKN@eager_deref?$AA@ DB 'eager_deref', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MMBBJBIN@struct_compress?$AA@
CONST	SEGMENT
??_C@_0BA@MMBBJBIN@struct_compress?$AA@ DB 'struct_compress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IHJMJJPN@jump_compress?$AA@
CONST	SEGMENT
??_C@_0O@IHJMJJPN@jump_compress?$AA@ DB 'jump_compress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEPNNIPB@trail_size?$AA@
CONST	SEGMENT
??_C@_0L@KEPNNIPB@trail_size?$AA@ DB 'trail_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NELPJPHD@stack_size?$AA@
CONST	SEGMENT
??_C@_0L@NELPJPHD@stack_size?$AA@ DB 'stack_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMPAINDI@heap_size?$AA@
CONST	SEGMENT
??_C@_09HMPAINDI@heap_size?$AA@ DB 'heap_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BIIGCIG@inC?$AA@
CONST	SEGMENT
??_C@_03BIIGCIG@inC?$AA@ DB 'inC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GAILHCO@ip_addr?$AA@
CONST	SEGMENT
??_C@_07GAILHCO@ip_addr?$AA@ DB 'ip_addr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHKIGBEA@hostname?$AA@
CONST	SEGMENT
??_C@_08EHKIGBEA@hostname?$AA@ DB 'hostname', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNBMPGOF@startup_mes?$AA@
CONST	SEGMENT
??_C@_0M@NNBMPGOF@startup_mes?$AA@ DB 'startup_mes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hdefaults
_TEXT	SEGMENT
_hdefaults PROC						; COMDAT

; 403  :   return
; 404  :     HDEFS("startup_mes",startup_mes()) &&
; 405  :     HDEFS("hostname",get_host()) &&
; 406  :     HDEFS("ip_addr",get_ip_addr()) &&
; 407  :     HDEFI("version",VERSION) &&
; 408  :     HDEFI("inC",g.inC) &&
; 409  :     HDEFI("heap_size",W2Ks(max.HEAP)) &&
; 410  :     HDEFI("stack_size",W2Ks(max.CHOICE)) &&
; 411  :     HDEFI("trail_size",W2Ks(max.TRAIL)) &&
; 412  :     HDEFI("jump_compress",JUMP_COMPRESS) &&
; 413  :     HDEFI("struct_compress",STRUCT_COMPRESS) &&
; 414  :     HDEFI("eager_deref",EAGER_DEREF) &&
; 415  :     HDEFI("gc_level",GC) &&
; 416  :     HDEFI("var",VARTAG) &&
; 417  :     HDEFI("int",INTTAG) &&
; 418  :     HDEFI("/",FUNTAG) &&
; 419  :     HDEFI("?",BADTAG) &&
; 420  :     HDEFI("tagbits",TAGBITS) &&
; 421  :     HDEFI("wordsize",(sizeof(bp_long)<<3)) &&
; 422  :     HDEFI("threads",THREADS) &&
; 423  :     HDEFI("x86",VCC)
; 424  :   ;

  00000	e8 00 00 00 00	 call	 _startup_mes
  00005	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  0000c	51		 push	 ecx
  0000d	6a 00		 push	 0
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 _new_func
  00015	83 c4 08	 add	 esp, 8
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NNBMPGOF@startup_mes?$AA@
  00020	e8 00 00 00 00	 call	 _new_func
  00025	83 c4 08	 add	 esp, 8
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00030	e8 00 00 00 00	 call	 _new_func
  00035	83 c4 08	 add	 esp, 8
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _hdef
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	85 c0		 test	 eax, eax
  00043	0f 84 9d 02 00
	00		 je	 $LN3@hdefaults
  00049	e8 00 00 00 00	 call	 _get_host
  0004e	0f b6 15 70 01
	00 00		 movzx	 edx, BYTE PTR _g+368
  00055	52		 push	 edx
  00056	6a 00		 push	 0
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _new_func
  0005e	83 c4 08	 add	 esp, 8
  00061	50		 push	 eax
  00062	6a 00		 push	 0
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_08EHKIGBEA@hostname?$AA@
  00069	e8 00 00 00 00	 call	 _new_func
  0006e	83 c4 08	 add	 esp, 8
  00071	50		 push	 eax
  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00079	e8 00 00 00 00	 call	 _new_func
  0007e	83 c4 08	 add	 esp, 8
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 _hdef
  00087	83 c4 10	 add	 esp, 16			; 00000010H
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 54 02 00
	00		 je	 $LN3@hdefaults
  00092	e8 00 00 00 00	 call	 _get_ip_addr
  00097	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  0009e	51		 push	 ecx
  0009f	6a 00		 push	 0
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _new_func
  000a7	83 c4 08	 add	 esp, 8
  000aa	50		 push	 eax
  000ab	6a 00		 push	 0
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_07GAILHCO@ip_addr?$AA@
  000b2	e8 00 00 00 00	 call	 _new_func
  000b7	83 c4 08	 add	 esp, 8
  000ba	50		 push	 eax
  000bb	6a 00		 push	 0
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  000c2	e8 00 00 00 00	 call	 _new_func
  000c7	83 c4 08	 add	 esp, 8
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _hdef
  000d0	83 c4 10	 add	 esp, 16			; 00000010H
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 0b 02 00
	00		 je	 $LN3@hdefaults
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_07CPCPJPKL@version?$AA@
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  000e5	b9 b0 04 00 00	 mov	 ecx, 1200		; 000004b0H
  000ea	e8 00 00 00 00	 call	 _hdef_int
  000ef	83 c4 08	 add	 esp, 8
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 ec 01 00
	00		 je	 $LN3@hdefaults
  000fa	8b 0d d4 00 00
	00		 mov	 ecx, DWORD PTR _g+212
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_03BIIGCIG@inC?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  0010a	e8 00 00 00 00	 call	 _hdef_int
  0010f	83 c4 08	 add	 esp, 8
  00112	85 c0		 test	 eax, eax
  00114	0f 84 cc 01 00
	00		 je	 $LN3@hdefaults
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _max
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_09HMPAINDI@heap_size?$AA@
  00125	c1 e9 08	 shr	 ecx, 8
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  0012d	e8 00 00 00 00	 call	 _hdef_int
  00132	83 c4 08	 add	 esp, 8
  00135	85 c0		 test	 eax, eax
  00137	0f 84 a9 01 00
	00		 je	 $LN3@hdefaults
  0013d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _max+4
  00143	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NELPJPHD@stack_size?$AA@
  00148	c1 e9 08	 shr	 ecx, 8
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00150	e8 00 00 00 00	 call	 _hdef_int
  00155	83 c4 08	 add	 esp, 8
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 86 01 00
	00		 je	 $LN3@hdefaults
  00160	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _max+8
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KEPNNIPB@trail_size?$AA@
  0016b	c1 e9 08	 shr	 ecx, 8
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00173	e8 00 00 00 00	 call	 _hdef_int
  00178	83 c4 08	 add	 esp, 8
  0017b	85 c0		 test	 eax, eax
  0017d	0f 84 63 01 00
	00		 je	 $LN3@hdefaults
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IHJMJJPN@jump_compress?$AA@
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  0018d	b9 01 00 00 00	 mov	 ecx, 1
  00192	e8 00 00 00 00	 call	 _hdef_int
  00197	83 c4 08	 add	 esp, 8
  0019a	85 c0		 test	 eax, eax
  0019c	0f 84 44 01 00
	00		 je	 $LN3@hdefaults
  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MMBBJBIN@struct_compress?$AA@
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  001ac	b9 01 00 00 00	 mov	 ecx, 1
  001b1	e8 00 00 00 00	 call	 _hdef_int
  001b6	83 c4 08	 add	 esp, 8
  001b9	85 c0		 test	 eax, eax
  001bb	0f 84 25 01 00
	00		 je	 $LN3@hdefaults
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MFJMKHKN@eager_deref?$AA@
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	e8 00 00 00 00	 call	 _hdef_int
  001d5	83 c4 08	 add	 esp, 8
  001d8	85 c0		 test	 eax, eax
  001da	0f 84 06 01 00
	00		 je	 $LN3@hdefaults
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_08ENOJNMAG@gc_level?$AA@
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  001ea	b9 01 00 00 00	 mov	 ecx, 1
  001ef	e8 00 00 00 00	 call	 _hdef_int
  001f4	83 c4 08	 add	 esp, 8
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 e7 00 00
	00		 je	 $LN3@hdefaults
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_03MEPDGFMA@var?$AA@
  00204	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00209	33 c9		 xor	 ecx, ecx
  0020b	e8 00 00 00 00	 call	 _hdef_int
  00210	83 c4 08	 add	 esp, 8
  00213	85 c0		 test	 eax, eax
  00215	0f 84 cb 00 00
	00		 je	 $LN3@hdefaults
  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_03JBIPMCLC@int?$AA@
  00220	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00225	b9 01 00 00 00	 mov	 ecx, 1
  0022a	e8 00 00 00 00	 call	 _hdef_int
  0022f	83 c4 08	 add	 esp, 8
  00232	85 c0		 test	 eax, eax
  00234	0f 84 ac 00 00
	00		 je	 $LN3@hdefaults
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1?$AA@
  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00244	b9 03 00 00 00	 mov	 ecx, 3
  00249	e8 00 00 00 00	 call	 _hdef_int
  0024e	83 c4 08	 add	 esp, 8
  00251	85 c0		 test	 eax, eax
  00253	0f 84 8d 00 00
	00		 je	 $LN3@hdefaults
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00263	b9 02 00 00 00	 mov	 ecx, 2
  00268	e8 00 00 00 00	 call	 _hdef_int
  0026d	83 c4 08	 add	 esp, 8
  00270	85 c0		 test	 eax, eax
  00272	74 72		 je	 SHORT $LN3@hdefaults
  00274	68 00 00 00 00	 push	 OFFSET ??_C@_07HIMBLBFC@tagbits?$AA@
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  0027e	b9 02 00 00 00	 mov	 ecx, 2
  00283	e8 00 00 00 00	 call	 _hdef_int
  00288	83 c4 08	 add	 esp, 8
  0028b	85 c0		 test	 eax, eax
  0028d	74 57		 je	 SHORT $LN3@hdefaults
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_08NFNNCLOG@wordsize?$AA@
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  00299	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0029e	e8 00 00 00 00	 call	 _hdef_int
  002a3	83 c4 08	 add	 esp, 8
  002a6	85 c0		 test	 eax, eax
  002a8	74 3c		 je	 SHORT $LN3@hdefaults
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_07NFPADACG@threads?$AA@
  002af	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  002b4	b9 01 00 00 00	 mov	 ecx, 1
  002b9	e8 00 00 00 00	 call	 _hdef_int
  002be	83 c4 08	 add	 esp, 8
  002c1	85 c0		 test	 eax, eax
  002c3	74 21		 je	 SHORT $LN3@hdefaults
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_03NDFEINMN@x86?$AA@
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_08FLKCLMNF@bp_state?$AA@
  002cf	b9 01 00 00 00	 mov	 ecx, 1
  002d4	e8 00 00 00 00	 call	 _hdef_int
  002d9	83 c4 08	 add	 esp, 8
  002dc	85 c0		 test	 eax, eax
  002de	74 06		 je	 SHORT $LN3@hdefaults
  002e0	b8 01 00 00 00	 mov	 eax, 1

; 425  : }

  002e5	c3		 ret	 0
$LN3@hdefaults:

; 403  :   return
; 404  :     HDEFS("startup_mes",startup_mes()) &&
; 405  :     HDEFS("hostname",get_host()) &&
; 406  :     HDEFS("ip_addr",get_ip_addr()) &&
; 407  :     HDEFI("version",VERSION) &&
; 408  :     HDEFI("inC",g.inC) &&
; 409  :     HDEFI("heap_size",W2Ks(max.HEAP)) &&
; 410  :     HDEFI("stack_size",W2Ks(max.CHOICE)) &&
; 411  :     HDEFI("trail_size",W2Ks(max.TRAIL)) &&
; 412  :     HDEFI("jump_compress",JUMP_COMPRESS) &&
; 413  :     HDEFI("struct_compress",STRUCT_COMPRESS) &&
; 414  :     HDEFI("eager_deref",EAGER_DEREF) &&
; 415  :     HDEFI("gc_level",GC) &&
; 416  :     HDEFI("var",VARTAG) &&
; 417  :     HDEFI("int",INTTAG) &&
; 418  :     HDEFI("/",FUNTAG) &&
; 419  :     HDEFI("?",BADTAG) &&
; 420  :     HDEFI("tagbits",TAGBITS) &&
; 421  :     HDEFI("wordsize",(sizeof(bp_long)<<3)) &&
; 422  :     HDEFI("threads",THREADS) &&
; 423  :     HDEFI("x86",VCC)
; 424  :   ;

  002e6	33 c0		 xor	 eax, eax

; 425  : }

  002e8	c3		 ret	 0
_hdefaults ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PPIJGMPL@callback?$AA@			; `string'
PUBLIC	??_C@_06GGCDBJHP@answer?$AA@			; `string'
PUBLIC	??_C@_05BKABJGDH@query?$AA@			; `string'
PUBLIC	??_C@_09BFELHLO@reconsult?$AA@			; `string'
PUBLIC	??_C@_07OLJGFCKG@compile?$AA@			; `string'
PUBLIC	??_C@_0BC@HMGHANFH@startup_file_name?$AA@	; `string'
PUBLIC	??_C@_0BC@NLPKNAK@current_user_file?$AA@	; `string'
PUBLIC	??_C@_0L@BBFHLDAC@current_db?$AA@		; `string'
PUBLIC	??_C@_06NOLKIBGG@implem?$AA@			; `string'
PUBLIC	??_C@_06JJLAMBGK@target?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	??_C@_07PBHABHOB@linking?$AA@			; `string'
PUBLIC	??_C@_0M@GCILGOCP@user_output?$AA@		; `string'
PUBLIC	??_C@_0L@FAMAGEAK@user_input?$AA@		; `string'
PUBLIC	??_C@_08FJJIDCOK@tellfunc?$AA@			; `string'
PUBLIC	??_C@_07HPLPEHED@seefunc?$AA@			; `string'
PUBLIC	??_C@_08BGIJKJCF@tellfile?$AA@			; `string'
PUBLIC	??_C@_06ILKIAHNN@lineno?$AA@			; `string'
PUBLIC	??_C@_07DAKONMIM@seefile?$AA@			; `string'
PUBLIC	??_C@_08PMKMEHFK@db_ratio?$AA@			; `string'
PUBLIC	??_C@_0M@NLHACMPK@load_method?$AA@		; `string'
PUBLIC	??_C@_09GNCBFNIF@this_port?$AA@			; `string'
PUBLIC	??_C@_05PMBAOCDH@quiet?$AA@			; `string'
PUBLIC	??_C@_04LJPLFJDB@bbhi?$AA@			; `string'
PUBLIC	??_C@_04EIEIPGIG@bbgc?$AA@			; `string'
PUBLIC	??_C@_02DPGMDCM@gc?$AA@				; `string'
PUBLIC	??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@	; `string'
PUBLIC	??_C@_08FHIBLNMK@peval_io?$AA@			; `string'
PUBLIC	??_C@_09ELFALMPH@for_entry?$AA@			; `string'
PUBLIC	??_C@_0N@FJAFMCOA@member_entry?$AA@		; `string'
PUBLIC	??_C@_08HAIKBAPL@metatrue?$AA@			; `string'
PUBLIC	??_C@_08CCNDIAKO@metacall?$AA@			; `string'
PUBLIC	??_C@_0L@CGEGGNLF@prolog_run?$AA@		; `string'
PUBLIC	??_C@_0M@GFBJNNBE@prolog_init?$AA@		; `string'
PUBLIC	??_C@_0M@FBJEHGOI@prolog_load?$AA@		; `string'
PUBLIC	??_C@_0BM@IBODNHLO@inconsistent?5runtime?5system?$AA@ ; `string'
PUBLIC	??_C@_04OMFAIDPG@call?$AA@			; `string'
EXTRN	_hget:PROC
;	COMDAT ??_C@_08PPIJGMPL@callback?$AA@
CONST	SEGMENT
??_C@_08PPIJGMPL@callback?$AA@ DB 'callback', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGCDBJHP@answer?$AA@
CONST	SEGMENT
??_C@_06GGCDBJHP@answer?$AA@ DB 'answer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BKABJGDH@query?$AA@
CONST	SEGMENT
??_C@_05BKABJGDH@query?$AA@ DB 'query', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BFELHLO@reconsult?$AA@
CONST	SEGMENT
??_C@_09BFELHLO@reconsult?$AA@ DB 'reconsult', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLJGFCKG@compile?$AA@
CONST	SEGMENT
??_C@_07OLJGFCKG@compile?$AA@ DB 'compile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HMGHANFH@startup_file_name?$AA@
CONST	SEGMENT
??_C@_0BC@HMGHANFH@startup_file_name?$AA@ DB 'startup_file_name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLPKNAK@current_user_file?$AA@
CONST	SEGMENT
??_C@_0BC@NLPKNAK@current_user_file?$AA@ DB 'current_user_file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBFHLDAC@current_db?$AA@
CONST	SEGMENT
??_C@_0L@BBFHLDAC@current_db?$AA@ DB 'current_db', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NOLKIBGG@implem?$AA@
CONST	SEGMENT
??_C@_06NOLKIBGG@implem?$AA@ DB 'implem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JJLAMBGK@target?$AA@
CONST	SEGMENT
??_C@_06JJLAMBGK@target?$AA@ DB 'target', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBHABHOB@linking?$AA@
CONST	SEGMENT
??_C@_07PBHABHOB@linking?$AA@ DB 'linking', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GCILGOCP@user_output?$AA@
CONST	SEGMENT
??_C@_0M@GCILGOCP@user_output?$AA@ DB 'user_output', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FAMAGEAK@user_input?$AA@
CONST	SEGMENT
??_C@_0L@FAMAGEAK@user_input?$AA@ DB 'user_input', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJJIDCOK@tellfunc?$AA@
CONST	SEGMENT
??_C@_08FJJIDCOK@tellfunc?$AA@ DB 'tellfunc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPLPEHED@seefunc?$AA@
CONST	SEGMENT
??_C@_07HPLPEHED@seefunc?$AA@ DB 'seefunc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BGIJKJCF@tellfile?$AA@
CONST	SEGMENT
??_C@_08BGIJKJCF@tellfile?$AA@ DB 'tellfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILKIAHNN@lineno?$AA@
CONST	SEGMENT
??_C@_06ILKIAHNN@lineno?$AA@ DB 'lineno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DAKONMIM@seefile?$AA@
CONST	SEGMENT
??_C@_07DAKONMIM@seefile?$AA@ DB 'seefile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMKMEHFK@db_ratio?$AA@
CONST	SEGMENT
??_C@_08PMKMEHFK@db_ratio?$AA@ DB 'db_ratio', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLHACMPK@load_method?$AA@
CONST	SEGMENT
??_C@_0M@NLHACMPK@load_method?$AA@ DB 'load_method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GNCBFNIF@this_port?$AA@
CONST	SEGMENT
??_C@_09GNCBFNIF@this_port?$AA@ DB 'this_port', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PMBAOCDH@quiet?$AA@
CONST	SEGMENT
??_C@_05PMBAOCDH@quiet?$AA@ DB 'quiet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJPLFJDB@bbhi?$AA@
CONST	SEGMENT
??_C@_04LJPLFJDB@bbhi?$AA@ DB 'bbhi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIEIPGIG@bbgc?$AA@
CONST	SEGMENT
??_C@_04EIEIPGIG@bbgc?$AA@ DB 'bbgc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPGMDCM@gc?$AA@
CONST	SEGMENT
??_C@_02DPGMDCM@gc?$AA@ DB 'gc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
CONST	SEGMENT
??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@ DB 'sharing C-variable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHIBLNMK@peval_io?$AA@
CONST	SEGMENT
??_C@_08FHIBLNMK@peval_io?$AA@ DB 'peval_io', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELFALMPH@for_entry?$AA@
CONST	SEGMENT
??_C@_09ELFALMPH@for_entry?$AA@ DB 'for_entry', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJAFMCOA@member_entry?$AA@
CONST	SEGMENT
??_C@_0N@FJAFMCOA@member_entry?$AA@ DB 'member_entry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAIKBAPL@metatrue?$AA@
CONST	SEGMENT
??_C@_08HAIKBAPL@metatrue?$AA@ DB 'metatrue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCNDIAKO@metacall?$AA@
CONST	SEGMENT
??_C@_08CCNDIAKO@metacall?$AA@ DB 'metacall', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CGEGGNLF@prolog_run?$AA@
CONST	SEGMENT
??_C@_0L@CGEGGNLF@prolog_run?$AA@ DB 'prolog_run', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GFBJNNBE@prolog_init?$AA@
CONST	SEGMENT
??_C@_0M@GFBJNNBE@prolog_init?$AA@ DB 'prolog_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FBJEHGOI@prolog_load?$AA@
CONST	SEGMENT
??_C@_0M@FBJEHGOI@prolog_load?$AA@ DB 'prolog_load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IBODNHLO@inconsistent?5runtime?5system?$AA@
CONST	SEGMENT
??_C@_0BM@IBODNHLO@inconsistent?5runtime?5system?$AA@ DB 'inconsistent ru'
	DB	'ntime system', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OMFAIDPG@call?$AA@
CONST	SEGMENT
??_C@_04OMFAIDPG@call?$AA@ DB 'call', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _init_const_instr
_TEXT	SEGMENT
_init_const_instr PROC					; COMDAT

; 430  :   INIT_PRED(g.call,"call",1);

  00000	6a 02		 push	 2
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_04OMFAIDPG@call?$AA@
  00007	e8 00 00 00 00	 call	 _new_func
  0000c	50		 push	 eax
  0000d	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _hget
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	a3 00 00 00 00	 mov	 DWORD PTR _g, eax
  00020	85 c0		 test	 eax, eax
  00022	75 29		 jne	 SHORT $LN35@init_const
  00024	6a 01		 push	 1
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_04OMFAIDPG@call?$AA@
$LN40@init_const:
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  00031	51		 push	 ecx
$LN39@init_const:
  00032	e8 00 00 00 00	 call	 ___iob_func
  00037	83 c0 40	 add	 eax, 64			; 00000040H
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _fprintf
  00040	83 c4 10	 add	 esp, 16			; 00000010H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IBODNHLO@inconsistent?5runtime?5system?$AA@
$LN41@init_const:
  00048	e8 00 00 00 00	 call	 _fatal_error
$LN35@init_const:

; 431  :   /*INIT_PRED(g.prolog_main,"main",1);*/
; 432  :   INIT_PRED(g.prolog_load,"prolog_load",1);

  0004d	6a 02		 push	 2
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FBJEHGOI@prolog_load?$AA@
  00054	e8 00 00 00 00	 call	 _new_func
  00059	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104
  0005f	50		 push	 eax
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 _hget
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	a3 04 00 00 00	 mov	 DWORD PTR _g+4, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 0f		 jne	 SHORT $LN34@init_const
  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  00077	6a 01		 push	 1
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FBJEHGOI@prolog_load?$AA@
  0007e	50		 push	 eax
  0007f	eb b1		 jmp	 SHORT $LN39@init_const
$LN34@init_const:

; 433  :   INIT_PRED(g.prolog_init,"prolog_init",1);

  00081	6a 02		 push	 2
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GFBJNNBE@prolog_init?$AA@
  00088	e8 00 00 00 00	 call	 _new_func
  0008d	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _hget
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	a3 08 00 00 00	 mov	 DWORD PTR _g+8, eax
  000a2	85 c0		 test	 eax, eax
  000a4	75 13		 jne	 SHORT $LN33@init_const
  000a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  000ac	6a 01		 push	 1
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GFBJNNBE@prolog_init?$AA@
  000b3	52		 push	 edx
  000b4	e9 79 ff ff ff	 jmp	 $LN39@init_const
$LN33@init_const:

; 434  :   INIT_PRED(g.prolog_run,"prolog_run",1);

  000b9	6a 02		 push	 2
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CGEGGNLF@prolog_run?$AA@
  000c0	e8 00 00 00 00	 call	 _new_func
  000c5	50		 push	 eax
  000c6	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _hget
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	a3 0c 00 00 00	 mov	 DWORD PTR _g+12, eax
  000d9	85 c0		 test	 eax, eax
  000db	75 0c		 jne	 SHORT $LN32@init_const
  000dd	6a 01		 push	 1
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CGEGGNLF@prolog_run?$AA@
  000e4	e9 42 ff ff ff	 jmp	 $LN40@init_const
$LN32@init_const:

; 435  :   INIT_PRED(g.metacall,"metacall",1);

  000e9	6a 02		 push	 2
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_08CCNDIAKO@metacall?$AA@
  000f0	e8 00 00 00 00	 call	 _new_func
  000f5	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104
  000fb	50		 push	 eax
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _hget
  00102	83 c4 10	 add	 esp, 16			; 00000010H
  00105	a3 10 00 00 00	 mov	 DWORD PTR _g+16, eax
  0010a	6a 01		 push	 1
  0010c	85 c0		 test	 eax, eax
  0010e	75 10		 jne	 SHORT $LN31@init_const
  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_08CCNDIAKO@metacall?$AA@
  0011a	50		 push	 eax
  0011b	e9 12 ff ff ff	 jmp	 $LN39@init_const
$LN31@init_const:

; 436  :   INIT_PRED(g.metatrue,"metatrue",0);

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_08HAIKBAPL@metatrue?$AA@
  00125	e8 00 00 00 00	 call	 _new_func
  0012a	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR _g+104
  00130	50		 push	 eax
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 _hget
  00137	83 c4 10	 add	 esp, 16			; 00000010H
  0013a	a3 14 00 00 00	 mov	 DWORD PTR _g+20, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 12		 jne	 SHORT $LN30@init_const
  00143	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  00149	50		 push	 eax
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_08HAIKBAPL@metatrue?$AA@
  0014f	52		 push	 edx
  00150	e9 dd fe ff ff	 jmp	 $LN39@init_const
$LN30@init_const:

; 437  :   INIT_PRED(g.member_entry,"member_entry",2);

  00155	6a 03		 push	 3
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJAFMCOA@member_entry?$AA@
  0015c	e8 00 00 00 00	 call	 _new_func
  00161	50		 push	 eax
  00162	a1 68 00 00 00	 mov	 eax, DWORD PTR _g+104
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _hget
  0016d	83 c4 10	 add	 esp, 16			; 00000010H
  00170	a3 18 00 00 00	 mov	 DWORD PTR _g+24, eax
  00175	85 c0		 test	 eax, eax
  00177	75 0c		 jne	 SHORT $LN29@init_const
  00179	6a 02		 push	 2
  0017b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FJAFMCOA@member_entry?$AA@
  00180	e9 a6 fe ff ff	 jmp	 $LN40@init_const
$LN29@init_const:

; 438  :   INIT_PRED(g.for_entry,"for_entry",3);

  00185	6a 04		 push	 4
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_09ELFALMPH@for_entry?$AA@
  0018c	e8 00 00 00 00	 call	 _new_func
  00191	8b 15 68 00 00
	00		 mov	 edx, DWORD PTR _g+104
  00197	50		 push	 eax
  00198	52		 push	 edx
  00199	e8 00 00 00 00	 call	 _hget
  0019e	83 c4 10	 add	 esp, 16			; 00000010H
  001a1	a3 1c 00 00 00	 mov	 DWORD PTR _g+28, eax
  001a6	85 c0		 test	 eax, eax
  001a8	75 12		 jne	 SHORT $LN28@init_const
  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?format_mes@?1??init_const_instr@@9@9
  001af	6a 03		 push	 3
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_09ELFALMPH@for_entry?$AA@
  001b6	50		 push	 eax
  001b7	e9 76 fe ff ff	 jmp	 $LN39@init_const
$LN28@init_const:

; 439  : 
; 440  :   VSHARE("peval_io",g.peval_io);

  001bc	b9 d8 00 00 00	 mov	 ecx, OFFSET _g+216
  001c1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08FHIBLNMK@peval_io?$AA@
  001c6	e8 00 00 00 00	 call	 _hdef_ptr
  001cb	85 c0		 test	 eax, eax
  001cd	75 0a		 jne	 SHORT $LN27@init_const
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  001d4	e9 6f fe ff ff	 jmp	 $LN41@init_const
$LN27@init_const:

; 441  : 
; 442  :   VSHARE("gc",g.gc);

  001d9	b9 f8 00 00 00	 mov	 ecx, OFFSET _g+248
  001de	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_02DPGMDCM@gc?$AA@
  001e3	e8 00 00 00 00	 call	 _hdef_ptr
  001e8	85 c0		 test	 eax, eax
  001ea	75 0a		 jne	 SHORT $LN26@init_const
  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  001f1	e9 52 fe ff ff	 jmp	 $LN41@init_const
$LN26@init_const:

; 443  :   VSHARE("bbgc",g.bbgc);

  001f6	b9 fc 00 00 00	 mov	 ecx, OFFSET _g+252
  001fb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04EIEIPGIG@bbgc?$AA@
  00200	e8 00 00 00 00	 call	 _hdef_ptr
  00205	85 c0		 test	 eax, eax
  00207	75 0a		 jne	 SHORT $LN25@init_const
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0020e	e9 35 fe ff ff	 jmp	 $LN41@init_const
$LN25@init_const:

; 444  :   VSHARE("bbhi",g.bbhi);

  00213	b9 00 01 00 00	 mov	 ecx, OFFSET _g+256
  00218	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04LJPLFJDB@bbhi?$AA@
  0021d	e8 00 00 00 00	 call	 _hdef_ptr
  00222	85 c0		 test	 eax, eax
  00224	75 0a		 jne	 SHORT $LN24@init_const
  00226	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0022b	e9 18 fe ff ff	 jmp	 $LN41@init_const
$LN24@init_const:

; 445  : 
; 446  :   VSHARE("quiet",max.QUIET);

  00230	b9 24 00 00 00	 mov	 ecx, OFFSET _max+36
  00235	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05PMBAOCDH@quiet?$AA@
  0023a	e8 00 00 00 00	 call	 _hdef_ptr
  0023f	85 c0		 test	 eax, eax
  00241	75 0a		 jne	 SHORT $LN23@init_const
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00248	e9 fb fd ff ff	 jmp	 $LN41@init_const
$LN23@init_const:

; 447  :   VSHARE("this_port",max.PORT);

  0024d	b9 34 00 00 00	 mov	 ecx, OFFSET _max+52
  00252	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09GNCBFNIF@this_port?$AA@
  00257	e8 00 00 00 00	 call	 _hdef_ptr
  0025c	85 c0		 test	 eax, eax
  0025e	75 0a		 jne	 SHORT $LN22@init_const
  00260	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00265	e9 de fd ff ff	 jmp	 $LN41@init_const
$LN22@init_const:

; 448  :   VSHARE("load_method",max.LMETH);

  0026a	b9 28 00 00 00	 mov	 ecx, OFFSET _max+40
  0026f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@NLHACMPK@load_method?$AA@
  00274	e8 00 00 00 00	 call	 _hdef_ptr
  00279	85 c0		 test	 eax, eax
  0027b	75 0a		 jne	 SHORT $LN21@init_const
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00282	e9 c1 fd ff ff	 jmp	 $LN41@init_const
$LN21@init_const:

; 449  :   VSHARE("db_ratio",max.DB_RATIO);

  00287	b9 2c 00 00 00	 mov	 ecx, OFFSET _max+44
  0028c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08PMKMEHFK@db_ratio?$AA@
  00291	e8 00 00 00 00	 call	 _hdef_ptr
  00296	85 c0		 test	 eax, eax
  00298	75 0a		 jne	 SHORT $LN20@init_const
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0029f	e9 a4 fd ff ff	 jmp	 $LN41@init_const
$LN20@init_const:

; 450  :   VSHARE("seefile",g.seefile);

  002a4	b9 30 01 00 00	 mov	 ecx, OFFSET _g+304
  002a9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07DAKONMIM@seefile?$AA@
  002ae	e8 00 00 00 00	 call	 _hdef_ptr
  002b3	85 c0		 test	 eax, eax
  002b5	75 0a		 jne	 SHORT $LN19@init_const
  002b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  002bc	e9 87 fd ff ff	 jmp	 $LN41@init_const
$LN19@init_const:

; 451  :   VSHARE("lineno",g.lineno);

  002c1	b9 40 01 00 00	 mov	 ecx, OFFSET _g+320
  002c6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06ILKIAHNN@lineno?$AA@
  002cb	e8 00 00 00 00	 call	 _hdef_ptr
  002d0	85 c0		 test	 eax, eax
  002d2	75 0a		 jne	 SHORT $LN18@init_const
  002d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  002d9	e9 6a fd ff ff	 jmp	 $LN41@init_const
$LN18@init_const:

; 452  :   VSHARE("tellfile",g.tellfile);

  002de	b9 34 01 00 00	 mov	 ecx, OFFSET _g+308
  002e3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08BGIJKJCF@tellfile?$AA@
  002e8	e8 00 00 00 00	 call	 _hdef_ptr
  002ed	85 c0		 test	 eax, eax
  002ef	75 0a		 jne	 SHORT $LN17@init_const
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  002f6	e9 4d fd ff ff	 jmp	 $LN41@init_const
$LN17@init_const:

; 453  :   VSHARE("seefunc",g.seefunc);

  002fb	b9 8c 00 00 00	 mov	 ecx, OFFSET _g+140
  00300	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07HPLPEHED@seefunc?$AA@
  00305	e8 00 00 00 00	 call	 _hdef_ptr
  0030a	85 c0		 test	 eax, eax
  0030c	75 0a		 jne	 SHORT $LN16@init_const
  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00313	e9 30 fd ff ff	 jmp	 $LN41@init_const
$LN16@init_const:

; 454  :   VSHARE("tellfunc",g.tellfunc);

  00318	b9 90 00 00 00	 mov	 ecx, OFFSET _g+144
  0031d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08FJJIDCOK@tellfunc?$AA@
  00322	e8 00 00 00 00	 call	 _hdef_ptr
  00327	85 c0		 test	 eax, eax
  00329	75 0a		 jne	 SHORT $LN15@init_const
  0032b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00330	e9 13 fd ff ff	 jmp	 $LN41@init_const
$LN15@init_const:

; 455  :   VSHARE("user_input",g.user_input);

  00335	b9 38 01 00 00	 mov	 ecx, OFFSET _g+312
  0033a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@FAMAGEAK@user_input?$AA@
  0033f	e8 00 00 00 00	 call	 _hdef_ptr
  00344	85 c0		 test	 eax, eax
  00346	75 0a		 jne	 SHORT $LN14@init_const
  00348	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0034d	e9 f6 fc ff ff	 jmp	 $LN41@init_const
$LN14@init_const:

; 456  :   VSHARE("user_output",g.user_output);

  00352	b9 3c 01 00 00	 mov	 ecx, OFFSET _g+316
  00357	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@GCILGOCP@user_output?$AA@
  0035c	e8 00 00 00 00	 call	 _hdef_ptr
  00361	85 c0		 test	 eax, eax
  00363	75 0a		 jne	 SHORT $LN13@init_const
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0036a	e9 d9 fc ff ff	 jmp	 $LN41@init_const
$LN13@init_const:

; 457  :   VSHARE("linking",g.linking);

  0036f	b9 f4 00 00 00	 mov	 ecx, OFFSET _g+244
  00374	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07PBHABHOB@linking?$AA@
  00379	e8 00 00 00 00	 call	 _hdef_ptr
  0037e	85 c0		 test	 eax, eax
  00380	75 0a		 jne	 SHORT $LN12@init_const
  00382	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00387	e9 bc fc ff ff	 jmp	 $LN41@init_const
$LN12@init_const:

; 458  :   VSHARE("source",g.source);

  0038c	b9 c8 00 00 00	 mov	 ecx, OFFSET _g+200
  00391	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06OEKOLKIL@source?$AA@
  00396	e8 00 00 00 00	 call	 _hdef_ptr
  0039b	85 c0		 test	 eax, eax
  0039d	75 0a		 jne	 SHORT $LN11@init_const
  0039f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003a4	e9 9f fc ff ff	 jmp	 $LN41@init_const
$LN11@init_const:

; 459  :   VSHARE("target",g.target);

  003a9	b9 cc 00 00 00	 mov	 ecx, OFFSET _g+204
  003ae	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06JJLAMBGK@target?$AA@
  003b3	e8 00 00 00 00	 call	 _hdef_ptr
  003b8	85 c0		 test	 eax, eax
  003ba	75 0a		 jne	 SHORT $LN10@init_const
  003bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003c1	e9 82 fc ff ff	 jmp	 $LN41@init_const
$LN10@init_const:

; 460  :   VSHARE("implem",g.implem);

  003c6	b9 d0 00 00 00	 mov	 ecx, OFFSET _g+208
  003cb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06NOLKIBGG@implem?$AA@
  003d0	e8 00 00 00 00	 call	 _hdef_ptr
  003d5	85 c0		 test	 eax, eax
  003d7	75 0a		 jne	 SHORT $LN9@init_const
  003d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003de	e9 65 fc ff ff	 jmp	 $LN41@init_const
$LN9@init_const:

; 461  : 
; 462  :   VSHARE("current_db",g.current_db);

  003e3	b9 bc 00 00 00	 mov	 ecx, OFFSET _g+188
  003e8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@BBFHLDAC@current_db?$AA@
  003ed	e8 00 00 00 00	 call	 _hdef_ptr
  003f2	85 c0		 test	 eax, eax
  003f4	75 0a		 jne	 SHORT $LN8@init_const
  003f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003fb	e9 48 fc ff ff	 jmp	 $LN41@init_const
$LN8@init_const:

; 463  :   VSHARE("current_user_file",g.current_user_file);

  00400	b9 c0 00 00 00	 mov	 ecx, OFFSET _g+192
  00405	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@NLPKNAK@current_user_file?$AA@
  0040a	e8 00 00 00 00	 call	 _hdef_ptr
  0040f	85 c0		 test	 eax, eax
  00411	75 0a		 jne	 SHORT $LN7@init_const
  00413	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00418	e9 2b fc ff ff	 jmp	 $LN41@init_const
$LN7@init_const:

; 464  :   VSHARE("startup_file_name",g.startup_file_name);

  0041d	b9 e0 00 00 00	 mov	 ecx, OFFSET _g+224
  00422	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BC@HMGHANFH@startup_file_name?$AA@
  00427	e8 00 00 00 00	 call	 _hdef_ptr
  0042c	85 c0		 test	 eax, eax
  0042e	75 0a		 jne	 SHORT $LN6@init_const
  00430	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00435	e9 0e fc ff ff	 jmp	 $LN41@init_const
$LN6@init_const:

; 465  :   VSHARE("compile",g.compile);

  0043a	b9 b4 00 00 00	 mov	 ecx, OFFSET _g+180
  0043f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07OLJGFCKG@compile?$AA@
  00444	e8 00 00 00 00	 call	 _hdef_ptr
  00449	85 c0		 test	 eax, eax
  0044b	75 0a		 jne	 SHORT $LN5@init_const
  0044d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00452	e9 f1 fb ff ff	 jmp	 $LN41@init_const
$LN5@init_const:

; 466  :   VSHARE("reconsult",g.reconsult);

  00457	b9 b8 00 00 00	 mov	 ecx, OFFSET _g+184
  0045c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09BFELHLO@reconsult?$AA@
  00461	e8 00 00 00 00	 call	 _hdef_ptr
  00466	85 c0		 test	 eax, eax
  00468	75 0a		 jne	 SHORT $LN4@init_const
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0046f	e9 d4 fb ff ff	 jmp	 $LN41@init_const
$LN4@init_const:

; 467  : 
; 468  :   VSHARE("query",g.query);

  00474	b9 e4 00 00 00	 mov	 ecx, OFFSET _g+228
  00479	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05BKABJGDH@query?$AA@
  0047e	e8 00 00 00 00	 call	 _hdef_ptr
  00483	85 c0		 test	 eax, eax
  00485	75 0a		 jne	 SHORT $LN3@init_const
  00487	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0048c	e9 b7 fb ff ff	 jmp	 $LN41@init_const
$LN3@init_const:

; 469  :   VSHARE("answer",g.answer);

  00491	b9 e8 00 00 00	 mov	 ecx, OFFSET _g+232
  00496	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06GGCDBJHP@answer?$AA@
  0049b	e8 00 00 00 00	 call	 _hdef_ptr
  004a0	85 c0		 test	 eax, eax
  004a2	75 0a		 jne	 SHORT $LN2@init_const
  004a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  004a9	e9 9a fb ff ff	 jmp	 $LN41@init_const
$LN2@init_const:

; 470  :   VSHARE("callback",g.callback);

  004ae	b9 ec 00 00 00	 mov	 ecx, OFFSET _g+236
  004b3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08PPIJGMPL@callback?$AA@
  004b8	e8 00 00 00 00	 call	 _hdef_ptr
  004bd	85 c0		 test	 eax, eax
  004bf	75 0a		 jne	 SHORT $LN1@init_const
  004c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  004c6	e9 7d fb ff ff	 jmp	 $LN41@init_const
$LN1@init_const:

; 471  : }

  004cb	c3		 ret	 0
$LN38@init_const:
_init_const_instr ENDP
_TEXT	ENDS
PUBLIC	_make_byte_array
EXTRN	_calloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT _make_byte_array
_TEXT	SEGMENT
_a_size$ = 8						; size = 4
_make_byte_array PROC					; COMDAT

; 478  :   return ZALLOC(a_size,byte);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _a_size$[esp-4]
  00004	6a 01		 push	 1
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8

; 479  : }

  0000f	c3		 ret	 0
_make_byte_array ENDP
_TEXT	ENDS
PUBLIC	_make_char_array
; Function compile flags: /Ogtpy
;	COMDAT _make_char_array
_TEXT	SEGMENT
_a_size$ = 8						; size = 4
_make_char_array PROC					; COMDAT

; 483  :   return ZALLOC(a_size,char);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _a_size$[esp-4]
  00004	6a 01		 push	 1
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8

; 484  : }

  0000f	c3		 ret	 0
_make_char_array ENDP
_TEXT	ENDS
PUBLIC	_make_hentry
; Function compile flags: /Ogtpy
;	COMDAT _make_hentry
_TEXT	SEGMENT
_a_size$ = 8						; size = 4
_make_hentry PROC					; COMDAT

; 488  :   return ZALLOC(a_size,struct hentry);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _a_size$[esp-4]
  00004	6a 0c		 push	 12			; 0000000cH
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8

; 489  : }

  0000f	c3		 ret	 0
_make_hentry ENDP
_TEXT	ENDS
PUBLIC	_make_atomtable
; Function compile flags: /Ogtpy
;	COMDAT _make_atomtable
_TEXT	SEGMENT
_a_size$ = 8						; size = 4
_make_atomtable PROC					; COMDAT

; 493  :   return ZALLOC(a_size,string);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _a_size$[esp-4]
  00004	6a 04		 push	 4
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _calloc
  0000c	83 c4 08	 add	 esp, 8

; 494  : }

  0000f	c3		 ret	 0
_make_atomtable ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _fill_var_array
_TEXT	SEGMENT
_fill_var_array PROC					; COMDAT
; _t$ = eax
; _a_size$ = ecx

; 498  :   for(i=0; i<a_size; i++)

  00000	85 c9		 test	 ecx, ecx
  00002	7e 08		 jle	 SHORT $LN1@fill_var_a
$LL3@fill_var_a:

; 499  :     SETREF(t+i,t+i);

  00004	89 00		 mov	 DWORD PTR [eax], eax
  00006	83 c0 04	 add	 eax, 4
  00009	49		 dec	 ecx
  0000a	75 f8		 jne	 SHORT $LL3@fill_var_a
$LN1@fill_var_a:

; 500  : }

  0000c	c3		 ret	 0
_fill_var_array ENDP
_TEXT	ENDS
PUBLIC	_make_var_array
EXTRN	_malloc:PROC
; Function compile flags: /Ogtpy
;	COMDAT _make_var_array
_TEXT	SEGMENT
_a_size$ = 8						; size = 4
_make_var_array PROC					; COMDAT

; 503  : { term t;

  00000	56		 push	 esi

; 504  :   t=(term)TALLOC(a_size);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _a_size$[esp]
  00005	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _malloc
  00012	83 c4 04	 add	 esp, 4

; 505  :   fill_var_array(t,a_size);

  00015	85 f6		 test	 esi, esi
  00017	7e 0f		 jle	 SHORT $LN3@make_var_a

; 504  :   t=(term)TALLOC(a_size);

  00019	8b c8		 mov	 ecx, eax
  0001b	8b d6		 mov	 edx, esi
  0001d	8d 49 00	 npad	 3

; 505  :   fill_var_array(t,a_size);

$LL5@make_var_a:
  00020	89 09		 mov	 DWORD PTR [ecx], ecx
  00022	83 c1 04	 add	 ecx, 4
  00025	4a		 dec	 edx
  00026	75 f8		 jne	 SHORT $LL5@make_var_a
$LN3@make_var_a:
  00028	5e		 pop	 esi

; 506  :   return t;
; 507  : }

  00029	c3		 ret	 0
_make_var_array ENDP
_TEXT	ENDS
PUBLIC	_init_var_array
; Function compile flags: /Ogtpy
;	COMDAT _init_var_array
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_size$ = 12						; size = 4
_init_var_array PROC					; COMDAT

; 520  :   fill_var_array(handle,size);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _size$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	7e 16		 jle	 SHORT $LN10@init_var_a
  00008	8b 54 24 04	 mov	 edx, DWORD PTR _handle$[esp-4]
  0000c	8b c2		 mov	 eax, edx
  0000e	8b ff		 npad	 2
$LL5@init_var_a:
  00010	89 00		 mov	 DWORD PTR [eax], eax
  00012	83 c0 04	 add	 eax, 4
  00015	49		 dec	 ecx
  00016	75 f8		 jne	 SHORT $LL5@init_var_a

; 521  :   SETREF(handle,handle+1);

  00018	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 522  : }

  0001d	c3		 ret	 0
$LN10@init_var_a:

; 521  :   SETREF(handle,handle+1);

  0001e	8b 44 24 04	 mov	 eax, DWORD PTR _handle$[esp-4]
  00022	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 522  : }

  00027	c3		 ret	 0
_init_var_array ENDP
_TEXT	ENDS
PUBLIC	_make_stack
; Function compile flags: /Ogtpy
;	COMDAT _make_stack
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_check$ = 16						; size = 4
_name$ = 20						; size = 4
_area$ = 24						; size = 4
_notzeroed$ = 28					; size = 4
_make_stack PROC					; COMDAT

; 525  : {

  00000	53		 push	 ebx

; 526  :   s->size=n;
; 527  :   s->over=check;

  00001	8b 5c 24 10	 mov	 ebx, DWORD PTR _check$[esp]
  00005	56		 push	 esi
  00006	8b 74 24 0c	 mov	 esi, DWORD PTR _s$[esp+4]
  0000a	57		 push	 edi
  0000b	8b 7c 24 14	 mov	 edi, DWORD PTR _n$[esp+8]
  0000f	89 3e		 mov	 DWORD PTR [esi], edi
  00011	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 528  :   if(n<check) return FALSE;

  00014	3b fb		 cmp	 edi, ebx
  00016	7d 06		 jge	 SHORT $LN2@make_stack
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	33 c0		 xor	 eax, eax
  0001c	5b		 pop	 ebx

; 542  : }

  0001d	c3		 ret	 0
$LN2@make_stack:

; 529  : 
; 530  :   if(!area) {

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR _area$[esp+8]
  00022	85 c0		 test	 eax, eax
  00024	75 23		 jne	 SHORT $LN6@make_stack

; 531  :       area = (notzeroed ? TALLOC(n) : ZALLOC(n,term));

  00026	39 44 24 24	 cmp	 DWORD PTR _notzeroed$[esp+8], eax
  0002a	74 12		 je	 SHORT $LN5@make_stack
  0002c	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _malloc
  00039	83 c4 04	 add	 esp, 4
  0003c	eb 0b		 jmp	 SHORT $LN6@make_stack
$LN5@make_stack:
  0003e	6a 04		 push	 4
  00040	57		 push	 edi
  00041	e8 00 00 00 00	 call	 _calloc
  00046	83 c4 08	 add	 esp, 8
$LN6@make_stack:

; 532  :   }
; 533  : 
; 534  :   s->base=area;
; 535  :   s->end=s->base+s->size;

  00049	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]

; 536  :   s->margin=s->end-s->over;

  0004c	8d 14 9d 00 00
	00 00		 lea	 edx, DWORD PTR [ebx*4]
  00053	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00056	2b ca		 sub	 ecx, edx

; 537  :   s->top=s->base;
; 538  :   s->oldtop=s->base;
; 539  :   s->maxused=0;
; 540  :   s->name=name;
; 541  :   return !!s->base;

  00058	33 d2		 xor	 edx, edx
  0005a	85 c0		 test	 eax, eax
  0005c	0f 95 c2	 setne	 dl
  0005f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00062	8b 4c 24 1c	 mov	 ecx, DWORD PTR _name$[esp+8]
  00066	5f		 pop	 edi
  00067	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0006a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0006d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00070	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00077	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  0007a	5e		 pop	 esi
  0007b	8b c2		 mov	 eax, edx
  0007d	5b		 pop	 ebx

; 542  : }

  0007e	c3		 ret	 0
_make_stack ENDP
_TEXT	ENDS
PUBLIC	??_C@_05MFBNJCGK@board?$AA@			; `string'
PUBLIC	_make_bboard
;	COMDAT ??_C@_05MFBNJCGK@board?$AA@
CONST	SEGMENT
??_C@_05MFBNJCGK@board?$AA@ DB 'board', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _make_bboard
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_make_bboard PROC					; COMDAT

; 565  : #if defined REUSE
; 566  :   if(max.BOARD>wam_bp_size)
; 567  :     return MAKE_BBOARD(max.BOARD,NULL);
; 568  :   else
; 569  :     return MAKE_BBOARD(wam_bp_size/sizeof(term),(term *)wam_bp);
; 570  : #else
; 571  :   return MAKE_BBOARD(max.BOARD,NULL);

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR _max+16
  00005	a3 98 01 00 00	 mov	 DWORD PTR _g+408, eax
  0000a	c7 05 9c 01 00
	00 01 02 00 00	 mov	 DWORD PTR _g+412, 513	; 00000201H
  00014	3d 01 02 00 00	 cmp	 eax, 513		; 00000201H
  00019	7d 03		 jge	 SHORT $LN9@make_bboar
  0001b	33 c0		 xor	 eax, eax

; 572  : #endif
; 573  : }

  0001d	c3		 ret	 0
$LN9@make_bboar:
  0001e	56		 push	 esi

; 565  : #if defined REUSE
; 566  :   if(max.BOARD>wam_bp_size)
; 567  :     return MAKE_BBOARD(max.BOARD,NULL);
; 568  :   else
; 569  :     return MAKE_BBOARD(wam_bp_size/sizeof(term),(term *)wam_bp);
; 570  : #else
; 571  :   return MAKE_BBOARD(max.BOARD,NULL);

  0001f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _malloc
  0002c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002f	89 0d b0 01 00
	00		 mov	 DWORD PTR _g+432, ecx
  00035	81 c1 fc f7 ff
	ff		 add	 ecx, -2052		; fffff7fcH
  0003b	89 0d ac 01 00
	00		 mov	 DWORD PTR _g+428, ecx
  00041	33 c9		 xor	 ecx, ecx
  00043	83 c4 04	 add	 esp, 4
  00046	85 c0		 test	 eax, eax
  00048	0f 95 c1	 setne	 cl
  0004b	a3 a8 01 00 00	 mov	 DWORD PTR _g+424, eax
  00050	a3 a0 01 00 00	 mov	 DWORD PTR _g+416, eax
  00055	a3 a4 01 00 00	 mov	 DWORD PTR _g+420, eax
  0005a	c7 05 b4 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+436, 0
  00064	c7 05 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+440, OFFSET ??_C@_05MFBNJCGK@board?$AA@
  0006e	5e		 pop	 esi
  0006f	8b c1		 mov	 eax, ecx

; 572  : #endif
; 573  : }

  00071	c3		 ret	 0
_make_bboard ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@DHLDDPH@not?5enough?5common?5memory?$AA@ ; `string'
PUBLIC	??_C@_04NDFOBODE@code?$AA@			; `string'
PUBLIC	_init_common_mem
EXTRN	_hinit:PROC
EXTRN	_init_instr_len:PROC
EXTRN	_make_symtable:PROC
;	COMDAT ??_C@_0BJ@DHLDDPH@not?5enough?5common?5memory?$AA@
CONST	SEGMENT
??_C@_0BJ@DHLDDPH@not?5enough?5common?5memory?$AA@ DB 'not enough common '
	DB	'memory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04NDFOBODE@code?$AA@
CONST	SEGMENT
??_C@_04NDFOBODE@code?$AA@ DB 'code', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _init_common_mem
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_init_common_mem PROC					; COMDAT

; 577  :   no errctr=0;
; 578  : 
; 579  :   errctr+=!make_stack(&g.shared[InstrStk],max.CODE,4,"code",NULL,1);

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR _max+12
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	a3 74 01 00 00	 mov	 DWORD PTR _g+372, eax
  0000c	c7 05 78 01 00
	00 04 00 00 00	 mov	 DWORD PTR _g+376, 4
  00016	83 f8 04	 cmp	 eax, 4
  00019	7d 04		 jge	 SHORT $LN18@init_commo
  0001b	33 ff		 xor	 edi, edi
  0001d	eb 4e		 jmp	 SHORT $LN10@init_commo
$LN18@init_commo:
  0001f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _malloc
  0002c	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0002f	89 0d 8c 01 00
	00		 mov	 DWORD PTR _g+396, ecx
  00035	83 c1 f0	 add	 ecx, -16		; fffffff0H
  00038	89 0d 88 01 00
	00		 mov	 DWORD PTR _g+392, ecx
  0003e	33 c9		 xor	 ecx, ecx
  00040	83 c4 04	 add	 esp, 4
  00043	85 c0		 test	 eax, eax
  00045	0f 95 c1	 setne	 cl
  00048	a3 84 01 00 00	 mov	 DWORD PTR _g+388, eax
  0004d	a3 7c 01 00 00	 mov	 DWORD PTR _g+380, eax
  00052	a3 80 01 00 00	 mov	 DWORD PTR _g+384, eax
  00057	c7 05 90 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+400, 0
  00061	c7 05 94 01 00
	00 00 00 00 00	 mov	 DWORD PTR _g+404, OFFSET ??_C@_04NDFOBODE@code?$AA@
  0006b	8b f9		 mov	 edi, ecx
$LN10@init_commo:

; 580  :   errctr+=!make_symtable();

  0006d	e8 00 00 00 00	 call	 _make_symtable
  00072	f7 d8		 neg	 eax
  00074	1b f6		 sbb	 esi, esi
  00076	33 d2		 xor	 edx, edx
  00078	46		 inc	 esi
  00079	85 ff		 test	 edi, edi
  0007b	0f 94 c2	 sete	 dl
  0007e	03 f2		 add	 esi, edx

; 581  : 
; 582  :   init_instr_len();

  00080	e8 00 00 00 00	 call	 _init_instr_len

; 583  : 
; 584  :   g.stop=g.sbuf=make_char_array(max.SBUF);

  00085	a1 1c 00 00 00	 mov	 eax, DWORD PTR _max+28
  0008a	6a 01		 push	 1
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _calloc

; 585  : 
; 586  :   errctr += !g.sbuf;

  00092	33 c9		 xor	 ecx, ecx
  00094	83 c4 08	 add	 esp, 8
  00097	85 c0		 test	 eax, eax
  00099	0f 94 c1	 sete	 cl
  0009c	a3 4c 01 00 00	 mov	 DWORD PTR _g+332, eax
  000a1	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  000a6	03 f1		 add	 esi, ecx

; 587  : 
; 588  :   /* this makes bboard older than htable (to look more permanent) */
; 589  : 
; 590  :   if(!OUTPUT_INT(g.bbhi)) errctr+=!make_bboard(wam);

  000a8	f7 05 00 01 00
	00 fc ff ff ff	 test	 DWORD PTR _g+256, -4	; fffffffcH
  000b2	75 14		 jne	 SHORT $LN3@init_commo
  000b4	8b 54 24 0c	 mov	 edx, DWORD PTR _wam$[esp+4]
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 _make_bboard
  000be	83 c4 04	 add	 esp, 4
  000c1	f7 d8		 neg	 eax
  000c3	1b c0		 sbb	 eax, eax
  000c5	40		 inc	 eax
  000c6	03 f0		 add	 esi, eax
$LN3@init_commo:

; 591  : 
; 592  :   /* should be older than heap (to look more permanent) */
; 593  :   /* errctr+=!(g.connect=new_var_array(MAXDCG)); GC BUG ->local to engine */
; 594  : 
; 595  :   errctr+=!(g.engines=ZALLOC(MAXENGINES,stack));

  000c8	6a 04		 push	 4
  000ca	68 00 04 00 00	 push	 1024			; 00000400H
  000cf	e8 00 00 00 00	 call	 _calloc
  000d4	33 c9		 xor	 ecx, ecx
  000d6	83 c4 08	 add	 esp, 8
  000d9	85 c0		 test	 eax, eax
  000db	0f 94 c1	 sete	 cl
  000de	a3 54 01 00 00	 mov	 DWORD PTR _g+340, eax

; 596  :   g.lastengine=g.engines-1;

  000e3	83 c0 fc	 add	 eax, -4			; fffffffcH
  000e6	a3 58 01 00 00	 mov	 DWORD PTR _g+344, eax
  000eb	03 f1		 add	 esi, ecx

; 597  :   errctr+=!(hinit() && hdefaults());

  000ed	e8 00 00 00 00	 call	 _hinit
  000f2	85 c0		 test	 eax, eax
  000f4	74 0d		 je	 SHORT $LN6@init_commo
  000f6	e8 00 00 00 00	 call	 _hdefaults
  000fb	85 c0		 test	 eax, eax
  000fd	74 04		 je	 SHORT $LN6@init_commo
  000ff	33 c0		 xor	 eax, eax
  00101	eb 05		 jmp	 SHORT $LN7@init_commo
$LN6@init_commo:
  00103	b8 01 00 00 00	 mov	 eax, 1
$LN7@init_commo:
  00108	5f		 pop	 edi
  00109	03 c6		 add	 eax, esi
  0010b	5e		 pop	 esi

; 598  : 
; 599  :   if(errctr)

  0010c	74 1e		 je	 SHORT $LN2@init_commo

; 600  :     ERREXIT("not enough common memory")

  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHLDDPH@not?5enough?5common?5memory?$AA@
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00118	e8 00 00 00 00	 call	 ___iob_func
  0011d	83 c0 40	 add	 eax, 64			; 00000040H
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 _fprintf
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH
  00129	33 c0		 xor	 eax, eax

; 603  : }

  0012b	c3		 ret	 0
$LN2@init_commo:

; 601  :   else
; 602  :     return TRUE;

  0012c	b8 01 00 00 00	 mov	 eax, 1

; 603  : }

  00131	c3		 ret	 0
_init_common_mem ENDP
_TEXT	ENDS
PUBLIC	_is_engine
; Function compile flags: /Ogtpy
;	COMDAT _is_engine
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_is_engine PROC						; COMDAT

; 607  :   if(NULL==wam) return FALSE;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _wam$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	74 1a		 je	 SHORT $LN2@is_engine

; 608  :   for(p=g.engines;p<=g.lastengine;p++)

  00008	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  0000d	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  00013	3b c1		 cmp	 eax, ecx
  00015	77 0b		 ja	 SHORT $LN2@is_engine
$LL4@is_engine:

; 609  :     {
; 610  :        if(*p==wam)

  00017	39 10		 cmp	 DWORD PTR [eax], edx
  00019	74 0a		 je	 SHORT $LN9@is_engine

; 608  :   for(p=g.engines;p<=g.lastengine;p++)

  0001b	83 c0 04	 add	 eax, 4
  0001e	3b c1		 cmp	 eax, ecx
  00020	76 f5		 jbe	 SHORT $LL4@is_engine
$LN2@is_engine:

; 613  :          }
; 614  :     }
; 615  :   return FALSE;

  00022	33 c0		 xor	 eax, eax

; 616  : }

  00024	c3		 ret	 0
$LN9@is_engine:

; 611  :          {
; 612  :            return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 616  : }

  0002a	c3		 ret	 0
_is_engine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@ ; `string'
PUBLIC	_set_engine_prop
;	COMDAT ??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@
CONST	SEGMENT
??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@ DB 'trying to s'
	DB	'et engine property on a non-engine', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _set_engine_prop
_TEXT	SEGMENT
_engine$ = 8						; size = 4
_propNo$ = 12						; size = 4
_valNo$ = 16						; size = 4
_set_engine_prop PROC					; COMDAT

; 619  :   stack wam=INT2PTR(engine);

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _engine$[esp-4]
  00004	4a		 dec	 edx

; 620  :   if(!is_engine(wam)) {

  00005	74 1a		 je	 SHORT $LN5@set_engine
  00007	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  0000c	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  00012	3b c1		 cmp	 eax, ecx
  00014	77 0b		 ja	 SHORT $LN5@set_engine
$LL7@set_engine:
  00016	39 10		 cmp	 DWORD PTR [eax], edx
  00018	74 23		 je	 SHORT $LN1@set_engine
  0001a	83 c0 04	 add	 eax, 4
  0001d	3b c1		 cmp	 eax, ecx
  0001f	76 f5		 jbe	 SHORT $LL7@set_engine
$LN5@set_engine:

; 621  :     warnmes("trying to set engine property on a non-engine"); /*$$*/

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  0002b	e8 00 00 00 00	 call	 ___iob_func
  00030	83 c0 40	 add	 eax, 64			; 00000040H
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _fprintf
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 625  : #if (TRACE>0)
; 626  :   fprintf(STD_err,"TRACE set_engine_prop: %ld %ld %ld\n",
; 627  :     OUTPUT_INT(engine),propNo,valNo);
; 628  : #endif
; 629  : }

  0003c	c3		 ret	 0
$LN1@set_engine:

; 622  :     return;
; 623  :   }
; 624  :   SET_ENGINE(propNo,valNo);

  0003d	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00040	8b 4c 24 0c	 mov	 ecx, DWORD PTR _valNo$[esp-4]
  00044	8b 54 24 08	 mov	 edx, DWORD PTR _propNo$[esp-4]
  00048	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 625  : #if (TRACE>0)
; 626  :   fprintf(STD_err,"TRACE set_engine_prop: %ld %ld %ld\n",
; 627  :     OUTPUT_INT(engine),propNo,valNo);
; 628  : #endif
; 629  : }

  0004b	c3		 ret	 0
_set_engine_prop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@GDFGOGHE@trying?5to?5get?5engine?5property?5on@ ; `string'
PUBLIC	_get_engine_prop
;	COMDAT ??_C@_0CO@GDFGOGHE@trying?5to?5get?5engine?5property?5on@
CONST	SEGMENT
??_C@_0CO@GDFGOGHE@trying?5to?5get?5engine?5property?5on@ DB 'trying to g'
	DB	'et engine property on a non-engine', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _get_engine_prop
_TEXT	SEGMENT
_engine$ = 8						; size = 4
_propNo$ = 12						; size = 4
_get_engine_prop PROC					; COMDAT

; 631  : cell get_engine_prop(cell engine,int propNo) {

  00000	56		 push	 esi

; 632  :   if((no)propNo>=max.ENGINE_ATTR) return INPUT_INT(0);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _propNo$[esp]
  00005	3b 35 30 00 00
	00		 cmp	 esi, DWORD PTR _max+48
  0000b	73 3c		 jae	 SHORT $LN18@get_engine

; 633  :   { stack wam=INT2PTR(engine);

  0000d	8b 54 24 08	 mov	 edx, DWORD PTR _engine$[esp]
  00011	4a		 dec	 edx

; 634  :     if(!is_engine(wam)) {

  00012	74 1a		 je	 SHORT $LN6@get_engine
  00014	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  00019	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  0001f	3b c1		 cmp	 eax, ecx
  00021	77 0b		 ja	 SHORT $LN6@get_engine
$LL8@get_engine:
  00023	39 10		 cmp	 DWORD PTR [eax], edx
  00025	74 29		 je	 SHORT $LN1@get_engine
  00027	83 c0 04	 add	 eax, 4
  0002a	3b c1		 cmp	 eax, ecx
  0002c	76 f5		 jbe	 SHORT $LL8@get_engine
$LN6@get_engine:

; 635  :       warnmes("trying to get engine property on a non-engine");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GDFGOGHE@trying?5to?5get?5engine?5property?5on@
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00038	e8 00 00 00 00	 call	 ___iob_func
  0003d	83 c0 40	 add	 eax, 64			; 00000040H
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _fprintf
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@get_engine:

; 636  :       return INPUT_INT(0); /*$$*/

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	5e		 pop	 esi

; 639  :   }
; 640  : }

  0004f	c3		 ret	 0
$LN1@get_engine:

; 637  :     }
; 638  :     return (cell)GET_ENGINE(propNo);

  00050	8b 42 7c	 mov	 eax, DWORD PTR [edx+124]
  00053	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00056	5e		 pop	 esi

; 639  :   }
; 640  : }

  00057	c3		 ret	 0
_get_engine_prop ENDP
_TEXT	ENDS
PUBLIC	_get_engine_thread
; Function compile flags: /Ogtpy
;	COMDAT _get_engine_thread
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_get_engine_thread PROC					; COMDAT

; 643  :   return OUTPUT_INT(get_engine_prop(PTR2INT(wam),ENGINE_THREAD));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _wam$[esp-4]
  00004	40		 inc	 eax
  00005	6a 05		 push	 5
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _get_engine_prop
  0000d	83 c4 08	 add	 esp, 8
  00010	c1 f8 02	 sar	 eax, 2

; 644  : }

  00013	c3		 ret	 0
_get_engine_thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DLNOJIGH@add_engine?3?5engine?5table?5full?$AA@ ; `string'
EXTRN	_current_thread:PROC
;	COMDAT ??_C@_0BO@DLNOJIGH@add_engine?3?5engine?5table?5full?$AA@
CONST	SEGMENT
??_C@_0BO@DLNOJIGH@add_engine?3?5engine?5table?5full?$AA@ DB 'add_engine:'
	DB	' engine table full', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _add_engine
_TEXT	SEGMENT
_engine_type$ = 8					; size = 4
_parent$ = 12						; size = 4
_add_engine PROC					; COMDAT
; _wam$ = esi

; 648  :   if(g.lastengine>=g.engines+MAXENGINES-1)

  00000	8b 0d 54 01 00
	00		 mov	 ecx, DWORD PTR _g+340
  00006	a1 58 01 00 00	 mov	 eax, DWORD PTR _g+344
  0000b	81 c1 fc 0f 00
	00		 add	 ecx, 4092		; 00000ffcH
  00011	3b c1		 cmp	 eax, ecx
  00013	72 1e		 jb	 SHORT $LN4@add_engine

; 649  :     {
; 650  :       warnmes("add_engine: engine table full");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DLNOJIGH@add_engine?3?5engine?5table?5full?$AA@
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  0001f	e8 00 00 00 00	 call	 ___iob_func
  00024	83 c0 40	 add	 eax, 64			; 00000040H
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _fprintf
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  :       return FALSE;

  00030	33 c0		 xor	 eax, eax

; 664  : }

  00032	c3		 ret	 0
$LN4@add_engine:

; 652  :     }
; 653  :   g.lastengine++;

  00033	83 c0 04	 add	 eax, 4
  00036	57		 push	 edi
  00037	a3 58 01 00 00	 mov	 DWORD PTR _g+344, eax

; 654  :   *g.lastengine=wam;
; 655  :   for(i=0; i<max.ENGINE_ATTR; i++) {

  0003c	33 ff		 xor	 edi, edi
  0003e	89 30		 mov	 DWORD PTR [eax], esi
  00040	39 3d 30 00 00
	00		 cmp	 DWORD PTR _max+48, edi
  00046	76 53		 jbe	 SHORT $LN1@add_engine
$LL3@add_engine:

; 656  :     set_engine_prop(PTR2INT(wam),i,INPUT_INT(0));

  00048	85 f6		 test	 esi, esi
  0004a	74 1f		 je	 SHORT $LN13@add_engine
  0004c	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  00051	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  00057	3b c1		 cmp	 eax, ecx
  00059	77 10		 ja	 SHORT $LN13@add_engine
  0005b	eb 03 8d 49 00	 npad	 5
$LL15@add_engine:
  00060	39 30		 cmp	 DWORD PTR [eax], esi
  00062	74 24		 je	 SHORT $LN9@add_engine
  00064	83 c0 04	 add	 eax, 4
  00067	3b c1		 cmp	 eax, ecx
  00069	76 f5		 jbe	 SHORT $LL15@add_engine
$LN13@add_engine:
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00075	e8 00 00 00 00	 call	 ___iob_func
  0007a	83 c0 40	 add	 eax, 64			; 00000040H
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _fprintf
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	eb 0a		 jmp	 SHORT $LN2@add_engine
$LN9@add_engine:
  00088	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  0008b	c7 04 ba 01 00
	00 00		 mov	 DWORD PTR [edx+edi*4], 1
$LN2@add_engine:

; 654  :   *g.lastengine=wam;
; 655  :   for(i=0; i<max.ENGINE_ATTR; i++) {

  00092	47		 inc	 edi
  00093	3b 3d 30 00 00
	00		 cmp	 edi, DWORD PTR _max+48
  00099	72 ad		 jb	 SHORT $LL3@add_engine
$LN1@add_engine:

; 657  :   }
; 658  :   SET_ENGINE_TYPE(engine_type);

  0009b	8b 44 24 08	 mov	 eax, DWORD PTR _engine_type$[esp]
  0009f	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]
  000a2	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 659  :   SET_ENGINE_PARENT(parent);

  000a9	8b 44 24 0c	 mov	 eax, DWORD PTR _parent$[esp]
  000ad	83 c9 01	 or	 ecx, 1
  000b0	89 0a		 mov	 DWORD PTR [edx], ecx
  000b2	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  000b5	40		 inc	 eax
  000b6	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 660  :   SET_ENGINE_ERROR(ENGINE_OK);

  000b9	8b 56 7c	 mov	 edx, DWORD PTR [esi+124]

; 661  :   set_engine_prop(PTR2INT(wam),ENGINE_THREAD,INPUT_INT(current_thread(wam)));

  000bc	56		 push	 esi
  000bd	c7 42 18 01 00
	00 00		 mov	 DWORD PTR [edx+24], 1
  000c4	e8 00 00 00 00	 call	 _current_thread
  000c9	8b 0d 54 01 00
	00		 mov	 ecx, DWORD PTR _g+340
  000cf	8b 15 58 01 00
	00		 mov	 edx, DWORD PTR _g+344
  000d5	03 c0		 add	 eax, eax
  000d7	03 c0		 add	 eax, eax
  000d9	83 c4 04	 add	 esp, 4
  000dc	83 c8 01	 or	 eax, 1
  000df	5f		 pop	 edi
  000e0	3b ca		 cmp	 ecx, edx
  000e2	77 0b		 ja	 SHORT $LN25@add_engine
$LL27@add_engine:
  000e4	39 31		 cmp	 DWORD PTR [ecx], esi
  000e6	74 28		 je	 SHORT $LN21@add_engine
  000e8	83 c1 04	 add	 ecx, 4
  000eb	3b ca		 cmp	 ecx, edx
  000ed	76 f5		 jbe	 SHORT $LL27@add_engine
$LN25@add_engine:
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LKEHNMLP@trying?5to?5set?5engine?5property?5on@
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  000f9	e8 00 00 00 00	 call	 ___iob_func
  000fe	83 c0 40	 add	 eax, 64			; 00000040H
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 _fprintf
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH

; 662  :   TRACE_ENGINE("add_engine")
; 663  :   return TRUE;

  0010a	b8 01 00 00 00	 mov	 eax, 1

; 664  : }

  0010f	c3		 ret	 0

; 661  :   set_engine_prop(PTR2INT(wam),ENGINE_THREAD,INPUT_INT(current_thread(wam)));

$LN21@add_engine:
  00110	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00113	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 662  :   TRACE_ENGINE("add_engine")
; 663  :   return TRUE;

  00116	b8 01 00 00 00	 mov	 eax, 1

; 664  : }

  0011b	c3		 ret	 0
_add_engine ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@HCKMNFCH@del_engine?3?5engine?5notfound?$AA@ ; `string'
;	COMDAT ??_C@_0BM@HCKMNFCH@del_engine?3?5engine?5notfound?$AA@
CONST	SEGMENT
??_C@_0BM@HCKMNFCH@del_engine?3?5engine?5notfound?$AA@ DB 'del_engine: en'
	DB	'gine notfound', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _del_engine
_TEXT	SEGMENT
_del_engine PROC					; COMDAT
; _wam$ = edx

; 668  :   for(p=g.engines;p<=g.lastengine;p++)

  00000	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  00005	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  0000b	3b c1		 cmp	 eax, ecx
  0000d	77 0c		 ja	 SHORT $LN2@del_engine
  0000f	90		 npad	 1
$LL4@del_engine:

; 669  :     {
; 670  :        if(*p==wam)

  00010	39 10		 cmp	 DWORD PTR [eax], edx
  00012	74 25		 je	 SHORT $LN10@del_engine

; 668  :   for(p=g.engines;p<=g.lastengine;p++)

  00014	83 c0 04	 add	 eax, 4
  00017	3b c1		 cmp	 eax, ecx
  00019	76 f5		 jbe	 SHORT $LL4@del_engine
$LN2@del_engine:

; 675  :          }
; 676  :     }
; 677  :   warnmes("del_engine: engine notfound");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HCKMNFCH@del_engine?3?5engine?5notfound?$AA@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00025	e8 00 00 00 00	 call	 ___iob_func
  0002a	83 c0 40	 add	 eax, 64			; 00000040H
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _fprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 678  :   return FALSE;

  00036	33 c0		 xor	 eax, eax

; 679  : }

  00038	c3		 ret	 0
$LN10@del_engine:

; 671  :          { *p = *g.lastengine;

  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx

; 672  :            g.lastengine--;

  0003d	83 2d 58 01 00
	00 04		 sub	 DWORD PTR _g+344, 4

; 673  :            TRACE_ENGINE("del_engine")
; 674  :            return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 679  : }

  00049	c3		 ret	 0
_del_engine ENDP
_TEXT	ENDS
PUBLIC	_heap_safe_margin
; Function compile flags: /Ogtpy
;	COMDAT _heap_safe_margin
_TEXT	SEGMENT
_heap_size$ = 8						; size = 4
_heap_safe_margin PROC					; COMDAT

; 684  :    bp_long at_least=MAXREG<<1;
; 685  :    bp_long at_most=MAXREG<<3;
; 686  :    bp_long margin=heap_size>>6;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _heap_size$[esp-4]
  00004	c1 f8 06	 sar	 eax, 6

; 687  : #if GC>1
; 688  :    margin=at_least;
; 689  : #else
; 690  :    if (margin<at_least) margin=at_least;

  00007	3d fe 0f 00 00	 cmp	 eax, 4094		; 00000ffeH
  0000c	7d 06		 jge	 SHORT $LN2@heap_safe_
  0000e	b8 fe 0f 00 00	 mov	 eax, 4094		; 00000ffeH

; 692  : #endif
; 693  :    return margin;
; 694  : }

  00013	c3		 ret	 0
$LN2@heap_safe_:

; 691  :    if (margin>at_most) margin=at_most;

  00014	3d f8 3f 00 00	 cmp	 eax, 16376		; 00003ff8H
  00019	7e 05		 jle	 SHORT $LN1@heap_safe_
  0001b	b8 f8 3f 00 00	 mov	 eax, 16376		; 00003ff8H
$LN1@heap_safe_:

; 692  : #endif
; 693  :    return margin;
; 694  : }

  00020	c3		 ret	 0
_heap_safe_margin ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@INPEAPEM@add_engine?5failed?$AA@	; `string'
PUBLIC	??_C@_0BJ@BBFGMPME@not?5enough?5engine?5memory?$AA@ ; `string'
PUBLIC	??_C@_04PKENOLLO@heap?$AA@			; `string'
PUBLIC	??_C@_05FAEIOGEG@trail?$AA@			; `string'
PUBLIC	??_C@_06DDDNEJEA@choice?$AA@			; `string'
PUBLIC	??_C@_0BC@KKCENDLJ@engine_attributes?$AA@	; `string'
PUBLIC	_init_engine_mem
;	COMDAT ??_C@_0BC@INPEAPEM@add_engine?5failed?$AA@
CONST	SEGMENT
??_C@_0BC@INPEAPEM@add_engine?5failed?$AA@ DB 'add_engine failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBFGMPME@not?5enough?5engine?5memory?$AA@
CONST	SEGMENT
??_C@_0BJ@BBFGMPME@not?5enough?5engine?5memory?$AA@ DB 'not enough engine'
	DB	' memory', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKENOLLO@heap?$AA@
CONST	SEGMENT
??_C@_04PKENOLLO@heap?$AA@ DB 'heap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAEIOGEG@trail?$AA@
CONST	SEGMENT
??_C@_05FAEIOGEG@trail?$AA@ DB 'trail', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DDDNEJEA@choice?$AA@
CONST	SEGMENT
??_C@_06DDDNEJEA@choice?$AA@ DB 'choice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKCENDLJ@engine_attributes?$AA@
CONST	SEGMENT
??_C@_0BC@KKCENDLJ@engine_attributes?$AA@ DB 'engine_attributes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _init_engine_mem
_TEXT	SEGMENT
_errctr$ = 8						; size = 4
_wam$ = 8						; size = 4
_heap_size$ = 12					; size = 4
_stack_size$ = 16					; size = 4
_trail_size$ = 20					; size = 4
_engine_type$ = 24					; size = 4
_parent$ = 28						; size = 4
_init_engine_mem PROC					; COMDAT

; 701  : 
; 702  :   no errctr=0;
; 703  : 
; 704  :   /* normally heap_safe_margin(..) must be the max size of what
; 705  :      can go to the heap between 2 EXECUTEs */
; 706  : 
; 707  :   errctr+=!make_stack(&wam[MesStk],max.ENGINE_ATTR,4,
; 708  :                       "engine_attributes",NULL,1);

  00000	a1 30 00 00 00	 mov	 eax, DWORD PTR _max+48
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 74 24 10	 mov	 esi, DWORD PTR _wam$[esp+8]
  0000c	57		 push	 edi
  0000d	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00010	c7 46 70 04 00
	00 00		 mov	 DWORD PTR [esi+112], 4
  00017	83 f8 04	 cmp	 eax, 4
  0001a	7d 06		 jge	 SHORT $LN37@init_engin
  0001c	33 ed		 xor	 ebp, ebp
  0001e	33 c0		 xor	 eax, eax
  00020	eb 46		 jmp	 SHORT $LN7@init_engin
$LN37@init_engin:
  00022	03 c0		 add	 eax, eax
  00024	03 c0		 add	 eax, eax
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 _malloc
  0002c	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0002f	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00032	33 ed		 xor	 ebp, ebp
  00034	33 d2		 xor	 edx, edx
  00036	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  0003c	83 c1 f0	 add	 ecx, -16		; fffffff0H
  0003f	83 c4 04	 add	 esp, 4
  00042	3b c5		 cmp	 eax, ebp
  00044	0f 95 c2	 setne	 dl
  00047	89 46 7c	 mov	 DWORD PTR [esi+124], eax
  0004a	89 46 74	 mov	 DWORD PTR [esi+116], eax
  0004d	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00050	89 8e 80 00 00
	00		 mov	 DWORD PTR [esi+128], ecx
  00056	89 ae 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebp
  0005c	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], OFFSET ??_C@_0BC@KKCENDLJ@engine_attributes?$AA@
  00066	8b c2		 mov	 eax, edx
$LN7@init_engin:
  00068	33 db		 xor	 ebx, ebx
  0006a	3b c5		 cmp	 eax, ebp

; 709  : 
; 710  : #if GC>0
; 711  :   wam[MarkStk].size=ZERO; /* Lazy allocation: on the first use of GC*/
; 712  :   wam[MarkStk].base=NULL;
; 713  : #endif
; 714  : 
; 715  :   errctr+=!make_stack(&wam[ChoiceStk],stack_size,MAXARITY+3,"choice",
; 716  :           NULL,1);

  0006c	8b 44 24 1c	 mov	 eax, DWORD PTR _stack_size$[esp+12]
  00070	0f 94 c3	 sete	 bl
  00073	89 ae 90 00 00
	00		 mov	 DWORD PTR [esi+144], ebp
  00079	89 ae a0 00 00
	00		 mov	 DWORD PTR [esi+160], ebp
  0007f	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00082	c7 46 4c 03 01
	00 00		 mov	 DWORD PTR [esi+76], 259	; 00000103H
  00089	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0008e	7d 04		 jge	 SHORT $LN38@init_engin
  00090	33 c0		 xor	 eax, eax
  00092	eb 3b		 jmp	 SHORT $LN13@init_engin
$LN38@init_engin:
  00094	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 _malloc
  000a1	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000a4	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  000a7	81 c1 f4 fb ff
	ff		 add	 ecx, -1036		; fffffbf4H
  000ad	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  000b0	33 c9		 xor	 ecx, ecx
  000b2	83 c4 04	 add	 esp, 4
  000b5	3b c5		 cmp	 eax, ebp
  000b7	0f 95 c1	 setne	 cl
  000ba	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000bd	89 46 50	 mov	 DWORD PTR [esi+80], eax
  000c0	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000c3	89 6e 64	 mov	 DWORD PTR [esi+100], ebp
  000c6	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], OFFSET ??_C@_06DDDNEJEA@choice?$AA@
  000cd	8b c1		 mov	 eax, ecx
$LN13@init_engin:
  000cf	33 d2		 xor	 edx, edx
  000d1	3b c5		 cmp	 eax, ebp

; 717  : 
; 718  : 
; 719  :   errctr+=!make_stack(&wam[TrailStk],trail_size,MAXARITY+1,"trail",
; 720  :           NULL,1);

  000d3	8b 44 24 20	 mov	 eax, DWORD PTR _trail_size$[esp+12]
  000d7	0f 94 c2	 sete	 dl
  000da	89 46 24	 mov	 DWORD PTR [esi+36], eax
  000dd	c7 46 28 01 01
	00 00		 mov	 DWORD PTR [esi+40], 257	; 00000101H
  000e4	03 da		 add	 ebx, edx
  000e6	3d 01 01 00 00	 cmp	 eax, 257		; 00000101H
  000eb	7d 04		 jge	 SHORT $LN39@init_engin
  000ed	33 c0		 xor	 eax, eax
  000ef	eb 3b		 jmp	 SHORT $LN19@init_engin
$LN39@init_engin:
  000f1	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]
  000f8	57		 push	 edi
  000f9	e8 00 00 00 00	 call	 _malloc
  000fe	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00101	89 4e 3c	 mov	 DWORD PTR [esi+60], ecx
  00104	81 c1 fc fb ff
	ff		 add	 ecx, -1028		; fffffbfcH
  0010a	89 4e 38	 mov	 DWORD PTR [esi+56], ecx
  0010d	33 c9		 xor	 ecx, ecx
  0010f	83 c4 04	 add	 esp, 4
  00112	3b c5		 cmp	 eax, ebp
  00114	0f 95 c1	 setne	 cl
  00117	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0011a	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0011d	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00120	89 6e 40	 mov	 DWORD PTR [esi+64], ebp
  00123	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], OFFSET ??_C@_05FAEIOGEG@trail?$AA@
  0012a	8b c1		 mov	 eax, ecx
$LN19@init_engin:
  0012c	33 d2		 xor	 edx, edx
  0012e	3b c5		 cmp	 eax, ebp

; 721  : 
; 722  : 
; 723  :   errctr+= !make_stack(&wam[HeapStk],heap_size,
; 724  :                        heap_safe_margin(heap_size),"heap",NULL,1);

  00130	8b 44 24 18	 mov	 eax, DWORD PTR _heap_size$[esp+12]
  00134	0f 94 c2	 sete	 dl
  00137	8b f8		 mov	 edi, eax
  00139	c1 ff 06	 sar	 edi, 6
  0013c	03 da		 add	 ebx, edx
  0013e	89 5c 24 14	 mov	 DWORD PTR _errctr$[esp+12], ebx
  00142	81 ff fe 0f 00
	00		 cmp	 edi, 4094		; 00000ffeH
  00148	7d 07		 jge	 SHORT $LN24@init_engin
  0014a	bf fe 0f 00 00	 mov	 edi, 4094		; 00000ffeH
  0014f	eb 0d		 jmp	 SHORT $LN23@init_engin
$LN24@init_engin:
  00151	81 ff f8 3f 00
	00		 cmp	 edi, 16376		; 00003ff8H
  00157	7e 05		 jle	 SHORT $LN23@init_engin
  00159	bf f8 3f 00 00	 mov	 edi, 16376		; 00003ff8H
$LN23@init_engin:
  0015e	89 06		 mov	 DWORD PTR [esi], eax
  00160	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00163	3b c7		 cmp	 eax, edi
  00165	7d 04		 jge	 SHORT $LN40@init_engin
  00167	33 c0		 xor	 eax, eax
  00169	eb 42		 jmp	 SHORT $LN29@init_engin
$LN40@init_engin:
  0016b	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  00172	53		 push	 ebx
  00173	e8 00 00 00 00	 call	 _malloc
  00178	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  0017b	8b 5c 24 18	 mov	 ebx, DWORD PTR _errctr$[esp+16]
  0017f	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
  00182	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  00189	2b ca		 sub	 ecx, edx
  0018b	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  0018e	33 c9		 xor	 ecx, ecx
  00190	83 c4 04	 add	 esp, 4
  00193	3b c5		 cmp	 eax, ebp
  00195	0f 95 c1	 setne	 cl
  00198	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0019b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0019e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  001a1	89 6e 1c	 mov	 DWORD PTR [esi+28], ebp
  001a4	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET ??_C@_04PKENOLLO@heap?$AA@
  001ab	8b c1		 mov	 eax, ecx
$LN29@init_engin:
  001ad	33 d2		 xor	 edx, edx
  001af	3b c5		 cmp	 eax, ebp
  001b1	0f 94 c2	 sete	 dl
  001b4	03 d3		 add	 edx, ebx

; 725  : 
; 726  :   /* starting from 5.84 dcg streams are local to each wam */
; 727  : 
; 728  :   if(errctr)

  001b6	74 22		 je	 SHORT $LN2@init_engin

; 729  :     ERREXIT("not enough engine memory")

  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BBFGMPME@not?5enough?5engine?5memory?$AA@
$LN41@init_engin:
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  001c2	e8 00 00 00 00	 call	 ___iob_func
  001c7	83 c0 40	 add	 eax, 64			; 00000040H
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _fprintf
  001d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d3	5f		 pop	 edi
  001d4	5e		 pop	 esi
  001d5	5d		 pop	 ebp
  001d6	33 c0		 xor	 eax, eax
  001d8	5b		 pop	 ebx

; 740  : }

  001d9	c3		 ret	 0
$LN2@init_engin:

; 730  : 
; 731  : /* moved to engine
; 732  :   { term g_connect=DCGSTART();
; 733  :     init_var_array(g_connect,MAXDCG);
; 734  :   }
; 735  : */
; 736  :   if(!add_engine(wam,engine_type,parent))

  001da	8b 44 24 28	 mov	 eax, DWORD PTR _parent$[esp+12]
  001de	8b 4c 24 24	 mov	 ecx, DWORD PTR _engine_type$[esp+12]
  001e2	50		 push	 eax
  001e3	51		 push	 ecx
  001e4	e8 00 00 00 00	 call	 _add_engine
  001e9	83 c4 08	 add	 esp, 8
  001ec	85 c0		 test	 eax, eax
  001ee	75 07		 jne	 SHORT $LN1@init_engin

; 737  :     ERREXIT("add_engine failed");

  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@INPEAPEM@add_engine?5failed?$AA@
  001f5	eb c6		 jmp	 SHORT $LN41@init_engin
$LN1@init_engin:
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5d		 pop	 ebp

; 738  : 
; 739  :   return TRUE;

  001fa	b8 01 00 00 00	 mov	 eax, 1
  001ff	5b		 pop	 ebx

; 740  : }

  00200	c3		 ret	 0
_init_engine_mem ENDP
_TEXT	ENDS
PUBLIC	_create_engine
; Function compile flags: /Ogtpy
;	COMDAT _create_engine
_TEXT	SEGMENT
_oldwam$ = 8						; size = 4
_h$ = 12						; size = 4
_s$ = 16						; size = 4
_t$ = 20						; size = 4
_create_engine PROC					; COMDAT

; 744  : { register stack wam;

  00000	53		 push	 ebx

; 745  :   wam=ZALLOC(MaxStk,struct stack);

  00001	6a 24		 push	 36			; 00000024H
  00003	6a 05		 push	 5
  00005	e8 00 00 00 00	 call	 _calloc
  0000a	8b d8		 mov	 ebx, eax
  0000c	83 c4 08	 add	 esp, 8

; 746  :   if(!wam) return NULL;

  0000f	85 db		 test	 ebx, ebx
  00011	75 02		 jne	 SHORT $LN5@create_eng
  00013	5b		 pop	 ebx

; 753  : }

  00014	c3		 ret	 0
$LN5@create_eng:

; 747  :   ScaleToWords(h);
; 748  :   ScaleToWords(s);
; 749  :   ScaleToWords(t);
; 750  :   {bp_long i; for(i=0;i<MaxStk;i++) wam[i]=oldwam[i];}

  00015	8b 44 24 08	 mov	 eax, DWORD PTR _oldwam$[esp]
  00019	8b 54 24 10	 mov	 edx, DWORD PTR _s$[esp]
  0001d	c1 64 24 0c 08	 shl	 DWORD PTR _h$[esp], 8
  00022	c1 64 24 14 08	 shl	 DWORD PTR _t$[esp], 8
  00027	55		 push	 ebp
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	b9 09 00 00 00	 mov	 ecx, 9
  0002f	8b f0		 mov	 esi, eax
  00031	8b fb		 mov	 edi, ebx
  00033	f3 a5		 rep movsd
  00035	8d 7b 24	 lea	 edi, DWORD PTR [ebx+36]
  00038	8d 70 24	 lea	 esi, DWORD PTR [eax+36]
  0003b	b9 09 00 00 00	 mov	 ecx, 9
  00040	f3 a5		 rep movsd
  00042	8d 7b 48	 lea	 edi, DWORD PTR [ebx+72]
  00045	8d 70 48	 lea	 esi, DWORD PTR [eax+72]
  00048	b9 09 00 00 00	 mov	 ecx, 9
  0004d	f3 a5		 rep movsd
  0004f	8d 70 6c	 lea	 esi, DWORD PTR [eax+108]
  00052	b9 09 00 00 00	 mov	 ecx, 9
  00057	8d 7b 6c	 lea	 edi, DWORD PTR [ebx+108]
  0005a	f3 a5		 rep movsd
  0005c	8d bb 90 00 00
	00		 lea	 edi, DWORD PTR [ebx+144]
  00062	8d b0 90 00 00
	00		 lea	 esi, DWORD PTR [eax+144]
  00068	b9 09 00 00 00	 mov	 ecx, 9
  0006d	f3 a5		 rep movsd

; 751  :   if(!init_engine_mem(wam,h,s,t,EMPTY_ENGINE,oldwam)) return NULL;

  0006f	8b 0d 30 00 00
	00		 mov	 ecx, DWORD PTR _max+48
  00075	c1 e2 08	 shl	 edx, 8
  00078	89 54 24 1c	 mov	 DWORD PTR _s$[esp+12], edx
  0007c	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  0007f	c7 43 70 04 00
	00 00		 mov	 DWORD PTR [ebx+112], 4
  00086	83 f9 04	 cmp	 ecx, 4
  00089	7d 04		 jge	 SHORT $LN52@create_eng
  0008b	33 f6		 xor	 esi, esi
  0008d	eb 53		 jmp	 SHORT $LN14@create_eng
$LN52@create_eng:
  0008f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _malloc
  0009c	8b 4b 6c	 mov	 ecx, DWORD PTR [ebx+108]
  0009f	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  000a2	33 d2		 xor	 edx, edx
  000a4	89 8b 84 00 00
	00		 mov	 DWORD PTR [ebx+132], ecx
  000aa	83 c1 f0	 add	 ecx, -16		; fffffff0H
  000ad	83 c4 04	 add	 esp, 4
  000b0	85 c0		 test	 eax, eax
  000b2	0f 95 c2	 setne	 dl
  000b5	89 43 7c	 mov	 DWORD PTR [ebx+124], eax
  000b8	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  000bb	89 43 78	 mov	 DWORD PTR [ebx+120], eax
  000be	8b 44 24 14	 mov	 eax, DWORD PTR _oldwam$[esp+12]
  000c2	89 8b 80 00 00
	00		 mov	 DWORD PTR [ebx+128], ecx
  000c8	c7 83 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+136], 0
  000d2	8b f2		 mov	 esi, edx
  000d4	8b 54 24 1c	 mov	 edx, DWORD PTR _s$[esp+12]
  000d8	c7 83 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+140], OFFSET ??_C@_0BC@KKCENDLJ@engine_attributes?$AA@
$LN14@create_eng:
  000e2	33 c9		 xor	 ecx, ecx
  000e4	85 f6		 test	 esi, esi
  000e6	0f 94 c1	 sete	 cl
  000e9	33 f6		 xor	 esi, esi
  000eb	89 b3 90 00 00
	00		 mov	 DWORD PTR [ebx+144], esi
  000f1	89 b3 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], esi
  000f7	89 53 48	 mov	 DWORD PTR [ebx+72], edx
  000fa	c7 43 4c 03 01
	00 00		 mov	 DWORD PTR [ebx+76], 259	; 00000103H
  00101	8b e9		 mov	 ebp, ecx
  00103	81 fa 03 01 00
	00		 cmp	 edx, 259		; 00000103H
  00109	7c 43		 jl	 SHORT $LN20@create_eng
  0010b	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00112	56		 push	 esi
  00113	e8 00 00 00 00	 call	 _malloc
  00118	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0011b	33 d2		 xor	 edx, edx
  0011d	89 4b 60	 mov	 DWORD PTR [ebx+96], ecx
  00120	81 c1 f4 fb ff
	ff		 add	 ecx, -1036		; fffffbf4H
  00126	83 c4 04	 add	 esp, 4
  00129	85 c0		 test	 eax, eax
  0012b	0f 95 c2	 setne	 dl
  0012e	89 43 58	 mov	 DWORD PTR [ebx+88], eax
  00131	89 43 50	 mov	 DWORD PTR [ebx+80], eax
  00134	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  00137	8b 44 24 14	 mov	 eax, DWORD PTR _oldwam$[esp+12]
  0013b	89 4b 5c	 mov	 DWORD PTR [ebx+92], ecx
  0013e	c7 43 64 00 00
	00 00		 mov	 DWORD PTR [ebx+100], 0
  00145	c7 43 68 00 00
	00 00		 mov	 DWORD PTR [ebx+104], OFFSET ??_C@_06DDDNEJEA@choice?$AA@
  0014c	8b f2		 mov	 esi, edx
$LN20@create_eng:
  0014e	33 c9		 xor	 ecx, ecx
  00150	85 f6		 test	 esi, esi
  00152	0f 94 c1	 sete	 cl
  00155	c7 43 28 01 01
	00 00		 mov	 DWORD PTR [ebx+40], 257	; 00000101H
  0015c	03 e9		 add	 ebp, ecx
  0015e	8b 4c 24 20	 mov	 ecx, DWORD PTR _t$[esp+12]
  00162	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx
  00165	81 f9 01 01 00
	00		 cmp	 ecx, 257		; 00000101H
  0016b	7d 04		 jge	 SHORT $LN54@create_eng
  0016d	33 f6		 xor	 esi, esi
  0016f	eb 43		 jmp	 SHORT $LN26@create_eng
$LN54@create_eng:
  00171	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00178	56		 push	 esi
  00179	e8 00 00 00 00	 call	 _malloc
  0017e	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00181	33 d2		 xor	 edx, edx
  00183	89 4b 3c	 mov	 DWORD PTR [ebx+60], ecx
  00186	81 c1 fc fb ff
	ff		 add	 ecx, -1028		; fffffbfcH
  0018c	83 c4 04	 add	 esp, 4
  0018f	85 c0		 test	 eax, eax
  00191	0f 95 c2	 setne	 dl
  00194	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00197	89 43 2c	 mov	 DWORD PTR [ebx+44], eax
  0019a	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  0019d	8b 44 24 14	 mov	 eax, DWORD PTR _oldwam$[esp+12]
  001a1	89 4b 38	 mov	 DWORD PTR [ebx+56], ecx
  001a4	c7 43 40 00 00
	00 00		 mov	 DWORD PTR [ebx+64], 0
  001ab	c7 43 44 00 00
	00 00		 mov	 DWORD PTR [ebx+68], OFFSET ??_C@_05FAEIOGEG@trail?$AA@
  001b2	8b f2		 mov	 esi, edx
$LN26@create_eng:
  001b4	33 c9		 xor	 ecx, ecx
  001b6	85 f6		 test	 esi, esi
  001b8	0f 94 c1	 sete	 cl
  001bb	03 e9		 add	 ebp, ecx
  001bd	8b 4c 24 18	 mov	 ecx, DWORD PTR _h$[esp+12]
  001c1	8b f1		 mov	 esi, ecx
  001c3	c1 fe 06	 sar	 esi, 6
  001c6	81 fe fe 0f 00
	00		 cmp	 esi, 4094		; 00000ffeH
  001cc	7d 07		 jge	 SHORT $LN31@create_eng
  001ce	be fe 0f 00 00	 mov	 esi, 4094		; 00000ffeH
  001d3	eb 0d		 jmp	 SHORT $LN30@create_eng
$LN31@create_eng:
  001d5	81 fe f8 3f 00
	00		 cmp	 esi, 16376		; 00003ff8H
  001db	7e 05		 jle	 SHORT $LN30@create_eng
  001dd	be f8 3f 00 00	 mov	 esi, 16376		; 00003ff8H
$LN30@create_eng:
  001e2	89 0b		 mov	 DWORD PTR [ebx], ecx
  001e4	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  001e7	3b ce		 cmp	 ecx, esi
  001e9	7d 04		 jge	 SHORT $LN55@create_eng
  001eb	33 f6		 xor	 esi, esi
  001ed	eb 46		 jmp	 SHORT $LN36@create_eng
$LN55@create_eng:
  001ef	8d 3c 8d 00 00
	00 00		 lea	 edi, DWORD PTR [ecx*4]
  001f6	57		 push	 edi
  001f7	e8 00 00 00 00	 call	 _malloc
  001fc	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  001ff	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx
  00202	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
  00209	2b ca		 sub	 ecx, edx
  0020b	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx
  0020e	33 c9		 xor	 ecx, ecx
  00210	83 c4 04	 add	 esp, 4
  00213	85 c0		 test	 eax, eax
  00215	0f 95 c1	 setne	 cl
  00218	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0021b	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0021e	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00221	8b 44 24 14	 mov	 eax, DWORD PTR _oldwam$[esp+12]
  00225	c7 43 1c 00 00
	00 00		 mov	 DWORD PTR [ebx+28], 0
  0022c	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], OFFSET ??_C@_04PKENOLLO@heap?$AA@
  00233	8b f1		 mov	 esi, ecx
$LN36@create_eng:
  00235	33 d2		 xor	 edx, edx
  00237	85 f6		 test	 esi, esi
  00239	0f 94 c2	 sete	 dl
  0023c	03 d5		 add	 edx, ebp
  0023e	74 07		 je	 SHORT $LN9@create_eng
  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BBFGMPME@not?5enough?5engine?5memory?$AA@
  00245	eb 16		 jmp	 SHORT $LN58@create_eng
$LN9@create_eng:
  00247	50		 push	 eax
  00248	6a 01		 push	 1
  0024a	8b f3		 mov	 esi, ebx
  0024c	e8 00 00 00 00	 call	 _add_engine
  00251	83 c4 08	 add	 esp, 8
  00254	85 c0		 test	 eax, eax
  00256	75 22		 jne	 SHORT $LN1@create_eng
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@INPEAPEM@add_engine?5failed?$AA@
$LN58@create_eng:
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PDNEECPB@warning?3?5?$CK?$CK?$CK?5?$CFs?5?$CK?$CK?$CK?6?$AA@
  00262	e8 00 00 00 00	 call	 ___iob_func
  00267	83 c0 40	 add	 eax, 64			; 00000040H
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _fprintf
  00270	83 c4 0c	 add	 esp, 12			; 0000000cH
  00273	5f		 pop	 edi
  00274	5e		 pop	 esi
  00275	5d		 pop	 ebp
  00276	33 c0		 xor	 eax, eax
  00278	5b		 pop	 ebx

; 753  : }

  00279	c3		 ret	 0
$LN1@create_eng:
  0027a	5f		 pop	 edi
  0027b	5e		 pop	 esi
  0027c	5d		 pop	 ebp

; 752  :   return wam;

  0027d	8b c3		 mov	 eax, ebx
  0027f	5b		 pop	 ebx

; 753  : }

  00280	c3		 ret	 0
_create_engine ENDP
_TEXT	ENDS
PUBLIC	_destroy_engine
EXTRN	_free:PROC
EXTRN	_thread_destroy:PROC
; Function compile flags: /Ogtpy
;	COMDAT _destroy_engine
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_destroy_engine PROC					; COMDAT

; 756  : {

  00000	56		 push	 esi

; 757  :   /* if(!is_engine(wam)) return FALSE; */
; 758  : #if THREADS>0
; 759  :   if(is_engine(wam) && RUNNING_ENGINE==GET_ENGINE_TYPE()) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _wam$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 40		 je	 SHORT $LN3@destroy_en
  00009	a1 54 01 00 00	 mov	 eax, DWORD PTR _g+340
  0000e	8b 0d 58 01 00
	00		 mov	 ecx, DWORD PTR _g+344
  00014	3b c1		 cmp	 eax, ecx
  00016	77 31		 ja	 SHORT $LN3@destroy_en
$LL9@destroy_en:
  00018	39 30		 cmp	 DWORD PTR [eax], esi
  0001a	74 09		 je	 SHORT $LN18@destroy_en
  0001c	83 c0 04	 add	 eax, 4
  0001f	3b c1		 cmp	 eax, ecx
  00021	76 f5		 jbe	 SHORT $LL9@destroy_en
  00023	eb 24		 jmp	 SHORT $LN3@destroy_en
$LN18@destroy_en:
  00025	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0002d	83 f9 14	 cmp	 ecx, 20			; 00000014H
  00030	75 17		 jne	 SHORT $LN3@destroy_en

; 760  :     int t=get_engine_thread(wam);

  00032	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00035	6a 05		 push	 5
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _get_engine_prop
  0003d	c1 f8 02	 sar	 eax, 2

; 761  :     /*fprintf(STD_err,"!!!!thread=%d\n",t);*/
; 762  :     (void)thread_destroy(t);

  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _thread_destroy
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@destroy_en:

; 763  :   }
; 764  : #endif
; 765  :   if(!del_engine(wam)) return FALSE;

  00049	8b d6		 mov	 edx, esi
  0004b	e8 00 00 00 00	 call	 _del_engine
  00050	85 c0		 test	 eax, eax
  00052	75 02		 jne	 SHORT $LN2@destroy_en
  00054	5e		 pop	 esi

; 777  : }

  00055	c3		 ret	 0
$LN2@destroy_en:

; 766  :   SET_ENGINE_TYPE(DEAD_ENGINE);

  00056	8b 46 7c	 mov	 eax, DWORD PTR [esi+124]
  00059	c7 00 11 00 00
	00		 mov	 DWORD PTR [eax], 17	; 00000011H

; 767  :   XFREE(wam[HeapStk].base);

  0005f	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _free

; 768  :   XFREE(wam[ChoiceStk].base);

  00068	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _free

; 769  :   XFREE(wam[TrailStk].base);

  00071	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _free

; 770  : #if GC>0
; 771  :   if(NULL!=wam[MarkStk].base)

  0007a	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	85 c0		 test	 eax, eax
  00085	74 09		 je	 SHORT $LN1@destroy_en

; 772  :     XFREE(wam[MarkStk].base);

  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _free
  0008d	83 c4 04	 add	 esp, 4
$LN1@destroy_en:

; 773  : #endif
; 774  :   XFREE(wam[MesStk].base); /* contains also props of the engine */

  00090	8b 4e 7c	 mov	 ecx, DWORD PTR [esi+124]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _free

; 775  :   XFREE(wam);

  00099	56		 push	 esi
  0009a	e8 00 00 00 00	 call	 _free
  0009f	83 c4 08	 add	 esp, 8

; 776  :   return TRUE;

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	5e		 pop	 esi

; 777  : }

  000a8	c3		 ret	 0
_destroy_engine ENDP
_TEXT	ENDS
PUBLIC	_list_engines
; Function compile flags: /Ogtpy
;	COMDAT _list_engines
_TEXT	SEGMENT
_H$ = 8							; size = 4
_list_engines PROC					; COMDAT

; 781  :   for(p=g.engines+0;p<=g.lastengine;p++)

  00000	8b 0d 54 01 00
	00		 mov	 ecx, DWORD PTR _g+340
  00006	8b 44 24 04	 mov	 eax, DWORD PTR _H$[esp-4]
  0000a	3b 0d 58 01 00
	00		 cmp	 ecx, DWORD PTR _g+344
  00010	77 1e		 ja	 SHORT $LN1@list_engin
  00012	56		 push	 esi
$LL3@list_engin:

; 782  :     {      wam=*p;

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]

; 783  :            PUSH_LIST(PTR2INT(wam));

  00015	8b 35 24 00 00
	00		 mov	 esi, DWORD PTR _g+36
  0001b	89 30		 mov	 DWORD PTR [eax], esi
  0001d	42		 inc	 edx
  0001e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00021	83 c1 04	 add	 ecx, 4
  00024	83 c0 08	 add	 eax, 8
  00027	3b 0d 58 01 00
	00		 cmp	 ecx, DWORD PTR _g+344
  0002d	76 e4		 jbe	 SHORT $LL3@list_engin
  0002f	5e		 pop	 esi
$LN1@list_engin:

; 784  : #if (TRACE > 0)
; 785  :            fprintf(STD_err,
; 786  :              "engine [%d]=[%lu], type=%ld\n",
; 787  :               p-g.engines,(no)wam,GET_ENGINE_TYPE()
; 788  :            );
; 789  : #endif
; 790  :     }
; 791  :   PUSH_NIL();

  00030	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR _g+32
  00036	89 08		 mov	 DWORD PTR [eax], ecx
  00038	83 c0 04	 add	 eax, 4

; 792  :   return H;
; 793  : }

  0003b	c3		 ret	 0
_list_engines ENDP
_TEXT	ENDS
PUBLIC	_init_random
EXTRN	_rand:PROC
EXTRN	_srand:PROC
; Function compile flags: /Ogtpy
;	COMDAT _init_random
_TEXT	SEGMENT
_seed$ = 8						; size = 4
_init_random PROC					; COMDAT

; 799  : { if(0==seed) seed=17+(unsigned)realtime(3);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _seed$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 0e		 jne	 SHORT $LN1@init_rando
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 __time64
  0000e	83 c4 04	 add	 esp, 4
  00011	2d 6f f0 05 2f	 sub	 eax, 788918383		; 2f05f06fH
$LN1@init_rando:

; 800  :   /*fprintf(STD_err,"seed=%d\n",seed);*/
; 801  :   srand(seed);

  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _srand
  0001c	83 c4 04	 add	 esp, 4

; 802  :   rand();

  0001f	e9 00 00 00 00	 jmp	 _rand
_init_random ENDP
_TEXT	ENDS
PUBLIC	_start_profiler
; Function compile flags: /Ogtpy
;	COMDAT _start_profiler
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_start_profiler PROC					; COMDAT

; 807  : #if TRACE>1 || PROF
; 808  :   profiler(0,cbase,wam[ChoiceStk].base,(term)wam[HeapStk].base,wam);
; 809  : #endif
; 810  : 
; 811  : #if TRACE>0 || PROF
; 812  :   fprintf(STD_err,"BEGIN EXECUTION PROF=%d TRACE=%d\n\n",PROF,TRACE);
; 813  : #endif
; 814  : }

  00000	c3		 ret	 0
_start_profiler ENDP
_TEXT	ENDS
PUBLIC	_end_profiler
; Function compile flags: /Ogtpy
;	COMDAT _end_profiler
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_end_profiler PROC					; COMDAT

; 818  : 
; 819  : #if TRACE>1 || PROF==3
; 820  :   profiler(2,cbase,wam[ChoiceStk].base,(term)wam[HeapStk].base,wam);
; 821  :      /*mallocmap();*/
; 822  : #endif
; 823  : 
; 824  : #if TRACE==3
; 825  :   show_regions(wam[ChoiceStk].base,(term)wam[HeapStk].base,wam);
; 826  : #endif
; 827  : }

  00000	c3		 ret	 0
_end_profiler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@DLMACPPH@?$CFs?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld@ ; `string'
PUBLIC	??_C@_0CE@NMEPBAOM@?6BinProlog?5command?5line?3?6?6OPTION@ ; `string'
PUBLIC	??_C@_0CH@DDFKIKCO@?6?9h?5?$DN?$DN?$DO?5HEAP?5SIZE?5in?5Kbytes?0?5?5de@ ; `string'
PUBLIC	??_C@_0CH@BBPIFEL@?6?9s?5?$DN?$DN?$DO?5STACK?5SIZE?5in?5Kbytes?0?5de@ ; `string'
PUBLIC	??_C@_0CH@EIMJGIMH@?6?9t?5?$DN?$DN?$DO?5TRAIL?5SIZE?5in?5Kbytes?0?5de@ ; `string'
PUBLIC	??_C@_0CH@LJGJNMJG@?6?9c?5?$DN?$DN?$DO?5CODE?5SIZE?5in?5Kbytes?0?5?5de@ ; `string'
PUBLIC	??_C@_0DE@LPGJNJNM@?6?9a?5?$DN?$DN?$DO?5MAX?4?5ATOMS?0?5give?5exponen@ ; `string'
PUBLIC	??_C@_0DN@HNIKEPII@?6?9d?5?$DN?$DN?$DO?5HASH?5DICT?4?5entries?0?5give@ ; `string'
PUBLIC	??_C@_0CG@NBDEABJE@?6?9i?5?$DN?$DN?$DO?5IOBUFFER?0?5in?5Kbytes?0?5def@ ; `string'
PUBLIC	??_C@_0CC@ICAHFJLD@?6?9q?5?$DN?$DN?$DO?5QUIETNESS?5level?0?5default@ ; `string'
PUBLIC	??_C@_0O@FPFKBKGK@?6?6ARGUMENTS?3?6?$AA@	; `string'
PUBLIC	??_C@_0EG@GEEACGMK@?6?5?5STARTUP?5FILE?3?5?$CK?4bp?0?5?$CK?4pl?0?5?$CK?4w@ ; `string'
PUBLIC	??_C@_06MNNHBPJC@wam?4bp?$AA@			; `string'
PUBLIC	??_C@_0CE@BBJKAGJO@cellsize?$DN?$CFu?5termsize?$DN?$CFu?5symbits?$DN@ ; `string'
;	COMDAT ??_C@_0DM@DLMACPPH@?$CFs?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld@
CONST	SEGMENT
??_C@_0DM@DLMACPPH@?$CFs?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld@ DB '%'
	DB	's %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%s%s', 0aH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NMEPBAOM@?6BinProlog?5command?5line?3?6?6OPTION@
CONST	SEGMENT
??_C@_0CE@NMEPBAOM@?6BinProlog?5command?5line?3?6?6OPTION@ DB 0aH, 'BinPr'
	DB	'olog command line:', 0aH, 0aH, 'OPTIONS:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DDFKIKCO@?6?9h?5?$DN?$DN?$DO?5HEAP?5SIZE?5in?5Kbytes?0?5?5de@
CONST	SEGMENT
??_C@_0CH@DDFKIKCO@?6?9h?5?$DN?$DN?$DO?5HEAP?5SIZE?5in?5Kbytes?0?5?5de@ DB 0aH
	DB	'-h ==> HEAP SIZE in Kbytes,  default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BBPIFEL@?6?9s?5?$DN?$DN?$DO?5STACK?5SIZE?5in?5Kbytes?0?5de@
CONST	SEGMENT
??_C@_0CH@BBPIFEL@?6?9s?5?$DN?$DN?$DO?5STACK?5SIZE?5in?5Kbytes?0?5de@ DB 0aH
	DB	'-s ==> STACK SIZE in Kbytes, default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EIMJGIMH@?6?9t?5?$DN?$DN?$DO?5TRAIL?5SIZE?5in?5Kbytes?0?5de@
CONST	SEGMENT
??_C@_0CH@EIMJGIMH@?6?9t?5?$DN?$DN?$DO?5TRAIL?5SIZE?5in?5Kbytes?0?5de@ DB 0aH
	DB	'-t ==> TRAIL SIZE in Kbytes, default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LJGJNMJG@?6?9c?5?$DN?$DN?$DO?5CODE?5SIZE?5in?5Kbytes?0?5?5de@
CONST	SEGMENT
??_C@_0CH@LJGJNMJG@?6?9c?5?$DN?$DN?$DO?5CODE?5SIZE?5in?5Kbytes?0?5?5de@ DB 0aH
	DB	'-c ==> CODE SIZE in Kbytes,  default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LPGJNJNM@?6?9a?5?$DN?$DN?$DO?5MAX?4?5ATOMS?0?5give?5exponen@
CONST	SEGMENT
??_C@_0DE@LPGJNJNM@?6?9a?5?$DN?$DN?$DO?5MAX?4?5ATOMS?0?5give?5exponen@ DB 0aH
	DB	'-a ==> MAX. ATOMS, give exponent of 2, 2**default=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HNIKEPII@?6?9d?5?$DN?$DN?$DO?5HASH?5DICT?4?5entries?0?5give@
CONST	SEGMENT
??_C@_0DN@HNIKEPII@?6?9d?5?$DN?$DN?$DO?5HASH?5DICT?4?5entries?0?5give@ DB 0aH
	DB	'-d ==> HASH DICT. entries, give exponent of 2,  2**default=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NBDEABJE@?6?9i?5?$DN?$DN?$DO?5IOBUFFER?0?5in?5Kbytes?0?5def@
CONST	SEGMENT
??_C@_0CG@NBDEABJE@?6?9i?5?$DN?$DN?$DO?5IOBUFFER?0?5in?5Kbytes?0?5def@ DB 0aH
	DB	'-i ==> IOBUFFER, in Kbytes, default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ICAHFJLD@?6?9q?5?$DN?$DN?$DO?5QUIETNESS?5level?0?5default@
CONST	SEGMENT
??_C@_0CC@ICAHFJLD@?6?9q?5?$DN?$DN?$DO?5QUIETNESS?5level?0?5default@ DB 0aH
	DB	'-q ==> QUIETNESS level, default:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPFKBKGK@?6?6ARGUMENTS?3?6?$AA@
CONST	SEGMENT
??_C@_0O@FPFKBKGK@?6?6ARGUMENTS?3?6?$AA@ DB 0aH, 0aH, 'ARGUMENTS:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GEEACGMK@?6?5?5STARTUP?5FILE?3?5?$CK?4bp?0?5?$CK?4pl?0?5?$CK?4w@
CONST	SEGMENT
??_C@_0EG@GEEACGMK@?6?5?5STARTUP?5FILE?3?5?$CK?4bp?0?5?$CK?4pl?0?5?$CK?4w@ DB 0aH
	DB	'  STARTUP FILE: *.bp, *.pl, *.wam or', 0aH, '  GOAL: pred(arg'
	DB	's),', 0aH, '  default: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNNHBPJC@wam?4bp?$AA@
CONST	SEGMENT
??_C@_06MNNHBPJC@wam?4bp?$AA@ DB 'wam.bp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BBJKAGJO@cellsize?$DN?$CFu?5termsize?$DN?$CFu?5symbits?$DN@
CONST	SEGMENT
??_C@_0CE@BBJKAGJO@cellsize?$DN?$CFu?5termsize?$DN?$CFu?5symbits?$DN@ DB 'c'
	DB	'ellsize=%u termsize=%u symbits=%u', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _opt_help
_TEXT	SEGMENT
_opt_help PROC						; COMDAT

; 884  :   (void) fprintf(STD_err, "cellsize=%u termsize=%u symbits=%u\n",
; 885  :       (unsigned)sizeof(cell), (unsigned)sizeof(term), (unsigned)SYMBITS);

  00000	6a 16		 push	 22			; 00000016H
  00002	6a 04		 push	 4
  00004	6a 04		 push	 4
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BBJKAGJO@cellsize?$DN?$CFu?5termsize?$DN?$CFu?5symbits?$DN@
  0000b	e8 00 00 00 00	 call	 ___iob_func
  00010	83 c0 40	 add	 eax, 64			; 00000040H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _fprintf

; 886  :   (void) fprintf(
; 887  :       STD_err,
; 888  :       "%s %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%ld %s%s%s\n\n",
; 889  :       "\nBinProlog command line:\n\nOPTIONS:\n",
; 890  : 
; 891  :       "\n-h ==> HEAP SIZE in Kbytes,  default:",
; 892  :       (long)W2Ks(max.HEAP),
; 893  :       "\n-s ==> STACK SIZE in Kbytes, default:",
; 894  :       (long)W2Ks(max.CHOICE),
; 895  :       "\n-t ==> TRAIL SIZE in Kbytes, default:",
; 896  :       (long)W2Ks(max.TRAIL),
; 897  :       "\n-c ==> CODE SIZE in Kbytes,  default:",
; 898  :       (long)W2Ks(max.CODE),
; 899  :       "\n-a ==> MAX. ATOMS, give exponent of 2, 2**default=",
; 900  :       (long)max.ATOMS,
; 901  :       "\n-d ==> HASH DICT. entries, give exponent of 2,  2**default=",
; 902  :       (long)max.DICT,
; 903  :       "\n-i ==> IOBUFFER, in Kbytes, default:",
; 904  :       (long)max.SBUF >> 10,
; 905  :       "\n-q ==> QUIETNESS level, default:",
; 906  :       (long)OUTPUT_INT(max.QUIET),
; 907  : 
; 908  :       "\n\nARGUMENTS:\n",
; 909  :       "\n  STARTUP FILE: *.bp, *.pl, *.wam or\n  GOAL: pred(args),\n  default: ",
; 910  :       "wam.bp");

  00019	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  0001e	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR _max+28
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _max+20
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_06MNNHBPJC@wam?4bp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@GEEACGMK@?6?5?5STARTUP?5FILE?3?5?$CK?4bp?0?5?$CK?4pl?0?5?$CK?4w@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FPFKBKGK@?6?6ARGUMENTS?3?6?$AA@
  0003c	c1 f8 02	 sar	 eax, 2
  0003f	50		 push	 eax
  00040	a1 18 00 00 00	 mov	 eax, DWORD PTR _max+24
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ICAHFJLD@?6?9q?5?$DN?$DN?$DO?5QUIETNESS?5level?0?5default@
  0004a	c1 f9 0a	 sar	 ecx, 10			; 0000000aH
  0004d	51		 push	 ecx
  0004e	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _max+12
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NBDEABJE@?6?9i?5?$DN?$DN?$DO?5IOBUFFER?0?5in?5Kbytes?0?5def@
  00059	52		 push	 edx
  0005a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _max+8
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HNIKEPII@?6?9d?5?$DN?$DN?$DO?5HASH?5DICT?4?5entries?0?5give@
  00065	50		 push	 eax
  00066	a1 04 00 00 00	 mov	 eax, DWORD PTR _max+4
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LPGJNJNM@?6?9a?5?$DN?$DN?$DO?5MAX?4?5ATOMS?0?5give?5exponen@
  00070	c1 e9 08	 shr	 ecx, 8
  00073	51		 push	 ecx
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _max
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@LJGJNMJG@?6?9c?5?$DN?$DN?$DO?5CODE?5SIZE?5in?5Kbytes?0?5?5de@
  0007f	c1 ea 08	 shr	 edx, 8
  00082	52		 push	 edx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@EIMJGIMH@?6?9t?5?$DN?$DN?$DO?5TRAIL?5SIZE?5in?5Kbytes?0?5de@
  00088	c1 e8 08	 shr	 eax, 8
  0008b	50		 push	 eax
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BBPIFEL@?6?9s?5?$DN?$DN?$DO?5STACK?5SIZE?5in?5Kbytes?0?5de@
  00091	c1 e9 08	 shr	 ecx, 8
  00094	51		 push	 ecx
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DDFKIKCO@?6?9h?5?$DN?$DN?$DO?5HEAP?5SIZE?5in?5Kbytes?0?5?5de@
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NMEPBAOM@?6BinProlog?5command?5line?3?6?6OPTION@
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DLMACPPH@?$CFs?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld?5?$CFs?$CFld@
  000a4	e8 00 00 00 00	 call	 ___iob_func
  000a9	83 c0 40	 add	 eax, 64			; 00000040H
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _fprintf
  000b2	83 c4 58	 add	 esp, 88			; 00000058H

; 911  : }

  000b5	c3		 ret	 0
_opt_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@MMANGPFP@MAXARITY?3?$CFd?5MAXREG?3?$CFd?5TEMPARGS?3?$CF@ ; `string'
;	COMDAT ??_C@_0CO@MMANGPFP@MAXARITY?3?$CFd?5MAXREG?3?$CFd?5TEMPARGS?3?$CF@
CONST	SEGMENT
??_C@_0CO@MMANGPFP@MAXARITY?3?$CFd?5MAXREG?3?$CFd?5TEMPARGS?3?$CF@ DB 'MA'
	DB	'XARITY:%d MAXREG:%d TEMPARGS:%d MAXDCG:%d', 0aH, 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _state_info
_TEXT	SEGMENT
_state_info PROC					; COMDAT

; 914  : (void)fprintf(STD_err,"MAXARITY:%d MAXREG:%d TEMPARGS:%d MAXDCG:%d\n\n",
; 915  :                        (int)MAXARITY,   (int)MAXREG,   (int)TEMPARGS,   (int)MAXDCG);

  00000	68 ff 00 00 00	 push	 255			; 000000ffH
  00005	6a 08		 push	 8
  00007	68 ff 07 00 00	 push	 2047			; 000007ffH
  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MMANGPFP@MAXARITY?3?$CFd?5MAXREG?3?$CFd?5TEMPARGS?3?$CF@
  00016	e8 00 00 00 00	 call	 ___iob_func
  0001b	83 c0 40	 add	 eax, 64			; 00000040H
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _fprintf
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 916  : }

  00027	c3		 ret	 0
_state_info ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@EEKNHEAM@bad?5option?3?5?9?$CFc?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	_get_cmd_line_options
EXTRN	_atol:PROC
;	COMDAT ??_C@_0BD@EEKNHEAM@bad?5option?3?5?9?$CFc?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@EEKNHEAM@bad?5option?3?5?9?$CFc?$CFs?6?$AA@ DB 'bad option: -%c'
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@ DB '*** BAD '
	DB	'OPTION=%s', 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _get_cmd_line_options
_TEXT	SEGMENT
_fname$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_get_cmd_line_options PROC				; COMDAT

; 940  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 941  :   int nth, errflag=0;
; 942  :   char *fname=NULL;
; 943  :   char option,*optarg;
; 944  :   DECLOPTS();
; 945  : 
; 946  :   for(nth=1; nth<argc; nth++)

  00003	bb 01 00 00 00	 mov	 ebx, 1
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _fname$[esp+20], 0
  00012	39 5c 24 18	 cmp	 DWORD PTR _argc$[esp+16], ebx
  00016	0f 8e 7d 03 00
	00		 jle	 $LN55@get_cmd_li
  0001c	8b 6c 24 1c	 mov	 ebp, DWORD PTR _argv$[esp+16]
$LL67@get_cmd_li:

; 947  :    {
; 948  :      if(ISOPT())

  00020	8b 54 9d 00	 mov	 edx, DWORD PTR [ebp+ebx*4]
  00024	8b c2		 mov	 eax, edx
  00026	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL65@get_cmd_li:
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	84 c9		 test	 cl, cl
  00035	75 f9		 jne	 SHORT $LL65@get_cmd_li
  00037	2b c6		 sub	 eax, esi
  00039	83 f8 02	 cmp	 eax, 2
  0003c	0f 82 41 03 00
	00		 jb	 $LN54@get_cmd_li
  00042	80 3a 2d	 cmp	 BYTE PTR [edx], 45	; 0000002dH
  00045	0f 85 38 03 00
	00		 jne	 $LN54@get_cmd_li

; 949  :        {
; 950  :         option=OPTKEY();

  0004b	8b c2		 mov	 eax, edx
  0004d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]

; 951  :         optarg=OPTVAL();

  00050	8d 70 02	 lea	 esi, DWORD PTR [eax+2]

; 952  : 
; 953  :         switch(option)

  00053	0f be c1	 movsx	 eax, cl
  00056	83 c0 9f	 add	 eax, -97		; ffffff9fH
  00059	83 f8 13	 cmp	 eax, 19			; 00000013H
  0005c	0f 87 41 03 00
	00		 ja	 $LN3@get_cmd_li
  00062	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN69@get_cmd_li[eax*4]
$LN51@get_cmd_li:

; 954  :           {
; 955  : 
; 956  :             SWITCHOPTS()

  00069	56		 push	 esi
  0006a	e8 00 00 00 00	 call	 _atol
  0006f	8b f8		 mov	 edi, eax
  00071	83 c4 04	 add	 esp, 4
  00074	85 ff		 test	 edi, edi
  00076	79 1f		 jns	 SHORT $LN49@get_cmd_li
  00078	56		 push	 esi
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0007e	e8 00 00 00 00	 call	 ___iob_func
  00083	83 c0 40	 add	 eax, 64			; 00000040H
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _fprintf
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 f7 02 00
	00		 jne	 $LN56@get_cmd_li
$LN49@get_cmd_li:
  00097	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  0009a	c1 ef 02	 shr	 edi, 2
  0009d	89 3d 00 00 00
	00		 mov	 DWORD PTR _max, edi
  000a3	e9 e6 02 00 00	 jmp	 $LN56@get_cmd_li
$LN47@get_cmd_li:
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _atol
  000ae	8b f8		 mov	 edi, eax
  000b0	83 c4 04	 add	 esp, 4
  000b3	85 ff		 test	 edi, edi
  000b5	79 1f		 jns	 SHORT $LN45@get_cmd_li
  000b7	56		 push	 esi
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  000bd	e8 00 00 00 00	 call	 ___iob_func
  000c2	83 c0 40	 add	 eax, 64			; 00000040H
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _fprintf
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	85 c0		 test	 eax, eax
  000d0	0f 85 b8 02 00
	00		 jne	 $LN56@get_cmd_li
$LN45@get_cmd_li:
  000d6	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  000d9	c1 ef 02	 shr	 edi, 2
  000dc	89 3d 04 00 00
	00		 mov	 DWORD PTR _max+4, edi
  000e2	e9 a7 02 00 00	 jmp	 $LN56@get_cmd_li
$LN43@get_cmd_li:
  000e7	56		 push	 esi
  000e8	e8 00 00 00 00	 call	 _atol
  000ed	8b f8		 mov	 edi, eax
  000ef	83 c4 04	 add	 esp, 4
  000f2	85 ff		 test	 edi, edi
  000f4	79 1f		 jns	 SHORT $LN41@get_cmd_li
  000f6	56		 push	 esi
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  000fc	e8 00 00 00 00	 call	 ___iob_func
  00101	83 c0 40	 add	 eax, 64			; 00000040H
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _fprintf
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 79 02 00
	00		 jne	 $LN56@get_cmd_li
$LN41@get_cmd_li:
  00115	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  00118	c1 ef 02	 shr	 edi, 2
  0011b	89 3d 08 00 00
	00		 mov	 DWORD PTR _max+8, edi
  00121	e9 68 02 00 00	 jmp	 $LN56@get_cmd_li
$LN39@get_cmd_li:
  00126	56		 push	 esi
  00127	e8 00 00 00 00	 call	 _atol
  0012c	8b f8		 mov	 edi, eax
  0012e	83 c4 04	 add	 esp, 4
  00131	85 ff		 test	 edi, edi
  00133	79 1f		 jns	 SHORT $LN37@get_cmd_li
  00135	56		 push	 esi
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0013b	e8 00 00 00 00	 call	 ___iob_func
  00140	83 c0 40	 add	 eax, 64			; 00000040H
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 _fprintf
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014c	85 c0		 test	 eax, eax
  0014e	0f 85 3a 02 00
	00		 jne	 $LN56@get_cmd_li
$LN37@get_cmd_li:
  00154	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  00157	c1 ef 02	 shr	 edi, 2
  0015a	89 3d 0c 00 00
	00		 mov	 DWORD PTR _max+12, edi
  00160	e9 29 02 00 00	 jmp	 $LN56@get_cmd_li
$LN35@get_cmd_li:
  00165	56		 push	 esi
  00166	e8 00 00 00 00	 call	 _atol
  0016b	8b f8		 mov	 edi, eax
  0016d	83 c4 04	 add	 esp, 4
  00170	85 ff		 test	 edi, edi
  00172	79 1f		 jns	 SHORT $LN33@get_cmd_li
  00174	56		 push	 esi
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0017a	e8 00 00 00 00	 call	 ___iob_func
  0017f	83 c0 40	 add	 eax, 64			; 00000040H
  00182	50		 push	 eax
  00183	e8 00 00 00 00	 call	 _fprintf
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018b	85 c0		 test	 eax, eax
  0018d	0f 85 fb 01 00
	00		 jne	 $LN56@get_cmd_li
$LN33@get_cmd_li:
  00193	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  00196	c1 ef 02	 shr	 edi, 2
  00199	89 3d 10 00 00
	00		 mov	 DWORD PTR _max+16, edi
  0019f	e9 ea 01 00 00	 jmp	 $LN56@get_cmd_li
$LN31@get_cmd_li:
  001a4	56		 push	 esi
  001a5	e8 00 00 00 00	 call	 _atol
  001aa	8b f8		 mov	 edi, eax
  001ac	83 c4 04	 add	 esp, 4
  001af	85 ff		 test	 edi, edi
  001b1	79 1f		 jns	 SHORT $LN29@get_cmd_li
  001b3	56		 push	 esi
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  001b9	e8 00 00 00 00	 call	 ___iob_func
  001be	83 c0 40	 add	 eax, 64			; 00000040H
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _fprintf
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ca	85 c0		 test	 eax, eax
  001cc	0f 85 bc 01 00
	00		 jne	 $LN56@get_cmd_li
$LN29@get_cmd_li:
  001d2	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  001d5	0f 8c b3 01 00
	00		 jl	 $LN56@get_cmd_li
  001db	83 ff 1b	 cmp	 edi, 27			; 0000001bH
  001de	0f 87 aa 01 00
	00		 ja	 $LN56@get_cmd_li
  001e4	b8 01 00 00 00	 mov	 eax, 1
  001e9	8b cf		 mov	 ecx, edi
  001eb	d3 e0		 shl	 eax, cl
  001ed	a3 14 00 00 00	 mov	 DWORD PTR _max+20, eax
  001f2	e9 97 01 00 00	 jmp	 $LN56@get_cmd_li
$LN27@get_cmd_li:
  001f7	56		 push	 esi
  001f8	e8 00 00 00 00	 call	 _atol
  001fd	8b f8		 mov	 edi, eax
  001ff	83 c4 04	 add	 esp, 4
  00202	85 ff		 test	 edi, edi
  00204	79 1f		 jns	 SHORT $LN25@get_cmd_li
  00206	56		 push	 esi
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0020c	e8 00 00 00 00	 call	 ___iob_func
  00211	83 c0 40	 add	 eax, 64			; 00000040H
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 _fprintf
  0021a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021d	85 c0		 test	 eax, eax
  0021f	0f 85 69 01 00
	00		 jne	 $LN56@get_cmd_li
$LN25@get_cmd_li:
  00225	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00228	0f 8c 60 01 00
	00		 jl	 $LN56@get_cmd_li
  0022e	83 ff 16	 cmp	 edi, 22			; 00000016H
  00231	0f 87 57 01 00
	00		 ja	 $LN56@get_cmd_li
  00237	ba 01 00 00 00	 mov	 edx, 1
  0023c	8b cf		 mov	 ecx, edi
  0023e	d3 e2		 shl	 edx, cl
  00240	89 15 18 00 00
	00		 mov	 DWORD PTR _max+24, edx
  00246	e9 43 01 00 00	 jmp	 $LN56@get_cmd_li
$LN23@get_cmd_li:
  0024b	56		 push	 esi
  0024c	e8 00 00 00 00	 call	 _atol
  00251	8b f8		 mov	 edi, eax
  00253	83 c4 04	 add	 esp, 4
  00256	85 ff		 test	 edi, edi
  00258	79 1f		 jns	 SHORT $LN21@get_cmd_li
  0025a	56		 push	 esi
  0025b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  00260	e8 00 00 00 00	 call	 ___iob_func
  00265	83 c0 40	 add	 eax, 64			; 00000040H
  00268	50		 push	 eax
  00269	e8 00 00 00 00	 call	 _fprintf
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00271	85 c0		 test	 eax, eax
  00273	0f 85 15 01 00
	00		 jne	 $LN56@get_cmd_li
$LN21@get_cmd_li:
  00279	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  0027c	89 3d 1c 00 00
	00		 mov	 DWORD PTR _max+28, edi
  00282	e9 07 01 00 00	 jmp	 $LN56@get_cmd_li
$LN19@get_cmd_li:
  00287	56		 push	 esi
  00288	e8 00 00 00 00	 call	 _atol
  0028d	8b f8		 mov	 edi, eax
  0028f	83 c4 04	 add	 esp, 4
  00292	85 ff		 test	 edi, edi
  00294	79 1f		 jns	 SHORT $LN17@get_cmd_li
  00296	56		 push	 esi
  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0029c	e8 00 00 00 00	 call	 ___iob_func
  002a1	83 c0 40	 add	 eax, 64			; 00000040H
  002a4	50		 push	 eax
  002a5	e8 00 00 00 00	 call	 _fprintf
  002aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ad	85 c0		 test	 eax, eax
  002af	0f 85 d9 00 00
	00		 jne	 $LN56@get_cmd_li
$LN17@get_cmd_li:
  002b5	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  002bc	83 c8 01	 or	 eax, 1
  002bf	a3 24 00 00 00	 mov	 DWORD PTR _max+36, eax
  002c4	e9 c5 00 00 00	 jmp	 $LN56@get_cmd_li
$LN15@get_cmd_li:
  002c9	56		 push	 esi
  002ca	e8 00 00 00 00	 call	 _atol
  002cf	8b f8		 mov	 edi, eax
  002d1	83 c4 04	 add	 esp, 4
  002d4	85 ff		 test	 edi, edi
  002d6	79 1f		 jns	 SHORT $LN13@get_cmd_li
  002d8	56		 push	 esi
  002d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  002de	e8 00 00 00 00	 call	 ___iob_func
  002e3	83 c0 40	 add	 eax, 64			; 00000040H
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _fprintf
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ef	85 c0		 test	 eax, eax
  002f1	0f 85 97 00 00
	00		 jne	 $LN56@get_cmd_li
$LN13@get_cmd_li:
  002f7	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  002fe	83 c9 01	 or	 ecx, 1
  00301	89 0d 28 00 00
	00		 mov	 DWORD PTR _max+40, ecx
  00307	e9 82 00 00 00	 jmp	 $LN56@get_cmd_li
$LN11@get_cmd_li:
  0030c	56		 push	 esi
  0030d	e8 00 00 00 00	 call	 _atol
  00312	8b f8		 mov	 edi, eax
  00314	83 c4 04	 add	 esp, 4
  00317	85 ff		 test	 edi, edi
  00319	79 1b		 jns	 SHORT $LN9@get_cmd_li
  0031b	56		 push	 esi
  0031c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  00321	e8 00 00 00 00	 call	 ___iob_func
  00326	83 c0 40	 add	 eax, 64			; 00000040H
  00329	50		 push	 eax
  0032a	e8 00 00 00 00	 call	 _fprintf
  0032f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00332	85 c0		 test	 eax, eax
  00334	75 58		 jne	 SHORT $LN56@get_cmd_li
$LN9@get_cmd_li:
  00336	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  0033d	83 ca 01	 or	 edx, 1
  00340	89 15 2c 00 00
	00		 mov	 DWORD PTR _max+44, edx
  00346	eb 46		 jmp	 SHORT $LN56@get_cmd_li
$LN7@get_cmd_li:
  00348	56		 push	 esi
  00349	e8 00 00 00 00	 call	 _atol
  0034e	8b f8		 mov	 edi, eax
  00350	83 c4 04	 add	 esp, 4
  00353	85 ff		 test	 edi, edi
  00355	79 1b		 jns	 SHORT $LN5@get_cmd_li
  00357	56		 push	 esi
  00358	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OBAHJNNG@?$CK?$CK?$CK?5BAD?5OPTION?$DN?$CFs?6?$AA@
  0035d	e8 00 00 00 00	 call	 ___iob_func
  00362	83 c0 40	 add	 eax, 64			; 00000040H
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 _fprintf
  0036b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036e	85 c0		 test	 eax, eax
  00370	75 1c		 jne	 SHORT $LN56@get_cmd_li
$LN5@get_cmd_li:
  00372	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  00379	83 c8 01	 or	 eax, 1
  0037c	a3 34 00 00 00	 mov	 DWORD PTR _max+52, eax

; 961  :             break;
; 962  :           }
; 963  : 
; 964  :         }
; 965  :      else

  00381	eb 0b		 jmp	 SHORT $LN56@get_cmd_li
$LN54@get_cmd_li:

; 966  :        if(!fname) fname=NONOPTVAL();

  00383	83 7c 24 10 00	 cmp	 DWORD PTR _fname$[esp+20], 0
  00388	75 04		 jne	 SHORT $LN56@get_cmd_li
  0038a	89 54 24 10	 mov	 DWORD PTR _fname$[esp+20], edx
$LN56@get_cmd_li:

; 941  :   int nth, errflag=0;
; 942  :   char *fname=NULL;
; 943  :   char option,*optarg;
; 944  :   DECLOPTS();
; 945  : 
; 946  :   for(nth=1; nth<argc; nth++)

  0038e	43		 inc	 ebx
  0038f	3b 5c 24 18	 cmp	 ebx, DWORD PTR _argc$[esp+16]
  00393	0f 8c 87 fc ff
	ff		 jl	 $LL67@get_cmd_li
$LN55@get_cmd_li:

; 967  :    }
; 968  : 
; 969  :   return fname;

  00399	8b 44 24 10	 mov	 eax, DWORD PTR _fname$[esp+20]
  0039d	5f		 pop	 edi
  0039e	5e		 pop	 esi
  0039f	5d		 pop	 ebp
  003a0	5b		 pop	 ebx

; 970  : }

  003a1	59		 pop	 ecx
  003a2	c3		 ret	 0
$LN3@get_cmd_li:

; 957  : 
; 958  :             default:
; 959  :               fprintf(STD_err,"bad option: -%c%s\n",option,optarg);

  003a3	0f be c9	 movsx	 ecx, cl
  003a6	56		 push	 esi
  003a7	51		 push	 ecx
  003a8	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEKNHEAM@bad?5option?3?5?9?$CFc?$CFs?6?$AA@
  003ad	e8 00 00 00 00	 call	 ___iob_func
  003b2	83 c0 40	 add	 eax, 64			; 00000040H
  003b5	50		 push	 eax
  003b6	e8 00 00 00 00	 call	 _fprintf
  003bb	83 c4 10	 add	 esp, 16			; 00000010H

; 960  :               BADOPTS()

  003be	e8 00 00 00 00	 call	 _opt_help
  003c3	6a 02		 push	 2
  003c5	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  003ca	e8 00 00 00 00	 call	 _bp_exit
$LN68@get_cmd_li:
  003cf	90		 npad	 1
$LN69@get_cmd_li:

; 970  : }

  003d0	00 00 00 00	 DD	 $LN27@get_cmd_li
  003d4	00 00 00 00	 DD	 $LN35@get_cmd_li
  003d8	00 00 00 00	 DD	 $LN39@get_cmd_li
  003dc	00 00 00 00	 DD	 $LN31@get_cmd_li
  003e0	00 00 00 00	 DD	 $LN3@get_cmd_li
  003e4	00 00 00 00	 DD	 $LN3@get_cmd_li
  003e8	00 00 00 00	 DD	 $LN3@get_cmd_li
  003ec	00 00 00 00	 DD	 $LN51@get_cmd_li
  003f0	00 00 00 00	 DD	 $LN23@get_cmd_li
  003f4	00 00 00 00	 DD	 $LN3@get_cmd_li
  003f8	00 00 00 00	 DD	 $LN3@get_cmd_li
  003fc	00 00 00 00	 DD	 $LN15@get_cmd_li
  00400	00 00 00 00	 DD	 $LN3@get_cmd_li
  00404	00 00 00 00	 DD	 $LN3@get_cmd_li
  00408	00 00 00 00	 DD	 $LN3@get_cmd_li
  0040c	00 00 00 00	 DD	 $LN7@get_cmd_li
  00410	00 00 00 00	 DD	 $LN19@get_cmd_li
  00414	00 00 00 00	 DD	 $LN11@get_cmd_li
  00418	00 00 00 00	 DD	 $LN47@get_cmd_li
  0041c	00 00 00 00	 DD	 $LN43@get_cmd_li
_get_cmd_line_options ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _configure_bb
_TEXT	SEGMENT
_configure_bb PROC					; COMDAT

; 1015 :   if(0==max.BOARD)

  00000	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR _max+16, 0
  00007	75 1f		 jne	 SHORT $LN2@configure_

; 1016 :     {
; 1017 :       max.BOARD=1<<12;     /* small initial bboard size*/

  00009	c7 05 10 00 00
	00 00 10 00 00	 mov	 DWORD PTR _max+16, 4096	; 00001000H

; 1018 :       g.bbgc=INPUT_INT(2); /* dynamic gc-able bboard */

  00013	c7 05 fc 00 00
	00 09 00 00 00	 mov	 DWORD PTR _g+252, 9

; 1019 :       g.bbhi=INPUT_INT(1); /* high bboard */

  0001d	c7 05 00 01 00
	00 05 00 00 00	 mov	 DWORD PTR _g+256, 5

; 1025 :     }
; 1026 : }

  00027	c3		 ret	 0
$LN2@configure_:

; 1020 :     }
; 1021 :   else
; 1022 :     {
; 1023 :       g.bbgc=INPUT_INT(1); /* static gc-able bboard*/

  00028	c7 05 fc 00 00
	00 05 00 00 00	 mov	 DWORD PTR _g+252, 5

; 1024 :       g.bbhi=INPUT_INT(0); /* low bboard */

  00032	c7 05 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR _g+256, 1

; 1025 :     }
; 1026 : }

  0003c	c3		 ret	 0
_configure_bb ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@GBHBIFKO@?6program?5interrupted?$CItimes?$DN?$CFd?0er@ ; `string'
PUBLIC	??_C@_0DB@PDNFCADG@?6interrupted?$CItimes?$DN?$CFd?0code?$DN?$CFd?$CJ?4?4@ ; `string'
PUBLIC	??_C@_0DO@EOOJGKLO@?6interrupted?5during?5link?5phase?$CIt@ ; `string'
PUBLIC	??_C@_0CN@FNMBAGHC@?6Previous?5interrupt?5caught?5?$CFld?5s@ ; `string'
PUBLIC	_bp_interrupt_handler
EXTRN	_signal:PROC
EXTRN	_hbak:PROC
EXTRN	_restart_orig:PROC
_BSS	SEGMENT
_root_wam DB	0b4H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DD@GBHBIFKO@?6program?5interrupted?$CItimes?$DN?$CFd?0er@
CONST	SEGMENT
??_C@_0DD@GBHBIFKO@?6program?5interrupted?$CItimes?$DN?$CFd?0er@ DB 0aH, 'p'
	DB	'rogram interrupted(times=%d,error=%d)...exiting', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PDNFCADG@?6interrupted?$CItimes?$DN?$CFd?0code?$DN?$CFd?$CJ?4?4@
CONST	SEGMENT
??_C@_0DB@PDNFCADG@?6interrupted?$CItimes?$DN?$CFd?0code?$DN?$CFd?$CJ?4?4@ DB 0aH
	DB	'interrupted(times=%d,code=%d)...reinitializing', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@EOOJGKLO@?6interrupted?5during?5link?5phase?$CIt@
CONST	SEGMENT
??_C@_0DO@EOOJGKLO@?6interrupted?5during?5link?5phase?$CIt@ DB 0aH, 'inte'
	DB	'rrupted during link phase(times=%d,code=%d)...rebooting', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FNMBAGHC@?6Previous?5interrupt?5caught?5?$CFld?5s@
CONST	SEGMENT
??_C@_0CN@FNMBAGHC@?6Previous?5interrupt?5caught?5?$CFld?5s@ DB 0aH, 'Pre'
	DB	'vious interrupt caught %ld seconds ago!', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bp_interrupt_handler
_TEXT	SEGMENT
$T7961 = -8						; size = 8
_i$ = 8							; size = 4
_bp_interrupt_handler PROC				; COMDAT

; 1036 : void FORCE_CDECL bp_interrupt_handler(int i) {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi

; 1037 :   static int ctr=0;
; 1038 :   register stack wam=root_wam;
; 1039 :   int errcode=OUTPUT_INT(g.err.id);

  00004	8b 35 5c 01 00
	00		 mov	 esi, DWORD PTR _g+348
  0000a	57		 push	 edi

; 1040 :   static bp_long last_interrupt_time=ZERO;
; 1041 :   bp_long this_time=realtime(2);

  0000b	6a 00		 push	 0
  0000d	c1 fe 02	 sar	 esi, 2
  00010	e8 00 00 00 00	 call	 __time64
  00015	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?startval@?1??realtime@@9@9
  0001b	83 c4 04	 add	 esp, 4
  0001e	8d b8 80 0f fa
	d0		 lea	 edi, DWORD PTR [eax-788918400]

; 1042 :   if(this_time-last_interrupt_time<=1)

  00024	8b c7		 mov	 eax, edi
  00026	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?last_interrupt_time@?1??bp_interrupt_handler@@9@9
  0002c	89 54 24 0c	 mov	 DWORD PTR $T7961[esp+20], edx
  00030	83 f8 01	 cmp	 eax, 1
  00033	7f 05		 jg	 SHORT $LN6@bp_interru

; 1043 :      errcode=1; /* exit if ^C is pressed twice */

  00035	be 01 00 00 00	 mov	 esi, 1
$LN6@bp_interru:

; 1044 :   fprintf(STD_err,"\nPrevious interrupt caught %ld seconds ago!\n",
; 1045 :     this_time-last_interrupt_time);

  0003a	50		 push	 eax
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FNMBAGHC@?6Previous?5interrupt?5caught?5?$CFld?5s@
  00040	e8 00 00 00 00	 call	 ___iob_func
  00045	83 c0 40	 add	 eax, 64			; 00000040H
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _fprintf

; 1046 :   last_interrupt_time=this_time;
; 1047 :   ctr++;

  0004e	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ctr@?1??bp_interrupt_handler@@9@9
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	89 3d 00 00 00
	00		 mov	 DWORD PTR ?last_interrupt_time@?1??bp_interrupt_handler@@9@9, edi

; 1048 :   if(errcode || g.stopper) {

  0005d	85 f6		 test	 esi, esi
  0005f	75 7e		 jne	 SHORT $LN4@bp_interru
  00061	39 35 bc 01 00
	00		 cmp	 DWORD PTR _g+444, esi
  00067	75 76		 jne	 SHORT $LN4@bp_interru

; 1053 :   }
; 1054 :   else {
; 1055 : 	/* g.stopper tries to NOTIFY all running engines
; 1056 : 	   to return NULL at the next SAFE return point
; 1057 : 	*/
; 1058 : 	g.stopper=(sizeof(cell)<<3)-1; /* ensures: (x >> g.stopper) == 0 */
; 1059 : 
; 1060 : 	if(OUTPUT_INT(g.linking)) {

  00069	f7 05 f4 00 00
	00 fc ff ff ff	 test	 DWORD PTR _g+244, -4	; fffffffcH
  00073	c7 05 bc 01 00
	00 1f 00 00 00	 mov	 DWORD PTR _g+444, 31	; 0000001fH
  0007d	74 20		 je	 SHORT $LN2@bp_interru

; 1061 :       restart_orig(wam);

  0007f	68 00 00 00 00	 push	 OFFSET _root_wam
  00084	e8 00 00 00 00	 call	 _restart_orig

; 1062 : 	   fprintf(STD_err,
; 1063 : 	    "\ninterrupted during link phase(times=%d,code=%d)...rebooting\n",ctr,i);

  00089	8b 44 24 18	 mov	 eax, DWORD PTR _i$[esp+16]
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ctr@?1??bp_interrupt_handler@@9@9
  00093	83 c4 04	 add	 esp, 4
  00096	50		 push	 eax
  00097	51		 push	 ecx
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@EOOJGKLO@?6interrupted?5during?5link?5phase?$CIt@

; 1064 : 	}
; 1065 :     else {

  0009d	eb 1a		 jmp	 SHORT $LN29@bp_interru
$LN2@bp_interru:

; 1066 :       hbak(BBOARDTIME);

  0009f	6a 03		 push	 3
  000a1	e8 00 00 00 00	 call	 _hbak

; 1067 :       fprintf(STD_err,
; 1068 : 	    "\ninterrupted(times=%d,code=%d)...reinitializing\n",ctr,i);

  000a6	8b 54 24 18	 mov	 edx, DWORD PTR _i$[esp+16]
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ctr@?1??bp_interrupt_handler@@9@9
  000af	83 c4 04	 add	 esp, 4
  000b2	52		 push	 edx
  000b3	50		 push	 eax
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@PDNFCADG@?6interrupted?$CItimes?$DN?$CFd?0code?$DN?$CFd?$CJ?4?4@
$LN29@bp_interru:
  000b9	e8 00 00 00 00	 call	 ___iob_func
  000be	83 c0 40	 add	 eax, 64			; 00000040H
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _fprintf
  000c7	83 c4 10	 add	 esp, 16			; 00000010H

; 1069 :     }
; 1070 :   }
; 1071 :   install_interrupt_handler();

  000ca	68 00 00 00 00	 push	 OFFSET _bp_interrupt_handler
  000cf	6a 02		 push	 2
  000d1	e8 00 00 00 00	 call	 _signal
  000d6	83 c4 08	 add	 esp, 8
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 1072 : }

  000db	83 c4 08	 add	 esp, 8
  000de	c3		 ret	 0
$LN4@bp_interru:

; 1049 :     fprintf(STD_err,
; 1050 : 	"\nprogram interrupted(times=%d,error=%d)...exiting\n",
; 1051 :       ctr,errcode);

  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ctr@?1??bp_interrupt_handler@@9@9
  000e5	56		 push	 esi
  000e6	51		 push	 ecx
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GBHBIFKO@?6program?5interrupted?$CItimes?$DN?$CFd?0er@
  000ec	e8 00 00 00 00	 call	 ___iob_func
  000f1	83 c0 40	 add	 eax, 64			; 00000040H
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _fprintf
  000fa	83 c4 10	 add	 esp, 16			; 00000010H

; 1052 :     bp_halt(errcode);

  000fd	56		 push	 esi
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_06OOHAPEBD@halted?$AA@
  00103	e8 00 00 00 00	 call	 _bp_exit
$LN28@bp_interru:
  00108	cc		 int	 3
_bp_interrupt_handler ENDP
_TEXT	ENDS
PUBLIC	_install_interrupt_handler
; Function compile flags: /Ogtpy
;	COMDAT _install_interrupt_handler
_TEXT	SEGMENT
_install_interrupt_handler PROC				; COMDAT

; 1076 : #if 0 && (VCC==0)
; 1077 :   signal(SIGQUIT,bp_halt);
; 1078 :   signal(SIGINT,bp_halt);
; 1079 :   signal(SIGPIPE,SIG_IGN);
; 1080 : #if THREADS>0 && SOLARIS>0
; 1081 :   sigignore(SIGUSR1);
; 1082 :   sigignore(SIGUSR2);
; 1083 : #endif
; 1084 : #else
; 1085 :   // OS X turn off for dbugging with gdb
; 1086 :   signal(SIGINT,bp_interrupt_handler);

  00000	68 00 00 00 00	 push	 OFFSET _bp_interrupt_handler
  00005	6a 02		 push	 2
  00007	e8 00 00 00 00	 call	 _signal
  0000c	83 c4 08	 add	 esp, 8

; 1087 : #endif
; 1088 :   /*
; 1089 :   fprintf(STD_err,"Installed interrupt handler\n");
; 1090 :   */
; 1091 : }

  0000f	c3		 ret	 0
_install_interrupt_handler ENDP
_TEXT	ENDS
PUBLIC	??_C@_07OKCGJHED@err_wam?$AA@			; `string'
PUBLIC	??_C@_08KCNEHNEJ@err_arg2?$AA@			; `string'
PUBLIC	??_C@_08IJPJCOIK@err_arg1?$AA@			; `string'
PUBLIC	??_C@_07GMKLHLL@err_mes?$AA@			; `string'
PUBLIC	??_C@_06KLBMBNFO@err_id?$AA@			; `string'
PUBLIC	??_C@_0L@MNIMHPCL@mes_margin?$AA@		; `string'
PUBLIC	??_C@_03FNPJCMMD@mes?$AA@			; `string'
PUBLIC	??_C@_0N@JJBBCAGN@stack_margin?$AA@		; `string'
PUBLIC	??_C@_05IANLDAEP@stack?$AA@			; `string'
PUBLIC	??_C@_0N@HIBMHONF@trail_margin?$AA@		; `string'
PUBLIC	??_C@_04DFHGHGBC@dcgs?$AA@			; `string'
PUBLIC	??_C@_04PPLNELOM@regs?$AA@			; `string'
PUBLIC	??_C@_0M@HJCFGPKE@heap_margin?$AA@		; `string'
PUBLIC	??_C@_09OLBFCAGK@heap_base?$AA@			; `string'
PUBLIC	??_C@_0O@CJKDEHAG@bboard_margin?$AA@		; `string'
PUBLIC	??_C@_0L@MHBENID@bboard_top?$AA@		; `string'
PUBLIC	??_C@_06PFJKLBHL@bboard?$AA@			; `string'
PUBLIC	??_C@_0M@OKGGFPFE@code_margin?$AA@		; `string'
PUBLIC	??_C@_08GALJIIAC@code_top?$AA@			; `string'
PUBLIC	??_C@_0M@LMKHIEJN@code_oldtop?$AA@		; `string'
PUBLIC	??_C@_0BO@PBJIPKBJ@Finished?5loading?5system?5code?4?$AA@ ; `string'
PUBLIC	??_C@_0CG@POIOINEI@Start?5loading?5system?5code?5from?5?$DM@ ; `string'
PUBLIC	??_C@_0BE@HOEOJMND@internal?5code?5array?$AA@	; `string'
PUBLIC	??_C@_04LCMACLFG@?4txt?$AA@			; `string'
PUBLIC	??_C@_04JJADPCEN@?4pro?$AA@			; `string'
PUBLIC	??_C@_04CIICLFFP@?4wam?$AA@			; `string'
EXTRN	_init_orig_wam:PROC
EXTRN	_load_kernel:PROC
EXTRN	_init_mutexes:PROC
EXTRN	_wam_bp_size:DWORD
;	COMDAT ??_C@_07OKCGJHED@err_wam?$AA@
; File c:\a15\ms_vs10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_07OKCGJHED@err_wam?$AA@ DB 'err_wam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCNEHNEJ@err_arg2?$AA@
CONST	SEGMENT
??_C@_08KCNEHNEJ@err_arg2?$AA@ DB 'err_arg2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJPJCOIK@err_arg1?$AA@
CONST	SEGMENT
??_C@_08IJPJCOIK@err_arg1?$AA@ DB 'err_arg1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMKLHLL@err_mes?$AA@
CONST	SEGMENT
??_C@_07GMKLHLL@err_mes?$AA@ DB 'err_mes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLBMBNFO@err_id?$AA@
CONST	SEGMENT
??_C@_06KLBMBNFO@err_id?$AA@ DB 'err_id', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNIMHPCL@mes_margin?$AA@
CONST	SEGMENT
??_C@_0L@MNIMHPCL@mes_margin?$AA@ DB 'mes_margin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNPJCMMD@mes?$AA@
CONST	SEGMENT
??_C@_03FNPJCMMD@mes?$AA@ DB 'mes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJBBCAGN@stack_margin?$AA@
CONST	SEGMENT
??_C@_0N@JJBBCAGN@stack_margin?$AA@ DB 'stack_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IANLDAEP@stack?$AA@
CONST	SEGMENT
??_C@_05IANLDAEP@stack?$AA@ DB 'stack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HIBMHONF@trail_margin?$AA@
CONST	SEGMENT
??_C@_0N@HIBMHONF@trail_margin?$AA@ DB 'trail_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFHGHGBC@dcgs?$AA@
CONST	SEGMENT
??_C@_04DFHGHGBC@dcgs?$AA@ DB 'dcgs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPLNELOM@regs?$AA@
CONST	SEGMENT
??_C@_04PPLNELOM@regs?$AA@ DB 'regs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HJCFGPKE@heap_margin?$AA@
CONST	SEGMENT
??_C@_0M@HJCFGPKE@heap_margin?$AA@ DB 'heap_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OLBFCAGK@heap_base?$AA@
CONST	SEGMENT
??_C@_09OLBFCAGK@heap_base?$AA@ DB 'heap_base', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CJKDEHAG@bboard_margin?$AA@
CONST	SEGMENT
??_C@_0O@CJKDEHAG@bboard_margin?$AA@ DB 'bboard_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHBENID@bboard_top?$AA@
CONST	SEGMENT
??_C@_0L@MHBENID@bboard_top?$AA@ DB 'bboard_top', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PFJKLBHL@bboard?$AA@
CONST	SEGMENT
??_C@_06PFJKLBHL@bboard?$AA@ DB 'bboard', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKGGFPFE@code_margin?$AA@
CONST	SEGMENT
??_C@_0M@OKGGFPFE@code_margin?$AA@ DB 'code_margin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GALJIIAC@code_top?$AA@
CONST	SEGMENT
??_C@_08GALJIIAC@code_top?$AA@ DB 'code_top', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMKHIEJN@code_oldtop?$AA@
CONST	SEGMENT
??_C@_0M@LMKHIEJN@code_oldtop?$AA@ DB 'code_oldtop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PBJIPKBJ@Finished?5loading?5system?5code?4?$AA@
CONST	SEGMENT
??_C@_0BO@PBJIPKBJ@Finished?5loading?5system?5code?4?$AA@ DB 'Finished lo'
	DB	'ading system code.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@POIOINEI@Start?5loading?5system?5code?5from?5?$DM@
CONST	SEGMENT
??_C@_0CG@POIOINEI@Start?5loading?5system?5code?5from?5?$DM@ DB 'Start lo'
	DB	'ading system code from <%s>.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HOEOJMND@internal?5code?5array?$AA@
CONST	SEGMENT
??_C@_0BE@HOEOJMND@internal?5code?5array?$AA@ DB 'internal code array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LCMACLFG@?4txt?$AA@
CONST	SEGMENT
??_C@_04LCMACLFG@?4txt?$AA@ DB '.txt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JJADPCEN@?4pro?$AA@
CONST	SEGMENT
??_C@_04JJADPCEN@?4pro?$AA@ DB '.pro', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CIICLFFP@?4wam?$AA@
CONST	SEGMENT
??_C@_04CIICLFFP@?4wam?$AA@ DB '.wam', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\ru.c
CONST	ENDS
;	COMDAT _new_bp
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_new_bp	PROC						; COMDAT
; _bp_stdin$ = ecx
; _bp_stdout$ = edx

; 1094 : static stack new_bp(int argc, char **argv,FILE *bp_stdin,FILE *bp_stdout) {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 1095 :   string fname;
; 1096 :   int quiet=FALSE;

  00002	33 db		 xor	 ebx, ebx

; 1097 :   register stack wam=root_wam;
; 1098 : 
; 1099 :   g.stopper=0;
; 1100 : 
; 1101 :   g.inC=!!wam_bp_size;

  00004	33 c0		 xor	 eax, eax
  00006	33 ed		 xor	 ebp, ebp
  00008	39 1d 00 00 00
	00		 cmp	 DWORD PTR _wam_bp_size, ebx
  0000e	56		 push	 esi
  0000f	0f 95 c0	 setne	 al
  00012	57		 push	 edi
  00013	89 1d bc 01 00
	00		 mov	 DWORD PTR _g+444, ebx

; 1102 : 
; 1103 :   g.user_input=bp_stdin;

  00019	89 0d 38 01 00
	00		 mov	 DWORD PTR _g+312, ecx

; 1104 :   g.user_output=bp_stdout; /* DO NOT CHANGE ! */

  0001f	89 15 3c 01 00
	00		 mov	 DWORD PTR _g+316, edx

; 1105 : 
; 1106 :   g.lineno=0;

  00025	89 1d 40 01 00
	00		 mov	 DWORD PTR _g+320, ebx
  0002b	a3 d4 00 00 00	 mov	 DWORD PTR _g+212, eax

; 1107 : 
; 1108 :   init_mutexes();

  00030	e8 00 00 00 00	 call	 _init_mutexes

; 1109 : 
; 1110 :   g.stime=cputime();

  00035	e8 00 00 00 00	 call	 _clock
  0003a	6b c0 64	 imul	 eax, 100		; 00000064H
  0003d	8b c8		 mov	 ecx, eax
  0003f	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00044	f7 e9		 imul	 ecx

; 1111 : 
; 1112 :   fname=get_cmd_line_options(argc,argv);

  00046	8b 4c 24 18	 mov	 ecx, DWORD PTR _argv$[esp+12]
  0004a	c1 fa 05	 sar	 edx, 5
  0004d	8b c2		 mov	 eax, edx
  0004f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00052	03 c2		 add	 eax, edx
  00054	8b 54 24 14	 mov	 edx, DWORD PTR _argc$[esp+12]
  00058	51		 push	 ecx
  00059	52		 push	 edx
  0005a	a3 20 01 00 00	 mov	 DWORD PTR _g+288, eax
  0005f	e8 00 00 00 00	 call	 _get_cmd_line_options
  00064	8b f8		 mov	 edi, eax
  00066	83 c4 08	 add	 esp, 8

; 1113 : 
; 1114 :   /* Allows quiet execution of CGI scripts in cgi-bin
; 1115 :      from 9.58 only suppresses initial message - for
; 1116 :      better debugging of scripts.
; 1117 : 
; 1118 :      If a file ends with *.wam *.pro, *.txt or starts with $
; 1119 :      no banner message is printed.
; 1120 :   */
; 1121 : 
; 1122 :   if(fname) {

  00069	3b fb		 cmp	 edi, ebx
  0006b	0f 84 e9 00 00
	00		 je	 $LN100@new_bp

; 1123 : 	  if('$'== fname[0]) {

  00071	80 3f 24	 cmp	 BYTE PTR [edi], 36	; 00000024H
  00074	75 13		 jne	 SHORT $LN39@new_bp

; 1124 : 	    fname++;

  00076	47		 inc	 edi

; 1135 : 		  quiet=TRUE;

  00077	8d 6b 01	 lea	 ebp, DWORD PTR [ebx+1]

; 1136 : 	  }
; 1137 :   }
; 1138 : 
; 1139 :   if(quiet) max.QUIET=INPUT_INT(5); /* toplevel resets to 2 */

  0007a	c7 05 24 00 00
	00 15 00 00 00	 mov	 DWORD PTR _max+36, 21	; 00000015H
  00084	e9 fb 00 00 00	 jmp	 $LN99@new_bp
$LN39@new_bp:

; 1125 : 	    quiet=TRUE;
; 1126 : 	  }
; 1127 : 	  else {
; 1128 : 		  int l=strlen(fname);

  00089	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008c	8d 64 24 00	 npad	 4
$LL86@new_bp:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	3a cb		 cmp	 cl, bl
  00095	75 f9		 jne	 SHORT $LL86@new_bp
  00097	2b c2		 sub	 eax, edx

; 1129 : 		  if(l>4 && (
; 1130 : 		    0==strcmp(".wam",fname+l-4) ||
; 1131 : 		    (0==strcmp(".pro",fname+l-4) && QLEVEL()<3) ||
; 1132 : 		    0==strcmp(".txt",fname+l-4)
; 1133 : 		    )
; 1134 : 		  )

  00099	83 f8 04	 cmp	 eax, 4
  0009c	0f 8e b8 00 00
	00		 jle	 $LN100@new_bp
  000a2	8d 74 38 fc	 lea	 esi, DWORD PTR [eax+edi-4]
  000a6	8b ce		 mov	 ecx, esi
  000a8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04CIICLFFP@?4wam?$AA@
  000ad	8d 49 00	 npad	 3
$LL87@new_bp:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN88@new_bp
  000b6	3a d3		 cmp	 dl, bl
  000b8	74 12		 je	 SHORT $LN89@new_bp
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN88@new_bp
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	3a d3		 cmp	 dl, bl
  000ca	75 e4		 jne	 SHORT $LL87@new_bp
$LN89@new_bp:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN90@new_bp
$LN88@new_bp:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN90@new_bp:
  000d5	3b c3		 cmp	 eax, ebx
  000d7	74 70		 je	 SHORT $LN36@new_bp
  000d9	8b ce		 mov	 ecx, esi
  000db	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04JJADPCEN@?4pro?$AA@
$LL91@new_bp:
  000e0	8a 10		 mov	 dl, BYTE PTR [eax]
  000e2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000e4	75 1a		 jne	 SHORT $LN92@new_bp
  000e6	3a d3		 cmp	 dl, bl
  000e8	74 12		 je	 SHORT $LN93@new_bp
  000ea	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000ed	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000f0	75 0e		 jne	 SHORT $LN92@new_bp
  000f2	83 c0 02	 add	 eax, 2
  000f5	83 c1 02	 add	 ecx, 2
  000f8	3a d3		 cmp	 dl, bl
  000fa	75 e4		 jne	 SHORT $LL91@new_bp
$LN93@new_bp:
  000fc	33 c0		 xor	 eax, eax
  000fe	eb 05		 jmp	 SHORT $LN94@new_bp
$LN92@new_bp:
  00100	1b c0		 sbb	 eax, eax
  00102	83 d8 ff	 sbb	 eax, -1
$LN94@new_bp:
  00105	3b c3		 cmp	 eax, ebx
  00107	75 0d		 jne	 SHORT $LN35@new_bp
  00109	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  0010e	83 e0 fc	 and	 eax, -4			; fffffffcH
  00111	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00114	7c 33		 jl	 SHORT $LN36@new_bp
$LN35@new_bp:
  00116	8b ce		 mov	 ecx, esi
  00118	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04LCMACLFG@?4txt?$AA@
  0011d	8d 49 00	 npad	 3
$LL95@new_bp:
  00120	8a 10		 mov	 dl, BYTE PTR [eax]
  00122	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00124	75 1a		 jne	 SHORT $LN96@new_bp
  00126	3a d3		 cmp	 dl, bl
  00128	74 12		 je	 SHORT $LN97@new_bp
  0012a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0012d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00130	75 0e		 jne	 SHORT $LN96@new_bp
  00132	83 c0 02	 add	 eax, 2
  00135	83 c1 02	 add	 ecx, 2
  00138	3a d3		 cmp	 dl, bl
  0013a	75 e4		 jne	 SHORT $LL95@new_bp
$LN97@new_bp:
  0013c	33 c0		 xor	 eax, eax
  0013e	eb 05		 jmp	 SHORT $LN98@new_bp
$LN96@new_bp:
  00140	1b c0		 sbb	 eax, eax
  00142	83 d8 ff	 sbb	 eax, -1
$LN98@new_bp:
  00145	3b c3		 cmp	 eax, ebx
  00147	75 11		 jne	 SHORT $LN100@new_bp
$LN36@new_bp:

; 1135 : 		  quiet=TRUE;

  00149	bd 01 00 00 00	 mov	 ebp, 1

; 1136 : 	  }
; 1137 :   }
; 1138 : 
; 1139 :   if(quiet) max.QUIET=INPUT_INT(5); /* toplevel resets to 2 */

  0014e	c7 05 24 00 00
	00 15 00 00 00	 mov	 DWORD PTR _max+36, 21	; 00000015H
  00158	eb 2a		 jmp	 SHORT $LN99@new_bp
$LN100@new_bp:

; 1140 :   else quietmes("%s\n",startup_mes());

  0015a	e8 00 00 00 00	 call	 _startup_mes
  0015f	8b 0d 24 00 00
	00		 mov	 ecx, DWORD PTR _max+36
  00165	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00168	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0016b	7d 17		 jge	 SHORT $LN99@new_bp
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00173	e8 00 00 00 00	 call	 ___iob_func
  00178	83 c0 40	 add	 eax, 64			; 00000040H
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _fprintf
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN99@new_bp:

; 1141 : 
; 1142 :   g.timestamp=SYSTIME;

  00184	88 1d 70 01 00
	00		 mov	 BYTE PTR _g+368, bl

; 1143 : 
; 1144 :   configure_bb();

  0018a	39 1d 10 00 00
	00		 cmp	 DWORD PTR _max+16, ebx
  00190	75 20		 jne	 SHORT $LN55@new_bp
  00192	c7 05 10 00 00
	00 00 10 00 00	 mov	 DWORD PTR _max+16, 4096	; 00001000H
  0019c	c7 05 fc 00 00
	00 09 00 00 00	 mov	 DWORD PTR _g+252, 9
  001a6	c7 05 00 01 00
	00 05 00 00 00	 mov	 DWORD PTR _g+256, 5
  001b0	eb 14		 jmp	 SHORT $LN54@new_bp
$LN55@new_bp:
  001b2	c7 05 fc 00 00
	00 05 00 00 00	 mov	 DWORD PTR _g+252, 5
  001bc	c7 05 00 01 00
	00 01 00 00 00	 mov	 DWORD PTR _g+256, 1
$LN54@new_bp:

; 1145 : 
; 1146 :   if(!init_common_mem(wam)) return NULL;

  001c6	68 00 00 00 00	 push	 OFFSET _root_wam
  001cb	e8 00 00 00 00	 call	 _init_common_mem
  001d0	83 c4 04	 add	 esp, 4
  001d3	85 c0		 test	 eax, eax
  001d5	75 07		 jne	 SHORT $LN32@new_bp
$LN105@new_bp:
  001d7	5f		 pop	 edi
  001d8	5e		 pop	 esi
  001d9	5d		 pop	 ebp
  001da	33 c0		 xor	 eax, eax
  001dc	5b		 pop	 ebx

; 1248 : }

  001dd	c3		 ret	 0
$LN32@new_bp:

; 1147 : 
; 1148 :   if(QLEVEL()<2) opt_help();

  001de	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  001e3	8b d0		 mov	 edx, eax
  001e5	83 e2 fc	 and	 edx, -4			; fffffffcH
  001e8	83 fa 08	 cmp	 edx, 8
  001eb	7d 0a		 jge	 SHORT $LN31@new_bp
  001ed	e8 00 00 00 00	 call	 _opt_help
  001f2	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
$LN31@new_bp:

; 1149 :   if(QLEVEL()<1) state_info();

  001f7	83 e0 fc	 and	 eax, -4			; fffffffcH
  001fa	83 f8 04	 cmp	 eax, 4
  001fd	7d 27		 jge	 SHORT $LN101@new_bp
  001ff	68 ff 00 00 00	 push	 255			; 000000ffH
  00204	6a 08		 push	 8
  00206	68 ff 07 00 00	 push	 2047			; 000007ffH
  0020b	68 00 01 00 00	 push	 256			; 00000100H
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MMANGPFP@MAXARITY?3?$CFd?5MAXREG?3?$CFd?5TEMPARGS?3?$CF@
  00215	e8 00 00 00 00	 call	 ___iob_func
  0021a	83 c0 40	 add	 eax, 64			; 00000040H
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _fprintf
  00223	83 c4 18	 add	 esp, 24			; 00000018H
$LN101@new_bp:

; 1150 : 
; 1151 : #ifdef CPARSER
; 1152 :   inittokenizer(); /* added by kdb */
; 1153 : #endif
; 1154 : 
; 1155 :   make_constants(argc,argv); /* after h&sym table */

  00226	8b 44 24 18	 mov	 eax, DWORD PTR _argv$[esp+12]
  0022a	8b 4c 24 14	 mov	 ecx, DWORD PTR _argc$[esp+12]
  0022e	50		 push	 eax
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 _make_constants
  00235	83 c4 08	 add	 esp, 8

; 1156 : 
; 1157 :   g.timestamp=LOADTIME;

  00238	c6 05 70 01 00
	00 01		 mov	 BYTE PTR _g+368, 1

; 1158 : 
; 1159 :   if(!quiet) {

  0023f	3b eb		 cmp	 ebp, ebx
  00241	75 30		 jne	 SHORT $LN102@new_bp

; 1160 :     char *where=(NULL==fname)? "internal code array":fname;

  00243	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@HOEOJMND@internal?5code?5array?$AA@
  00248	3b fb		 cmp	 edi, ebx
  0024a	74 02		 je	 SHORT $LN44@new_bp
  0024c	8b c7		 mov	 eax, edi
$LN44@new_bp:

; 1161 :     quietmes("Start loading system code from <%s>.\n",where);

  0024e	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR _max+36
  00254	83 e2 fc	 and	 edx, -4			; fffffffcH
  00257	83 fa 14	 cmp	 edx, 20			; 00000014H
  0025a	7d 17		 jge	 SHORT $LN102@new_bp
  0025c	50		 push	 eax
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@POIOINEI@Start?5loading?5system?5code?5from?5?$DM@
  00262	e8 00 00 00 00	 call	 ___iob_func
  00267	83 c0 40	 add	 eax, 64			; 00000040H
  0026a	50		 push	 eax
  0026b	e8 00 00 00 00	 call	 _fprintf
  00270	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN102@new_bp:

; 1162 :   }
; 1163 : 
; 1164 :   if(!load_kernel(fname,wam)) {

  00273	68 00 00 00 00	 push	 OFFSET _root_wam
  00278	57		 push	 edi
  00279	e8 00 00 00 00	 call	 _load_kernel
  0027e	83 c4 08	 add	 esp, 8
  00281	85 c0		 test	 eax, eax

; 1165 :     return NULL;

  00283	0f 84 4e ff ff
	ff		 je	 $LN105@new_bp

; 1166 :   }
; 1167 : 
; 1168 :   if(!quiet) quietmes("%s\n","Finished loading system code.");

  00289	3b eb		 cmp	 ebp, ebx
  0028b	75 28		 jne	 SHORT $LN63@new_bp
  0028d	a1 24 00 00 00	 mov	 eax, DWORD PTR _max+36
  00292	83 e0 fc	 and	 eax, -4			; fffffffcH
  00295	83 f8 14	 cmp	 eax, 20			; 00000014H
  00298	7d 1b		 jge	 SHORT $LN63@new_bp
  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@PBJIPKBJ@Finished?5loading?5system?5code?4?$AA@
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  002a4	e8 00 00 00 00	 call	 ___iob_func
  002a9	83 c0 40	 add	 eax, 64			; 00000040H
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 _fprintf
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN63@new_bp:

; 1169 : 
; 1170 :   init_const_instr();

  002b5	e8 00 00 00 00	 call	 _init_const_instr

; 1171 : 
; 1172 :   /* FOR A ROOT ENGINE DO ONLY THIS */
; 1173 : 
; 1174 : 
; 1175 : #if 1
; 1176 :   if(!init_engine_mem(wam,max.HEAP,max.CHOICE,max.TRAIL,ROOT_ENGINE,wam))

  002ba	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _max+8
  002c0	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _max+4
  002c6	a1 00 00 00 00	 mov	 eax, DWORD PTR _max
  002cb	68 00 00 00 00	 push	 OFFSET _root_wam
  002d0	53		 push	 ebx
  002d1	51		 push	 ecx
  002d2	52		 push	 edx
  002d3	50		 push	 eax
  002d4	68 00 00 00 00	 push	 OFFSET _root_wam
  002d9	e8 00 00 00 00	 call	 _init_engine_mem
  002de	83 c4 18	 add	 esp, 24			; 00000018H
  002e1	85 c0		 test	 eax, eax

; 1177 :     return NULL;

  002e3	0f 84 ee fe ff
	ff		 je	 $LN105@new_bp

; 1178 : #else
; 1179 :   if(!init_engine_mem(wam,K2Ws(64),K2Ws(8),K2Ws(8),ROOT_ENGINE,wam))
; 1180 :     return NULL;
; 1181 : #endif
; 1182 : 
; 1183 : /* the bboard is usually at a higher address in this case than the heap */
; 1184 : 
; 1185 : if(OUTPUT_INT(g.bbhi)) {

  002e9	f7 05 00 01 00
	00 fc ff ff ff	 test	 DWORD PTR _g+256, -4	; fffffffcH
  002f3	74 15		 je	 SHORT $LN24@new_bp

; 1186 :   if(!make_bboard(wam)) return NULL;

  002f5	68 00 00 00 00	 push	 OFFSET _root_wam
  002fa	e8 00 00 00 00	 call	 _make_bboard
  002ff	83 c4 04	 add	 esp, 4
  00302	85 c0		 test	 eax, eax
  00304	0f 84 cd fe ff
	ff		 je	 $LN105@new_bp
$LN24@new_bp:

; 1187 : }
; 1188 : 
; 1189 :   VSHARE("code",g.shared[InstrStk].base);

  0030a	0f b6 0d 70 01
	00 00		 movzx	 ecx, BYTE PTR _g+368
  00311	51		 push	 ecx
  00312	68 85 01 00 00	 push	 OFFSET _g+389
  00317	53		 push	 ebx
  00318	68 00 00 00 00	 push	 OFFSET ??_C@_04NDFOBODE@code?$AA@
  0031d	e8 00 00 00 00	 call	 _new_func
  00322	8b 15 c4 00 00
	00		 mov	 edx, DWORD PTR _g+196
  00328	83 c4 08	 add	 esp, 8
  0032b	50		 push	 eax
  0032c	52		 push	 edx
  0032d	e8 00 00 00 00	 call	 _hdef
  00332	83 c4 10	 add	 esp, 16			; 00000010H
  00335	85 c0		 test	 eax, eax
  00337	75 0a		 jne	 SHORT $LN23@new_bp
  00339	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0033e	e8 00 00 00 00	 call	 _fatal_error
$LN23@new_bp:

; 1190 :   VSHARE("code_oldtop",g.shared[InstrStk].oldtop);

  00343	b9 80 01 00 00	 mov	 ecx, OFFSET _g+384
  00348	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@LMKHIEJN@code_oldtop?$AA@
  0034d	e8 00 00 00 00	 call	 _hdef_ptr
  00352	85 c0		 test	 eax, eax
  00354	75 0a		 jne	 SHORT $LN22@new_bp
  00356	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0035b	e8 00 00 00 00	 call	 _fatal_error
$LN22@new_bp:

; 1191 :   VSHARE("code_top",g.shared[InstrStk].top);

  00360	b9 7c 01 00 00	 mov	 ecx, OFFSET _g+380
  00365	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08GALJIIAC@code_top?$AA@
  0036a	e8 00 00 00 00	 call	 _hdef_ptr
  0036f	85 c0		 test	 eax, eax
  00371	75 0a		 jne	 SHORT $LN21@new_bp
  00373	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00378	e8 00 00 00 00	 call	 _fatal_error
$LN21@new_bp:

; 1192 :   VSHARE("code_margin",g.shared[InstrStk].margin);

  0037d	b9 88 01 00 00	 mov	 ecx, OFFSET _g+392
  00382	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@OKGGFPFE@code_margin?$AA@
  00387	e8 00 00 00 00	 call	 _hdef_ptr
  0038c	85 c0		 test	 eax, eax
  0038e	75 0a		 jne	 SHORT $LN20@new_bp
  00390	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00395	e8 00 00 00 00	 call	 _fatal_error
$LN20@new_bp:

; 1193 : 
; 1194 :   VSHARE("bboard",g.shared[BBoardStk].base);

  0039a	b9 a8 01 00 00	 mov	 ecx, OFFSET _g+424
  0039f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06PFJKLBHL@bboard?$AA@
  003a4	e8 00 00 00 00	 call	 _hdef_ptr
  003a9	85 c0		 test	 eax, eax
  003ab	75 0a		 jne	 SHORT $LN19@new_bp
  003ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003b2	e8 00 00 00 00	 call	 _fatal_error
$LN19@new_bp:

; 1195 :   VSHARE("bboard_top",g.shared[BBoardStk].top);

  003b7	b9 a0 01 00 00	 mov	 ecx, OFFSET _g+416
  003bc	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@MHBENID@bboard_top?$AA@
  003c1	e8 00 00 00 00	 call	 _hdef_ptr
  003c6	85 c0		 test	 eax, eax
  003c8	75 0a		 jne	 SHORT $LN18@new_bp
  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003cf	e8 00 00 00 00	 call	 _fatal_error
$LN18@new_bp:

; 1196 :   VSHARE("bboard_margin",g.shared[BBoardStk].margin);

  003d4	b9 ac 01 00 00	 mov	 ecx, OFFSET _g+428
  003d9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0O@CJKDEHAG@bboard_margin?$AA@
  003de	e8 00 00 00 00	 call	 _hdef_ptr
  003e3	85 c0		 test	 eax, eax
  003e5	75 0a		 jne	 SHORT $LN17@new_bp
  003e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  003ec	e8 00 00 00 00	 call	 _fatal_error
$LN17@new_bp:

; 1197 : 
; 1198 :   VSHARE("heap_base",wam[HeapStk].base);

  003f1	b9 10 00 00 00	 mov	 ecx, OFFSET _root_wam+16
  003f6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09OLBFCAGK@heap_base?$AA@
  003fb	e8 00 00 00 00	 call	 _hdef_ptr
  00400	85 c0		 test	 eax, eax
  00402	75 0a		 jne	 SHORT $LN16@new_bp
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00409	e8 00 00 00 00	 call	 _fatal_error
$LN16@new_bp:

; 1199 :   VSHARE("heap_margin",wam[HeapStk].margin);

  0040e	b9 14 00 00 00	 mov	 ecx, OFFSET _root_wam+20
  00413	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@HJCFGPKE@heap_margin?$AA@
  00418	e8 00 00 00 00	 call	 _hdef_ptr
  0041d	85 c0		 test	 eax, eax
  0041f	75 0a		 jne	 SHORT $LN15@new_bp
  00421	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00426	e8 00 00 00 00	 call	 _fatal_error
$LN15@new_bp:

; 1200 :   VSHARE("heap",*HEAPSTART()); /* use directly val(bp_state,heap,X) to get this */

  0042b	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _root_wam+16
  00431	81 c1 1c 20 00
	00		 add	 ecx, 8220		; 0000201cH
  00437	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04PKENOLLO@heap?$AA@
  0043c	e8 00 00 00 00	 call	 _hdef_ptr
  00441	85 c0		 test	 eax, eax
  00443	75 0a		 jne	 SHORT $LN14@new_bp
  00445	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0044a	e8 00 00 00 00	 call	 _fatal_error
$LN14@new_bp:

; 1201 :   VSHARE("regs",*LOCATEREGS()); /* addr of regs[0]: val(bp_state,regs,R) */

  0044f	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _root_wam+16
  00455	83 c1 20	 add	 ecx, 32			; 00000020H
  00458	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04PPLNELOM@regs?$AA@
  0045d	e8 00 00 00 00	 call	 _hdef_ptr
  00462	85 c0		 test	 eax, eax
  00464	75 0a		 jne	 SHORT $LN13@new_bp
  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0046b	e8 00 00 00 00	 call	 _fatal_error
$LN13@new_bp:

; 1202 :   VSHARE("dcgs",*DCGSTART());

  00470	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR _root_wam+16
  00476	81 c1 20 1c 00
	00		 add	 ecx, 7200		; 00001c20H
  0047c	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04DFHGHGBC@dcgs?$AA@
  00481	e8 00 00 00 00	 call	 _hdef_ptr
  00486	85 c0		 test	 eax, eax
  00488	75 0a		 jne	 SHORT $LN12@new_bp
  0048a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0048f	e8 00 00 00 00	 call	 _fatal_error
$LN12@new_bp:

; 1203 :   VSHARE("trail",wam[TrailStk].base);

  00494	b9 34 00 00 00	 mov	 ecx, OFFSET _root_wam+52
  00499	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05FAEIOGEG@trail?$AA@
  0049e	e8 00 00 00 00	 call	 _hdef_ptr
  004a3	85 c0		 test	 eax, eax
  004a5	75 0a		 jne	 SHORT $LN11@new_bp
  004a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  004ac	e8 00 00 00 00	 call	 _fatal_error
$LN11@new_bp:

; 1204 :   VSHARE("trail_margin",wam[TrailStk].margin);

  004b1	b9 38 00 00 00	 mov	 ecx, OFFSET _root_wam+56
  004b6	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@HIBMHONF@trail_margin?$AA@
  004bb	e8 00 00 00 00	 call	 _hdef_ptr
  004c0	85 c0		 test	 eax, eax
  004c2	75 0a		 jne	 SHORT $LN10@new_bp
  004c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  004c9	e8 00 00 00 00	 call	 _fatal_error
$LN10@new_bp:

; 1205 :   VSHARE("stack",wam[ChoiceStk].base);

  004ce	b9 58 00 00 00	 mov	 ecx, OFFSET _root_wam+88
  004d3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_05IANLDAEP@stack?$AA@
  004d8	e8 00 00 00 00	 call	 _hdef_ptr
  004dd	85 c0		 test	 eax, eax
  004df	75 0a		 jne	 SHORT $LN9@new_bp
  004e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  004e6	e8 00 00 00 00	 call	 _fatal_error
$LN9@new_bp:

; 1206 :   VSHARE("stack_margin",wam[ChoiceStk].margin);

  004eb	b9 5c 00 00 00	 mov	 ecx, OFFSET _root_wam+92
  004f0	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0N@JJBBCAGN@stack_margin?$AA@
  004f5	e8 00 00 00 00	 call	 _hdef_ptr
  004fa	85 c0		 test	 eax, eax
  004fc	75 0a		 jne	 SHORT $LN8@new_bp
  004fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00503	e8 00 00 00 00	 call	 _fatal_error
$LN8@new_bp:

; 1207 : 
; 1208 :   VSHARE("mes",wam[MesStk].base);

  00508	b9 7c 00 00 00	 mov	 ecx, OFFSET _root_wam+124
  0050d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03FNPJCMMD@mes?$AA@
  00512	e8 00 00 00 00	 call	 _hdef_ptr
  00517	85 c0		 test	 eax, eax
  00519	75 0a		 jne	 SHORT $LN7@new_bp
  0051b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00520	e8 00 00 00 00	 call	 _fatal_error
$LN7@new_bp:

; 1209 :   VSHARE("mes_margin",wam[MesStk].margin);

  00525	b9 80 00 00 00	 mov	 ecx, OFFSET _root_wam+128
  0052a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@MNIMHPCL@mes_margin?$AA@
  0052f	e8 00 00 00 00	 call	 _hdef_ptr
  00534	85 c0		 test	 eax, eax
  00536	75 0a		 jne	 SHORT $LN6@new_bp
  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0053d	e8 00 00 00 00	 call	 _fatal_error
$LN6@new_bp:

; 1210 : 
; 1211 :   VSHARE("err_id",g.err.id);

  00542	b9 5c 01 00 00	 mov	 ecx, OFFSET _g+348
  00547	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06KLBMBNFO@err_id?$AA@
  0054c	e8 00 00 00 00	 call	 _hdef_ptr
  00551	85 c0		 test	 eax, eax
  00553	75 0a		 jne	 SHORT $LN5@new_bp
  00555	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  0055a	e8 00 00 00 00	 call	 _fatal_error
$LN5@new_bp:

; 1212 :   VSHARE("err_mes",g.err.mes);

  0055f	b9 60 01 00 00	 mov	 ecx, OFFSET _g+352
  00564	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07GMKLHLL@err_mes?$AA@
  00569	e8 00 00 00 00	 call	 _hdef_ptr
  0056e	85 c0		 test	 eax, eax
  00570	75 0a		 jne	 SHORT $LN4@new_bp
  00572	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00577	e8 00 00 00 00	 call	 _fatal_error
$LN4@new_bp:

; 1213 :   VSHARE("err_arg1",g.err.arg1);

  0057c	b9 64 01 00 00	 mov	 ecx, OFFSET _g+356
  00581	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08IJPJCOIK@err_arg1?$AA@
  00586	e8 00 00 00 00	 call	 _hdef_ptr
  0058b	85 c0		 test	 eax, eax
  0058d	75 0a		 jne	 SHORT $LN3@new_bp
  0058f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  00594	e8 00 00 00 00	 call	 _fatal_error
$LN3@new_bp:

; 1214 :   VSHARE("err_arg2",g.err.arg2);

  00599	b9 68 01 00 00	 mov	 ecx, OFFSET _g+360
  0059e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08KCNEHNEJ@err_arg2?$AA@
  005a3	e8 00 00 00 00	 call	 _hdef_ptr
  005a8	85 c0		 test	 eax, eax
  005aa	75 0a		 jne	 SHORT $LN2@new_bp
  005ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  005b1	e8 00 00 00 00	 call	 _fatal_error
$LN2@new_bp:

; 1215 :   VSHARE("err_wam",g.err.wam);

  005b6	b9 6c 01 00 00	 mov	 ecx, OFFSET _g+364
  005bb	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07OKCGJHED@err_wam?$AA@
  005c0	e8 00 00 00 00	 call	 _hdef_ptr
  005c5	85 c0		 test	 eax, eax
  005c7	75 0a		 jne	 SHORT $LN1@new_bp
  005c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OIAMEMAI@sharing?5C?9variable?$AA@
  005ce	e8 00 00 00 00	 call	 _fatal_error
$LN1@new_bp:

; 1216 : 
; 1217 :   init_random(0);

  005d3	53		 push	 ebx
  005d4	e8 00 00 00 00	 call	 __time64
  005d9	2d 6f f0 05 2f	 sub	 eax, 788918383		; 2f05f06fH
  005de	50		 push	 eax
  005df	e8 00 00 00 00	 call	 _srand
  005e4	e8 00 00 00 00	 call	 _rand

; 1218 : 
; 1219 :  g.timestamp=RUNTIME;
; 1220 : 
; 1221 :   CLEAR_BP_ERROR();

  005e9	a1 38 00 00 00	 mov	 eax, DWORD PTR _g+56

; 1222 : 
; 1223 : /*
; 1224 :   #include <sys/resource.h>
; 1225 :   { struct rlimit rlp;
; 1226 : 
; 1227 :     getrlimit(RLIMIT_CORE, &rlp);
; 1228 :     rlp.rlim_cur=(rlim_t)0;
; 1229 :     setrlimit(RLIMIT_CORE,&rlp);
; 1230 : 
; 1231 :     getrlimit(RLIMIT_DATA, &rlp);
; 1232 :     rlp.rlim_cur=(rlim_t)max.MAX_CORE;
; 1233 :     setrlimit(RLIMIT_DATA,&rlp);
; 1234 : 
; 1235 :     getrlimit(RLIMIT_VMEM, &rlp);
; 1236 :     rlp.rlim_cur=(rlim_t)max.MAX_CORE;
; 1237 :     setrlimit(RLIMIT_VMEM,&rlp);
; 1238 :   }
; 1239 : */
; 1240 : 
; 1241 :   init_orig_wam(wam);

  005ee	68 00 00 00 00	 push	 OFFSET _root_wam
  005f3	c6 05 70 01 00
	00 02		 mov	 BYTE PTR _g+368, 2
  005fa	c7 05 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR _g+348, 1
  00604	a3 60 01 00 00	 mov	 DWORD PTR _g+352, eax
  00609	a3 64 01 00 00	 mov	 DWORD PTR _g+356, eax
  0060e	a3 68 01 00 00	 mov	 DWORD PTR _g+360, eax
  00613	89 1d 6c 01 00
	00		 mov	 DWORD PTR _g+364, ebx
  00619	e8 00 00 00 00	 call	 _init_orig_wam
  0061e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1242 : 
; 1243 : #if ERROR_HANDLER
; 1244 :   install_interrupt_handler();

  00621	e8 00 00 00 00	 call	 _install_interrupt_handler
  00626	5f		 pop	 edi
  00627	5e		 pop	 esi
  00628	5d		 pop	 ebp

; 1245 : #endif
; 1246 : 
; 1247 :   return wam;

  00629	b8 00 00 00 00	 mov	 eax, OFFSET _root_wam
  0062e	5b		 pop	 ebx

; 1248 : }

  0062f	c3		 ret	 0
$LN104@new_bp:
_new_bp	ENDP
_TEXT	ENDS
PUBLIC	_init_bp0
EXTRN	_interp:PROC
; Function compile flags: /Ogtpy
;	COMDAT _init_bp0
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_bp_stdin$ = 16						; size = 4
_bp_stdout$ = 20					; size = 4
_init_bp0 PROC						; COMDAT

; 1252 :   int i;
; 1253 :   stack wam=new_bp(argc,argv,bp_stdin,bp_stdout);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _argv$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _argc$[esp-4]
  00008	8b 54 24 10	 mov	 edx, DWORD PTR _bp_stdout$[esp-4]
  0000c	56		 push	 esi
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR _bp_stdin$[esp+8]
  00013	e8 00 00 00 00	 call	 _new_bp
  00018	8b f0		 mov	 esi, eax
  0001a	83 c4 08	 add	 esp, 8

; 1254 :   if(NULL==wam) return NULL;

  0001d	85 f6		 test	 esi, esi
  0001f	75 02		 jne	 SHORT $LN2@init_bp0
  00021	5e		 pop	 esi

; 1262 : }

  00022	c3		 ret	 0
$LN2@init_bp0:

; 1255 : #if TRACE>0
; 1256 :   fprintf(STD_err,"entering interp(wam)\n");
; 1257 : #endif
; 1258 :   i=interp(wam,g.prolog_load);

  00023	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _g+4
  00029	52		 push	 edx
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _interp
  00030	83 c4 08	 add	 esp, 8

; 1259 :   if(ENGINE_OK==i) /* run only if init is ok */

  00033	85 c0		 test	 eax, eax
  00035	75 0f		 jne	 SHORT $LN1@init_bp0

; 1260 :     interp(wam,g.prolog_init);

  00037	a1 08 00 00 00	 mov	 eax, DWORD PTR _g+8
  0003c	50		 push	 eax
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 _interp
  00043	83 c4 08	 add	 esp, 8
$LN1@init_bp0:

; 1261 :   return wam;

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 1262 : }

  00049	c3		 ret	 0
_init_bp0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@PAIPKIIH@?$CK?$CK?$CK?5fatal?5error?5in?5query?3?5?$CFs?0?5co@ ; `string'
PUBLIC	??_C@_0BN@MMFKAGK@default?5toplevel?10?5or?5main?10?$AA@ ; `string'
PUBLIC	_run_bp0
;	COMDAT ??_C@_0CH@PAIPKIIH@?$CK?$CK?$CK?5fatal?5error?5in?5query?3?5?$CFs?0?5co@
CONST	SEGMENT
??_C@_0CH@PAIPKIIH@?$CK?$CK?$CK?5fatal?5error?5in?5query?3?5?$CFs?0?5co@ DB '*'
	DB	'** fatal error in query: %s, code %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMFKAGK@default?5toplevel?10?5or?5main?10?$AA@
CONST	SEGMENT
??_C@_0BN@MMFKAGK@default?5toplevel?10?5or?5main?10?$AA@ DB 'default topl'
	DB	'evel/0 or main/0', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _run_bp0
_TEXT	SEGMENT
_wam$ = 8						; size = 4
_query$ = 12						; size = 4
_retcode$ = 16						; size = 4
_run_bp0 PROC						; COMDAT

; 1265 : 
; 1266 :   int i=GET_ENGINE_ERROR();

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 41 7c	 mov	 eax, DWORD PTR [ecx+124]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 1267 : 
; 1268 :   g.answer=g.empty;

  0000a	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR _g+56
  00010	c1 f8 02	 sar	 eax, 2
  00013	56		 push	 esi

; 1269 :   start_profiler(wam);
; 1270 :   if(ENGINE_OK==i) { /* run only if init_bp is ok */

  00014	8b 74 24 0c	 mov	 esi, DWORD PTR _query$[esp]
  00018	89 15 e8 00 00
	00		 mov	 DWORD PTR _g+232, edx
  0001e	85 c0		 test	 eax, eax
  00020	75 1c		 jne	 SHORT $LN6@run_bp0

; 1271 :     if(NULL!=query) {

  00022	85 f6		 test	 esi, esi
  00024	74 08		 je	 SHORT $LN5@run_bp0

; 1272 :     /*
; 1273 :       INPUT_STRING(query) can slowly result in a full symbol table
; 1274 :       do periodically ask_bp(restart,_) to clean it up
; 1275 :       note that this results in loosing content of the dynamic db
; 1276 :       among other unpredictables - should be fixed by avoiding
; 1277 :       to internalize "query" each time
; 1278 :      */
; 1279 :       g.query=PTR2INT(query); /*was INPUT_STRING(query);*/

  00026	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00029	a3 e4 00 00 00	 mov	 DWORD PTR _g+228, eax
$LN5@run_bp0:

; 1280 :     }
; 1281 :     i=interp(wam,g.prolog_run);

  0002e	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR _g+12
  00034	52		 push	 edx
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _interp
  0003b	83 c4 08	 add	 esp, 8
$LN6@run_bp0:

; 1282 :   }
; 1283 :   if(ENGINE_FORCE_HALT==i)

  0003e	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  00041	75 02		 jne	 SHORT $LN4@run_bp0

; 1284 :     i=ENGINE_OK; /* act like a normal halt */

  00043	33 c0		 xor	 eax, eax
$LN4@run_bp0:

; 1285 :   end_profiler(wam);
; 1286 : 
; 1287 :   *retcode=i;

  00045	8b 4c 24 10	 mov	 ecx, DWORD PTR _retcode$[esp]
  00049	89 01		 mov	 DWORD PTR [ecx], eax

; 1288 : 
; 1289 :   if(ENGINE_OK!=i) {

  0004b	85 c0		 test	 eax, eax
  0004d	74 25		 je	 SHORT $LN3@run_bp0

; 1290 :     if(NULL==query) query="default toplevel/0 or main/0";

  0004f	85 f6		 test	 esi, esi
  00051	75 05		 jne	 SHORT $LN2@run_bp0
  00053	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0BN@MMFKAGK@default?5toplevel?10?5or?5main?10?$AA@
$LN2@run_bp0:

; 1291 :     fprintf(STD_err,
; 1292 :       "*** fatal error in query: %s, code %d\n",query,i);

  00058	50		 push	 eax
  00059	56		 push	 esi
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PAIPKIIH@?$CK?$CK?$CK?5fatal?5error?5in?5query?3?5?$CFs?0?5co@
  0005f	e8 00 00 00 00	 call	 ___iob_func
  00064	83 c0 40	 add	 eax, 64			; 00000040H
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _fprintf
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@run_bp0:

; 1293 :     /* returns NULL on error */
; 1294 :     return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	5e		 pop	 esi

; 1303 : }

  00073	c3		 ret	 0
$LN3@run_bp0:

; 1295 :   }
; 1296 : 
; 1297 :   /* return NULL on failure */
; 1298 :   if(g.answer==g.empty)

  00074	a1 e8 00 00 00	 mov	 eax, DWORD PTR _g+232
  00079	3b 05 38 00 00
	00		 cmp	 eax, DWORD PTR _g+56

; 1299 :     return NULL;

  0007f	74 ef		 je	 SHORT $LN13@run_bp0

; 1300 : 
; 1301 :   /* returns first answer if suceeding to find it */
; 1302 :   return INT2PTR(g.answer); /* was NAME(g.answer) */

  00081	48		 dec	 eax
  00082	5e		 pop	 esi

; 1303 : }

  00083	c3		 ret	 0
_run_bp0 ENDP
_TEXT	ENDS
END
