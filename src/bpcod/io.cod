; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\io.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_g_quote DD	01H DUP (?)
_BSS	ENDS
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\io.c
;	COMDAT _qSOUT0
_TEXT	SEGMENT
_qSOUT0	PROC						; COMDAT
; _str$ = eax

; 31   : static void qSOUT0(char *str) {

  00000	56		 push	 esi
  00001	8b f0		 mov	 esi, eax

; 32   :   char c='\0'; 
; 33   :   char *s=str;
; 34   :   /* if(*s!='\'') { */
; 35   :     while((c = *s++)) {

  00003	8a 06		 mov	 al, BYTE PTR [esi]
  00005	57		 push	 edi
  00006	8b ce		 mov	 ecx, esi
  00008	bf 01 00 00 00	 mov	 edi, 1
  0000d	84 c0		 test	 al, al
  0000f	74 10		 je	 SHORT $LN18@qSOUT0
$LL11@qSOUT0:

; 36   :       if(c<'a'||c>'z') break;

  00011	8d 50 9f	 lea	 edx, DWORD PTR [eax-97]
  00014	03 cf		 add	 ecx, edi
  00016	80 fa 19	 cmp	 dl, 25			; 00000019H
  00019	77 08		 ja	 SHORT $LN10@qSOUT0

; 32   :   char c='\0'; 
; 33   :   char *s=str;
; 34   :   /* if(*s!='\'') { */
; 35   :     while((c = *s++)) {

  0001b	8a 01		 mov	 al, BYTE PTR [ecx]
  0001d	84 c0		 test	 al, al
  0001f	75 f0		 jne	 SHORT $LL11@qSOUT0
$LN18@qSOUT0:
  00021	03 cf		 add	 ecx, edi
$LN10@qSOUT0:

; 37   :     }
; 38   :   /*}*/
; 39   :   if(c=='\0' && s!=str+1) {

  00023	84 c0		 test	 al, al
  00025	75 2e		 jne	 SHORT $LN7@qSOUT0
  00027	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0002a	3b c8		 cmp	 ecx, eax
  0002c	74 27		 je	 SHORT $LN7@qSOUT0

; 40   : 	  SOUT0(str);

  0002e	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
$LL6@qSOUT0:
  00033	8a 0e		 mov	 cl, BYTE PTR [esi]
  00035	88 08		 mov	 BYTE PTR [eax], cl
  00037	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	03 c7		 add	 eax, edi
  00040	03 f7		 add	 esi, edi
  00042	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00047	84 d2		 test	 dl, dl
  00049	75 e8		 jne	 SHORT $LL6@qSOUT0
  0004b	2b c7		 sub	 eax, edi
  0004d	5f		 pop	 edi
  0004e	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00053	5e		 pop	 esi

; 46   :   }
; 47   : }

  00054	c3		 ret	 0
$LN7@qSOUT0:

; 41   :   }
; 42   :   else {
; 43   : 	  COUT('\'');

  00055	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  0005a	c6 00 27	 mov	 BYTE PTR [eax], 39	; 00000027H
  0005d	8b 15 50 01 00
	00		 mov	 edx, DWORD PTR _g+336
  00063	03 d7		 add	 edx, edi
  00065	89 15 50 01 00
	00		 mov	 DWORD PTR _g+336, edx

; 44   : 	  qSOUT1(str);

  0006b	8a 06		 mov	 al, BYTE PTR [esi]
  0006d	8b ce		 mov	 ecx, esi
  0006f	88 02		 mov	 BYTE PTR [edx], al
  00071	84 c0		 test	 al, al
  00073	74 28		 je	 SHORT $LN19@qSOUT0
$LL3@qSOUT0:
  00075	01 3d 50 01 00
	00		 add	 DWORD PTR _g+336, edi
  0007b	03 cf		 add	 ecx, edi
  0007d	3c 27		 cmp	 al, 39			; 00000027H
  0007f	75 0e		 jne	 SHORT $LN1@qSOUT0
  00081	8b 15 50 01 00
	00		 mov	 edx, DWORD PTR _g+336
  00087	88 02		 mov	 BYTE PTR [edx], al
  00089	01 3d 50 01 00
	00		 add	 DWORD PTR _g+336, edi
$LN1@qSOUT0:
  0008f	8a 01		 mov	 al, BYTE PTR [ecx]
  00091	8b 15 50 01 00
	00		 mov	 edx, DWORD PTR _g+336
  00097	88 02		 mov	 BYTE PTR [edx], al
  00099	84 c0		 test	 al, al
  0009b	75 d8		 jne	 SHORT $LL3@qSOUT0
$LN19@qSOUT0:

; 45   : 	  COUT('\'');

  0009d	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  000a2	c6 00 27	 mov	 BYTE PTR [eax], 39	; 00000027H
  000a5	01 3d 50 01 00
	00		 add	 DWORD PTR _g+336, edi
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi

; 46   :   }
; 47   : }

  000ad	c3		 ret	 0
_qSOUT0	ENDP
_TEXT	ENDS
PUBLIC	_trim_float
; Function compile flags: /Ogtpy
;	COMDAT _trim_float
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_trim_float PROC					; COMDAT

; 59   :   int l=strlen(buf); 

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _buf$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	56		 push	 esi
  00007	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL8@trim_float:
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 d2		 test	 dl, dl
  00015	75 f9		 jne	 SHORT $LL8@trim_float
  00017	2b c6		 sub	 eax, esi
  00019	5e		 pop	 esi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL4@trim_float:

; 60   :   while('0'==buf[--l]); 

  00020	48		 dec	 eax
  00021	80 3c 08 30	 cmp	 BYTE PTR [eax+ecx], 48	; 00000030H
  00025	74 f9		 je	 SHORT $LL4@trim_float

; 61   :   if(buf[l]=='.')

  00027	80 3c 08 2e	 cmp	 BYTE PTR [eax+ecx], 46	; 0000002eH
  0002b	75 05		 jne	 SHORT $LN2@trim_float

; 62   :     buf[l]='\0';

  0002d	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 65   : }

  00031	c3		 ret	 0
$LN2@trim_float:

; 63   :   else 
; 64   :     buf[l+1]='\0';

  00032	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0

; 65   : }

  00037	c3		 ret	 0
_trim_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_06HPGHLIIM@?$CF?$CD?48Lf?$AA@		; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
PUBLIC	??_C@_0DE@NAPGKGOC@string?5buffer?5?$CI?9i?5option?$CJ?5exceed@ ; `string'
EXTRN	_ints_to_double:PROC
EXTRN	_atomtable:DWORD
EXTRN	_htable:DWORD
EXTRN	_sprintf:PROC
EXTRN	_warnmes:PROC
EXTRN	_max:BYTE
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?ibuf@?1??out@@9@9 DB 040H DUP (?)			; `out'::`2'::ibuf
_BSS	ENDS
;	COMDAT ??_C@_06HPGHLIIM@?$CF?$CD?48Lf?$AA@
CONST	SEGMENT
??_C@_06HPGHLIIM@?$CF?$CD?48Lf?$AA@ DB '%#.8Lf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NAPGKGOC@string?5buffer?5?$CI?9i?5option?$CJ?5exceed@
CONST	SEGMENT
??_C@_0DE@NAPGKGOC@string?5buffer?5?$CI?9i?5option?$CJ?5exceed@ DB 'strin'
	DB	'g buffer (-i option) exceeded or infinite term', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _out
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_out	PROC						; COMDAT

; 114  :   static char ibuf[MAX1];
; 115  :   
; 116  :   FDEREF(xval);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _xval$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d8		 mov	 ebx, eax
  00008	a8 03		 test	 al, 3
  0000a	75 12		 jne	 SHORT $LN52@out
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	a8 03		 test	 al, 3
  00010	75 0c		 jne	 SHORT $LN52@out
$LL53@out:
  00012	3b d8		 cmp	 ebx, eax
  00014	74 08		 je	 SHORT $LN52@out
  00016	8b d8		 mov	 ebx, eax
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	a8 03		 test	 al, 3
  0001c	74 f4		 je	 SHORT $LL53@out
$LN52@out:

; 117  :   if(g.stop-g.sbuf>(bp_long)max.SBUF-MAX1)

  0001e	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  00024	8b 35 1c 00 00
	00		 mov	 esi, DWORD PTR _max+28
  0002a	8b d1		 mov	 edx, ecx
  0002c	2b 15 4c 01 00
	00		 sub	 edx, DWORD PTR _g+332
  00032	83 c6 c0	 add	 esi, -64		; ffffffc0H
  00035	3b d6		 cmp	 edx, esi
  00037	7e 10		 jle	 SHORT $LN51@out

; 118  :     { warnmes("string buffer (-i option) exceeded or infinite term"); return; }

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@NAPGKGOC@string?5buffer?5?$CI?9i?5option?$CJ?5exceed@
  0003e	e8 00 00 00 00	 call	 _warnmes
  00043	83 c4 04	 add	 esp, 4
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  00048	c3		 ret	 0
$LN51@out:

; 119  :   if(VAR(xval))

  00049	8b d0		 mov	 edx, eax
  0004b	83 e2 03	 and	 edx, 3
  0004e	0f 85 bd 01 00
	00		 jne	 $LN50@out

; 120  :     { 
; 121  : /* obsolete
; 122  :       ASSERT2((void*)g.shared[BBoardStk].base<(void*)htable &&
; 123  :               (void*)htable<(void*)wam[HeapStk].base, xval);
; 124  : */
; 125  :       VOUT(HeapStk,COUT('x'))

  00054	8b 54 24 10	 mov	 edx, DWORD PTR _wam$[esp+4]
  00058	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0005b	72 64		 jb	 SHORT $LN49@out
  0005d	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  00060	73 5f		 jae	 SHORT $LN49@out
  00062	c6 01 5f	 mov	 BYTE PTR [ecx], 95	; 0000005fH
  00065	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  0006b	41		 inc	 ecx
  0006c	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  00072	c6 01 78	 mov	 BYTE PTR [ecx], 120	; 00000078H
  00075	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0007b	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  0007e	c1 e8 02	 shr	 eax, 2
  00081	50		 push	 eax
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  00087	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  0008c	e8 00 00 00 00	 call	 _sprintf
  00091	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
  0009e	8b ff		 npad	 2
$LL48@out:
  000a0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000a3	88 10		 mov	 BYTE PTR [eax], dl
  000a5	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  000aa	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000ad	40		 inc	 eax
  000ae	41		 inc	 ecx
  000af	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  000b4	84 d2		 test	 dl, dl
  000b6	75 e8		 jne	 SHORT $LL48@out
  000b8	48		 dec	 eax
  000b9	5e		 pop	 esi
  000ba	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  000bf	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  000c0	c3		 ret	 0
$LN49@out:

; 126  :         BOUT(COUT('b'))

  000c1	3b 05 a8 01 00
	00		 cmp	 eax, DWORD PTR _g+424
  000c7	72 68		 jb	 SHORT $LN45@out
  000c9	3b 05 b0 01 00
	00		 cmp	 eax, DWORD PTR _g+432
  000cf	73 60		 jae	 SHORT $LN45@out
  000d1	c6 01 5f	 mov	 BYTE PTR [ecx], 95	; 0000005fH
  000d4	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  000da	41		 inc	 ecx
  000db	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  000e1	c6 01 62	 mov	 BYTE PTR [ecx], 98	; 00000062H
  000e4	2b 05 a8 01 00
	00		 sub	 eax, DWORD PTR _g+424
  000ea	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  000f0	c1 e8 02	 shr	 eax, 2
  000f3	50		 push	 eax
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  000f9	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  000fe	e8 00 00 00 00	 call	 _sprintf
  00103	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
$LL44@out:
  00110	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00113	88 10		 mov	 BYTE PTR [eax], dl
  00115	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  0011a	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0011d	40		 inc	 eax
  0011e	41		 inc	 ecx
  0011f	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00124	84 d2		 test	 dl, dl
  00126	75 e8		 jne	 SHORT $LL44@out
  00128	48		 dec	 eax
  00129	5e		 pop	 esi
  0012a	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0012f	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  00130	c3		 ret	 0
$LN45@out:

; 127  :            TVOUT(htable,max.DICT*3*sizeof(cell),COUT('h')) 

  00131	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _htable
  00137	3b c6		 cmp	 eax, esi
  00139	72 76		 jb	 SHORT $LN41@out
  0013b	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR _max+20
  00141	8d 14 52	 lea	 edx, DWORD PTR [edx+edx*2]
  00144	c1 e2 04	 shl	 edx, 4
  00147	03 d6		 add	 edx, esi
  00149	3b c2		 cmp	 eax, edx
  0014b	73 64		 jae	 SHORT $LN41@out
  0014d	c6 01 5f	 mov	 BYTE PTR [ecx], 95	; 0000005fH
  00150	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  00156	41		 inc	 ecx
  00157	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  0015d	c6 01 68	 mov	 BYTE PTR [ecx], 104	; 00000068H
  00160	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _htable
  00166	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0016c	c1 e8 02	 shr	 eax, 2
  0016f	50		 push	 eax
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  00175	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  0017a	e8 00 00 00 00	 call	 _sprintf
  0017f	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
  0018c	8d 64 24 00	 npad	 4
$LL40@out:
  00190	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00193	88 10		 mov	 BYTE PTR [eax], dl
  00195	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  0019a	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0019d	40		 inc	 eax
  0019e	41		 inc	 ecx
  0019f	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  001a4	84 d2		 test	 dl, dl
  001a6	75 e8		 jne	 SHORT $LL40@out
  001a8	48		 dec	 eax
  001a9	5e		 pop	 esi
  001aa	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  001af	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  001b0	c3		 ret	 0
$LN41@out:

; 128  :             MVOUT(COUT('m'));

  001b1	c6 01 5f	 mov	 BYTE PTR [ecx], 95	; 0000005fH
  001b4	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  001ba	50		 push	 eax
  001bb	41		 inc	 ecx
  001bc	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  001c7	c6 01 6d	 mov	 BYTE PTR [ecx], 109	; 0000006dH
  001ca	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  001d0	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  001d5	e8 00 00 00 00	 call	 _sprintf
  001da	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  001df	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
  001e7	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL37@out:
  001f0	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001f3	88 10		 mov	 BYTE PTR [eax], dl
  001f5	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  001fa	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  001fd	40		 inc	 eax
  001fe	41		 inc	 ecx
  001ff	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00204	84 d2		 test	 dl, dl
  00206	75 e8		 jne	 SHORT $LL37@out
  00208	48		 dec	 eax
  00209	5e		 pop	 esi
  0020a	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0020f	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  00210	c3		 ret	 0
$LN50@out:
  00211	55		 push	 ebp

; 129  :     }
; 130  :   else
; 131  :     {
; 132  :       if(INTEGER(xval))

  00212	bd 01 00 00 00	 mov	 ebp, 1
  00217	3b d5		 cmp	 edx, ebp
  00219	75 4a		 jne	 SHORT $LN34@out

; 133  :         {IOUT(OUTPUT_INT(xval));}

  0021b	c1 f8 02	 sar	 eax, 2
  0021e	50		 push	 eax
  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  00224	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  00229	e8 00 00 00 00	 call	 _sprintf
  0022e	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00233	83 c4 0c	 add	 esp, 12			; 0000000cH
  00236	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
  0023b	eb 03 8d 49 00	 npad	 5
$LL33@out:
  00240	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00243	88 10		 mov	 BYTE PTR [eax], dl
  00245	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  0024a	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0024d	03 c5		 add	 eax, ebp
  0024f	03 cd		 add	 ecx, ebp
  00251	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00256	84 d2		 test	 dl, dl
  00258	75 e6		 jne	 SHORT $LL33@out
  0025a	2b c5		 sub	 eax, ebp
  0025c	5d		 pop	 ebp
  0025d	5e		 pop	 esi
  0025e	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  00263	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  00264	c3		 ret	 0
$LN34@out:
  00265	57		 push	 edi

; 134  :       else
; 135  :   { 
; 136  :     if(!GETARITY(xval))

  00266	8b f8		 mov	 edi, eax
  00268	c1 ef 18	 shr	 edi, 24			; 00000018H
  0026b	85 ff		 test	 edi, edi
  0026d	75 5a		 jne	 SHORT $LN30@out

; 137  :       {SOUT(NAME(xval));}

  0026f	c1 e8 02	 shr	 eax, 2
  00272	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00277	39 3d 00 00 00
	00		 cmp	 DWORD PTR _g_quote, edi
  0027d	74 12		 je	 SHORT $LN29@out
  0027f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  00285	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00288	5f		 pop	 edi
  00289	5d		 pop	 ebp
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx
  0028c	e9 00 00 00 00	 jmp	 _qSOUT0
$LN29@out:
  00291	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  00297	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0029a	8d 9b 00 00 00
	00		 npad	 6
$LL27@out:
  002a0	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  002a3	88 11		 mov	 BYTE PTR [ecx], dl
  002a5	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  002ab	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002ae	03 cd		 add	 ecx, ebp
  002b0	03 c5		 add	 eax, ebp
  002b2	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  002b8	84 d2		 test	 dl, dl
  002ba	75 e4		 jne	 SHORT $LL27@out
  002bc	5f		 pop	 edi
  002bd	2b cd		 sub	 ecx, ebp
  002bf	5d		 pop	 ebp
  002c0	5e		 pop	 esi
  002c1	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  002c7	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  002c8	c3		 ret	 0
$LN30@out:

; 138  :     /* operators can be handled here easily
; 139  :     else if(g.DIF==xval)
; 140  :       {
; 141  :         out(xref+1,wam),
; 142  :         SOUT(NAME(s));
; 143  :         out(xref+2,wam);
; 144  :       }
; 145  :     */
; 146  :     else if IS_LIST(xval)

  002c9	39 05 24 00 00
	00		 cmp	 DWORD PTR _g+36, eax
  002cf	0f 85 b6 00 00
	00		 jne	 $LN24@out

; 147  :       {
; 148  :         COUT('[');
; 149  :         out((cell)(++xref),wam); 

  002d5	8b 74 24 18	 mov	 esi, DWORD PTR _wam$[esp+12]
  002d9	83 c3 04	 add	 ebx, 4
  002dc	56		 push	 esi
  002dd	c6 01 5b	 mov	 BYTE PTR [ecx], 91	; 0000005bH
  002e0	01 2d 50 01 00
	00		 add	 DWORD PTR _g+336, ebp
  002e6	53		 push	 ebx
  002e7	e8 00 00 00 00	 call	 _out

; 150  :         ++xref;

  002ec	83 c3 04	 add	 ebx, 4
  002ef	83 c4 08	 add	 esp, 8

; 151  :         FDEREF(T2C(xref));

  002f2	f6 c3 03	 test	 bl, 3
  002f5	74 04		 je	 SHORT $LN65@out
  002f7	8b c3		 mov	 eax, ebx
  002f9	eb 12		 jmp	 SHORT $LN66@out
$LN65@out:
  002fb	8b 03		 mov	 eax, DWORD PTR [ebx]
  002fd	a8 03		 test	 al, 3
  002ff	75 0c		 jne	 SHORT $LN66@out
$LL21@out:
  00301	3b d8		 cmp	 ebx, eax
  00303	74 08		 je	 SHORT $LN66@out
  00305	8b d8		 mov	 ebx, eax
  00307	8b 00		 mov	 eax, DWORD PTR [eax]
  00309	a8 03		 test	 al, 3
  0030b	74 f4		 je	 SHORT $LL21@out
$LN66@out:

; 152  :         while(IS_LIST(xval))

  0030d	39 05 24 00 00
	00		 cmp	 DWORD PTR _g+36, eax
  00313	75 41		 jne	 SHORT $LN18@out
$LL19@out:

; 153  :          {
; 154  :            COUT(',');

  00315	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336

; 155  :            out((cell)(++xref),wam);

  0031a	83 c3 04	 add	 ebx, 4
  0031d	56		 push	 esi
  0031e	c6 00 2c	 mov	 BYTE PTR [eax], 44	; 0000002cH
  00321	01 2d 50 01 00
	00		 add	 DWORD PTR _g+336, ebp
  00327	53		 push	 ebx
  00328	e8 00 00 00 00	 call	 _out

; 156  :            ++xref;

  0032d	83 c3 04	 add	 ebx, 4
  00330	83 c4 08	 add	 esp, 8

; 157  :            FDEREF(T2C(xref));

  00333	f6 c3 03	 test	 bl, 3
  00336	74 04		 je	 SHORT $LN67@out
  00338	8b c3		 mov	 eax, ebx
  0033a	eb 12		 jmp	 SHORT $LN14@out
$LN67@out:
  0033c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0033e	a8 03		 test	 al, 3
  00340	75 0c		 jne	 SHORT $LN14@out
$LL15@out:
  00342	3b d8		 cmp	 ebx, eax
  00344	74 08		 je	 SHORT $LN14@out
  00346	8b d8		 mov	 ebx, eax
  00348	8b 00		 mov	 eax, DWORD PTR [eax]
  0034a	a8 03		 test	 al, 3
  0034c	74 f4		 je	 SHORT $LL15@out
$LN14@out:

; 152  :         while(IS_LIST(xval))

  0034e	39 05 24 00 00
	00		 cmp	 DWORD PTR _g+36, eax
  00354	74 bf		 je	 SHORT $LL19@out
$LN18@out:

; 158  :          }
; 159  :         if(g.NIL!=xval)

  00356	39 05 20 00 00
	00		 cmp	 DWORD PTR _g+32, eax
  0035c	74 19		 je	 SHORT $LN13@out

; 160  :           {
; 161  :             COUT('|');

  0035e	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336

; 162  :             out((cell)xref,wam);

  00364	56		 push	 esi
  00365	c6 01 7c	 mov	 BYTE PTR [ecx], 124	; 0000007cH
  00368	01 2d 50 01 00
	00		 add	 DWORD PTR _g+336, ebp
  0036e	53		 push	 ebx
  0036f	e8 00 00 00 00	 call	 _out
  00374	83 c4 08	 add	 esp, 8
$LN13@out:

; 163  :           }
; 164  :         COUT(']');

  00377	8b 15 50 01 00
	00		 mov	 edx, DWORD PTR _g+336
  0037d	5f		 pop	 edi
  0037e	c6 02 5d	 mov	 BYTE PTR [edx], 93	; 0000005dH
  00381	01 2d 50 01 00
	00		 add	 DWORD PTR _g+336, ebp
  00387	5d		 pop	 ebp
  00388	5e		 pop	 esi
  00389	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  0038a	c3		 ret	 0
$LN24@out:

; 165  :       }
; 166  :         else if (BP_FLOAT(xval)) 

  0038b	39 05 94 00 00
	00		 cmp	 DWORD PTR _g+148, eax
  00391	75 64		 jne	 SHORT $LN11@out

; 167  :         {
; 168  :            FLOAT_OUT(ints_to_double(
; 169  :                 (half)(xref[1]),
; 170  :                 (half)(xref[2]),
; 171  :                 (half)(xref[3])));

  00393	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00396	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00399	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0039c	50		 push	 eax
  0039d	51		 push	 ecx
  0039e	52		 push	 edx
  0039f	e8 00 00 00 00	 call	 _ints_to_double
  003a4	dd 5c 24 04	 fstp	 QWORD PTR [esp+4]
  003a8	83 c4 04	 add	 esp, 4
  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_06HPGHLIIM@?$CF?$CD?48Lf?$AA@
  003b0	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  003b5	e8 00 00 00 00	 call	 _sprintf
  003ba	68 00 00 00 00	 push	 OFFSET ?ibuf@?1??out@@9@9
  003bf	e8 00 00 00 00	 call	 _trim_float
  003c4	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  003c9	83 c4 14	 add	 esp, 20			; 00000014H
  003cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?ibuf@?1??out@@9@9
$LL10@out:
  003d1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  003d4	88 10		 mov	 BYTE PTR [eax], dl
  003d6	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  003db	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  003de	03 c5		 add	 eax, ebp
  003e0	03 cd		 add	 ecx, ebp
  003e2	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  003e7	84 d2		 test	 dl, dl
  003e9	75 e6		 jne	 SHORT $LL10@out
  003eb	5f		 pop	 edi
  003ec	2b c5		 sub	 eax, ebp
  003ee	5d		 pop	 ebp
  003ef	5e		 pop	 esi
  003f0	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  003f5	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  003f6	c3		 ret	 0
$LN11@out:

; 172  :         }
; 173  :     else
; 174  :       { register no i;
; 175  :         SOUT(NAME(xval));

  003f7	c1 e8 02	 shr	 eax, 2
  003fa	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  003ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _g_quote, 0
  00406	74 16		 je	 SHORT $LN7@out
  00408	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  0040e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00411	e8 00 00 00 00	 call	 _qSOUT0
  00416	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  0041c	eb 34		 jmp	 SHORT $LN6@out
$LN7@out:
  0041e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable
  00424	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]
  00427	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL5@out:
  00430	8a 06		 mov	 al, BYTE PTR [esi]
  00432	88 01		 mov	 BYTE PTR [ecx], al
  00434	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  0043a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0043c	03 cd		 add	 ecx, ebp
  0043e	03 f5		 add	 esi, ebp
  00440	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  00446	84 d2		 test	 dl, dl
  00448	75 e6		 jne	 SHORT $LL5@out
  0044a	2b cd		 sub	 ecx, ebp
  0044c	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
$LN6@out:

; 176  :         COUT('(');

  00452	c6 01 28	 mov	 BYTE PTR [ecx], 40	; 00000028H
  00455	01 2d 50 01 00
	00		 add	 DWORD PTR _g+336, ebp

; 177  :         for (i=1; i<GETARITY(xval); i++)

  0045b	8b f5		 mov	 esi, ebp
  0045d	3b fd		 cmp	 edi, ebp
  0045f	8b 6c 24 18	 mov	 ebp, DWORD PTR _wam$[esp+12]
  00463	76 21		 jbe	 SHORT $LN1@out
$LL3@out:

; 178  :           {
; 179  :             out(xref[i],wam);

  00465	8b 04 b3	 mov	 eax, DWORD PTR [ebx+esi*4]
  00468	55		 push	 ebp
  00469	50		 push	 eax
  0046a	e8 00 00 00 00	 call	 _out

; 180  :             COUT(',');

  0046f	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  00475	c6 01 2c	 mov	 BYTE PTR [ecx], 44	; 0000002cH
  00478	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0047e	46		 inc	 esi
  0047f	83 c4 08	 add	 esp, 8
  00482	3b f7		 cmp	 esi, edi
  00484	72 df		 jb	 SHORT $LL3@out
$LN1@out:

; 181  :           }
; 182  :         out((cell)(xref+i),wam);

  00486	8d 14 b3	 lea	 edx, DWORD PTR [ebx+esi*4]
  00489	55		 push	 ebp
  0048a	52		 push	 edx
  0048b	e8 00 00 00 00	 call	 _out

; 183  :         COUT(')');

  00490	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00495	83 c4 08	 add	 esp, 8
  00498	5f		 pop	 edi
  00499	5d		 pop	 ebp
  0049a	5e		 pop	 esi
  0049b	c6 00 29	 mov	 BYTE PTR [eax], 41	; 00000029H
  0049e	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  004a4	5b		 pop	 ebx

; 184  :       }
; 185  :   }
; 186  :     }
; 187  : }

  004a5	c3		 ret	 0
_out	ENDP
_TEXT	ENDS
PUBLIC	_swrite
; Function compile flags: /Ogtpy
;	COMDAT _swrite
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_swrite	PROC						; COMDAT

; 195  :   g_quote=0;
; 196  :   BUFOUT();

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _xval$[esp-4]
  00008	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0
  00019	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0001e	e8 00 00 00 00	 call	 _out
  00023	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00028	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002b	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336

; 197  :   return g.sbuf;

  00031	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  00036	83 c4 08	 add	 esp, 8

; 198  : }

  00039	c3		 ret	 0
_swrite	ENDP
_TEXT	ENDS
PUBLIC	_sout
EXTRN	_new_func:PROC
; Function compile flags: /Ogtpy
;	COMDAT _sout
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_sout	PROC						; COMDAT

; 203  :   g_quote=0;
; 204  :   BUFOUT();

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _xval$[esp-4]
  00008	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0
  00019	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0001e	e8 00 00 00 00	 call	 _out
  00023	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00028	83 c4 08	 add	 esp, 8
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002e	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336

; 205  :   return INPUT_STRING(g.sbuf);

  00034	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _wam$[esp-4], 0
  0003c	8b 0d 4c 01 00
	00		 mov	 ecx, DWORD PTR _g+332
  00042	89 4c 24 04	 mov	 DWORD PTR _xval$[esp-4], ecx
  00046	e9 00 00 00 00	 jmp	 _new_func
_sout	ENDP
_TEXT	ENDS
PUBLIC	_qsout
; Function compile flags: /Ogtpy
;	COMDAT _qsout
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_qsout	PROC						; COMDAT

; 209  :   g_quote=1;
; 210  :   BUFOUT();

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _xval$[esp-4]
  00008	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g_quote, 1
  00019	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0001e	e8 00 00 00 00	 call	 _out
  00023	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00028	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002b	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336

; 211  :   g_quote=0;
; 212  :   return g.sbuf;

  00031	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  00036	83 c4 08	 add	 esp, 8
  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0

; 213  : }

  00043	c3		 ret	 0
_qsout	ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	_fout
EXTRN	_fprintf:PROC
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _fout
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_f$ = 16						; size = 4
_fout	PROC						; COMDAT

; 217  :   g_quote=0;
; 218  :   BUFOUT();

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _xval$[esp-4]
  00008	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  0000d	51		 push	 ecx
  0000e	52		 push	 edx
  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0
  00019	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0001e	e8 00 00 00 00	 call	 _out
  00023	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336

; 219  :   fprintf(f,"%s",g.sbuf);

  00028	8b 54 24 14	 mov	 edx, DWORD PTR _f$[esp+4]
  0002c	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002f	8b 0d 4c 01 00
	00		 mov	 ecx, DWORD PTR _g+332
  00035	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _fprintf
  00047	83 c4 14	 add	 esp, 20			; 00000014H

; 220  : #if defined SGI || defined AIX
; 221  :   fflush(f);
; 222  : #endif
; 223  : }

  0004a	c3		 ret	 0
_fout	ENDP
_TEXT	ENDS
PUBLIC	_qprint
EXTRN	_fflush:PROC
; Function compile flags: /Ogtpy
;	COMDAT _qprint
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_wam$ = 12						; size = 4
_f$ = 16						; size = 4
_qprint	PROC						; COMDAT

; 237  :   BUFOUT();

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _wam$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _xval$[esp-4]
  00008	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	52		 push	 edx
  00010	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _g_quote, 1
  0001a	a3 50 01 00 00	 mov	 DWORD PTR _g+336, eax
  0001f	e8 00 00 00 00	 call	 _out
  00024	a1 50 01 00 00	 mov	 eax, DWORD PTR _g+336
  00029	c6 00 00	 mov	 BYTE PTR [eax], 0

; 238  :   g_quote=0;
; 239  :   {string t;
; 240  :   t=g.sbuf+strlen(g.sbuf);

  0002c	8b 15 4c 01 00
	00		 mov	 edx, DWORD PTR _g+332
  00032	8b c2		 mov	 eax, edx
  00034	83 c4 08	 add	 esp, 8
  00037	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0
  00047	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL3@qprint:
  00050	8a 08		 mov	 cl, BYTE PTR [eax]
  00052	40		 inc	 eax
  00053	84 c9		 test	 cl, cl
  00055	75 f9		 jne	 SHORT $LL3@qprint
  00057	2b c6		 sub	 eax, esi

; 241  :   *t++='.';
; 242  :   *t++='\n';
; 243  :   *t='\0';
; 244  :   }
; 245  : #ifdef VIVO
; 246  :   {
; 247  :    if(QLEVEL()==1111) {
; 248  :     bp_long i; string s=g.sbuf; bp_long l=strlen(s);
; 249  :     for(i=0;i<l;i++) {
; 250  :       s[i]=(char)obfuscate((bp_long)s[i]);
; 251  :     }
; 252  :    }
; 253  :   }
; 254  : #endif
; 255  :   fprintf(f,"%s",g.sbuf);

  00059	8b 74 24 10	 mov	 esi, DWORD PTR _f$[esp]
  0005d	66 c7 04 10 2e
	0a		 mov	 WORD PTR [eax+edx], 2606 ; 00000a2eH
  00063	88 4c 10 02	 mov	 BYTE PTR [eax+edx+2], cl
  00067	8b 0d 4c 01 00
	00		 mov	 ecx, DWORD PTR _g+332
  0006d	51		 push	 ecx
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 _fprintf

; 256  :   fflush(f);

  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 _fflush
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	5e		 pop	 esi

; 257  : }

  00083	c3		 ret	 0
_qprint	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
PUBLIC	_errmes
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _errmes
_TEXT	SEGMENT
_mes$ = 8						; size = 4
_arg$ = 12						; size = 4
_wam$ = 16						; size = 4
_errmes	PROC						; COMDAT

; 260  : { fprintf(STD_err,"%s ",mes);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _mes$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_03IKGEINEE@?$CFs?5?$AA@
  0000b	e8 00 00 00 00	 call	 ___iob_func
  00010	83 c0 40	 add	 eax, 64			; 00000040H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _fprintf

; 261  :   fout(T2C(&arg),wam,STD_err);

  00019	e8 00 00 00 00	 call	 ___iob_func
  0001e	8b 54 24 1c	 mov	 edx, DWORD PTR _wam$[esp+12]
  00022	8b 0d 4c 01 00
	00		 mov	 ecx, DWORD PTR _g+332
  00028	8d 70 40	 lea	 esi, DWORD PTR [eax+64]
  0002b	52		 push	 edx
  0002c	8d 44 24 1c	 lea	 eax, DWORD PTR _arg$[esp+16]
  00030	50		 push	 eax
  00031	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _g_quote, 0
  0003b	89 0d 50 01 00
	00		 mov	 DWORD PTR _g+336, ecx
  00041	e8 00 00 00 00	 call	 _out
  00046	8b 0d 50 01 00
	00		 mov	 ecx, DWORD PTR _g+336
  0004c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0004f	8b 15 4c 01 00
	00		 mov	 edx, DWORD PTR _g+332
  00055	ff 05 50 01 00
	00		 inc	 DWORD PTR _g+336
  0005b	52		 push	 edx
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 _fprintf
  00067	83 c4 20	 add	 esp, 32			; 00000020H

; 262  :   fprintf(STD_err,"\n");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0006f	e8 00 00 00 00	 call	 ___iob_func
  00074	83 c0 40	 add	 eax, 64			; 00000040H
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _fprintf
  0007d	83 c4 08	 add	 esp, 8
  00080	5e		 pop	 esi

; 263  : }

  00081	c3		 ret	 0
_errmes	ENDP
_TEXT	ENDS
END
