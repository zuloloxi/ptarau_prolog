; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\float.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_double_to_ints
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\float.c
;	COMDAT _double_to_ints
_TEXT	SEGMENT
_s$ = 8							; size = 8
_f$ = 8							; size = 8
_pi1$ = 16						; size = 4
_pi2$ = 20						; size = 4
_pi3$ = 24						; size = 4
_double_to_ints PROC					; COMDAT

; 26   :    s.i.t0=0;s.i.t1=0;
; 27   :    s.d=f; 

  00000	dd 44 24 04	 fld	 QWORD PTR _f$[esp-4]
  00004	56		 push	 esi
  00005	dd 5c 24 08	 fstp	 QWORD PTR _s$[esp]

; 28   :    i2=s.i.t0;
; 29   :    i3=s.i.t1;
; 30   :    i0=(i2<<LEFTBITS)>>LEFTBITS;
; 31   :    i1=((i3<<LEFTBITS)>>LEFTBITS)<<RIGHTBITS;
; 32   :    i1=(i1|i0)<<RIGHTBITS;
; 33   :    i2=(i2>>RIGHTBITS)<<RIGHTBITS;;
; 34   :    i3=(i3>>RIGHTBITS)<<RIGHTBITS;
; 35   :    i1+= INTTAG;
; 36   :    i2+= INTTAG;
; 37   :    i3+= INTTAG;
; 38   : #if TRACE>FLOAT_TRACE
; 39   :    fprintf(STD_err,"f=%f --> i1=%d i2=%d i3=%d\n",f,i1,i2,i3);
; 40   : #endif
; 41   :    *pi1=i1; *pi2=i2; *pi3=i3;

  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _s$[esp+4]
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _s$[esp]
  00011	8b d0		 mov	 edx, eax
  00013	83 e2 03	 and	 edx, 3
  00016	03 d2		 add	 edx, edx
  00018	8b f1		 mov	 esi, ecx
  0001a	03 d2		 add	 edx, edx
  0001c	83 e6 03	 and	 esi, 3
  0001f	0b d6		 or	 edx, esi
  00021	8b 74 24 10	 mov	 esi, DWORD PTR _pi1$[esp]
  00025	8d 14 95 01 00
	00 00		 lea	 edx, DWORD PTR [edx*4+1]
  0002c	89 16		 mov	 DWORD PTR [esi], edx
  0002e	8b 54 24 14	 mov	 edx, DWORD PTR _pi2$[esp]
  00032	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00035	41		 inc	 ecx
  00036	89 0a		 mov	 DWORD PTR [edx], ecx
  00038	8b 4c 24 18	 mov	 ecx, DWORD PTR _pi3$[esp]
  0003c	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003f	40		 inc	 eax
  00040	89 01		 mov	 DWORD PTR [ecx], eax
  00042	5e		 pop	 esi

; 42   : 
; 43   : }

  00043	c3		 ret	 0
_double_to_ints ENDP
_TEXT	ENDS
PUBLIC	_ints_to_double
; Function compile flags: /Ogtpy
;	COMDAT _ints_to_double
_TEXT	SEGMENT
_s$ = -8						; size = 8
_i1$ = 8						; size = 4
_i2$ = 12						; size = 4
_i3$ = 16						; size = 4
_ints_to_double PROC					; COMDAT

; 46   : {  split_double s; half i0;

  00000	83 ec 08	 sub	 esp, 8

; 47   : #if TRACE>FLOAT_TRACE
; 48   :    fprintf(STD_err,"[1] ints->%d,%d,%d\n",i1,i2,i3);
; 49   : #endif
; 50   :    i1 -= INTTAG;

  00003	8b 44 24 0c	 mov	 eax, DWORD PTR _i1$[esp+4]

; 51   :    i2 -= INTTAG;

  00007	8b 54 24 10	 mov	 edx, DWORD PTR _i2$[esp+4]
  0000b	48		 dec	 eax

; 52   :    i3 -= INTTAG;
; 53   : #if TRACE>FLOAT_TRACE
; 54   :    fprintf(STD_err,"[2] ints->%d,%d,%d\n",
; 55   :       i1>>TAGBITS,i2>>TAGBITS,i3>>TAGBITS);
; 56   : #endif
; 57   :    i1=i1>>RIGHTBITS;

  0000c	c1 e8 02	 shr	 eax, 2

; 58   :    i0=(i1<<LEFTBITS)>>LEFTBITS;

  0000f	8b c8		 mov	 ecx, eax
  00011	83 e1 03	 and	 ecx, 3
  00014	4a		 dec	 edx

; 59   :    i1=i1>>RIGHTBITS;
; 60   :    i2=i2|i0;

  00015	0b ca		 or	 ecx, edx

; 61   :    i3=i3|i1;
; 62   :    s.i.t0=i2;

  00017	89 0c 24	 mov	 DWORD PTR _s$[esp+8], ecx
  0001a	8b 4c 24 14	 mov	 ecx, DWORD PTR _i3$[esp+4]
  0001e	c1 e8 02	 shr	 eax, 2
  00021	49		 dec	 ecx
  00022	0b c1		 or	 eax, ecx

; 63   :    s.i.t1=i3;

  00024	89 44 24 04	 mov	 DWORD PTR _s$[esp+12], eax

; 64   : #if TRACE>FLOAT_TRACE
; 65   :    fprintf(STD_err,"[3] float->%f\n",s.d);
; 66   : #endif
; 67   :    return s.d;

  00028	dd 04 24	 fld	 QWORD PTR _s$[esp+8]

; 68   : }

  0002b	83 c4 08	 add	 esp, 8
  0002e	c3		 ret	 0
_ints_to_double ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@NDKLGCIJ@?$CFs?5TAG?$DN?$CFld?0VALUE?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@LPGOALAM@bad?5arg?5in?5arithmetic?5operation?$AA@ ; `string'
PUBLIC	_bad_arith_arg
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_warnmes:PROC
;	COMDAT ??_C@_0BG@NDKLGCIJ@?$CFs?5TAG?$DN?$CFld?0VALUE?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BG@NDKLGCIJ@?$CFs?5TAG?$DN?$CFld?0VALUE?$DN?$CFld?6?$AA@ DB '%s TA'
	DB	'G=%ld,VALUE=%ld', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LPGOALAM@bad?5arg?5in?5arithmetic?5operation?$AA@
CONST	SEGMENT
??_C@_0CA@LPGOALAM@bad?5arg?5in?5arithmetic?5operation?$AA@ DB 'bad arg i'
	DB	'n arithmetic operation', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _bad_arith_arg
_TEXT	SEGMENT
_xval$ = 8						; size = 4
_mes$ = 12						; size = 4
_bad_arith_arg PROC					; COMDAT

; 83   :   warnmes("bad arg in arithmetic operation");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LPGOALAM@bad?5arg?5in?5arithmetic?5operation?$AA@
  00005	e8 00 00 00 00	 call	 _warnmes

; 84   :   fprintf(STD_err,"%s TAG=%ld,VALUE=%ld\n",mes,GETTAG(xval),xval>>TAGBITS);

  0000a	8b 44 24 08	 mov	 eax, DWORD PTR _xval$[esp]
  0000e	8b 54 24 0c	 mov	 edx, DWORD PTR _mes$[esp]
  00012	8b c8		 mov	 ecx, eax
  00014	83 c4 04	 add	 esp, 4
  00017	c1 e9 02	 shr	 ecx, 2
  0001a	51		 push	 ecx
  0001b	83 e0 03	 and	 eax, 3
  0001e	50		 push	 eax
  0001f	52		 push	 edx
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NDKLGCIJ@?$CFs?5TAG?$DN?$CFld?0VALUE?$DN?$CFld?6?$AA@
  00025	e8 00 00 00 00	 call	 ___iob_func
  0002a	83 c0 40	 add	 eax, 64			; 00000040H
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _fprintf
  00033	83 c4 14	 add	 esp, 20			; 00000014H

; 85   : #if TRACE>0
; 86   :   { 
; 87   :     fprintf(STD_err,"%s %s ???\n",mes,smartref(xval,root_wam));
; 88   :   }
; 89   : #endif
; 90   : }

  00036	c3		 ret	 0
_bad_arith_arg ENDP
_TEXT	ENDS
PUBLIC	_make_float
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _make_float
_TEXT	SEGMENT
_H$ = 8							; size = 4
_s$5398 = 12						; size = 8
_f$ = 12						; size = 8
_make_float PROC					; COMDAT

; 122  :   PUT_FLOAT(f);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _H$[esp-4]
  00004	dd 44 24 08	 fld	 QWORD PTR _f$[esp-4]
  00008	8b 0d 94 00 00
	00		 mov	 ecx, DWORD PTR _g+148
  0000e	dd 5c 24 08	 fstp	 QWORD PTR _s$5398[esp-4]
  00012	8b 54 24 08	 mov	 edx, DWORD PTR _s$5398[esp-4]
  00016	56		 push	 esi
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	8b 4c 24 10	 mov	 ecx, DWORD PTR _s$5398[esp+4]
  0001d	8b f1		 mov	 esi, ecx
  0001f	83 e6 03	 and	 esi, 3
  00022	57		 push	 edi
  00023	03 f6		 add	 esi, esi
  00025	8b fa		 mov	 edi, edx
  00027	03 f6		 add	 esi, esi
  00029	83 e7 03	 and	 edi, 3
  0002c	0b f7		 or	 esi, edi
  0002e	83 e2 fc	 and	 edx, -4			; fffffffcH
  00031	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00034	8d 34 b5 01 00
	00 00		 lea	 esi, DWORD PTR [esi*4+1]
  0003b	42		 inc	 edx
  0003c	41		 inc	 ecx
  0003d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00040	5f		 pop	 edi
  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00044	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00047	83 c0 10	 add	 eax, 16			; 00000010H
  0004a	5e		 pop	 esi

; 123  :   return H;
; 124  : }

  0004b	c3		 ret	 0
_make_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GNMIELFD@?$DN?$DO?$AA@			; `string'
PUBLIC	__real@0000000000000000
PUBLIC	_float_compare
;	COMDAT ??_C@_02GNMIELFD@?$DN?$DO?$AA@
CONST	SEGMENT
??_C@_02GNMIELFD@?$DN?$DO?$AA@ DB '=>', 00H		; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _float_compare
_TEXT	SEGMENT
_s$5417 = -8						; size = 8
_s$5409 = -8						; size = 8
tv348 = 8						; size = 4
tv347 = 8						; size = 4
tv342 = 8						; size = 4
tv341 = 8						; size = 4
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_float_compare PROC					; COMDAT

; 135  :   TRY_GET_FLOAT(t1,f1) else f1=0.0;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _t1$[esp-4]
  00004	d9 ee		 fldz
  00006	8b c1		 mov	 eax, ecx
  00008	83 ec 08	 sub	 esp, 8
  0000b	83 e0 03	 and	 eax, 3
  0000e	56		 push	 esi
  0000f	8b 35 94 00 00
	00		 mov	 esi, DWORD PTR _g+148
  00015	83 f8 01	 cmp	 eax, 1
  00018	75 0f		 jne	 SHORT $LN16@float_comp
  0001a	c1 f9 02	 sar	 ecx, 2
  0001d	89 4c 24 10	 mov	 DWORD PTR tv348[esp+8], ecx
  00021	db 44 24 10	 fild	 DWORD PTR tv348[esp+8]
  00025	d8 c1		 fadd	 ST(0), ST(1)
  00027	eb 67		 jmp	 SHORT $LN9@float_comp
$LN16@float_comp:
  00029	85 c0		 test	 eax, eax
  0002b	75 61		 jne	 SHORT $LN14@float_comp
  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	8b d0		 mov	 edx, eax
  00031	80 e2 03	 and	 dl, 3
  00034	80 fa 01	 cmp	 dl, 1
  00037	75 0f		 jne	 SHORT $LN13@float_comp
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 44 24 10	 mov	 DWORD PTR tv347[esp+8], eax
  00040	db 44 24 10	 fild	 DWORD PTR tv347[esp+8]
  00044	d8 c1		 fadd	 ST(0), ST(1)
  00046	eb 48		 jmp	 SHORT $LN9@float_comp
$LN13@float_comp:
  00048	3b f0		 cmp	 esi, eax
  0004a	75 2b		 jne	 SHORT $LN56@float_comp
  0004c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0004f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00052	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00055	48		 dec	 eax
  00056	c1 e8 02	 shr	 eax, 2
  00059	57		 push	 edi
  0005a	8b f8		 mov	 edi, eax
  0005c	83 e7 03	 and	 edi, 3
  0005f	4a		 dec	 edx
  00060	0b d7		 or	 edx, edi
  00062	49		 dec	 ecx
  00063	c1 e8 02	 shr	 eax, 2
  00066	0b c8		 or	 ecx, eax
  00068	89 54 24 08	 mov	 DWORD PTR _s$5409[esp+16], edx
  0006c	89 4c 24 0c	 mov	 DWORD PTR _s$5409[esp+20], ecx
  00070	dd 44 24 08	 fld	 QWORD PTR _s$5409[esp+16]
  00074	5f		 pop	 edi
  00075	eb 19		 jmp	 SHORT $LN9@float_comp
$LN56@float_comp:
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_02GNMIELFD@?$DN?$DO?$AA@
  0007c	dd d8		 fstp	 ST(0)
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _bad_arith_arg
  00084	83 c4 08	 add	 esp, 8
  00087	33 c0		 xor	 eax, eax
  00089	5e		 pop	 esi

; 141  : }

  0008a	83 c4 08	 add	 esp, 8
  0008d	c3		 ret	 0
$LN14@float_comp:

; 135  :   TRY_GET_FLOAT(t1,f1) else f1=0.0;

  0008e	d9 c0		 fld	 ST(0)
$LN9@float_comp:

; 136  :   TRY_GET_FLOAT(t2,f2) else f2=0.0;

  00090	8b 4c 24 14	 mov	 ecx, DWORD PTR _t2$[esp+8]
  00094	8b c1		 mov	 eax, ecx
  00096	83 e0 03	 and	 eax, 3
  00099	83 f8 01	 cmp	 eax, 1
  0009c	75 0f		 jne	 SHORT $LN8@float_comp
  0009e	c1 f9 02	 sar	 ecx, 2
  000a1	89 4c 24 10	 mov	 DWORD PTR tv342[esp+8], ecx
  000a5	db 44 24 10	 fild	 DWORD PTR tv342[esp+8]
  000a9	de c2		 faddp	 ST(2), ST(0)
  000ab	eb 4e		 jmp	 SHORT $LN1@float_comp
$LN8@float_comp:
  000ad	85 c0		 test	 eax, eax
  000af	75 4a		 jne	 SHORT $LN1@float_comp
  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	8b d0		 mov	 edx, eax
  000b5	80 e2 03	 and	 dl, 3
  000b8	80 fa 01	 cmp	 dl, 1
  000bb	75 0f		 jne	 SHORT $LN43@float_comp
  000bd	c1 f8 02	 sar	 eax, 2
  000c0	89 44 24 10	 mov	 DWORD PTR tv341[esp+8], eax
  000c4	db 44 24 10	 fild	 DWORD PTR tv341[esp+8]
  000c8	de c2		 faddp	 ST(2), ST(0)
  000ca	eb 2f		 jmp	 SHORT $LN1@float_comp
$LN43@float_comp:
  000cc	dd d9		 fstp	 ST(1)
  000ce	3b f0		 cmp	 esi, eax
  000d0	75 a5		 jne	 SHORT $LN56@float_comp
  000d2	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000d5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d8	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  000db	48		 dec	 eax
  000dc	c1 e8 02	 shr	 eax, 2
  000df	8b f0		 mov	 esi, eax
  000e1	4a		 dec	 edx
  000e2	83 e6 03	 and	 esi, 3
  000e5	0b d6		 or	 edx, esi
  000e7	49		 dec	 ecx
  000e8	c1 e8 02	 shr	 eax, 2
  000eb	0b c8		 or	 ecx, eax
  000ed	89 54 24 04	 mov	 DWORD PTR _s$5417[esp+12], edx
  000f1	89 4c 24 08	 mov	 DWORD PTR _s$5417[esp+16], ecx
  000f5	dd 44 24 04	 fld	 QWORD PTR _s$5417[esp+12]
  000f9	d9 c9		 fxch	 ST(1)
$LN1@float_comp:

; 137  : #if TRACE>FLOAT_TRACE
; 138  :   fprintf(STD_err,"FLOAT_COMPARE: f1=%f f2=%f\n",f1,f2);
; 139  : #endif
; 140  :   return ZERO-(f1<f2)+(f2<f1);

  000fb	d8 d1		 fcom	 ST(1)
  000fd	df e0		 fnstsw	 ax
  000ff	f6 c4 05	 test	 ah, 5
  00102	7a 07		 jp	 SHORT $LN19@float_comp
  00104	b9 01 00 00 00	 mov	 ecx, 1
  00109	eb 02		 jmp	 SHORT $LN20@float_comp
$LN19@float_comp:
  0010b	33 c9		 xor	 ecx, ecx
$LN20@float_comp:
  0010d	de d9		 fcompp
  0010f	df e0		 fnstsw	 ax
  00111	f6 c4 41	 test	 ah, 65			; 00000041H
  00114	75 0c		 jne	 SHORT $LN21@float_comp
  00116	b8 01 00 00 00	 mov	 eax, 1
  0011b	2b c1		 sub	 eax, ecx
  0011d	5e		 pop	 esi

; 141  : }

  0011e	83 c4 08	 add	 esp, 8
  00121	c3		 ret	 0
$LN21@float_comp:

; 137  : #if TRACE>FLOAT_TRACE
; 138  :   fprintf(STD_err,"FLOAT_COMPARE: f1=%f f2=%f\n",f1,f2);
; 139  : #endif
; 140  :   return ZERO-(f1<f2)+(f2<f1);

  00122	33 c0		 xor	 eax, eax
  00124	2b c1		 sub	 eax, ecx
  00126	5e		 pop	 esi

; 141  : }

  00127	83 c4 08	 add	 esp, 8
  0012a	c3		 ret	 0
_float_compare ENDP
_TEXT	ENDS
PUBLIC	??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@		; `string'
PUBLIC	_float_op
;	COMDAT ??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@
CONST	SEGMENT
??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@ DB '==>', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _float_op
_TEXT	SEGMENT
_i2$ = -12						; size = 4
_s$5471 = -8						; size = 8
_i3$ = -8						; size = 4
_H$ = 8							; size = 4
_opcode$ = 12						; size = 1
tv439 = 16						; size = 4
tv438 = 16						; size = 4
tv435 = 16						; size = 4
tv434 = 16						; size = 4
_i1$ = 16						; size = 4
_t1$ = 16						; size = 4
_t2$ = 20						; size = 4
_float_op PROC						; COMDAT

; 147  : #if TRACE>FLOAT_TRACE
; 148  :   fprintf(STD_err,"FLOAT_OP 1: opcode=%u t1=%lu t2=%lu\n",opcode,t1,t2);
; 149  : #endif
; 150  :   GET_FLOAT(t1,f1);

  00000	d9 ee		 fldz
  00002	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00005	53		 push	 ebx
  00006	8b 1d 94 00 00
	00		 mov	 ebx, DWORD PTR _g+148
  0000c	56		 push	 esi
  0000d	8b 74 24 20	 mov	 esi, DWORD PTR _t1$[esp+16]
  00011	57		 push	 edi
  00012	8b fe		 mov	 edi, esi
  00014	83 e7 03	 and	 edi, 3
  00017	83 ff 01	 cmp	 edi, 1
  0001a	75 0f		 jne	 SHORT $LN29@float_op
  0001c	c1 fe 02	 sar	 esi, 2
  0001f	89 74 24 24	 mov	 DWORD PTR tv439[esp+20], esi
  00023	db 44 24 24	 fild	 DWORD PTR tv439[esp+20]
  00027	d8 c1		 fadd	 ST(0), ST(1)
  00029	eb 52		 jmp	 SHORT $LN23@float_op
$LN29@float_op:
  0002b	85 ff		 test	 edi, edi
  0002d	0f 85 c2 01 00
	00		 jne	 $LN84@float_op
  00033	8b 06		 mov	 eax, DWORD PTR [esi]
  00035	8b c8		 mov	 ecx, eax
  00037	80 e1 03	 and	 cl, 3
  0003a	80 f9 01	 cmp	 cl, 1
  0003d	75 0f		 jne	 SHORT $LN26@float_op
  0003f	c1 f8 02	 sar	 eax, 2
  00042	89 44 24 24	 mov	 DWORD PTR tv438[esp+20], eax
  00046	db 44 24 24	 fild	 DWORD PTR tv438[esp+20]
  0004a	d8 c1		 fadd	 ST(0), ST(1)
  0004c	eb 2f		 jmp	 SHORT $LN23@float_op
$LN26@float_op:
  0004e	3b d8		 cmp	 ebx, eax
  00050	0f 85 84 01 00
	00		 jne	 $LN80@float_op
  00056	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00059	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0005c	48		 dec	 eax
  0005d	c1 e8 02	 shr	 eax, 2
  00060	4a		 dec	 edx
  00061	8b c8		 mov	 ecx, eax
  00063	83 e1 03	 and	 ecx, 3
  00066	0b d1		 or	 edx, ecx
  00068	89 54 24 10	 mov	 DWORD PTR _s$5471[esp+24], edx
  0006c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0006f	4a		 dec	 edx
  00070	c1 e8 02	 shr	 eax, 2
  00073	0b d0		 or	 edx, eax
  00075	89 54 24 14	 mov	 DWORD PTR _s$5471[esp+28], edx
  00079	dd 44 24 10	 fld	 QWORD PTR _s$5471[esp+24]
$LN23@float_op:

; 151  :   GET_FLOAT(t2,f2);

  0007d	8b 74 24 28	 mov	 esi, DWORD PTR _t2$[esp+20]
  00081	8b fe		 mov	 edi, esi
  00083	83 e7 03	 and	 edi, 3
  00086	83 ff 01	 cmp	 edi, 1
  00089	75 0f		 jne	 SHORT $LN21@float_op
  0008b	c1 fe 02	 sar	 esi, 2
  0008e	89 74 24 24	 mov	 DWORD PTR tv435[esp+20], esi
  00092	db 44 24 24	 fild	 DWORD PTR tv435[esp+20]
  00096	de c2		 faddp	 ST(2), ST(0)
  00098	eb 43		 jmp	 SHORT $LN15@float_op
$LN21@float_op:
  0009a	85 ff		 test	 edi, edi
  0009c	0f 85 51 01 00
	00		 jne	 $LN74@float_op
  000a2	8b 06		 mov	 eax, DWORD PTR [esi]
  000a4	8b c8		 mov	 ecx, eax
  000a6	80 e1 03	 and	 cl, 3
  000a9	80 f9 01	 cmp	 cl, 1
  000ac	75 0f		 jne	 SHORT $LN77@float_op
  000ae	c1 f8 02	 sar	 eax, 2
  000b1	89 44 24 24	 mov	 DWORD PTR tv434[esp+20], eax
  000b5	db 44 24 24	 fild	 DWORD PTR tv434[esp+20]
  000b9	de c2		 faddp	 ST(2), ST(0)
  000bb	eb 20		 jmp	 SHORT $LN15@float_op
$LN77@float_op:
  000bd	dd d9		 fstp	 ST(1)
  000bf	3b d8		 cmp	 ebx, eax
  000c1	0f 85 13 01 00
	00		 jne	 $LN80@float_op
  000c7	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cd	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d0	52		 push	 edx
  000d1	50		 push	 eax
  000d2	51		 push	 ecx
  000d3	e8 00 00 00 00	 call	 _ints_to_double
  000d8	d9 c9		 fxch	 ST(1)
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@float_op:

; 152  : #if TRACE>FLOAT_TRACE
; 153  :   fprintf(STD_err,"FLOAT_OP 2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);
; 154  : #endif
; 155  :   switch(opcode)

  000dd	0f b6 44 24 20	 movzx	 eax, BYTE PTR _opcode$[esp+20]
  000e2	83 c0 b6	 add	 eax, -74		; ffffffb6H
  000e5	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  000e8	0f 87 df 00 00
	00		 ja	 $LN61@float_op
  000ee	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN92@float_op[eax*4]
$LN11@float_op:

; 156  :   {
; 157  :     case PLUS_3: EVAL_FLOAT(f1+f2)

  000f5	de c1		 faddp	 ST(1), ST(0)
  000f7	eb 0a		 jmp	 SHORT $LN12@float_op
$LN10@float_op:

; 158  :     case SUB_3: EVAL_FLOAT(f1-f2)

  000f9	de e1		 fsubrp	 ST(1), ST(0)
  000fb	eb 06		 jmp	 SHORT $LN12@float_op
$LN9@float_op:

; 159  :     case MUL_3: EVAL_FLOAT(f1*f2)

  000fd	de c9		 fmulp	 ST(1), ST(0)
  000ff	eb 02		 jmp	 SHORT $LN12@float_op
$LN8@float_op:

; 160  :     case FDIV_3: EVAL_FLOAT(f1/f2)

  00101	de f1		 fdivrp	 ST(1), ST(0)
$LN12@float_op:

; 168  :     default: { 
; 169  : 		/*fprintf(STD_err,"*** UNEXPECTED FLOAT_OP 2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);*/
; 170  : 		return 0;
; 171  : 	}
; 172  :   }
; 173  : #if TRACE>FLOAT_TRACE
; 174  :   fprintf(STD_err,"FLOAT_OP 3: opcode %u (Res)=H=%ld\n",opcode,H);
; 175  : #endif
; 176  :   PUT_FLOAT(f);

  00103	8d 54 24 10	 lea	 edx, DWORD PTR _i3$[esp+24]
  00107	52		 push	 edx
  00108	8d 44 24 10	 lea	 eax, DWORD PTR _i2$[esp+28]
  0010c	50		 push	 eax
  0010d	8d 4c 24 2c	 lea	 ecx, DWORD PTR _i1$[esp+28]
  00111	51		 push	 ecx
  00112	83 ec 08	 sub	 esp, 8
  00115	dd 1c 24	 fstp	 QWORD PTR [esp]
  00118	e8 00 00 00 00	 call	 _double_to_ints
  0011d	8b 44 24 30	 mov	 eax, DWORD PTR _H$[esp+40]
  00121	8b 54 24 38	 mov	 edx, DWORD PTR _i1$[esp+40]
  00125	8b 4c 24 20	 mov	 ecx, DWORD PTR _i2$[esp+44]
  00129	83 c4 14	 add	 esp, 20			; 00000014H
  0012c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0012f	8b 54 24 10	 mov	 edx, DWORD PTR _i3$[esp+24]
  00133	5f		 pop	 edi
  00134	89 18		 mov	 DWORD PTR [eax], ebx
  00136	5e		 pop	 esi
  00137	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0013a	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0013d	83 c0 10	 add	 eax, 16			; 00000010H
  00140	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
  00144	c3		 ret	 0
$LN7@float_op:

; 161  : 
; 162  :     case LESS_2: FLOAT_REL(<)

  00145	de d9		 fcompp
  00147	df e0		 fnstsw	 ax
  00149	f6 c4 05	 test	 ah, 5
  0014c	0f 8a d2 00 00
	00		 jp	 $LN32@float_op
  00152	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  00159	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015c	c3		 ret	 0
$LN6@float_op:

; 163  :     case GREATER_2: FLOAT_REL(>)

  0015d	de d9		 fcompp
  0015f	df e0		 fnstsw	 ax
  00161	f6 c4 41	 test	 ah, 65			; 00000041H
  00164	0f 85 ba 00 00
	00		 jne	 $LN32@float_op
  0016a	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  00171	83 c4 0c	 add	 esp, 12			; 0000000cH
  00174	c3		 ret	 0
$LN5@float_op:

; 164  :     case LESS_EQ_2: FLOAT_REL(<=)

  00175	de d9		 fcompp
  00177	df e0		 fnstsw	 ax
  00179	f6 c4 41	 test	 ah, 65			; 00000041H
  0017c	0f 8a a2 00 00
	00		 jp	 $LN32@float_op
  00182	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  00189	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018c	c3		 ret	 0
$LN4@float_op:

; 165  :     case GREATER_EQ_2: FLOAT_REL(>=)

  0018d	de d9		 fcompp
  0018f	df e0		 fnstsw	 ax
  00191	f6 c4 01	 test	 ah, 1
  00194	0f 85 8a 00 00
	00		 jne	 $LN32@float_op
  0019a	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	c3		 ret	 0
$LN3@float_op:

; 166  :     case ARITH_EQ_2: FLOAT_REL(==)

  001a5	da e9		 fucompp
  001a7	df e0		 fnstsw	 ax
  001a9	f6 c4 44	 test	 ah, 68			; 00000044H
  001ac	7a 76		 jp	 SHORT $LN32@float_op
  001ae	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  001b2	5f		 pop	 edi
  001b3	5e		 pop	 esi
  001b4	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b8	c3		 ret	 0
$LN2@float_op:

; 167  :     case ARITH_DIF_2: FLOAT_REL(!=)

  001b9	da e9		 fucompp
  001bb	df e0		 fnstsw	 ax
  001bd	f6 c4 44	 test	 ah, 68			; 00000044H
  001c0	7b 62		 jnp	 SHORT $LN32@float_op
  001c2	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	c3		 ret	 0
$LN61@float_op:
  001cd	5f		 pop	 edi

; 152  : #if TRACE>FLOAT_TRACE
; 153  :   fprintf(STD_err,"FLOAT_OP 2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);
; 154  : #endif
; 155  :   switch(opcode)

  001ce	dd d9		 fstp	 ST(1)
  001d0	5e		 pop	 esi
  001d1	dd d8		 fstp	 ST(0)
  001d3	33 c0		 xor	 eax, eax
  001d5	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d9	c3		 ret	 0
$LN80@float_op:

; 151  :   GET_FLOAT(t2,f2);

  001da	68 00 00 00 00	 push	 OFFSET ??_C@_02GNMIELFD@?$DN?$DO?$AA@
  001df	dd d8		 fstp	 ST(0)
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _bad_arith_arg
  001e7	83 c4 08	 add	 esp, 8
  001ea	5f		 pop	 edi
  001eb	5e		 pop	 esi
  001ec	33 c0		 xor	 eax, eax
  001ee	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f2	c3		 ret	 0
$LN74@float_op:

; 151  :   GET_FLOAT(t2,f2);

  001f3	dd d9		 fstp	 ST(1)
$LN84@float_op:

; 147  : #if TRACE>FLOAT_TRACE
; 148  :   fprintf(STD_err,"FLOAT_OP 1: opcode=%u t1=%lu t2=%lu\n",opcode,t1,t2);
; 149  : #endif
; 150  :   GET_FLOAT(t1,f1);

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LPGOALAM@bad?5arg?5in?5arithmetic?5operation?$AA@
  001fa	dd d8		 fstp	 ST(0)
  001fc	e8 00 00 00 00	 call	 _warnmes
  00201	83 c4 04	 add	 esp, 4
  00204	c1 ee 02	 shr	 esi, 2
  00207	56		 push	 esi
  00208	57		 push	 edi
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@
  0020e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NDKLGCIJ@?$CFs?5TAG?$DN?$CFld?0VALUE?$DN?$CFld?6?$AA@
  00213	e8 00 00 00 00	 call	 ___iob_func
  00218	83 c0 40	 add	 eax, 64			; 00000040H
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 _fprintf
  00221	83 c4 14	 add	 esp, 20			; 00000014H
$LN32@float_op:
  00224	5f		 pop	 edi
  00225	5e		 pop	 esi
  00226	33 c0		 xor	 eax, eax
  00228	5b		 pop	 ebx

; 177  : #if TRACE>FLOAT_TRACE
; 178  :   fprintf(STD_err,"FLOAT_OP 4: opcode %u (Res+16)=NewH=%ld\n",opcode,H);
; 179  : #endif
; 180  : 
; 181  :   return H;
; 182  : }

  00229	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022c	c3		 ret	 0
  0022d	8d 49 00	 npad	 3
$LN92@float_op:
  00230	00 00 00 00	 DD	 $LN11@float_op
  00234	00 00 00 00	 DD	 $LN10@float_op
  00238	00 00 00 00	 DD	 $LN9@float_op
  0023c	00 00 00 00	 DD	 $LN61@float_op
  00240	00 00 00 00	 DD	 $LN61@float_op
  00244	00 00 00 00	 DD	 $LN8@float_op
  00248	00 00 00 00	 DD	 $LN61@float_op
  0024c	00 00 00 00	 DD	 $LN61@float_op
  00250	00 00 00 00	 DD	 $LN61@float_op
  00254	00 00 00 00	 DD	 $LN7@float_op
  00258	00 00 00 00	 DD	 $LN6@float_op
  0025c	00 00 00 00	 DD	 $LN5@float_op
  00260	00 00 00 00	 DD	 $LN4@float_op
  00264	00 00 00 00	 DD	 $LN3@float_op
  00268	00 00 00 00	 DD	 $LN2@float_op
_float_op ENDP
_TEXT	ENDS
PUBLIC	_float_fun2
EXTRN	_atomtable:DWORD
EXTRN	__CIsqrt:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIlog:PROC
EXTRN	__CIpow:PROC
; Function compile flags: /Ogtpy
;	COMDAT _float_fun2
_TEXT	SEGMENT
tv358 = -16						; size = 8
_i2$ = -16						; size = 4
_i3$ = -8						; size = 4
_f1$ = -8						; size = 8
_H$ = 8							; size = 4
tv417 = 12						; size = 4
tv416 = 12						; size = 4
tv409 = 12						; size = 4
tv408 = 12						; size = 4
_i1$ = 12						; size = 4
_regs$ = 12						; size = 4
_float_fun2 PROC					; COMDAT

; 185  : {  cell xval=X(1); 

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _regs$[esp-4]
  00004	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 186  :    term xref,t1=C2T(X(2)),t2=C2T(X(3)); 

  00007	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0000a	83 ec 10	 sub	 esp, 16			; 00000010H
  0000d	56		 push	 esi
  0000e	8b 71 f4	 mov	 esi, DWORD PTR [ecx-12]

; 187  :    double f1,f2,f; no i1,i2,i3; byte opcode;
; 188  : 
; 189  :    ATOMIZE(xval); if(!SYMCONST(xval)) return NULL;

  00011	8b c8		 mov	 ecx, eax
  00013	83 e1 03	 and	 ecx, 3
  00016	74 0c		 je	 SHORT $LN31@float_fun2
  00018	83 f9 01	 cmp	 ecx, 1
  0001b	74 09		 je	 SHORT $LN27@float_fun2
  0001d	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00022	74 02		 je	 SHORT $LN27@float_fun2
$LN31@float_fun2:
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
$LN27@float_fun2:
  00026	8b c8		 mov	 ecx, eax
  00028	83 e1 03	 and	 ecx, 3
  0002b	80 f9 03	 cmp	 cl, 3
  0002e	0f 85 d2 01 00
	00		 jne	 $LN24@float_fun2
  00034	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00039	0f 85 c7 01 00
	00		 jne	 $LN24@float_fun2

; 190  :    opcode = *NAME(xval);

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable

; 191  : 
; 192  :    GET_FLOAT(t1,f1);

  00045	d9 ee		 fldz
  00047	c1 e8 02	 shr	 eax, 2
  0004a	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  0004f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00052	53		 push	 ebx
  00053	8a 18		 mov	 bl, BYTE PTR [eax]
  00055	8b c2		 mov	 eax, edx
  00057	83 e0 03	 and	 eax, 3
  0005a	57		 push	 edi
  0005b	8b 3d 94 00 00
	00		 mov	 edi, DWORD PTR _g+148
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 0f		 jne	 SHORT $LN23@float_fun2
  00066	c1 fa 02	 sar	 edx, 2
  00069	89 54 24 24	 mov	 DWORD PTR tv417[esp+24], edx
  0006d	db 44 24 24	 fild	 DWORD PTR tv417[esp+24]
  00071	d8 c1		 fadd	 ST(0), ST(1)
  00073	eb 3f		 jmp	 SHORT $LN70@float_fun2
$LN23@float_fun2:
  00075	85 c0		 test	 eax, eax
  00077	0f 85 70 01 00
	00		 jne	 $LN62@float_fun2
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	8b c8		 mov	 ecx, eax
  00081	80 e1 03	 and	 cl, 3
  00084	80 f9 01	 cmp	 cl, 1
  00087	75 0f		 jne	 SHORT $LN20@float_fun2
  00089	c1 f8 02	 sar	 eax, 2
  0008c	89 44 24 24	 mov	 DWORD PTR tv416[esp+24], eax
  00090	db 44 24 24	 fild	 DWORD PTR tv416[esp+24]
  00094	d8 c1		 fadd	 ST(0), ST(1)
  00096	eb 1c		 jmp	 SHORT $LN70@float_fun2
$LN20@float_fun2:
  00098	3b f8		 cmp	 edi, eax
  0009a	0f 85 34 01 00
	00		 jne	 $LN68@float_fun2
  000a0	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a3	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000a6	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _ints_to_double
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@float_fun2:

; 193  :    GET_FLOAT(t2,f2);

  000b4	8b c6		 mov	 eax, esi
  000b6	dd 54 24 14	 fst	 QWORD PTR _f1$[esp+28]
  000ba	83 e0 03	 and	 eax, 3
  000bd	83 f8 01	 cmp	 eax, 1
  000c0	75 0f		 jne	 SHORT $LN15@float_fun2
  000c2	c1 fe 02	 sar	 esi, 2
  000c5	89 74 24 24	 mov	 DWORD PTR tv409[esp+24], esi
  000c9	db 44 24 24	 fild	 DWORD PTR tv409[esp+24]
  000cd	de c2		 faddp	 ST(2), ST(0)
  000cf	eb 43		 jmp	 SHORT $LN9@float_fun2
$LN15@float_fun2:
  000d1	85 c0		 test	 eax, eax
  000d3	0f 85 e0 00 00
	00		 jne	 $LN52@float_fun2
  000d9	8b 06		 mov	 eax, DWORD PTR [esi]
  000db	8b c8		 mov	 ecx, eax
  000dd	80 e1 03	 and	 cl, 3
  000e0	80 f9 01	 cmp	 cl, 1
  000e3	75 0f		 jne	 SHORT $LN55@float_fun2
  000e5	c1 f8 02	 sar	 eax, 2
  000e8	89 44 24 24	 mov	 DWORD PTR tv408[esp+24], eax
  000ec	db 44 24 24	 fild	 DWORD PTR tv408[esp+24]
  000f0	de c2		 faddp	 ST(2), ST(0)
  000f2	eb 20		 jmp	 SHORT $LN9@float_fun2
$LN55@float_fun2:
  000f4	dd d9		 fstp	 ST(1)
  000f6	3b f8		 cmp	 edi, eax
  000f8	0f 85 d6 00 00
	00		 jne	 $LN68@float_fun2
  000fe	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00101	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00104	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00107	52		 push	 edx
  00108	50		 push	 eax
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 _ints_to_double
  0010f	d9 c9		 fxch	 ST(1)
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@float_fun2:

; 194  : 
; 195  : #if (TRACE>FLOAT_TRACE)
; 196  :    fprintf(STD_err,"FLOAT_FUN2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);
; 197  : #endif
; 198  : 
; 199  :   switch(opcode)

  00114	0f b6 c3	 movzx	 eax, bl
  00117	83 c0 9f	 add	 eax, -97		; ffffff9fH
  0011a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0011d	0f 87 89 00 00
	00		 ja	 $LN45@float_fun2
  00123	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN30@float_fun2[eax]
  0012a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@float_fun2[edx*4]
$LN5@float_fun2:

; 200  :   {
; 201  :     case 'p': EVAL_FLOAT(pow(f1,f2))

  00131	d9 c9		 fxch	 ST(1)
  00133	e8 00 00 00 00	 call	 __CIpow
  00138	eb 30		 jmp	 SHORT $LN6@float_fun2
$LN48@float_fun2:

; 194  : 
; 195  : #if (TRACE>FLOAT_TRACE)
; 196  :    fprintf(STD_err,"FLOAT_FUN2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);
; 197  : #endif
; 198  : 
; 199  :   switch(opcode)

  0013a	dd d8		 fstp	 ST(0)

; 202  :     case 'l': EVAL_FLOAT(log(f2)/log(f1))

  0013c	e8 00 00 00 00	 call	 __CIlog
  00141	dd 5c 24 0c	 fstp	 QWORD PTR tv358[esp+28]
  00145	dd 44 24 14	 fld	 QWORD PTR _f1$[esp+28]
  00149	e8 00 00 00 00	 call	 __CIlog
  0014e	dc 7c 24 0c	 fdivr	 QWORD PTR tv358[esp+28]
  00152	eb 16		 jmp	 SHORT $LN6@float_fun2
$LN3@float_fun2:

; 203  :     case 'a': EVAL_FLOAT(atan2(f1,f2))

  00154	d9 c9		 fxch	 ST(1)
  00156	e8 00 00 00 00	 call	 __CIatan2
  0015b	eb 0d		 jmp	 SHORT $LN6@float_fun2
$LN2@float_fun2:

; 204  :     /*case 'h': EVAL_FLOAT(hypot(f1,f2)) seems buggy under Solaris 2.4 */
; 205  : 
; 206  :     case 'h': EVAL_FLOAT(sqrt(f1*f1+f2*f2))

  0015d	d9 c1		 fld	 ST(1)
  0015f	de ca		 fmulp	 ST(2), ST(0)
  00161	dc c8		 fmul	 ST(0), ST(0)
  00163	de c1		 faddp	 ST(1), ST(0)
  00165	e8 00 00 00 00	 call	 __CIsqrt
$LN6@float_fun2:

; 207  : 
; 208  :     default: return 0;
; 209  :   }
; 210  :   PUT_FLOAT(f);

  0016a	8d 44 24 14	 lea	 eax, DWORD PTR _i3$[esp+28]
  0016e	50		 push	 eax
  0016f	8d 4c 24 10	 lea	 ecx, DWORD PTR _i2$[esp+32]
  00173	51		 push	 ecx
  00174	8d 54 24 2c	 lea	 edx, DWORD PTR _i1$[esp+32]
  00178	52		 push	 edx
  00179	83 ec 08	 sub	 esp, 8
  0017c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0017f	e8 00 00 00 00	 call	 _double_to_ints
  00184	8b 44 24 34	 mov	 eax, DWORD PTR _H$[esp+44]
  00188	8b 4c 24 38	 mov	 ecx, DWORD PTR _i1$[esp+44]
  0018c	8b 54 24 20	 mov	 edx, DWORD PTR _i2$[esp+48]
  00190	83 c4 14	 add	 esp, 20			; 00000014H
  00193	89 38		 mov	 DWORD PTR [eax], edi
  00195	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00198	8b 4c 24 14	 mov	 ecx, DWORD PTR _i3$[esp+28]
  0019c	5f		 pop	 edi
  0019d	5b		 pop	 ebx
  0019e	89 50 08	 mov	 DWORD PTR [eax+8], edx
  001a1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001a4	83 c0 10	 add	 eax, 16			; 00000010H
  001a7	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  001a8	83 c4 10	 add	 esp, 16			; 00000010H
  001ab	c3		 ret	 0
$LN45@float_fun2:
  001ac	5f		 pop	 edi

; 194  : 
; 195  : #if (TRACE>FLOAT_TRACE)
; 196  :    fprintf(STD_err,"FLOAT_FUN2: opcode=%u f1=%f f2=%f\n",opcode,f1,f2);
; 197  : #endif
; 198  : 
; 199  :   switch(opcode)

  001ad	dd d9		 fstp	 ST(1)
  001af	5b		 pop	 ebx
  001b0	dd d8		 fstp	 ST(0)
  001b2	33 c0		 xor	 eax, eax
  001b4	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  001b5	83 c4 10	 add	 esp, 16			; 00000010H
  001b8	c3		 ret	 0
$LN52@float_fun2:

; 193  :    GET_FLOAT(t2,f2);

  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@
  001be	dd d8		 fstp	 ST(0)
  001c0	56		 push	 esi
  001c1	dd d8		 fstp	 ST(0)
  001c3	e8 00 00 00 00	 call	 _bad_arith_arg
  001c8	83 c4 08	 add	 esp, 8
  001cb	5f		 pop	 edi
  001cc	5b		 pop	 ebx
  001cd	33 c0		 xor	 eax, eax
  001cf	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  001d0	83 c4 10	 add	 esp, 16			; 00000010H
  001d3	c3		 ret	 0
$LN68@float_fun2:

; 191  : 
; 192  :    GET_FLOAT(t1,f1);

  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_02GNMIELFD@?$DN?$DO?$AA@
  001d9	dd d8		 fstp	 ST(0)
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 _bad_arith_arg
  001e1	83 c4 08	 add	 esp, 8
  001e4	5f		 pop	 edi
  001e5	5b		 pop	 ebx
  001e6	33 c0		 xor	 eax, eax
  001e8	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  001e9	83 c4 10	 add	 esp, 16			; 00000010H
  001ec	c3		 ret	 0
$LN62@float_fun2:

; 191  : 
; 192  :    GET_FLOAT(t1,f1);

  001ed	68 00 00 00 00	 push	 OFFSET ??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@
  001f2	dd d8		 fstp	 ST(0)
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 _bad_arith_arg
  001fa	83 c4 08	 add	 esp, 8
  001fd	5f		 pop	 edi
  001fe	5b		 pop	 ebx
  001ff	33 c0		 xor	 eax, eax
  00201	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  00202	83 c4 10	 add	 esp, 16			; 00000010H
  00205	c3		 ret	 0
$LN24@float_fun2:

; 187  :    double f1,f2,f; no i1,i2,i3; byte opcode;
; 188  : 
; 189  :    ATOMIZE(xval); if(!SYMCONST(xval)) return NULL;

  00206	33 c0		 xor	 eax, eax
  00208	5e		 pop	 esi

; 211  :   return H;
; 212  : }

  00209	83 c4 10	 add	 esp, 16			; 00000010H
  0020c	c3		 ret	 0
  0020d	8d 49 00	 npad	 3
$LN73@float_fun2:
  00210	00 00 00 00	 DD	 $LN3@float_fun2
  00214	00 00 00 00	 DD	 $LN2@float_fun2
  00218	00 00 00 00	 DD	 $LN48@float_fun2
  0021c	00 00 00 00	 DD	 $LN5@float_fun2
  00220	00 00 00 00	 DD	 $LN45@float_fun2
$LN30@float_fun2:
  00224	00		 DB	 0
  00225	04		 DB	 4
  00226	04		 DB	 4
  00227	04		 DB	 4
  00228	04		 DB	 4
  00229	04		 DB	 4
  0022a	04		 DB	 4
  0022b	01		 DB	 1
  0022c	04		 DB	 4
  0022d	04		 DB	 4
  0022e	04		 DB	 4
  0022f	02		 DB	 2
  00230	04		 DB	 4
  00231	04		 DB	 4
  00232	04		 DB	 4
  00233	03		 DB	 3
_float_fun2 ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_float_fun
EXTRN	__CIacos:PROC
EXTRN	__CIasin:PROC
EXTRN	__CIatan:PROC
EXTRN	__CItan:PROC
EXTRN	__CIcos:PROC
EXTRN	__CIsin:PROC
EXTRN	__CIexp:PROC
EXTRN	_floor:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _float_fun
_TEXT	SEGMENT
tv374 = -12						; size = 4
_i2$ = -12						; size = 4
tv372 = -8						; size = 8
_i3$ = -8						; size = 4
_H$ = 8							; size = 4
tv394 = 12						; size = 4
tv393 = 12						; size = 4
tv377 = 12						; size = 2
_i1$ = 12						; size = 4
_regs$ = 12						; size = 4
_float_fun PROC						; COMDAT

; 215  : { cell xval=X(1); term t1=C2T(X(2)),xref;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _regs$[esp-4]
  00004	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00007	8b 49 f8	 mov	 ecx, DWORD PTR [ecx-8]

; 216  :   double f1,f; no i1,i2,i3; byte opcode;
; 217  :    ATOMIZE(xval);

  0000a	8b d0		 mov	 edx, eax
  0000c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000f	83 e2 03	 and	 edx, 3
  00012	74 0c		 je	 SHORT $LN30@float_fun
  00014	83 fa 01	 cmp	 edx, 1
  00017	74 09		 je	 SHORT $LN26@float_fun
  00019	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  0001e	74 02		 je	 SHORT $LN26@float_fun
$LN30@float_fun:
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@float_fun:

; 218  :    if(!SYMCONST(xval)) return NULL;

  00022	8b d0		 mov	 edx, eax
  00024	83 e2 03	 and	 edx, 3
  00027	80 fa 03	 cmp	 dl, 3
  0002a	0f 85 c3 01 00
	00		 jne	 $LN23@float_fun
  00030	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00035	0f 85 b8 01 00
	00		 jne	 $LN23@float_fun

; 219  :    opcode = *NAME(xval);

  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atomtable

; 220  :    GET_FLOAT(t1,f1);

  00041	d9 ee		 fldz
  00043	c1 e8 02	 shr	 eax, 2
  00046	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  0004b	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0004e	53		 push	 ebx
  0004f	8a 18		 mov	 bl, BYTE PTR [eax]
  00051	8b c1		 mov	 eax, ecx
  00053	83 e0 03	 and	 eax, 3
  00056	56		 push	 esi
  00057	8b 35 94 00 00
	00		 mov	 esi, DWORD PTR _g+148
  0005d	83 f8 01	 cmp	 eax, 1
  00060	75 0f		 jne	 SHORT $LN22@float_fun
  00062	c1 f9 02	 sar	 ecx, 2
  00065	89 4c 24 1c	 mov	 DWORD PTR tv394[esp+16], ecx
  00069	db 44 24 1c	 fild	 DWORD PTR tv394[esp+16]
  0006d	d8 c1		 fadd	 ST(0), ST(1)
  0006f	eb 3f		 jmp	 SHORT $LN16@float_fun
$LN22@float_fun:
  00071	85 c0		 test	 eax, eax
  00073	0f 85 62 01 00
	00		 jne	 $LN56@float_fun
  00079	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007b	8b d0		 mov	 edx, eax
  0007d	80 e2 03	 and	 dl, 3
  00080	80 fa 01	 cmp	 dl, 1
  00083	75 0f		 jne	 SHORT $LN19@float_fun
  00085	c1 f8 02	 sar	 eax, 2
  00088	89 44 24 1c	 mov	 DWORD PTR tv393[esp+16], eax
  0008c	db 44 24 1c	 fild	 DWORD PTR tv393[esp+16]
  00090	d8 c1		 fadd	 ST(0), ST(1)
  00092	eb 1c		 jmp	 SHORT $LN16@float_fun
$LN19@float_fun:
  00094	3b f0		 cmp	 esi, eax
  00096	0f 85 27 01 00
	00		 jne	 $LN62@float_fun
  0009c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0009f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a2	50		 push	 eax
  000a3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a6	52		 push	 edx
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _ints_to_double
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  000b0	0f b6 c3	 movzx	 eax, bl
  000b3	83 c0 bd	 add	 eax, -67		; ffffffbdH
  000b6	83 f8 31	 cmp	 eax, 49			; 00000031H
  000b9	0f 87 f8 00 00
	00		 ja	 $LN40@float_fun
  000bf	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN29@float_fun[eax]
  000c6	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN66@float_fun[ecx*4]
$LN12@float_fun:

; 225  :   {
; 226  :     case 'i': if(f1<0) f1++; /* SICStus but not SWI compatible */

  000cd	d8 d1		 fcom	 ST(1)
  000cf	df e0		 fnstsw	 ax
  000d1	dd d9		 fstp	 ST(1)
  000d3	f6 c4 05	 test	 ah, 5
  000d6	7a 06		 jp	 SHORT $LN11@float_fun
  000d8	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
$LN11@float_fun:

; 227  :               i1=(no)floor(f1);

  000de	83 ec 08	 sub	 esp, 8
  000e1	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e4	e8 00 00 00 00	 call	 _floor
  000e9	d9 7c 24 24	 fnstcw	 WORD PTR tv377[esp+24]
  000ed	0f b7 44 24 24	 movzx	 eax, WORD PTR tv377[esp+24]
  000f2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000f7	89 44 24 10	 mov	 DWORD PTR tv374[esp+28], eax
  000fb	83 c4 08	 add	 esp, 8
  000fe	d9 6c 24 08	 fldcw	 WORD PTR tv374[esp+20]
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	df 7c 24 04	 fistp	 QWORD PTR tv372[esp+12]
  00108	8b 44 24 04	 mov	 eax, DWORD PTR tv372[esp+12]

; 228  :               SETCELL(H++,INPUT_INT(i1)); return H;

  0010c	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00113	8b 44 24 10	 mov	 eax, DWORD PTR _H$[esp+8]
  00117	83 ca 01	 or	 edx, 1
  0011a	d9 6c 24 14	 fldcw	 WORD PTR tv377[esp+8]
  0011e	89 10		 mov	 DWORD PTR [eax], edx
  00120	83 c0 04	 add	 eax, 4

; 241  :   return H;
; 242  : }

  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
  00126	c3		 ret	 0
$LN49@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00127	dd d9		 fstp	 ST(1)

; 229  :     case 'e': EVAL_FLOAT(exp(f1))

  00129	e8 00 00 00 00	 call	 __CIexp
  0012e	eb 46		 jmp	 SHORT $LN13@float_fun
$LN48@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00130	dd d9		 fstp	 ST(1)

; 230  :     case 'l': EVAL_FLOAT(log(f1))

  00132	e8 00 00 00 00	 call	 __CIlog
  00137	eb 3d		 jmp	 SHORT $LN13@float_fun
$LN47@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00139	dd d9		 fstp	 ST(1)

; 231  :     case 's': EVAL_FLOAT(sin(f1))

  0013b	e8 00 00 00 00	 call	 __CIsin
  00140	eb 34		 jmp	 SHORT $LN13@float_fun
$LN46@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00142	dd d9		 fstp	 ST(1)

; 232  :     case 'c': EVAL_FLOAT(cos(f1))

  00144	e8 00 00 00 00	 call	 __CIcos
  00149	eb 2b		 jmp	 SHORT $LN13@float_fun
$LN45@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  0014b	dd d9		 fstp	 ST(1)

; 233  :     case 't': EVAL_FLOAT(tan(f1))

  0014d	e8 00 00 00 00	 call	 __CItan
  00152	eb 22		 jmp	 SHORT $LN13@float_fun
$LN44@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00154	dd d9		 fstp	 ST(1)

; 234  :     case 'T': EVAL_FLOAT(atan(f1))

  00156	e8 00 00 00 00	 call	 __CIatan
  0015b	eb 19		 jmp	 SHORT $LN13@float_fun
$LN43@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  0015d	dd d9		 fstp	 ST(1)

; 235  :     case 'S': EVAL_FLOAT(asin(f1))

  0015f	e8 00 00 00 00	 call	 __CIasin
  00164	eb 10		 jmp	 SHORT $LN13@float_fun
$LN42@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  00166	dd d9		 fstp	 ST(1)

; 236  :     case 'C': EVAL_FLOAT(acos(f1))

  00168	e8 00 00 00 00	 call	 __CIacos
  0016d	eb 07		 jmp	 SHORT $LN13@float_fun
$LN41@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  0016f	dd d9		 fstp	 ST(1)

; 237  :     case 'Q': EVAL_FLOAT(sqrt(f1))

  00171	e8 00 00 00 00	 call	 __CIsqrt
$LN13@float_fun:

; 238  :     default: return 0;
; 239  :   }
; 240  :   PUT_FLOAT(f);

  00176	8d 44 24 0c	 lea	 eax, DWORD PTR _i3$[esp+20]
  0017a	50		 push	 eax
  0017b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _i2$[esp+24]
  0017f	51		 push	 ecx
  00180	8d 54 24 24	 lea	 edx, DWORD PTR _i1$[esp+24]
  00184	52		 push	 edx
  00185	83 ec 08	 sub	 esp, 8
  00188	dd 1c 24	 fstp	 QWORD PTR [esp]
  0018b	e8 00 00 00 00	 call	 _double_to_ints
  00190	8b 44 24 2c	 mov	 eax, DWORD PTR _H$[esp+36]
  00194	8b 4c 24 30	 mov	 ecx, DWORD PTR _i1$[esp+36]
  00198	8b 54 24 1c	 mov	 edx, DWORD PTR _i2$[esp+40]
  0019c	83 c4 14	 add	 esp, 20			; 00000014H
  0019f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001a2	8b 4c 24 0c	 mov	 ecx, DWORD PTR _i3$[esp+20]
  001a6	89 30		 mov	 DWORD PTR [eax], esi
  001a8	5e		 pop	 esi
  001a9	89 50 08	 mov	 DWORD PTR [eax+8], edx
  001ac	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001af	83 c0 10	 add	 eax, 16			; 00000010H
  001b2	5b		 pop	 ebx

; 241  :   return H;
; 242  : }

  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	c3		 ret	 0
$LN40@float_fun:

; 221  : #if TRACE>FLOAT_TRACE
; 222  :   fprintf(STD_err,"FLOAT_FUN: opcode=%u f1=%f\n",opcode,f1);
; 223  : #endif
; 224  :   switch(opcode)

  001b7	dd d8		 fstp	 ST(0)
  001b9	5e		 pop	 esi
  001ba	dd d8		 fstp	 ST(0)
  001bc	33 c0		 xor	 eax, eax
  001be	5b		 pop	 ebx

; 241  :   return H;
; 242  : }

  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c2	c3		 ret	 0
$LN62@float_fun:

; 220  :    GET_FLOAT(t1,f1);

  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_02GNMIELFD@?$DN?$DO?$AA@
  001c8	dd d8		 fstp	 ST(0)
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _bad_arith_arg
  001d0	83 c4 08	 add	 esp, 8
  001d3	5e		 pop	 esi
  001d4	33 c0		 xor	 eax, eax
  001d6	5b		 pop	 ebx

; 241  :   return H;
; 242  : }

  001d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001da	c3		 ret	 0
$LN56@float_fun:

; 220  :    GET_FLOAT(t1,f1);

  001db	68 00 00 00 00	 push	 OFFSET ??_C@_03LBIMGNCB@?$DN?$DN?$DO?$AA@
  001e0	dd d8		 fstp	 ST(0)
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 _bad_arith_arg
  001e8	83 c4 08	 add	 esp, 8
  001eb	5e		 pop	 esi
  001ec	33 c0		 xor	 eax, eax
  001ee	5b		 pop	 ebx

; 241  :   return H;
; 242  : }

  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f2	c3		 ret	 0
$LN23@float_fun:

; 218  :    if(!SYMCONST(xval)) return NULL;

  001f3	33 c0		 xor	 eax, eax

; 241  :   return H;
; 242  : }

  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	c3		 ret	 0
  001f9	8d 49 00	 npad	 3
$LN66@float_fun:
  001fc	00 00 00 00	 DD	 $LN42@float_fun
  00200	00 00 00 00	 DD	 $LN41@float_fun
  00204	00 00 00 00	 DD	 $LN43@float_fun
  00208	00 00 00 00	 DD	 $LN44@float_fun
  0020c	00 00 00 00	 DD	 $LN46@float_fun
  00210	00 00 00 00	 DD	 $LN49@float_fun
  00214	00 00 00 00	 DD	 $LN12@float_fun
  00218	00 00 00 00	 DD	 $LN48@float_fun
  0021c	00 00 00 00	 DD	 $LN47@float_fun
  00220	00 00 00 00	 DD	 $LN45@float_fun
  00224	00 00 00 00	 DD	 $LN40@float_fun
$LN29@float_fun:
  00228	00		 DB	 0
  00229	0a		 DB	 10			; 0000000aH
  0022a	0a		 DB	 10			; 0000000aH
  0022b	0a		 DB	 10			; 0000000aH
  0022c	0a		 DB	 10			; 0000000aH
  0022d	0a		 DB	 10			; 0000000aH
  0022e	0a		 DB	 10			; 0000000aH
  0022f	0a		 DB	 10			; 0000000aH
  00230	0a		 DB	 10			; 0000000aH
  00231	0a		 DB	 10			; 0000000aH
  00232	0a		 DB	 10			; 0000000aH
  00233	0a		 DB	 10			; 0000000aH
  00234	0a		 DB	 10			; 0000000aH
  00235	0a		 DB	 10			; 0000000aH
  00236	01		 DB	 1
  00237	0a		 DB	 10			; 0000000aH
  00238	02		 DB	 2
  00239	03		 DB	 3
  0023a	0a		 DB	 10			; 0000000aH
  0023b	0a		 DB	 10			; 0000000aH
  0023c	0a		 DB	 10			; 0000000aH
  0023d	0a		 DB	 10			; 0000000aH
  0023e	0a		 DB	 10			; 0000000aH
  0023f	0a		 DB	 10			; 0000000aH
  00240	0a		 DB	 10			; 0000000aH
  00241	0a		 DB	 10			; 0000000aH
  00242	0a		 DB	 10			; 0000000aH
  00243	0a		 DB	 10			; 0000000aH
  00244	0a		 DB	 10			; 0000000aH
  00245	0a		 DB	 10			; 0000000aH
  00246	0a		 DB	 10			; 0000000aH
  00247	0a		 DB	 10			; 0000000aH
  00248	04		 DB	 4
  00249	0a		 DB	 10			; 0000000aH
  0024a	05		 DB	 5
  0024b	0a		 DB	 10			; 0000000aH
  0024c	0a		 DB	 10			; 0000000aH
  0024d	0a		 DB	 10			; 0000000aH
  0024e	06		 DB	 6
  0024f	0a		 DB	 10			; 0000000aH
  00250	0a		 DB	 10			; 0000000aH
  00251	07		 DB	 7
  00252	0a		 DB	 10			; 0000000aH
  00253	0a		 DB	 10			; 0000000aH
  00254	0a		 DB	 10			; 0000000aH
  00255	0a		 DB	 10			; 0000000aH
  00256	0a		 DB	 10			; 0000000aH
  00257	0a		 DB	 10			; 0000000aH
  00258	08		 DB	 8
  00259	09		 DB	 9
_float_fun ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@HHIOKNCM@?$CFld?$CF?9se?$CF?9ld?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_input_float
EXTRN	_atof:PROC
EXTRN	_sprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0N@HHIOKNCM@?$CFld?$CF?9se?$CF?9ld?5?$AA@
CONST	SEGMENT
??_C@_0N@HHIOKNCM@?$CFld?$CF?9se?$CF?9ld?5?$AA@ DB '%ld%-se%-ld ', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _input_float
_TEXT	SEGMENT
_i2$ = -272						; size = 4
_i3$ = -268						; size = 4
_i1$ = -264						; size = 4
_sbuf$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_H$ = 8							; size = 4
_regs$ = 12						; size = 4
_wam$ = 16						; size = 4
_input_float PROC					; COMDAT

; 246  : { no i1,i2,i3; double f;

  00000	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+272], eax
  00014	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR _regs$[esp+268]

; 247  :   char sbuf[255];
; 248  :   ATOMIZE(X(1)); ATOMIZE(X(2)); ATOMIZE(X(3));

  0001b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001e	56		 push	 esi
  0001f	8b d1		 mov	 edx, ecx
  00021	83 e2 03	 and	 edx, 3
  00024	57		 push	 edi
  00025	8b bc 24 1c 01
	00 00		 mov	 edi, DWORD PTR _H$[esp+276]
  0002c	74 0d		 je	 SHORT $LN7@input_floa
  0002e	83 fa 01	 cmp	 edx, 1
  00031	74 0d		 je	 SHORT $LN8@input_floa
  00033	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00039	74 05		 je	 SHORT $LN8@input_floa
$LN7@input_floa:
  0003b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN8@input_floa:
  00040	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  00043	8b d1		 mov	 edx, ecx
  00045	83 e2 03	 and	 edx, 3
  00048	74 0d		 je	 SHORT $LN5@input_floa
  0004a	83 fa 01	 cmp	 edx, 1
  0004d	74 0d		 je	 SHORT $LN6@input_floa
  0004f	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00055	74 05		 je	 SHORT $LN6@input_floa
$LN5@input_floa:
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	89 50 f8	 mov	 DWORD PTR [eax-8], edx
$LN6@input_floa:
  0005c	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  0005f	8b d1		 mov	 edx, ecx
  00061	83 e2 03	 and	 edx, 3
  00064	74 0d		 je	 SHORT $LN3@input_floa
  00066	83 fa 01	 cmp	 edx, 1
  00069	74 0d		 je	 SHORT $LN4@input_floa
  0006b	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00071	74 05		 je	 SHORT $LN4@input_floa
$LN3@input_floa:
  00073	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00075	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
$LN4@input_floa:

; 249  :   if(!(INTEGER(X(1)) && SYMCONST(X(2)) && INTEGER( X(3) ))) return FALSE;

  00078	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  0007b	8b d6		 mov	 edx, esi
  0007d	80 e2 03	 and	 dl, 3
  00080	80 fa 01	 cmp	 dl, 1
  00083	0f 85 b6 00 00
	00		 jne	 $LN1@input_floa
  00089	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  0008c	8b d1		 mov	 edx, ecx
  0008e	83 e2 03	 and	 edx, 3
  00091	80 fa 03	 cmp	 dl, 3
  00094	0f 85 a5 00 00
	00		 jne	 $LN1@input_floa
  0009a	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  000a0	0f 85 99 00 00
	00		 jne	 $LN1@input_floa
  000a6	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  000a9	8b d0		 mov	 edx, eax
  000ab	80 e2 03	 and	 dl, 3
  000ae	80 fa 01	 cmp	 dl, 1
  000b1	0f 85 88 00 00
	00		 jne	 $LN1@input_floa

; 250  :   sprintf(sbuf,"%ld%-se%-ld ",
; 251  :     OUTPUT_INT(X(1)),NAME(X(2)),OUTPUT_INT(X(3)));

  000b7	c1 f8 02	 sar	 eax, 2
  000ba	50		 push	 eax
  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atomtable
  000c0	c1 e9 02	 shr	 ecx, 2
  000c3	81 e1 ff ff 3f
	00		 and	 ecx, 4194303		; 003fffffH
  000c9	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  000cc	51		 push	 ecx
  000cd	c1 fe 02	 sar	 esi, 2
  000d0	56		 push	 esi
  000d1	8d 54 24 20	 lea	 edx, DWORD PTR _sbuf$[esp+292]
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HHIOKNCM@?$CFld?$CF?9se?$CF?9ld?5?$AA@
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 _sprintf
  000e0	83 c4 14	 add	 esp, 20			; 00000014H

; 252  : #if TRACE>FLOAT_TRACE
; 253  :   fprintf(STD_err,"input_float: <%s>\n",sbuf);
; 254  : #endif
; 255  :   f=atof(sbuf);
; 256  :   double_to_ints(f,&i1,&i2,&i3);

  000e3	8d 44 24 0c	 lea	 eax, DWORD PTR _i3$[esp+280]
  000e7	50		 push	 eax
  000e8	8d 4c 24 0c	 lea	 ecx, DWORD PTR _i2$[esp+284]
  000ec	51		 push	 ecx
  000ed	8d 54 24 18	 lea	 edx, DWORD PTR _i1$[esp+288]
  000f1	52		 push	 edx
  000f2	8d 44 24 20	 lea	 eax, DWORD PTR _sbuf$[esp+292]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _atof
  000fc	51		 push	 ecx
  000fd	dd 1c 24	 fstp	 QWORD PTR [esp]
  00100	e8 00 00 00 00	 call	 _double_to_ints

; 257  :   MAKE_FLOAT(i1,i2,i3);

  00105	8b 0d 94 00 00
	00		 mov	 ecx, DWORD PTR _g+148
  0010b	8b 44 24 1c	 mov	 eax, DWORD PTR _i2$[esp+300]
  0010f	8b 54 24 24	 mov	 edx, DWORD PTR _i1$[esp+300]
  00113	89 0f		 mov	 DWORD PTR [edi], ecx
  00115	8b 4c 24 20	 mov	 ecx, DWORD PTR _i3$[esp+300]
  00119	83 c4 14	 add	 esp, 20			; 00000014H
  0011c	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0011f	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00122	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  00125	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi

; 258  :   return H;
; 259  : }

  0012a	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+272]
  00131	33 cc		 xor	 ecx, esp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  0013e	c3		 ret	 0
$LN1@input_floa:
  0013f	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+280]
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	33 cc		 xor	 ecx, esp
  0014a	33 c0		 xor	 eax, eax
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  00157	c3		 ret	 0
_input_float ENDP
_TEXT	ENDS
END
