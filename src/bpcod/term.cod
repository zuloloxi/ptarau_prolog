; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A17\prolog\ptarau_prolog\src\term.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
_DATA	SEGMENT
_sNIL	DD	FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
_DATA	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
PUBLIC	_newTerm
EXTRN	_malloc:PROC
; Function compile flags: /Ogtpy
; File c:\a17\prolog\ptarau_prolog\src\term.c
;	COMDAT _newTerm
_TEXT	SEGMENT
_arity$ = 8						; size = 4
_newTerm PROC						; COMDAT

; 70   : Term newTerm(bp_long arity) {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 71   :   Term T=(Term)malloc(sizeof(struct Term));

  00003	6a 0c		 push	 12			; 0000000cH
  00005	e8 00 00 00 00	 call	 _malloc

; 72   :   /* range=0..arity, 0=functor, 1..arity=args */
; 73   :   T->size=arity+1;

  0000a	8b 74 24 14	 mov	 esi, DWORD PTR _arity$[esp+12]
  0000e	46		 inc	 esi
  0000f	8b f8		 mov	 edi, eax

; 74   :   T->types=(BYTE*)malloc(T->size*sizeof(BYTE));

  00011	56		 push	 esi
  00012	89 37		 mov	 DWORD PTR [edi], esi
  00014	e8 00 00 00 00	 call	 _malloc
  00019	8b d8		 mov	 ebx, eax

; 75   :   T->args=(OBJECT*)malloc(T->size*sizeof(OBJECT));

  0001b	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*4]
  00022	50		 push	 eax
  00023	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00026	e8 00 00 00 00	 call	 _malloc
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   :   {bp_long i;
; 77   :    for(i=0;i<T->size;i++) {

  0002e	33 c9		 xor	 ecx, ecx
  00030	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00033	85 f6		 test	 esi, esi
  00035	7e 19		 jle	 SHORT $LN8@newTerm
  00037	8b d6		 mov	 edx, esi
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL3@newTerm:

; 78   :      T->types[i]=(BYTE)BAD_TYPE;

  00040	c6 04 0b 00	 mov	 BYTE PTR [ebx+ecx], 0

; 79   :      T->args[i]=NULL;

  00044	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
  0004b	41		 inc	 ecx
  0004c	3b ca		 cmp	 ecx, edx
  0004e	7c f0		 jl	 SHORT $LL3@newTerm
$LN8@newTerm:

; 80   :    }
; 81   :   }
; 82   :   return T;

  00050	8b c7		 mov	 eax, edi
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 83   : }

  00055	c3		 ret	 0
_newTerm ENDP
_TEXT	ENDS
PUBLIC	_S2O
; Function compile flags: /Ogtpy
;	COMDAT _S2O
_TEXT	SEGMENT
_s$ = 8							; size = 4
_S2O	PROC						; COMDAT

; 86   :   return (OBJECT)s;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _s$[esp-4]

; 87   : }

  00004	c3		 ret	 0
_S2O	ENDP
_TEXT	ENDS
PUBLIC	_I2O
; Function compile flags: /Ogtpy
;	COMDAT _I2O
_TEXT	SEGMENT
_l$ = 8							; size = 4
_I2O	PROC						; COMDAT

; 90   :   return (OBJECT)l;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _l$[esp-4]

; 91   : }

  00004	c3		 ret	 0
_I2O	ENDP
_TEXT	ENDS
PUBLIC	_V2O
; Function compile flags: /Ogtpy
;	COMDAT _V2O
_TEXT	SEGMENT
_v$ = 8							; size = 4
_V2O	PROC						; COMDAT

; 94   :   return (OBJECT)v;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _v$[esp-4]

; 95   : }

  00004	c3		 ret	 0
_V2O	ENDP
_TEXT	ENDS
PUBLIC	_F2O
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _F2O
_TEXT	SEGMENT
_l$ = 8							; size = 4
_x$ = 8							; size = 8
_F2O	PROC						; COMDAT

; 98   :   ulong l; float *f=(float*)&l; *f=(float)x;

  00000	dd 44 24 04	 fld	 QWORD PTR _x$[esp-4]
  00004	d9 5c 24 04	 fstp	 DWORD PTR _l$[esp-4]

; 99   :   return (OBJECT)l;

  00008	8b 44 24 04	 mov	 eax, DWORD PTR _l$[esp-4]

; 100  : }

  0000c	c3		 ret	 0
_F2O	ENDP
_TEXT	ENDS
PUBLIC	_T2O
; Function compile flags: /Ogtpy
;	COMDAT _T2O
_TEXT	SEGMENT
_T$ = 8							; size = 4
_T2O	PROC						; COMDAT

; 103  :   return (OBJECT)T;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _T$[esp-4]

; 104  : }

  00004	c3		 ret	 0
_T2O	ENDP
_TEXT	ENDS
PUBLIC	_O2S
; Function compile flags: /Ogtpy
;	COMDAT _O2S
_TEXT	SEGMENT
_O$ = 8							; size = 4
_O2S	PROC						; COMDAT

; 107  :   return (char *)O;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _O$[esp-4]

; 108  : }

  00004	c3		 ret	 0
_O2S	ENDP
_TEXT	ENDS
PUBLIC	_O2I
; Function compile flags: /Ogtpy
;	COMDAT _O2I
_TEXT	SEGMENT
_O$ = 8							; size = 4
_O2I	PROC						; COMDAT

; 111  :   return (bp_long)O;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _O$[esp-4]

; 112  : }

  00004	c3		 ret	 0
_O2I	ENDP
_TEXT	ENDS
PUBLIC	_O2V
; Function compile flags: /Ogtpy
;	COMDAT _O2V
_TEXT	SEGMENT
_O$ = 8							; size = 4
_O2V	PROC						; COMDAT

; 115  :   return (ulong)O;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _O$[esp-4]

; 116  : }

  00004	c3		 ret	 0
_O2V	ENDP
_TEXT	ENDS
PUBLIC	_O2F
; Function compile flags: /Ogtpy
;	COMDAT _O2F
_TEXT	SEGMENT
_l$ = 8							; size = 4
_O$ = 8							; size = 4
_O2F	PROC						; COMDAT

; 119  :   ulong l=(ulong)O; 

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _O$[esp-4]
  00004	89 44 24 04	 mov	 DWORD PTR _l$[esp-4], eax

; 120  :   float *f; f=(float*)&l;
; 121  :   return (double)*f;

  00008	d9 44 24 04	 fld	 DWORD PTR _l$[esp-4]

; 122  : }

  0000c	c3		 ret	 0
_O2F	ENDP
_TEXT	ENDS
PUBLIC	_O2T
; Function compile flags: /Ogtpy
;	COMDAT _O2T
_TEXT	SEGMENT
_O$ = 8							; size = 4
_O2T	PROC						; COMDAT

; 125  :   return (Term)O;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _O$[esp-4]

; 126  : }

  00004	c3		 ret	 0
_O2T	ENDP
_TEXT	ENDS
PUBLIC	_freeTerm
EXTRN	_free:PROC
EXTRN	_freeTermString:PROC
; Function compile flags: /Ogtpy
;	COMDAT _freeTerm
_TEXT	SEGMENT
_T$ = 8							; size = 4
_freeTerm PROC						; COMDAT

; 140  : void freeTerm(Term T) {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 141  :   bp_long i;
; 142  :    for(i=0;i<T->size;i++) {

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _T$[esp+4]
  00006	33 f6		 xor	 esi, esi
  00008	39 37		 cmp	 DWORD PTR [edi], esi
  0000a	7e 34		 jle	 SHORT $LN4@freeTerm
  0000c	8d 64 24 00	 npad	 4
$LL6@freeTerm:

; 143  :      BYTE type=T->types[i];

  00010	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00013	8a 04 06	 mov	 al, BYTE PTR [esi+eax]

; 144  :      if(TERM_TYPE==type) {

  00016	3c 05		 cmp	 al, 5
  00018	75 0e		 jne	 SHORT $LN3@freeTerm

; 145  :        Term X=O2T(T->args[i]);
; 146  :        freeTerm(X);

  0001a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001d	8b 14 b1	 mov	 edx, DWORD PTR [ecx+esi*4]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _freeTerm
  00026	eb 10		 jmp	 SHORT $LN15@freeTerm
$LN3@freeTerm:

; 147  :      }
; 148  :      else if(STRING_TYPE==type) {

  00028	3c 01		 cmp	 al, 1
  0002a	75 0f		 jne	 SHORT $LN5@freeTerm

; 149  :        char *s=O2S(T->args[i]);
; 150  :        freeTermString(s);

  0002c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0002f	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 _freeTermString
$LN15@freeTerm:
  00038	83 c4 04	 add	 esp, 4
$LN5@freeTerm:

; 141  :   bp_long i;
; 142  :    for(i=0;i<T->size;i++) {

  0003b	46		 inc	 esi
  0003c	3b 37		 cmp	 esi, DWORD PTR [edi]
  0003e	7c d0		 jl	 SHORT $LL6@freeTerm
$LN4@freeTerm:

; 151  :      }
; 152  :    }
; 153  :    free(T->types);

  00040	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 _free

; 154  :    free(T->args);

  00049	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _free

; 155  :    free(T);

  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 _free
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi

; 156  : }

  0005d	c3		 ret	 0
_freeTerm ENDP
_TEXT	ENDS
PUBLIC	_getArity
; Function compile flags: /Ogtpy
;	COMDAT _getArity
_TEXT	SEGMENT
_T$ = 8							; size = 4
_getArity PROC						; COMDAT

; 159  :   return T->size-1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _T$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	48		 dec	 eax

; 160  : }

  00007	c3		 ret	 0
_getArity ENDP
_TEXT	ENDS
PUBLIC	_setArg
EXTRN	_newTermString:PROC
; Function compile flags: /Ogtpy
;	COMDAT _setArg
_TEXT	SEGMENT
_i$ = 8							; size = 4
_T$ = 12						; size = 4
_termType$ = 16						; size = 1
_arg$ = 20						; size = 4
_setArg	PROC						; COMDAT

; 162  : BYTE setArg(bp_long i,Term T,BYTE termType,OBJECT arg) {

  00000	56		 push	 esi

; 163  :   if(i<0 || i>=T->size || termType>LAST_TYPE || termType==BAD_TYPE) return FALSE;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _i$[esp]
  00005	57		 push	 edi
  00006	85 f6		 test	 esi, esi
  00008	78 45		 js	 SHORT $LN2@setArg
  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR _T$[esp+4]
  0000e	3b 37		 cmp	 esi, DWORD PTR [edi]
  00010	7d 3d		 jge	 SHORT $LN2@setArg
  00012	8a 44 24 14	 mov	 al, BYTE PTR _termType$[esp+4]
  00016	3c 05		 cmp	 al, 5
  00018	77 35		 ja	 SHORT $LN2@setArg
  0001a	84 c0		 test	 al, al
  0001c	74 31		 je	 SHORT $LN2@setArg

; 164  :   
; 165  :   T->types[i]=termType;

  0001e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00021	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 166  :   if(STRING_TYPE==termType) arg=S2O(newTermString(O2S(arg)));

  00024	3c 01		 cmp	 al, 1
  00026	75 18		 jne	 SHORT $LN10@setArg
  00028	8b 54 24 18	 mov	 edx, DWORD PTR _arg$[esp+4]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 _newTermString

; 167  :   T->args[i]=arg;

  00032	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00035	83 c4 04	 add	 esp, 4
  00038	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  0003b	5f		 pop	 edi

; 168  :   return TRUE;

  0003c	b0 01		 mov	 al, 1
  0003e	5e		 pop	 esi

; 169  : }

  0003f	c3		 ret	 0
$LN10@setArg:

; 166  :   if(STRING_TYPE==termType) arg=S2O(newTermString(O2S(arg)));

  00040	8b 44 24 18	 mov	 eax, DWORD PTR _arg$[esp+4]

; 167  :   T->args[i]=arg;

  00044	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00047	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  0004a	5f		 pop	 edi

; 168  :   return TRUE;

  0004b	b0 01		 mov	 al, 1
  0004d	5e		 pop	 esi

; 169  : }

  0004e	c3		 ret	 0
$LN2@setArg:
  0004f	5f		 pop	 edi

; 163  :   if(i<0 || i>=T->size || termType>LAST_TYPE || termType==BAD_TYPE) return FALSE;

  00050	32 c0		 xor	 al, al
  00052	5e		 pop	 esi

; 169  : }

  00053	c3		 ret	 0
_setArg	ENDP
_TEXT	ENDS
PUBLIC	_getType
; Function compile flags: /Ogtpy
;	COMDAT _getType
_TEXT	SEGMENT
_i$ = 8							; size = 4
_T$ = 12						; size = 4
_getType PROC						; COMDAT

; 172  :   if(i<0 || i>=T->size) return BAD_TYPE;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	78 0f		 js	 SHORT $LN1@getType
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR _T$[esp-4]
  0000c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000e	7d 07		 jge	 SHORT $LN1@getType

; 173  :   return T->types[i];

  00010	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00013	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]

; 174  : }

  00016	c3		 ret	 0
$LN1@getType:

; 172  :   if(i<0 || i>=T->size) return BAD_TYPE;

  00017	32 c0		 xor	 al, al

; 174  : }

  00019	c3		 ret	 0
_getType ENDP
_TEXT	ENDS
PUBLIC	_getArg
; Function compile flags: /Ogtpy
;	COMDAT _getArg
_TEXT	SEGMENT
_i$ = 8							; size = 4
_T$ = 12						; size = 4
_getArg	PROC						; COMDAT

; 177  :   if(i<0 || i>=T->size) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _i$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	78 0f		 js	 SHORT $LN1@getArg
  00008	8b 4c 24 08	 mov	 ecx, DWORD PTR _T$[esp-4]
  0000c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000e	7d 07		 jge	 SHORT $LN1@getArg

; 178  :   return T->args[i];

  00010	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00013	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 179  : }

  00016	c3		 ret	 0
$LN1@getArg:

; 177  :   if(i<0 || i>=T->size) return NULL;

  00017	33 c0		 xor	 eax, eax

; 179  : }

  00019	c3		 ret	 0
_getArg	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@IBGNKECF@bad?5data?5in?5compare?$AA@	; `string'
EXTRN	_warnmes:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BE@IBGNKECF@bad?5data?5in?5compare?$AA@
CONST	SEGMENT
??_C@_0BE@IBGNKECF@bad?5data?5in?5compare?$AA@ DB 'bad data in compare', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _compareObjects
_TEXT	SEGMENT
_xtype1$5334 = -4					; size = 1
_O1$ = 8						; size = 4
_l$6157 = 12						; size = 4
_ccode$ = 12						; size = 4
_type1$ = 12						; size = 1
_O2$ = 16						; size = 4
_xtype2$5336 = 20					; size = 1
_l$6162 = 20						; size = 4
_type2$ = 20						; size = 1
_compareObjects PROC					; COMDAT

; 181  : static bp_long compareObjects(OBJECT O1,BYTE type1, OBJECT O2,BYTE type2) {

  00000	51		 push	 ecx

; 182  :   bp_long ccode=(bp_long)type1-(bp_long)type2;

  00001	0f b6 44 24 0c	 movzx	 eax, BYTE PTR _type1$[esp]
  00006	0f b6 54 24 14	 movzx	 edx, BYTE PTR _type2$[esp]
  0000b	8b c8		 mov	 ecx, eax
  0000d	2b ca		 sub	 ecx, edx
  0000f	89 4c 24 0c	 mov	 DWORD PTR _ccode$[esp], ecx

; 183  :   if(0!=ccode) return ccode;

  00013	74 04		 je	 SHORT $LN15@compareObj
  00015	8b c1		 mov	 eax, ecx

; 233  : }

  00017	59		 pop	 ecx
  00018	c3		 ret	 0
$LN15@compareObj:

; 184  :   switch(type1) {

  00019	48		 dec	 eax
  0001a	83 f8 04	 cmp	 eax, 4
  0001d	0f 87 30 01 00
	00		 ja	 $LN1@compareObj
  00023	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN65@compareObj[eax*4]
$LN12@compareObj:

; 185  :     case STRING_TYPE: {
; 186  :       char *s1=O2S(O1);
; 187  :       char *s2=O2S(O2);
; 188  :       ccode=strcmp(s1,s2);

  0002a	8b 54 24 10	 mov	 edx, DWORD PTR _O2$[esp]
  0002e	8b 4c 24 08	 mov	 ecx, DWORD PTR _O1$[esp]
$LL56@compareObj:
  00032	8a 01		 mov	 al, BYTE PTR [ecx]
  00034	3a 02		 cmp	 al, BYTE PTR [edx]
  00036	75 1e		 jne	 SHORT $LN57@compareObj
  00038	84 c0		 test	 al, al
  0003a	74 12		 je	 SHORT $LN58@compareObj
  0003c	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0003f	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00042	75 12		 jne	 SHORT $LN57@compareObj
  00044	83 c1 02	 add	 ecx, 2
  00047	83 c2 02	 add	 edx, 2
  0004a	84 c0		 test	 al, al
  0004c	75 e4		 jne	 SHORT $LL56@compareObj
$LN58@compareObj:
  0004e	33 c0		 xor	 eax, eax
  00050	89 44 24 0c	 mov	 DWORD PTR _ccode$[esp], eax

; 233  : }

  00054	59		 pop	 ecx
  00055	c3		 ret	 0
$LN57@compareObj:

; 185  :     case STRING_TYPE: {
; 186  :       char *s1=O2S(O1);
; 187  :       char *s2=O2S(O2);
; 188  :       ccode=strcmp(s1,s2);

  00056	1b c0		 sbb	 eax, eax
  00058	83 d8 ff	 sbb	 eax, -1
  0005b	89 44 24 0c	 mov	 DWORD PTR _ccode$[esp], eax

; 233  : }

  0005f	59		 pop	 ecx
  00060	c3		 ret	 0
$LN11@compareObj:

; 189  :       /*fprintf(STD_err,"compareObjects: %d %d strings=> %s %s => %d\n",O1,O2,s1,s2,ccode);*/
; 190  :     } break;
; 191  :     case INT_TYPE: {
; 192  :       bp_long i1=O2I(O1);
; 193  :       bp_long i2=O2I(O2);
; 194  :       ccode=i1-i2;

  00061	8b 44 24 08	 mov	 eax, DWORD PTR _O1$[esp]
  00065	2b 44 24 10	 sub	 eax, DWORD PTR _O2$[esp]
  00069	89 44 24 0c	 mov	 DWORD PTR _ccode$[esp], eax

; 233  : }

  0006d	59		 pop	 ecx
  0006e	c3		 ret	 0
$LN10@compareObj:

; 195  :       /*fprintf(STD_err,"compareObjects: %d %d ints=> %d %d => %d\n",O1,O2,i1,i2,ccode);*/
; 196  :     } break;
; 197  :     case FLOAT_TYPE: {
; 198  :       double df1=O2F(O1);

  0006f	8b 44 24 08	 mov	 eax, DWORD PTR _O1$[esp]

; 199  :       double df2=O2F(O2);

  00073	8b 4c 24 10	 mov	 ecx, DWORD PTR _O2$[esp]
  00077	89 44 24 0c	 mov	 DWORD PTR _l$6157[esp], eax

; 200  :       ccode=(bp_long)(df1-df2);

  0007b	d9 44 24 0c	 fld	 DWORD PTR _l$6157[esp]
  0007f	89 4c 24 14	 mov	 DWORD PTR _l$6162[esp], ecx
  00083	d8 64 24 14	 fsub	 DWORD PTR _l$6162[esp]
  00087	e8 00 00 00 00	 call	 __ftol2_sse
  0008c	89 44 24 0c	 mov	 DWORD PTR _ccode$[esp], eax

; 233  : }

  00090	59		 pop	 ecx
  00091	c3		 ret	 0
$LN9@compareObj:

; 201  :     } break;
; 202  :     case VAR_TYPE: {
; 203  :       return 0;

  00092	33 c0		 xor	 eax, eax

; 233  : }

  00094	59		 pop	 ecx
  00095	c3		 ret	 0
$LN8@compareObj:
  00096	53		 push	 ebx

; 204  :     } break;
; 205  :     case TERM_TYPE: {
; 206  :       Term T1=O2T(O1);
; 207  :       bp_long a1=getArity(T1);
; 208  :       Term T2=O2T(O2);
; 209  :       bp_long a2=getArity(T2);

  00097	8b 5c 24 14	 mov	 ebx, DWORD PTR _O2$[esp+4]
  0009b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0009d	55		 push	 ebp
  0009e	8b 6c 24 10	 mov	 ebp, DWORD PTR _O1$[esp+8]
  000a2	57		 push	 edi
  000a3	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  000a6	4f		 dec	 edi
  000a7	48		 dec	 eax

; 210  :       bp_long i;
; 211  :       /*fprintf(STD_err,"compareObjects: %d %d terms => a1=%d a2=%d\n",O1,O2,a1,a2);*/
; 212  :       if(a1!=a2) ccode=a1-a2;

  000a8	3b f8		 cmp	 edi, eax
  000aa	74 0f		 je	 SHORT $LN7@compareObj
  000ac	2b f8		 sub	 edi, eax
  000ae	89 7c 24 18	 mov	 DWORD PTR _ccode$[esp+12], edi

; 231  :   }
; 232  :   return ccode;

  000b2	8b 44 24 18	 mov	 eax, DWORD PTR _ccode$[esp+12]
  000b6	5f		 pop	 edi
  000b7	5d		 pop	 ebp
  000b8	5b		 pop	 ebx

; 233  : }

  000b9	59		 pop	 ecx
  000ba	c3		 ret	 0
$LN7@compareObj:
  000bb	56		 push	 esi

; 213  :       else {
; 214  :         for(i=0;i<=a1;i++) {

  000bc	33 f6		 xor	 esi, esi
  000be	85 ff		 test	 edi, edi
  000c0	0f 88 83 00 00
	00		 js	 $LN64@compareObj
$LL60@compareObj:

; 215  :           bp_long c;
; 216  :           BYTE xtype1=getType(i,T1);

  000c6	85 f6		 test	 esi, esi
  000c8	78 11		 js	 SHORT $LN38@compareObj
  000ca	3b 75 00	 cmp	 esi, DWORD PTR [ebp]
  000cd	7d 0c		 jge	 SHORT $LN38@compareObj
  000cf	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  000d2	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  000d5	88 44 24 10	 mov	 BYTE PTR _xtype1$5334[esp+20], al
  000d9	eb 05		 jmp	 SHORT $LN40@compareObj
$LN38@compareObj:
  000db	c6 44 24 10 00	 mov	 BYTE PTR _xtype1$5334[esp+20], 0
$LN40@compareObj:

; 217  :           OBJECT X1=getArg(i,T1);    

  000e0	85 f6		 test	 esi, esi
  000e2	78 0d		 js	 SHORT $LN42@compareObj
  000e4	3b 75 00	 cmp	 esi, DWORD PTR [ebp]
  000e7	7d 08		 jge	 SHORT $LN42@compareObj
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000ec	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  000ef	eb 02		 jmp	 SHORT $LN44@compareObj
$LN42@compareObj:
  000f1	33 c9		 xor	 ecx, ecx
$LN44@compareObj:

; 218  :           BYTE xtype2=getType(i,T2);

  000f3	85 f6		 test	 esi, esi
  000f5	78 10		 js	 SHORT $LN46@compareObj
  000f7	3b 33		 cmp	 esi, DWORD PTR [ebx]
  000f9	7d 0c		 jge	 SHORT $LN46@compareObj
  000fb	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000fe	8a 04 16	 mov	 al, BYTE PTR [esi+edx]
  00101	88 44 24 24	 mov	 BYTE PTR _xtype2$5336[esp+16], al
  00105	eb 05		 jmp	 SHORT $LN48@compareObj
$LN46@compareObj:
  00107	c6 44 24 24 00	 mov	 BYTE PTR _xtype2$5336[esp+16], 0
$LN48@compareObj:

; 219  :           OBJECT X2=getArg(i,T2);    

  0010c	85 f6		 test	 esi, esi
  0010e	78 0c		 js	 SHORT $LN50@compareObj
  00110	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00112	7d 08		 jge	 SHORT $LN50@compareObj
  00114	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  00117	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  0011a	eb 02		 jmp	 SHORT $LN52@compareObj
$LN50@compareObj:
  0011c	33 c0		 xor	 eax, eax
$LN52@compareObj:

; 220  :           c=compareObjects(X1,xtype1,X2,xtype2);

  0011e	8b 54 24 24	 mov	 edx, DWORD PTR _xtype2$5336[esp+16]
  00122	52		 push	 edx
  00123	50		 push	 eax
  00124	8b 44 24 18	 mov	 eax, DWORD PTR _xtype1$5334[esp+28]
  00128	50		 push	 eax
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 _compareObjects
  0012f	83 c4 10	 add	 esp, 16			; 00000010H

; 221  :           if(0==c) continue;

  00132	85 c0		 test	 eax, eax
  00134	75 0f		 jne	 SHORT $LN2@compareObj

; 213  :       else {
; 214  :         for(i=0;i<=a1;i++) {

  00136	46		 inc	 esi
  00137	3b f7		 cmp	 esi, edi
  00139	7e 8b		 jle	 SHORT $LL60@compareObj

; 231  :   }
; 232  :   return ccode;

  0013b	8b 44 24 1c	 mov	 eax, DWORD PTR _ccode$[esp+16]
  0013f	5e		 pop	 esi
  00140	5f		 pop	 edi
  00141	5d		 pop	 ebp
  00142	5b		 pop	 ebx

; 233  : }

  00143	59		 pop	 ecx
  00144	c3		 ret	 0
$LN2@compareObj:

; 222  :           ccode=c;

  00145	89 44 24 1c	 mov	 DWORD PTR _ccode$[esp+16], eax
$LN64@compareObj:

; 231  :   }
; 232  :   return ccode;

  00149	8b 44 24 1c	 mov	 eax, DWORD PTR _ccode$[esp+16]
  0014d	5e		 pop	 esi
  0014e	5f		 pop	 edi
  0014f	5d		 pop	 ebp
  00150	5b		 pop	 ebx

; 233  : }

  00151	59		 pop	 ecx
  00152	c3		 ret	 0
$LN1@compareObj:

; 223  :           break;
; 224  :         }
; 225  :       }
; 226  :     } break;
; 227  :     default: 
; 228  :       /*fprintf(STD_err,"compareObjects: %d %d bad data => %d %d\n",O1,O2,type1,type2);*/
; 229  :       warnmes("bad data in compare");     

  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IBGNKECF@bad?5data?5in?5compare?$AA@
  00158	e8 00 00 00 00	 call	 _warnmes
  0015d	83 c4 04	 add	 esp, 4

; 230  :       return -2;

  00160	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 233  : }

  00165	59		 pop	 ecx
  00166	c3		 ret	 0
  00167	90		 npad	 1
$LN65@compareObj:
  00168	00 00 00 00	 DD	 $LN12@compareObj
  0016c	00 00 00 00	 DD	 $LN11@compareObj
  00170	00 00 00 00	 DD	 $LN10@compareObj
  00174	00 00 00 00	 DD	 $LN9@compareObj
  00178	00 00 00 00	 DD	 $LN8@compareObj
_compareObjects ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@OCJKLDFJ@NULL?5data?5in?5compareTerms?$AA@ ; `string'
PUBLIC	_compareTerms
;	COMDAT ??_C@_0BK@OCJKLDFJ@NULL?5data?5in?5compareTerms?$AA@
CONST	SEGMENT
??_C@_0BK@OCJKLDFJ@NULL?5data?5in?5compareTerms?$AA@ DB 'NULL data in com'
	DB	'pareTerms', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _compareTerms
_TEXT	SEGMENT
_T1$ = 8						; size = 4
_T2$ = 12						; size = 4
_compareTerms PROC					; COMDAT

; 242  :   bp_long ccode;
; 243  :   if(NULL==T1 || NULL==T2)  {

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _T1$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 2d		 je	 SHORT $LN5@compareTer
  00008	8b 44 24 08	 mov	 eax, DWORD PTR _T2$[esp-4]
  0000c	85 c0		 test	 eax, eax
  0000e	74 25		 je	 SHORT $LN5@compareTer

; 246  :   }
; 247  :   if(T1==T2) return 0;

  00010	3b c8		 cmp	 ecx, eax
  00012	75 03		 jne	 SHORT $LN4@compareTer
  00014	33 c0		 xor	 eax, eax

; 251  :   return ccode;
; 252  : }

  00016	c3		 ret	 0
$LN4@compareTer:

; 248  :   ccode=compareObjects(T2O(T1),TERM_TYPE,T2O(T2),TERM_TYPE);

  00017	6a 05		 push	 5
  00019	50		 push	 eax
  0001a	6a 05		 push	 5
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 _compareObjects
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 249  :   if(ccode>0) ccode=1;

  00025	85 c0		 test	 eax, eax
  00027	7e 06		 jle	 SHORT $LN13@compareTer
  00029	b8 01 00 00 00	 mov	 eax, 1

; 251  :   return ccode;
; 252  : }

  0002e	c3		 ret	 0
$LN13@compareTer:

; 250  :   else if(ccode<0) ccode=-1;

  0002f	79 16		 jns	 SHORT $LN7@compareTer
  00031	83 c8 ff	 or	 eax, -1

; 251  :   return ccode;
; 252  : }

  00034	c3		 ret	 0
$LN5@compareTer:

; 244  :      warnmes("NULL data in compareTerms");

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@OCJKLDFJ@NULL?5data?5in?5compareTerms?$AA@
  0003a	e8 00 00 00 00	 call	 _warnmes
  0003f	83 c4 04	 add	 esp, 4

; 245  :      return -2;

  00042	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN7@compareTer:

; 251  :   return ccode;
; 252  : }

  00047	c3		 ret	 0
_compareTerms ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KPMJPFKF@bad?5data?5in?5hashCodeOf?$AA@ ; `string'
PUBLIC	??_C@_0BP@DHBJAHCG@maxdepth?5exceded?5in?5hashCodeOf?$AA@ ; `string'
;	COMDAT ??_C@_0BH@KPMJPFKF@bad?5data?5in?5hashCodeOf?$AA@
CONST	SEGMENT
??_C@_0BH@KPMJPFKF@bad?5data?5in?5hashCodeOf?$AA@ DB 'bad data in hashCod'
	DB	'eOf', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHBJAHCG@maxdepth?5exceded?5in?5hashCodeOf?$AA@
CONST	SEGMENT
??_C@_0BP@DHBJAHCG@maxdepth?5exceded?5in?5hashCodeOf?$AA@ DB 'maxdepth ex'
	DB	'ceded in hashCodeOf', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hashCodeOf
_TEXT	SEGMENT
_xtype$5392 = -4					; size = 1
_O$ = 8							; size = 4
_type$ = 12						; size = 1
_arity$ = 16						; size = 4
_l$6229 = 20						; size = 4
_maxdepth$ = 20						; size = 4
_hashCodeOf PROC					; COMDAT

; 254  : static bp_long hashCodeOf(OBJECT O,BYTE type,bp_long arity,bp_long maxdepth) {

  00000	51		 push	 ecx
  00001	57		 push	 edi

; 255  :   bp_long hcode=0;

  00002	33 ff		 xor	 edi, edi

; 256  :   if(--maxdepth<0) {

  00004	ff 4c 24 18	 dec	 DWORD PTR _maxdepth$[esp+4]
  00008	79 13		 jns	 SHORT $LN17@hashCodeOf

; 257  :     warnmes("maxdepth exceded in hashCodeOf");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DHBJAHCG@maxdepth?5exceded?5in?5hashCodeOf?$AA@
  0000f	e8 00 00 00 00	 call	 _warnmes
  00014	83 c4 04	 add	 esp, 4

; 258  :     return -4;

  00017	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0001a	5f		 pop	 edi

; 296  : }

  0001b	59		 pop	 ecx
  0001c	c3		 ret	 0
$LN17@hashCodeOf:

; 259  :   }
; 260  :   switch(type) {

  0001d	0f b6 44 24 10	 movzx	 eax, BYTE PTR _type$[esp+4]
  00022	53		 push	 ebx
  00023	48		 dec	 eax
  00024	55		 push	 ebp
  00025	56		 push	 esi
  00026	83 f8 04	 cmp	 eax, 4
  00029	0f 87 be 00 00
	00		 ja	 $LN2@hashCodeOf
  0002f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN47@hashCodeOf[eax*4]
$LN14@hashCodeOf:

; 261  :     case STRING_TYPE: {
; 262  :       char *s=O2S(O);
; 263  :       STRING_HASH(s,hcode,arity);

  00036	8b 4c 24 18	 mov	 ecx, DWORD PTR _O$[esp+16]
  0003a	8a 01		 mov	 al, BYTE PTR [ecx]
  0003c	bf 05 15 00 00	 mov	 edi, 5381		; 00001505H
  00041	84 c0		 test	 al, al
  00043	74 13		 je	 SHORT $LN12@hashCodeOf
$LL13@hashCodeOf:
  00045	8b d7		 mov	 edx, edi
  00047	c1 e2 05	 shl	 edx, 5
  0004a	0f be c0	 movsx	 eax, al
  0004d	03 fa		 add	 edi, edx
  0004f	41		 inc	 ecx
  00050	03 f8		 add	 edi, eax
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	84 c0		 test	 al, al
  00056	75 ed		 jne	 SHORT $LL13@hashCodeOf
$LN12@hashCodeOf:
  00058	8b 4c 24 20	 mov	 ecx, DWORD PTR _arity$[esp+16]
  0005c	c1 e1 07	 shl	 ecx, 7
  0005f	03 f9		 add	 edi, ecx

; 264  :     } break;

  00061	eb 7c		 jmp	 SHORT $LN5@hashCodeOf
$LN11@hashCodeOf:

; 265  :     case INT_TYPE: {
; 266  :       hcode=O2I(O);

  00063	8b 7c 24 18	 mov	 edi, DWORD PTR _O$[esp+16]

; 267  :     } break;

  00067	eb 76		 jmp	 SHORT $LN5@hashCodeOf
$LN10@hashCodeOf:

; 268  :     case FLOAT_TYPE: {
; 269  :       double df=O2F(O);

  00069	8b 54 24 18	 mov	 edx, DWORD PTR _O$[esp+16]
  0006d	89 54 24 24	 mov	 DWORD PTR _l$6229[esp+16], edx

; 270  :       hcode=(bp_long)df;

  00071	d9 44 24 24	 fld	 DWORD PTR _l$6229[esp+16]
  00075	e8 00 00 00 00	 call	 __ftol2_sse
  0007a	8b f8		 mov	 edi, eax

; 271  :     } break;

  0007c	eb 61		 jmp	 SHORT $LN5@hashCodeOf
$LN9@hashCodeOf:
  0007e	5e		 pop	 esi
  0007f	5d		 pop	 ebp
  00080	5b		 pop	 ebx

; 272  :     case VAR_TYPE: {
; 273  :       return -1;

  00081	83 c8 ff	 or	 eax, -1
  00084	5f		 pop	 edi

; 296  : }

  00085	59		 pop	 ecx
  00086	c3		 ret	 0
$LN8@hashCodeOf:

; 274  :     } break;
; 275  :     case TERM_TYPE: {
; 276  :       Term T=O2T(O);
; 277  :       bp_long arity=getArity(T);

  00087	8b 5c 24 18	 mov	 ebx, DWORD PTR _O$[esp+16]
  0008b	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  0008d	4d		 dec	 ebp

; 278  :       bp_long i;
; 279  :       for(i=0;i<=arity;i++) {

  0008e	8b f7		 mov	 esi, edi
  00090	78 53		 js	 SHORT $LN1@hashCodeOf
$LL43@hashCodeOf:

; 280  :         bp_long h;
; 281  :         BYTE xtype=getType(i,T);

  00092	85 f6		 test	 esi, esi
  00094	78 10		 js	 SHORT $LN30@hashCodeOf
  00096	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00098	7d 0c		 jge	 SHORT $LN30@hashCodeOf
  0009a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0009d	8a 0c 06	 mov	 cl, BYTE PTR [esi+eax]
  000a0	88 4c 24 10	 mov	 BYTE PTR _xtype$5392[esp+20], cl
  000a4	eb 05		 jmp	 SHORT $LN32@hashCodeOf
$LN30@hashCodeOf:
  000a6	c6 44 24 10 00	 mov	 BYTE PTR _xtype$5392[esp+20], 0
$LN32@hashCodeOf:

; 282  :         OBJECT X=getArg(i,T);    

  000ab	85 f6		 test	 esi, esi
  000ad	78 0c		 js	 SHORT $LN34@hashCodeOf
  000af	3b 33		 cmp	 esi, DWORD PTR [ebx]
  000b1	7d 08		 jge	 SHORT $LN34@hashCodeOf
  000b3	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000b6	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  000b9	eb 02		 jmp	 SHORT $LN36@hashCodeOf
$LN34@hashCodeOf:
  000bb	33 c0		 xor	 eax, eax
$LN36@hashCodeOf:

; 283  :         h=hashCodeOf(X,xtype,arity,maxdepth);

  000bd	8b 4c 24 24	 mov	 ecx, DWORD PTR _maxdepth$[esp+16]
  000c1	8b 54 24 10	 mov	 edx, DWORD PTR _xtype$5392[esp+20]
  000c5	51		 push	 ecx
  000c6	55		 push	 ebp
  000c7	52		 push	 edx
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 _hashCodeOf
  000ce	83 c4 10	 add	 esp, 16			; 00000010H

; 284  :         if(h<0) return h;

  000d1	85 c0		 test	 eax, eax
  000d3	78 2a		 js	 SHORT $LN44@hashCodeOf

; 285  :         else {
; 286  :           hcode=(hcode<<5)+h;

  000d5	c1 e7 05	 shl	 edi, 5
  000d8	46		 inc	 esi
  000d9	03 f8		 add	 edi, eax
  000db	3b f5		 cmp	 esi, ebp
  000dd	7e b3		 jle	 SHORT $LL43@hashCodeOf
$LN5@hashCodeOf:

; 293  :   }
; 294  :   if(hcode<0) hcode=-hcode;

  000df	85 ff		 test	 edi, edi
  000e1	79 02		 jns	 SHORT $LN1@hashCodeOf
  000e3	f7 df		 neg	 edi
$LN1@hashCodeOf:
  000e5	5e		 pop	 esi
  000e6	5d		 pop	 ebp
  000e7	5b		 pop	 ebx

; 295  :   return hcode;

  000e8	8b c7		 mov	 eax, edi
  000ea	5f		 pop	 edi

; 296  : }

  000eb	59		 pop	 ecx
  000ec	c3		 ret	 0
$LN2@hashCodeOf:

; 287  :         }
; 288  :       }
; 289  :     } break;
; 290  :     default: 
; 291  :       warnmes("bad data in hashCodeOf");

  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KPMJPFKF@bad?5data?5in?5hashCodeOf?$AA@
  000f2	e8 00 00 00 00	 call	 _warnmes
  000f7	83 c4 04	 add	 esp, 4

; 292  :       return -2;

  000fa	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
$LN44@hashCodeOf:
  000ff	5e		 pop	 esi
  00100	5d		 pop	 ebp
  00101	5b		 pop	 ebx
  00102	5f		 pop	 edi

; 296  : }

  00103	59		 pop	 ecx
  00104	c3		 ret	 0
  00105	8d 49 00	 npad	 3
$LN47@hashCodeOf:
  00108	00 00 00 00	 DD	 $LN14@hashCodeOf
  0010c	00 00 00 00	 DD	 $LN11@hashCodeOf
  00110	00 00 00 00	 DD	 $LN10@hashCodeOf
  00114	00 00 00 00	 DD	 $LN9@hashCodeOf
  00118	00 00 00 00	 DD	 $LN8@hashCodeOf
_hashCodeOf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@NKJGPDON@NULL?5data?5in?5hashCode?$AA@ ; `string'
PUBLIC	_hashCode
;	COMDAT ??_C@_0BG@NKJGPDON@NULL?5data?5in?5hashCode?$AA@
CONST	SEGMENT
??_C@_0BG@NKJGPDON@NULL?5data?5in?5hashCode?$AA@ DB 'NULL data in hashCod'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _hashCode
_TEXT	SEGMENT
_T$ = 8							; size = 4
_hashCode PROC						; COMDAT

; 303  :   bp_long maxdepth=1<<16;
; 304  :   if(NULL==T) {

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _T$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	75 13		 jne	 SHORT $LN1@hashCode

; 305  :     warnmes("NULL data in hashCode");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NKJGPDON@NULL?5data?5in?5hashCode?$AA@
  0000d	e8 00 00 00 00	 call	 _warnmes
  00012	83 c4 04	 add	 esp, 4

; 306  :     return -3;

  00015	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 309  : }

  0001a	c3		 ret	 0
$LN1@hashCode:

; 307  :   }
; 308  :   return hashCodeOf(T2O(T),TERM_TYPE,getArity(T),maxdepth);

  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	68 00 00 01 00	 push	 65536			; 00010000H
  00022	48		 dec	 eax
  00023	50		 push	 eax
  00024	6a 05		 push	 5
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _hashCodeOf
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 309  : }

  0002f	c3		 ret	 0
_hashCode ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_07MHIBGEFC@?$DM?$DP?$CFld?$DP?$DO?$AA@	; `string'
PUBLIC	??_C@_06NPMEBNE@?$CF?$CD?44lf?$AA@		; `string'
PUBLIC	??_C@_04FECOJDBD@_?$CFld?$AA@			; `string'
PUBLIC	??_C@_03JALODAI@?$CFld?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	_trim_float:PROC
EXTRN	_sprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHIBGEFC@?$DM?$DP?$CFld?$DP?$DO?$AA@
CONST	SEGMENT
??_C@_07MHIBGEFC@?$DM?$DP?$CFld?$DP?$DO?$AA@ DB '<?%ld?>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NPMEBNE@?$CF?$CD?44lf?$AA@
CONST	SEGMENT
??_C@_06NPMEBNE@?$CF?$CD?44lf?$AA@ DB '%#.4lf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FECOJDBD@_?$CFld?$AA@
CONST	SEGMENT
??_C@_04FECOJDBD@_?$CFld?$AA@ DB '_%ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JALODAI@?$CFld?$AA@
CONST	SEGMENT
??_C@_03JALODAI@?$CFld?$AA@ DB '%ld', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _appendTo
_TEXT	SEGMENT
_l$6277 = -264						; size = 4
_dbuf$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 1
_appendTo PROC						; COMDAT
; _buf$ = edi
; _O$ = ecx

; 312  : static char *appendTo(char *buf,BYTE type,OBJECT O) {

  00000	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax

; 313  :   char dbuf[256];
; 314  :   size_t l=0;
; 315  :   switch(type) {

  00014	0f b6 84 24 0c
	01 00 00	 movzx	 eax, BYTE PTR _type$[esp+260]
  0001c	48		 dec	 eax
  0001d	56		 push	 esi
  0001e	83 f8 03	 cmp	 eax, 3
  00021	0f 87 be 00 00
	00		 ja	 $LN1@appendTo
  00027	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN23@appendTo[eax*4]
$LN5@appendTo:

; 316  :     case STRING_TYPE: {
; 317  :       char *s=(char *)O;
; 318  :       l=strlen(s);

  0002e	8b c1		 mov	 eax, ecx
  00030	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL16@appendTo:
  00033	8a 10		 mov	 dl, BYTE PTR [eax]
  00035	40		 inc	 eax
  00036	84 d2		 test	 dl, dl
  00038	75 f9		 jne	 SHORT $LL16@appendTo
  0003a	2b c6		 sub	 eax, esi

; 319  :       sprintf(buf,"%s",s);

  0003c	51		 push	 ecx

; 320  :     }
; 321  :     break;

  0003d	e9 cc 00 00 00	 jmp	 $LN21@appendTo
$LN4@appendTo:

; 322  :     case INT_TYPE: {
; 323  :       sprintf(dbuf,"%ld",O2I(O));

  00042	51		 push	 ecx
  00043	8d 44 24 0c	 lea	 eax, DWORD PTR _dbuf$[esp+272]
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_03JALODAI@?$CFld?$AA@
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _sprintf

; 324  :       l=strlen(dbuf);

  00052	8d 44 24 14	 lea	 eax, DWORD PTR _dbuf$[esp+280]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0005c	8d 64 24 00	 npad	 4
$LL17@appendTo:
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	40		 inc	 eax
  00063	84 c9		 test	 cl, cl
  00065	75 f9		 jne	 SHORT $LL17@appendTo

; 325  :       sprintf(buf,"%s",dbuf);

  00067	8d 4c 24 08	 lea	 ecx, DWORD PTR _dbuf$[esp+268]
  0006b	2b c2		 sub	 eax, edx
  0006d	51		 push	 ecx

; 326  :     }
; 327  :     break;

  0006e	e9 9b 00 00 00	 jmp	 $LN21@appendTo
$LN3@appendTo:

; 328  :     case VAR_TYPE: {
; 329  :       sprintf(dbuf,"_%ld",O2V(O));

  00073	51		 push	 ecx
  00074	8d 54 24 0c	 lea	 edx, DWORD PTR _dbuf$[esp+272]
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_04FECOJDBD@_?$CFld?$AA@
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _sprintf

; 330  :       l=strlen(dbuf);

  00083	8d 44 24 14	 lea	 eax, DWORD PTR _dbuf$[esp+280]
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0008d	8d 49 00	 npad	 3
$LL18@appendTo:
  00090	8a 08		 mov	 cl, BYTE PTR [eax]
  00092	40		 inc	 eax
  00093	84 c9		 test	 cl, cl
  00095	75 f9		 jne	 SHORT $LL18@appendTo
  00097	2b c2		 sub	 eax, edx
  00099	8b f0		 mov	 esi, eax

; 331  :       sprintf(buf,"%s",dbuf);

  0009b	8d 44 24 08	 lea	 eax, DWORD PTR _dbuf$[esp+268]
  0009f	50		 push	 eax

; 332  :     }
; 333  :     break;

  000a0	eb 6e		 jmp	 SHORT $LN22@appendTo
$LN2@appendTo:

; 334  :     case FLOAT_TYPE: {
; 335  :       double df=O2F(O);

  000a2	89 4c 24 04	 mov	 DWORD PTR _l$6277[esp+268], ecx

; 336  :       sprintf(dbuf,"%#.4lf",df);

  000a6	d9 44 24 04	 fld	 DWORD PTR _l$6277[esp+268]
  000aa	83 ec 08	 sub	 esp, 8
  000ad	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b0	8d 4c 24 10	 lea	 ecx, DWORD PTR _dbuf$[esp+276]
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_06NPMEBNE@?$CF?$CD?44lf?$AA@
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _sprintf

; 337  :       trim_float(dbuf);

  000bf	8d 54 24 18	 lea	 edx, DWORD PTR _dbuf$[esp+284]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 _trim_float

; 338  :       l=strlen(dbuf);

  000c9	8d 44 24 1c	 lea	 eax, DWORD PTR _dbuf$[esp+288]
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL19@appendTo:
  000d3	8a 08		 mov	 cl, BYTE PTR [eax]
  000d5	40		 inc	 eax
  000d6	84 c9		 test	 cl, cl
  000d8	75 f9		 jne	 SHORT $LL19@appendTo
  000da	2b c2		 sub	 eax, edx
  000dc	8b f0		 mov	 esi, eax

; 339  :       sprintf(buf,"%s",dbuf);

  000de	8d 44 24 08	 lea	 eax, DWORD PTR _dbuf$[esp+268]
  000e2	50		 push	 eax

; 340  :     }          
; 341  :     break;

  000e3	eb 2b		 jmp	 SHORT $LN22@appendTo
$LN1@appendTo:

; 342  :     default:
; 343  :       sprintf(dbuf,"<?%ld?>",(bp_long)O);

  000e5	51		 push	 ecx
  000e6	8d 4c 24 0c	 lea	 ecx, DWORD PTR _dbuf$[esp+272]
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_07MHIBGEFC@?$DM?$DP?$CFld?$DP?$DO?$AA@
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 _sprintf

; 344  :       l=strlen(dbuf);

  000f5	8d 44 24 14	 lea	 eax, DWORD PTR _dbuf$[esp+280]
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000ff	90		 npad	 1
$LL20@appendTo:
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	40		 inc	 eax
  00103	84 c9		 test	 cl, cl
  00105	75 f9		 jne	 SHORT $LL20@appendTo
  00107	2b c2		 sub	 eax, edx

; 345  :       sprintf(buf,"%s",dbuf);

  00109	8d 54 24 08	 lea	 edx, DWORD PTR _dbuf$[esp+268]
  0010d	52		 push	 edx
$LN21@appendTo:

; 344  :       l=strlen(dbuf);

  0010e	8b f0		 mov	 esi, eax
$LN22@appendTo:

; 345  :       sprintf(buf,"%s",dbuf);

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00115	57		 push	 edi
  00116	e8 00 00 00 00	 call	 _sprintf

; 346  :   }
; 347  :   return buf+l;
; 348  : }

  0011b	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+280]
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
  00125	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00128	5e		 pop	 esi
  00129	33 cc		 xor	 ecx, esp
  0012b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00130	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00136	c3		 ret	 0
  00137	90		 npad	 1
$LN23@appendTo:
  00138	00 00 00 00	 DD	 $LN5@appendTo
  0013c	00 00 00 00	 DD	 $LN4@appendTo
  00140	00 00 00 00	 DD	 $LN2@appendTo
  00144	00 00 00 00	 DD	 $LN3@appendTo
_appendTo ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _appTo
_TEXT	SEGMENT
_appTo	PROC						; COMDAT
; _buf$ = edi
; _s$ = edx

; 351  :   bp_long l=strlen(s);

  00000	8b c2		 mov	 eax, edx
  00002	56		 push	 esi
  00003	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL3@appTo:
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	40		 inc	 eax
  00009	84 c9		 test	 cl, cl
  0000b	75 f9		 jne	 SHORT $LL3@appTo

; 352  :   sprintf(buf,"%s",s);

  0000d	52		 push	 edx
  0000e	2b c6		 sub	 eax, esi
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00015	57		 push	 edi
  00016	8b f0		 mov	 esi, eax
  00018	e8 00 00 00 00	 call	 _sprintf
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  :   return buf+l;

  00020	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00023	5e		 pop	 esi

; 354  : }

  00024	c3		 ret	 0
_appTo	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@		; `string'
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@ DB '(null)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _toString0
_TEXT	SEGMENT
_l$5451 = 8						; size = 4
_T$ = 8							; size = 4
_type$5456 = 12						; size = 1
_buffer$ = 12						; size = 4
_toString0 PROC						; COMDAT

; 356  : static char *toString0(Term T,char *buffer) {

  00000	53		 push	 ebx

; 357  :   if(NULL==T) buffer=appTo(buffer,"(null)");

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _T$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 14	 mov	 edi, DWORD PTR _buffer$[esp+8]
  0000b	85 db		 test	 ebx, ebx
  0000d	75 16		 jne	 SHORT $LN11@toString0
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 _sprintf
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	83 c7 06	 add	 edi, 6
$LN11@toString0:

; 358  :   { bp_long i;
; 359  :     bp_long l=T->size;

  00025	8b 03		 mov	 eax, DWORD PTR [ebx]

; 360  :     for(i=0;i<l;i++) {

  00027	33 f6		 xor	 esi, esi
  00029	89 44 24 10	 mov	 DWORD PTR _l$5451[esp+8], eax
  0002d	85 c0		 test	 eax, eax
  0002f	0f 8e 93 00 00
	00		 jle	 $LN8@toString0
  00035	55		 push	 ebp
$LL10@toString0:

; 361  :       OBJECT X=T->args[i];

  00036	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 362  :       BYTE type=T->types[i];

  00039	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0003c	8b 2c b1	 mov	 ebp, DWORD PTR [ecx+esi*4]
  0003f	8a 0c 16	 mov	 cl, BYTE PTR [esi+edx]
  00042	88 4c 24 18	 mov	 BYTE PTR _type$5456[esp+12], cl

; 363  :      
; 364  :       if(i==1 && l>1) buffer=appTo(buffer,"(");

  00046	83 fe 01	 cmp	 esi, 1
  00049	75 0b		 jne	 SHORT $LN32@toString0
  0004b	3b c6		 cmp	 eax, esi
  0004d	7e 1d		 jle	 SHORT $LN6@toString0
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_01ODHLEDKK@?$CI?$AA@

; 365  :       if(i>1) buffer=appTo(buffer,",");  

  00054	eb 07		 jmp	 SHORT $LN33@toString0
$LN32@toString0:
  00056	7e 14		 jle	 SHORT $LN6@toString0
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_01IHBHIGKO@?0?$AA@
$LN33@toString0:
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00062	57		 push	 edi
  00063	e8 00 00 00 00	 call	 _sprintf
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	47		 inc	 edi
$LN6@toString0:

; 366  : 
; 367  :       if(NULL==X && BAD_TYPE==type) buffer=appTo(buffer,"(null)");  

  0006c	85 ed		 test	 ebp, ebp
  0006e	75 1f		 jne	 SHORT $LN31@toString0
  00070	80 7c 24 18 00	 cmp	 BYTE PTR _type$5456[esp+12], 0
  00075	75 18		 jne	 SHORT $LN31@toString0
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 _sprintf
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	83 c7 06	 add	 edi, 6
  0008d	eb 2b		 jmp	 SHORT $LN9@toString0
$LN31@toString0:

; 368  :       else if(TERM_TYPE==type && NULL!=X) {

  0008f	80 7c 24 18 05	 cmp	 BYTE PTR _type$5456[esp+12], 5
  00094	75 10		 jne	 SHORT $LN3@toString0
  00096	85 ed		 test	 ebp, ebp
  00098	74 0c		 je	 SHORT $LN3@toString0

; 369  :         buffer=toString0(O2T(X),buffer);

  0009a	57		 push	 edi
  0009b	55		 push	 ebp
  0009c	e8 00 00 00 00	 call	 _toString0
  000a1	83 c4 08	 add	 esp, 8

; 370  :       }
; 371  :       else {

  000a4	eb 12		 jmp	 SHORT $LN34@toString0
$LN3@toString0:

; 372  :         buffer=appendTo(buffer,T->types[i],X);

  000a6	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000a9	0f b6 04 16	 movzx	 eax, BYTE PTR [esi+edx]
  000ad	50		 push	 eax
  000ae	8b cd		 mov	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 _appendTo
  000b5	83 c4 04	 add	 esp, 4
$LN34@toString0:
  000b8	8b f8		 mov	 edi, eax
$LN9@toString0:

; 360  :     for(i=0;i<l;i++) {

  000ba	8b 44 24 14	 mov	 eax, DWORD PTR _l$5451[esp+12]
  000be	46		 inc	 esi
  000bf	3b f0		 cmp	 esi, eax
  000c1	0f 8c 6f ff ff
	ff		 jl	 $LL10@toString0
  000c7	5d		 pop	 ebp
$LN8@toString0:

; 373  :       }
; 374  :     }
; 375  :     if(l>1) buffer=appTo(buffer,")");

  000c8	83 f8 01	 cmp	 eax, 1
  000cb	7e 1a		 jle	 SHORT $LN28@toString0
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_01PKGAHCOL@?$CJ?$AA@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000d7	57		 push	 edi
  000d8	e8 00 00 00 00	 call	 _sprintf
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 376  :   }
; 377  :   return buffer;

  000e0	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx

; 378  : }

  000e6	c3		 ret	 0
$LN28@toString0:

; 376  :   }
; 377  :   return buffer;

  000e7	8b c7		 mov	 eax, edi
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx

; 378  : }

  000ec	c3		 ret	 0
_toString0 ENDP
_TEXT	ENDS
PUBLIC	_toString
; Function compile flags: /Ogtpy
;	COMDAT _toString
_TEXT	SEGMENT
_T$ = 8							; size = 4
_buffer$ = 12						; size = 4
_toString PROC						; COMDAT

; 381  :    buffer[0]='\0';
; 382  :    if(NULL==T || NULL==toString0(T,buffer)) {

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _T$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _buffer$[esp]
  00009	c6 06 00	 mov	 BYTE PTR [esi], 0
  0000c	85 c0		 test	 eax, eax
  0000e	74 0e		 je	 SHORT $LN1@toString
  00010	56		 push	 esi
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _toString0
  00017	83 c4 08	 add	 esp, 8
  0001a	85 c0		 test	 eax, eax
  0001c	75 0e		 jne	 SHORT $LN2@toString
$LN1@toString:

; 383  :      sprintf(buffer,"(null)");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _sprintf
  00029	83 c4 08	 add	 esp, 8
$LN2@toString:
  0002c	5e		 pop	 esi

; 384  :    }
; 385  : }

  0002d	c3		 ret	 0
_toString ENDP
_TEXT	ENDS
PUBLIC	_toNewString
EXTRN	_strdup:PROC
EXTRN	_g:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _toNewString
_TEXT	SEGMENT
_T$ = 8							; size = 4
_toNewString PROC					; COMDAT

; 388  :   char *s;
; 389  :   toString(T,g.sbuf);

  00000	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax
  00008	c6 00 00	 mov	 BYTE PTR [eax], 0
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _T$[esp]
  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN3@toNewStrin
  00013	56		 push	 esi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _toString0
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 0e		 jne	 SHORT $LN4@toNewStrin
$LN3@toNewStrin:
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _sprintf
  0002c	83 c4 08	 add	 esp, 8
$LN4@toNewStrin:

; 390  :   s=strdup(g.sbuf);

  0002f	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _strdup

; 391  :   g.sbuf[0]='\0';

  0003a	8b 0d 4c 01 00
	00		 mov	 ecx, DWORD PTR _g+332
  00040	83 c4 04	 add	 esp, 4
  00043	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00046	5e		 pop	 esi

; 392  :   return s; /* to be freed! */
; 393  : }

  00047	c3		 ret	 0
_toNewString ENDP
_TEXT	ENDS
PUBLIC	_stringLengthOf
; Function compile flags: /Ogtpy
;	COMDAT _stringLengthOf
_TEXT	SEGMENT
_T$ = 8							; size = 4
_stringLengthOf PROC					; COMDAT

; 396  :   bp_long l;
; 397  :   toString(T,g.sbuf);

  00000	a1 4c 01 00 00	 mov	 eax, DWORD PTR _g+332
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax
  00008	c6 00 00	 mov	 BYTE PTR [eax], 0
  0000b	8b 44 24 08	 mov	 eax, DWORD PTR _T$[esp]
  0000f	85 c0		 test	 eax, eax
  00011	74 0e		 je	 SHORT $LN3@stringLeng
  00013	56		 push	 esi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _toString0
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 0e		 jne	 SHORT $LN4@stringLeng
$LN3@stringLeng:
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _sprintf
  0002c	83 c4 08	 add	 esp, 8
$LN4@stringLeng:

; 398  :   l=strlen(g.sbuf);

  0002f	8b 15 4c 01 00
	00		 mov	 edx, DWORD PTR _g+332
  00035	8b c2		 mov	 eax, edx
  00037	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL7@stringLeng:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	40		 inc	 eax
  00043	84 c9		 test	 cl, cl
  00045	75 f9		 jne	 SHORT $LL7@stringLeng
  00047	2b c6		 sub	 eax, esi

; 399  :   g.sbuf[0]='\0';

  00049	88 0a		 mov	 BYTE PTR [edx], cl
  0004b	5e		 pop	 esi

; 400  :   return l;
; 401  : }

  0004c	c3		 ret	 0
_stringLengthOf ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_showTerm
EXTRN	_printf:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT _showTerm
_TEXT	SEGMENT
_sbuf$ = -262148					; size = 262144
__$ArrayPad$ = -4					; size = 4
_T$ = 8							; size = 4
_showTerm PROC						; COMDAT

; 403  : void showTerm(Term T) {

  00000	b8 04 00 04 00	 mov	 eax, 262148		; 00040004H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000f	33 c4		 xor	 eax, esp
  00011	89 84 24 00 00
	04 00		 mov	 DWORD PTR __$ArrayPad$[esp+262148], eax
  00018	8b 84 24 08 00
	04 00		 mov	 eax, DWORD PTR _T$[esp+262144]

; 404  :   char sbuf[1<<18];
; 405  :   toString(T,sbuf);

  0001f	c6 04 24 00	 mov	 BYTE PTR _sbuf$[esp+262148], 0
  00023	85 c0		 test	 eax, eax
  00025	74 11		 je	 SHORT $LN3@showTerm
  00027	8d 0c 24	 lea	 ecx, DWORD PTR _sbuf$[esp+262148]
  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _toString0
  00031	83 c4 08	 add	 esp, 8
  00034	85 c0		 test	 eax, eax
  00036	75 11		 jne	 SHORT $LN4@showTerm
$LN3@showTerm:
  00038	8d 14 24	 lea	 edx, DWORD PTR _sbuf$[esp+262148]
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_06OJHGLDPL@?$CInull?$CJ?$AA@
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _sprintf
  00046	83 c4 08	 add	 esp, 8
$LN4@showTerm:

; 406  :   printf("%s",sbuf);

  00049	8d 04 24	 lea	 eax, DWORD PTR _sbuf$[esp+262148]
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00052	e8 00 00 00 00	 call	 _printf

; 407  :   sbuf[0]='\0';
; 408  : }

  00057	8b 8c 24 08 00
	04 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+262156]
  0005e	83 c4 08	 add	 esp, 8
  00061	33 cc		 xor	 ecx, esp
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	81 c4 04 00 04
	00		 add	 esp, 262148		; 00040004H
  0006e	c3		 ret	 0
_showTerm ENDP
_TEXT	ENDS
EXTRN	_ints_to_double:PROC
EXTRN	_atomtable:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _externalize_object
_TEXT	SEGMENT
tv254 = -4						; size = 4
_xtype$5617 = 8						; size = 1
_t$ = 8							; size = 4
_result$ = 12						; size = 4
_type$ = 12						; size = 4
_externalize_object PROC				; COMDAT

; 452  : static OBJECT externalize_object(term t,BYTE *type) {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 453  :   OBJECT result=NULL;
; 454  :   *type=BAD_TYPE;

  00002	8b 5c 24 10	 mov	 ebx, DWORD PTR _type$[esp+4]
  00006	57		 push	 edi

; 455  : 
; 456  :   if(BP_is_integer(t)) {

  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _t$[esp+8]
  0000b	8b c7		 mov	 eax, edi
  0000d	83 e0 03	 and	 eax, 3
  00010	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00013	83 f8 01	 cmp	 eax, 1
  00016	75 0c		 jne	 SHORT $LN22@externaliz

; 457  :     bp_long i;
; 458  :     BP_get_integer(t,i);

  00018	c1 ff 02	 sar	 edi, 2

; 504  :   }
; 505  :   return result;

  0001b	8b c7		 mov	 eax, edi
  0001d	5f		 pop	 edi
  0001e	c6 03 02	 mov	 BYTE PTR [ebx], 2
  00021	5b		 pop	 ebx

; 506  : }

  00022	59		 pop	 ecx
  00023	c3		 ret	 0
$LN22@externaliz:

; 459  :     *type=INT_TYPE;
; 460  :     result=I2O(i);
; 461  :   }
; 462  :   else if(BP_is_atom(t)) {

  00024	83 f8 03	 cmp	 eax, 3
  00027	75 20		 jne	 SHORT $LN20@externaliz
  00029	f7 c7 00 00 00
	ff		 test	 edi, -16777216		; ff000000H
  0002f	75 18		 jne	 SHORT $LN20@externaliz

; 463  :     char *s;
; 464  :     BP_get_string(t,s);

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _atomtable
  00036	c1 ef 02	 shr	 edi, 2
  00039	81 e7 ff ff 3f
	00		 and	 edi, 4194303		; 003fffffH
  0003f	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00042	5f		 pop	 edi

; 465  :     *type=STRING_TYPE;

  00043	c6 03 01	 mov	 BYTE PTR [ebx], 1
  00046	5b		 pop	 ebx

; 506  : }

  00047	59		 pop	 ecx
  00048	c3		 ret	 0
$LN20@externaliz:

; 466  :    result=S2O(s);
; 467  :   }
; 468  :   else if(BP_is_var(t)) {

  00049	85 c0		 test	 eax, eax
  0004b	0f 85 39 01 00
	00		 jne	 $LN18@externaliz

; 469  :      cell val=GETREF(t);

  00051	56		 push	 esi
  00052	8b 37		 mov	 esi, DWORD PTR [edi]

; 470  :      if(BP_is_float(val)) {

  00054	39 35 94 00 00
	00		 cmp	 DWORD PTR _g+148, esi
  0005a	75 24		 jne	 SHORT $LN17@externaliz

; 471  :        double df=ints_to_double((half)(t[1]),(half)(t[2]),(half)(t[3]));

  0005c	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0005f	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00062	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00065	51		 push	 ecx
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _ints_to_double

; 472  :        *type=FLOAT_TYPE;
; 473  :        result=F2O(df);  

  0006d	d9 5c 24 24	 fstp	 DWORD PTR _result$[esp+24]

; 504  :   }
; 505  :   return result;

  00071	8b 44 24 24	 mov	 eax, DWORD PTR _result$[esp+24]
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	5e		 pop	 esi
  00079	5f		 pop	 edi
  0007a	c6 03 03	 mov	 BYTE PTR [ebx], 3
  0007d	5b		 pop	 ebx

; 506  : }

  0007e	59		 pop	 ecx
  0007f	c3		 ret	 0
$LN17@externaliz:

; 474  :      }
; 475  :      else if(BP_is_var(val)) {

  00080	8b c6		 mov	 eax, esi
  00082	83 e0 03	 and	 eax, 3
  00085	75 0a		 jne	 SHORT $LN15@externaliz

; 504  :   }
; 505  :   return result;

  00087	8b c6		 mov	 eax, esi
  00089	5e		 pop	 esi
  0008a	5f		 pop	 edi
  0008b	c6 03 04	 mov	 BYTE PTR [ebx], 4
  0008e	5b		 pop	 ebx

; 506  : }

  0008f	59		 pop	 ecx
  00090	c3		 ret	 0
$LN15@externaliz:

; 476  :        *type=VAR_TYPE;
; 477  :        result=V2O(val);
; 478  :      }
; 479  :      else if(BP_is_compound(val)) { /* recursive case */

  00091	83 f8 03	 cmp	 eax, 3
  00094	0f 85 e6 00 00
	00		 jne	 $LN13@externaliz
  0009a	8b c6		 mov	 eax, esi
  0009c	c1 e8 18	 shr	 eax, 24			; 00000018H
  0009f	89 44 24 0c	 mov	 DWORD PTR tv254[esp+16], eax
  000a3	85 c0		 test	 eax, eax
  000a5	0f 84 d5 00 00
	00		 je	 $LN13@externaliz

; 480  :        bp_long i;
; 481  :        bp_long l=GETARITY(val);
; 482  :        Term T=newTerm(l);

  000ab	55		 push	 ebp
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _newTerm

; 483  :        *type=TERM_TYPE;
; 484  :        setArg(0,T,STRING_TYPE,S2O(NAME(val)));

  000b2	c1 ee 02	 shr	 esi, 2
  000b5	c6 03 05	 mov	 BYTE PTR [ebx], 5
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atomtable
  000be	8b e8		 mov	 ebp, eax
  000c0	81 e6 ff ff 3f
	00		 and	 esi, 4194303		; 003fffffH
  000c6	8b 34 b1	 mov	 esi, DWORD PTR [ecx+esi*4]
  000c9	83 c4 04	 add	 esp, 4
  000cc	83 7d 00 00	 cmp	 DWORD PTR [ebp], 0
  000d0	7e 14		 jle	 SHORT $LN36@externaliz
  000d2	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  000d5	56		 push	 esi
  000d6	c6 02 01	 mov	 BYTE PTR [edx], 1
  000d9	e8 00 00 00 00	 call	 _newTermString
  000de	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000e1	83 c4 04	 add	 esp, 4
  000e4	89 01		 mov	 DWORD PTR [ecx], eax
$LN36@externaliz:

; 485  :        for(i=1;i<=l;i++) {

  000e6	be 01 00 00 00	 mov	 esi, 1
  000eb	39 74 24 10	 cmp	 DWORD PTR tv254[esp+20], esi
  000ef	0f 8c 83 00 00
	00		 jl	 $LN10@externaliz
  000f5	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  000f8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL12@externaliz:

; 486  :          OBJECT X; BYTE xtype=BAD_TYPE;

  00100	c6 44 24 18 00	 mov	 BYTE PTR _xtype$5617[esp+16], 0

; 487  :          cell xval;term xref;
; 488  :          FDEREF(t+i);

  00105	8b cb		 mov	 ecx, ebx
  00107	f6 c3 03	 test	 bl, 3
  0010a	74 04		 je	 SHORT $LN45@externaliz
  0010c	8b c3		 mov	 eax, ebx
  0010e	eb 12		 jmp	 SHORT $LN6@externaliz
$LN45@externaliz:
  00110	8b 03		 mov	 eax, DWORD PTR [ebx]
  00112	a8 03		 test	 al, 3
  00114	75 0c		 jne	 SHORT $LN6@externaliz
$LL7@externaliz:
  00116	3b c8		 cmp	 ecx, eax
  00118	74 08		 je	 SHORT $LN6@externaliz
  0011a	8b c8		 mov	 ecx, eax
  0011c	8b 00		 mov	 eax, DWORD PTR [eax]
  0011e	a8 03		 test	 al, 3
  00120	74 f4		 je	 SHORT $LL7@externaliz
$LN6@externaliz:

; 489  :          if(!BP_is_compound(xval)) xref=C2T(xval);

  00122	8b d0		 mov	 edx, eax
  00124	83 e2 03	 and	 edx, 3
  00127	80 fa 03	 cmp	 dl, 3
  0012a	75 07		 jne	 SHORT $LN4@externaliz
  0012c	a9 00 00 00 ff	 test	 eax, -16777216		; ff000000H
  00131	75 02		 jne	 SHORT $LN5@externaliz
$LN4@externaliz:
  00133	8b c8		 mov	 ecx, eax
$LN5@externaliz:

; 490  :          X=externalize_object(xref,&xtype);

  00135	8d 44 24 18	 lea	 eax, DWORD PTR _xtype$5617[esp+16]
  00139	50		 push	 eax
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 _externalize_object
  00140	83 c4 08	 add	 esp, 8

; 491  :          if(NULL==X && xtype==BAD_TYPE) {T=NULL; *type=BAD_TYPE; break;}

  00143	85 c0		 test	 eax, eax
  00145	75 06		 jne	 SHORT $LN3@externaliz
  00147	38 44 24 18	 cmp	 BYTE PTR _xtype$5617[esp+16], al
  0014b	74 22		 je	 SHORT $LN46@externaliz
$LN3@externaliz:

; 492  :          setArg(i,T,xtype,X);

  0014d	8b 4c 24 18	 mov	 ecx, DWORD PTR _xtype$5617[esp+16]
  00151	50		 push	 eax
  00152	51		 push	 ecx
  00153	55		 push	 ebp
  00154	56		 push	 esi
  00155	e8 00 00 00 00	 call	 _setArg
  0015a	46		 inc	 esi
  0015b	83 c4 10	 add	 esp, 16			; 00000010H
  0015e	83 c3 04	 add	 ebx, 4
  00161	3b 74 24 10	 cmp	 esi, DWORD PTR tv254[esp+20]
  00165	7e 99		 jle	 SHORT $LL12@externaliz

; 504  :   }
; 505  :   return result;

  00167	8b c5		 mov	 eax, ebp
  00169	5d		 pop	 ebp
  0016a	5e		 pop	 esi
  0016b	5f		 pop	 edi
  0016c	5b		 pop	 ebx

; 506  : }

  0016d	59		 pop	 ecx
  0016e	c3		 ret	 0
$LN46@externaliz:

; 491  :          if(NULL==X && xtype==BAD_TYPE) {T=NULL; *type=BAD_TYPE; break;}

  0016f	8b 54 24 1c	 mov	 edx, DWORD PTR _type$[esp+16]
  00173	33 ed		 xor	 ebp, ebp
  00175	c6 02 00	 mov	 BYTE PTR [edx], 0
$LN10@externaliz:

; 504  :   }
; 505  :   return result;

  00178	8b c5		 mov	 eax, ebp
  0017a	5d		 pop	 ebp
  0017b	5e		 pop	 esi
  0017c	5f		 pop	 edi
  0017d	5b		 pop	 ebx

; 506  : }

  0017e	59		 pop	 ecx
  0017f	c3		 ret	 0
$LN13@externaliz:
  00180	5e		 pop	 esi
  00181	5f		 pop	 edi

; 493  :        }
; 494  :        result=T;
; 495  :      }
; 496  :      else {
; 497  :        *type=BAD_TYPE;

  00182	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 498  :        result=NULL;

  00185	33 c0		 xor	 eax, eax
  00187	5b		 pop	 ebx

; 506  : }

  00188	59		 pop	 ecx
  00189	c3		 ret	 0
$LN18@externaliz:
  0018a	5f		 pop	 edi

; 499  :      }   
; 500  :   }
; 501  :   else {
; 502  :     *type=BAD_TYPE;

  0018b	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 503  :     result=NULL;

  0018e	33 c0		 xor	 eax, eax
  00190	5b		 pop	 ebx

; 506  : }

  00191	59		 pop	 ecx
  00192	c3		 ret	 0
_externalize_object ENDP
_TEXT	ENDS
PUBLIC	_externalize
; Function compile flags: /Ogtpy
;	COMDAT _externalize
_TEXT	SEGMENT
_type$ = -1						; size = 1
_t$ = 8							; size = 4
_externalize PROC					; COMDAT

; 512  : Term externalize(term t) {

  00000	51		 push	 ecx

; 513  :   BYTE type=BAD_TYPE;
; 514  :   Term T=NULL;
; 515  :   OBJECT X=externalize_object(t,&type);

  00001	8b 4c 24 08	 mov	 ecx, DWORD PTR _t$[esp]
  00005	53		 push	 ebx
  00006	57		 push	 edi
  00007	8d 44 24 0b	 lea	 eax, DWORD PTR _type$[esp+12]
  0000b	50		 push	 eax
  0000c	51		 push	 ecx
  0000d	c6 44 24 13 00	 mov	 BYTE PTR _type$[esp+20], 0
  00012	e8 00 00 00 00	 call	 _externalize_object

; 516  :   if(NULL==X && type==BAD_TYPE) T=NULL;

  00017	8a 5c 24 13	 mov	 bl, BYTE PTR _type$[esp+20]
  0001b	8b f8		 mov	 edi, eax
  0001d	83 c4 08	 add	 esp, 8
  00020	85 ff		 test	 edi, edi
  00022	75 0a		 jne	 SHORT $LN4@externaliz@2
  00024	84 db		 test	 bl, bl
  00026	75 06		 jne	 SHORT $LN4@externaliz@2
  00028	5f		 pop	 edi
  00029	33 c0		 xor	 eax, eax
  0002b	5b		 pop	 ebx

; 523  : }

  0002c	59		 pop	 ecx
  0002d	c3		 ret	 0
$LN4@externaliz@2:

; 517  :   else if(TERM_TYPE==type && X!=NULL) T=O2T(X);

  0002e	80 fb 05	 cmp	 bl, 5
  00031	75 04		 jne	 SHORT $LN2@externaliz@2
  00033	85 ff		 test	 edi, edi

; 518  :   else {

  00035	75 38		 jne	 SHORT $LN10@externaliz@2
$LN2@externaliz@2:
  00037	56		 push	 esi

; 519  :     T=newTerm(0);

  00038	6a 00		 push	 0
  0003a	e8 00 00 00 00	 call	 _newTerm
  0003f	8b f0		 mov	 esi, eax
  00041	83 c4 04	 add	 esp, 4

; 520  :     setArg(0,T,type,X);

  00044	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00047	8b c7		 mov	 eax, edi
  00049	7e 21		 jle	 SHORT $LN20@externaliz@2
  0004b	80 fb 05	 cmp	 bl, 5
  0004e	77 1c		 ja	 SHORT $LN20@externaliz@2
  00050	84 db		 test	 bl, bl
  00052	74 18		 je	 SHORT $LN20@externaliz@2
  00054	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00057	88 1a		 mov	 BYTE PTR [edx], bl
  00059	80 fb 01	 cmp	 bl, 1
  0005c	75 09		 jne	 SHORT $LN9@externaliz@2
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 _newTermString
  00064	83 c4 04	 add	 esp, 4
$LN9@externaliz@2:
  00067	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0006a	89 01		 mov	 DWORD PTR [ecx], eax
$LN20@externaliz@2:

; 521  :   }
; 522  :   return T;

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
$LN10@externaliz@2:
  0006f	5f		 pop	 edi
  00070	5b		 pop	 ebx

; 523  : }

  00071	59		 pop	 ecx
  00072	c3		 ret	 0
_externalize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@FPNIIBDK@bad?5data?5in?5internalize_object?$AA@ ; `string'
EXTRN	_make_float:PROC
EXTRN	_input_fun:PROC
;	COMDAT ??_C@_0BP@FPNIIBDK@bad?5data?5in?5internalize_object?$AA@
CONST	SEGMENT
??_C@_0BP@FPNIIBDK@bad?5data?5in?5internalize_object?$AA@ DB 'bad data in'
	DB	' internalize_object', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _internalize_object
_TEXT	SEGMENT
_O$ = 8							; size = 4
_type$ = 12						; size = 1
_xtype$5742 = 16					; size = 1
_H$ = 16						; size = 4
_l$6440 = 20						; size = 4
_result$ = 20						; size = 4
_internalize_object PROC				; COMDAT

; 526  :   *result=BP_nil;

  00000	a1 20 00 00 00	 mov	 eax, DWORD PTR _g+32
  00005	56		 push	 esi

; 527  :  
; 528  :   if(NULL==H) return NULL;

  00006	8b 74 24 10	 mov	 esi, DWORD PTR _H$[esp]
  0000a	57		 push	 edi
  0000b	8b 7c 24 18	 mov	 edi, DWORD PTR _result$[esp+4]
  0000f	89 07		 mov	 DWORD PTR [edi], eax
  00011	85 f6		 test	 esi, esi
  00013	75 05		 jne	 SHORT $LN16@internaliz
  00015	5f		 pop	 edi
  00016	33 c0		 xor	 eax, eax
  00018	5e		 pop	 esi

; 571  : }

  00019	c3		 ret	 0
$LN16@internaliz:

; 529  :   switch(type) {

  0001a	0f b6 44 24 10	 movzx	 eax, BYTE PTR _type$[esp+4]
  0001f	48		 dec	 eax
  00020	53		 push	 ebx
  00021	55		 push	 ebp
  00022	83 f8 04	 cmp	 eax, 4
  00025	0f 87 16 01 00
	00		 ja	 $LN1@internaliz
  0002b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN46@internaliz[eax*4]
$LN13@internaliz:

; 530  :     case STRING_TYPE: {
; 531  :       *result=BP_string(O2S(O));

  00032	8b 4c 24 14	 mov	 ecx, DWORD PTR _O$[esp+12]
  00036	6a 00		 push	 0
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _input_fun
  0003e	83 c4 08	 add	 esp, 8
  00041	5d		 pop	 ebp
  00042	5b		 pop	 ebx
  00043	89 07		 mov	 DWORD PTR [edi], eax
  00045	5f		 pop	 edi

; 569  :   }
; 570  :   return H;

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 571  : }

  00049	c3		 ret	 0
$LN12@internaliz:

; 532  :     } break;
; 533  :     case INT_TYPE: {
; 534  :       *result=BP_integer(O2I(O));

  0004a	8b 54 24 14	 mov	 edx, DWORD PTR _O$[esp+12]
  0004e	5d		 pop	 ebp
  0004f	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  00056	83 c8 01	 or	 eax, 1
  00059	5b		 pop	 ebx
  0005a	89 07		 mov	 DWORD PTR [edi], eax
  0005c	5f		 pop	 edi

; 569  :   }
; 570  :   return H;

  0005d	8b c6		 mov	 eax, esi
  0005f	5e		 pop	 esi

; 571  : }

  00060	c3		 ret	 0
$LN11@internaliz:

; 535  :     } break;
; 536  :     case FLOAT_TYPE: {
; 537  :       double df=O2F(O);

  00061	8b 4c 24 14	 mov	 ecx, DWORD PTR _O$[esp+12]
  00065	89 4c 24 20	 mov	 DWORD PTR _l$6440[esp+12], ecx

; 538  :       BP_make_float(*result,df);

  00069	d9 44 24 20	 fld	 DWORD PTR _l$6440[esp+12]
  0006d	83 ec 08	 sub	 esp, 8
  00070	dd 1c 24	 fstp	 QWORD PTR [esp]
  00073	56		 push	 esi
  00074	89 37		 mov	 DWORD PTR [edi], esi
  00076	e8 00 00 00 00	 call	 _make_float
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	5d		 pop	 ebp
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi
  00081	8b f0		 mov	 esi, eax
  00083	5e		 pop	 esi

; 571  : }

  00084	c3		 ret	 0
$LN10@internaliz:
  00085	5d		 pop	 ebp

; 539  :     } break;
; 540  :     case VAR_TYPE: {
; 541  :       /* TODO */
; 542  :       BP_put_new_var(*result);

  00086	89 36		 mov	 DWORD PTR [esi], esi
  00088	89 37		 mov	 DWORD PTR [edi], esi
  0008a	5b		 pop	 ebx
  0008b	83 c6 04	 add	 esi, 4
  0008e	5f		 pop	 edi

; 569  :   }
; 570  :   return H;

  0008f	8b c6		 mov	 eax, esi
  00091	5e		 pop	 esi

; 571  : }

  00092	c3		 ret	 0
$LN9@internaliz:

; 543  :     } break;
; 544  :     case TERM_TYPE: {
; 545  :       Term T=O2T(O);
; 546  :       bp_long i;
; 547  :       bp_long l=T->size;

  00093	8b 54 24 14	 mov	 edx, DWORD PTR _O$[esp+12]
  00097	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 548  :       cell *args=malloc(l*sizeof(cell));

  00099	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _malloc
  000a6	83 c4 04	 add	 esp, 4

; 549  :   
; 550  :       for(i=0;i<l;i++) {

  000a9	33 ff		 xor	 edi, edi
  000ab	8b e8		 mov	 ebp, eax
  000ad	85 db		 test	 ebx, ebx
  000af	7e 4e		 jle	 SHORT $LN6@internaliz
$LL42@internaliz:

; 551  :         BYTE xtype=getType(i,T);

  000b1	8b 44 24 14	 mov	 eax, DWORD PTR _O$[esp+12]
  000b5	85 ff		 test	 edi, edi
  000b7	78 10		 js	 SHORT $LN27@internaliz
  000b9	3b 38		 cmp	 edi, DWORD PTR [eax]
  000bb	7d 0c		 jge	 SHORT $LN27@internaliz
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c0	8a 14 0f	 mov	 dl, BYTE PTR [edi+ecx]
  000c3	88 54 24 1c	 mov	 BYTE PTR _xtype$5742[esp+12], dl
  000c7	eb 05		 jmp	 SHORT $LN29@internaliz
$LN27@internaliz:
  000c9	c6 44 24 1c 00	 mov	 BYTE PTR _xtype$5742[esp+12], 0
$LN29@internaliz:

; 552  :         OBJECT X=getArg(i,T);

  000ce	85 ff		 test	 edi, edi
  000d0	78 0c		 js	 SHORT $LN31@internaliz
  000d2	3b 38		 cmp	 edi, DWORD PTR [eax]
  000d4	7d 08		 jge	 SHORT $LN31@internaliz
  000d6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d9	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  000dc	eb 02		 jmp	 SHORT $LN33@internaliz
$LN31@internaliz:
  000de	33 c0		 xor	 eax, eax
$LN33@internaliz:

; 553  :      
; 554  :         H=internalize_object(X,xtype,H,args+i);

  000e0	8b 54 24 1c	 mov	 edx, DWORD PTR _xtype$5742[esp+12]
  000e4	8d 4c bd 00	 lea	 ecx, DWORD PTR [ebp+edi*4]
  000e8	51		 push	 ecx
  000e9	56		 push	 esi
  000ea	52		 push	 edx
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _internalize_object
  000f1	8b f0		 mov	 esi, eax
  000f3	83 c4 10	 add	 esp, 16			; 00000010H

; 555  :         if(NULL==H) return NULL;

  000f6	85 f6		 test	 esi, esi
  000f8	74 54		 je	 SHORT $LN39@internaliz

; 549  :   
; 550  :       for(i=0;i<l;i++) {

  000fa	47		 inc	 edi
  000fb	3b fb		 cmp	 edi, ebx
  000fd	7c b2		 jl	 SHORT $LL42@internaliz
$LN6@internaliz:

; 556  :       }     
; 557  :       args[0]=PUTARITY(args[0],getArity(T));

  000ff	8b 44 24 14	 mov	 eax, DWORD PTR _O$[esp+12]
  00103	8b 08		 mov	 ecx, DWORD PTR [eax]
  00105	8b 55 00	 mov	 edx, DWORD PTR [ebp]

; 558  :       *result=T2C(H);

  00108	8b 44 24 20	 mov	 eax, DWORD PTR _result$[esp+12]
  0010c	49		 dec	 ecx
  0010d	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00110	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00116	0b ca		 or	 ecx, edx
  00118	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  0011b	89 30		 mov	 DWORD PTR [eax], esi

; 559  :       for(i=0;i<l;i++) {

  0011d	33 c0		 xor	 eax, eax
  0011f	85 db		 test	 ebx, ebx
  00121	7e 0e		 jle	 SHORT $LN2@internaliz
$LL4@internaliz:

; 560  :         BP_put_arg(args[i]);

  00123	8b 4c 85 00	 mov	 ecx, DWORD PTR [ebp+eax*4]
  00127	89 0e		 mov	 DWORD PTR [esi], ecx
  00129	40		 inc	 eax
  0012a	83 c6 04	 add	 esi, 4
  0012d	3b c3		 cmp	 eax, ebx
  0012f	7c f2		 jl	 SHORT $LL4@internaliz
$LN2@internaliz:

; 561  :       }
; 562  :       free(args);

  00131	55		 push	 ebp
  00132	e8 00 00 00 00	 call	 _free
  00137	83 c4 04	 add	 esp, 4
  0013a	5d		 pop	 ebp
  0013b	5b		 pop	 ebx
  0013c	5f		 pop	 edi

; 569  :   }
; 570  :   return H;

  0013d	8b c6		 mov	 eax, esi
  0013f	5e		 pop	 esi

; 571  : }

  00140	c3		 ret	 0
$LN1@internaliz:

; 563  :     
; 564  :     } break;
; 565  :     default: 
; 566  :       /*fprintf(STD_err,"BAD_OBJECT=>object=%ld type=%ld H=%ld\n",O,type,H);*/
; 567  :       warnmes("bad data in internalize_object");

  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FPNIIBDK@bad?5data?5in?5internalize_object?$AA@
  00146	e8 00 00 00 00	 call	 _warnmes
  0014b	83 c4 04	 add	 esp, 4
$LN39@internaliz:

; 568  :       return NULL;

  0014e	5d		 pop	 ebp
  0014f	5b		 pop	 ebx
  00150	5f		 pop	 edi
  00151	33 c0		 xor	 eax, eax
  00153	5e		 pop	 esi

; 571  : }

  00154	c3		 ret	 0
  00155	8d 49 00	 npad	 3
$LN46@internaliz:
  00158	00 00 00 00	 DD	 $LN13@internaliz
  0015c	00 00 00 00	 DD	 $LN12@internaliz
  00160	00 00 00 00	 DD	 $LN11@internaliz
  00164	00 00 00 00	 DD	 $LN10@internaliz
  00168	00 00 00 00	 DD	 $LN9@internaliz
_internalize_object ENDP
_TEXT	ENDS
PUBLIC	_internalize
; Function compile flags: /Ogtpy
;	COMDAT _internalize
_TEXT	SEGMENT
_T$ = 8							; size = 4
_H$ = 12						; size = 4
_result$ = 16						; size = 4
_internalize PROC					; COMDAT

; 579  :   if(NULL==T) return NULL;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _T$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $LN1@internaliz@2

; 581  : }

  00008	c3		 ret	 0
$LN1@internaliz@2:

; 580  :   return internalize_object(T2O(T),TERM_TYPE,H,result);

  00009	8b 4c 24 0c	 mov	 ecx, DWORD PTR _result$[esp-4]
  0000d	8b 54 24 08	 mov	 edx, DWORD PTR _H$[esp-4]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	6a 05		 push	 5
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _internalize_object
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 581  : }

  0001e	c3		 ret	 0
_internalize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@NOGECHEG@bad?5op?9code?5in?5term_store_op?$AA@ ; `string'
PUBLIC	??_C@_02GNMIELFD@?$DN?$DO?$AA@			; `string'
PUBLIC	??_C@_0BH@GPAOEOPE@compareTerms?$CIK?0V?$CJ?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@OLNFHCCP@V?3to?5safely?5sized?5buffer?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@BIAAOPL@V?3stringLengthOf?$DN?$CFld?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@HONHNFNA@V?3toNewString?$DN?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@PIHKDHEP@V?3hashCode?$DN?$CFld?6?$AA@	; `string'
PUBLIC	??_C@_04MNJDMHJB@?$DM?$DNV?6?$AA@		; `string'
PUBLIC	??_C@_0BA@BHBHELII@K?3hashCode?$DN?$CFld?6?$AA@	; `string'
PUBLIC	??_C@_08OBDGPIMK@?$DM?$DNK?3?$CFld?6?$AA@	; `string'
PUBLIC	??_C@_03ICICOMAL@yes?$AA@			; `string'
PUBLIC	??_C@_0CJ@BBOMNFCH@op?9code?5of?5C?9function?5must?5be?5an@ ; `string'
PUBLIC	_term_store_op
EXTRN	_processTerm:PROC
EXTRN	_newKeyIterator:PROC
EXTRN	_countTerms:PROC
EXTRN	_deleteAllTerms:PROC
EXTRN	_updateCurrentTerm:PROC
EXTRN	_removeCurrentTerm:PROC
EXTRN	_getNextTerm:PROC
EXTRN	_hasTerms:PROC
EXTRN	_closeIterator:PROC
EXTRN	_newIterator:PROC
EXTRN	_putTerm:PROC
EXTRN	_pushTerm:PROC
EXTRN	_local_error:PROC
;	COMDAT ??_C@_0BN@NOGECHEG@bad?5op?9code?5in?5term_store_op?$AA@
CONST	SEGMENT
??_C@_0BN@NOGECHEG@bad?5op?9code?5in?5term_store_op?$AA@ DB 'bad op-code '
	DB	'in term_store_op', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GNMIELFD@?$DN?$DO?$AA@
CONST	SEGMENT
??_C@_02GNMIELFD@?$DN?$DO?$AA@ DB '=>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPAOEOPE@compareTerms?$CIK?0V?$CJ?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BH@GPAOEOPE@compareTerms?$CIK?0V?$CJ?$DN?$CFld?6?$AA@ DB 'compareT'
	DB	'erms(K,V)=%ld', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OLNFHCCP@V?3to?5safely?5sized?5buffer?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@OLNFHCCP@V?3to?5safely?5sized?5buffer?$DN?$CFs?6?$AA@ DB 'V:to '
	DB	'safely sized buffer=%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BIAAOPL@V?3stringLengthOf?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BG@BIAAOPL@V?3stringLengthOf?$DN?$CFld?6?$AA@ DB 'V:stringLengthOf'
	DB	'=%ld', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HONHNFNA@V?3toNewString?$DN?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@HONHNFNA@V?3toNewString?$DN?$CFs?6?$AA@ DB 'V:toNewString=%s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIHKDHEP@V?3hashCode?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BA@PIHKDHEP@V?3hashCode?$DN?$CFld?6?$AA@ DB 'V:hashCode=%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MNJDMHJB@?$DM?$DNV?6?$AA@
CONST	SEGMENT
??_C@_04MNJDMHJB@?$DM?$DNV?6?$AA@ DB '<=V', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHBHELII@K?3hashCode?$DN?$CFld?6?$AA@
CONST	SEGMENT
??_C@_0BA@BHBHELII@K?3hashCode?$DN?$CFld?6?$AA@ DB 'K:hashCode=%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBDGPIMK@?$DM?$DNK?3?$CFld?6?$AA@
CONST	SEGMENT
??_C@_08OBDGPIMK@?$DM?$DNK?3?$CFld?6?$AA@ DB '<=K:%ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes?$AA@
CONST	SEGMENT
??_C@_03ICICOMAL@yes?$AA@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BBOMNFCH@op?9code?5of?5C?9function?5must?5be?5an@
CONST	SEGMENT
??_C@_0CJ@BBOMNFCH@op?9code?5of?5C?9function?5must?5be?5an@ DB 'op-code o'
	DB	'f C-function must be an integer', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _term_store_op
_TEXT	SEGMENT
_H$ = 8							; size = 4
_result$5992 = 12					; size = 4
_result$5956 = 12					; size = 4
_result$5896 = 12					; size = 4
_result$5838 = 12					; size = 4
_regs$ = 12						; size = 4
_wam$ = 16						; size = 4
_term_store_op PROC					; COMDAT

; 601  : {

  00000	56		 push	 esi

; 602  :   BP_check_call();

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _regs$[esp]
  00005	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00008	8b c8		 mov	 ecx, eax
  0000a	80 e1 03	 and	 cl, 3
  0000d	80 f9 01	 cmp	 cl, 1
  00010	74 12		 je	 SHORT $LN21@term_store
  00012	5e		 pop	 esi
  00013	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _regs$[esp-4], OFFSET ??_C@_0CJ@BBOMNFCH@op?9code?5of?5C?9function?5must?5be?5an@
  0001b	89 44 24 04	 mov	 DWORD PTR _H$[esp-4], eax
  0001f	e9 00 00 00 00	 jmp	 _local_error
$LN21@term_store:
  00024	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00027	53		 push	 ebx
  00028	57		 push	 edi

; 603  :   BP_result=BP_string("yes");

  00029	33 db		 xor	 ebx, ebx
  0002b	53		 push	 ebx
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_03ICICOMAL@yes?$AA@
  00031	89 46 f0	 mov	 DWORD PTR [esi-16], eax
  00034	e8 00 00 00 00	 call	 _input_fun
  00039	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 604  : 
; 605  :   switch(BP_op) {

  0003c	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  0003f	c1 f8 02	 sar	 eax, 2
  00042	83 c4 08	 add	 esp, 8
  00045	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00048	0f 87 5f 03 00
	00		 ja	 $LN1@term_store
  0004e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN63@term_store[eax*4]
$LN18@term_store:

; 606  :     case TSTEST_K_V: {
; 607  :       Term K; Term V;    
; 608  :       K=externalize(C2T(BP_input));

  00055	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00058	55		 push	 ebp
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _externalize
  0005f	8b d8		 mov	 ebx, eax

; 609  :       showTerm(K);printf("<=K:%ld\n",(long)K);

  00061	53		 push	 ebx
  00062	e8 00 00 00 00	 call	 _showTerm
  00067	53		 push	 ebx
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_08OBDGPIMK@?$DM?$DNK?3?$CFld?6?$AA@
  0006d	e8 00 00 00 00	 call	 _printf

; 610  :       printf("K:hashCode=%ld\n",hashCode(K));

  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 _hashCode
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BHBHELII@K?3hashCode?$DN?$CFld?6?$AA@
  0007e	e8 00 00 00 00	 call	 _printf

; 611  : 
; 612  :       V=externalize(C2T(BP_data));  

  00083	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _externalize
  0008c	8b f8		 mov	 edi, eax

; 613  :       showTerm(V);printf("<=V\n");

  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 _showTerm
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_04MNJDMHJB@?$DM?$DNV?6?$AA@
  00099	e8 00 00 00 00	 call	 _printf

; 614  :       printf("V:hashCode=%ld\n",hashCode(V));

  0009e	57		 push	 edi
  0009f	e8 00 00 00 00	 call	 _hashCode
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PIHKDHEP@V?3hashCode?$DN?$CFld?6?$AA@
  000aa	e8 00 00 00 00	 call	 _printf

; 615  :       
; 616  :       { bp_long l; char *buf; char *s=toNewString(V); 

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 _toNewString
  000b5	8b e8		 mov	 ebp, eax

; 617  :         printf("V:toNewString=%s\n",s);

  000b7	55		 push	 ebp
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HONHNFNA@V?3toNewString?$DN?$CFs?6?$AA@
  000bd	e8 00 00 00 00	 call	 _printf
  000c2	83 c4 40	 add	 esp, 64			; 00000040H

; 618  :         free(s);

  000c5	55		 push	 ebp
  000c6	e8 00 00 00 00	 call	 _free

; 619  :         l=stringLengthOf(V);

  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 _stringLengthOf
  000d1	8b e8		 mov	 ebp, eax

; 620  :         printf("V:stringLengthOf=%ld\n",l);

  000d3	55		 push	 ebp
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BIAAOPL@V?3stringLengthOf?$DN?$CFld?6?$AA@
  000d9	e8 00 00 00 00	 call	 _printf

; 621  :         buf=(char *)malloc(l+1);

  000de	45		 inc	 ebp
  000df	55		 push	 ebp
  000e0	e8 00 00 00 00	 call	 _malloc
  000e5	8b e8		 mov	 ebp, eax

; 622  :         toString(V,buf);

  000e7	55		 push	 ebp
  000e8	57		 push	 edi
  000e9	e8 00 00 00 00	 call	 _toString

; 623  :         printf("V:to safely sized buffer=%s\n",buf);

  000ee	55		 push	 ebp
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OLNFHCCP@V?3to?5safely?5sized?5buffer?$DN?$CFs?6?$AA@
  000f4	e8 00 00 00 00	 call	 _printf

; 624  :         free(buf);

  000f9	55		 push	 ebp
  000fa	e8 00 00 00 00	 call	 _free

; 625  :       };
; 626  : 
; 627  :       printf("compareTerms(K,V)=%ld\n",compareTerms(K,V));

  000ff	57		 push	 edi
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _compareTerms
  00106	50		 push	 eax
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GPAOEOPE@compareTerms?$CIK?0V?$CJ?$DN?$CFld?6?$AA@
  0010c	e8 00 00 00 00	 call	 _printf

; 628  :       { cell result=ZERO;
; 629  :         Term KV=newTerm(2);

  00111	6a 02		 push	 2
  00113	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR _result$5838[esp+72], 0
  0011b	e8 00 00 00 00	 call	 _newTerm
  00120	8b e8		 mov	 ebp, eax
  00122	83 c4 3c	 add	 esp, 60			; 0000003cH

; 630  :         setArg(0,KV,STRING_TYPE,S2O("=>"));

  00125	83 7d 00 00	 cmp	 DWORD PTR [ebp], 0
  00129	7e 18		 jle	 SHORT $LN27@term_store
  0012b	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_02GNMIELFD@?$DN?$DO?$AA@
  00133	c6 00 01	 mov	 BYTE PTR [eax], 1
  00136	e8 00 00 00 00	 call	 _newTermString
  0013b	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  0013e	83 c4 04	 add	 esp, 4
  00141	89 01		 mov	 DWORD PTR [ecx], eax
$LN27@term_store:

; 631  : 
; 632  :         setArg(1,KV,TERM_TYPE,T2O(K));

  00143	83 7d 00 01	 cmp	 DWORD PTR [ebp], 1
  00147	b0 05		 mov	 al, 5
  00149	7e 0c		 jle	 SHORT $LN38@term_store
  0014b	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  0014e	88 42 01	 mov	 BYTE PTR [edx+1], al
  00151	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  00154	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
$LN38@term_store:

; 633  :         setArg(2,KV,TERM_TYPE,T2O(V));

  00157	83 7d 00 02	 cmp	 DWORD PTR [ebp], 2
  0015b	7e 0c		 jle	 SHORT $LN49@term_store
  0015d	8b 55 04	 mov	 edx, DWORD PTR [ebp+4]
  00160	88 42 02	 mov	 BYTE PTR [edx+2], al
  00163	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00166	89 78 08	 mov	 DWORD PTR [eax+8], edi
$LN49@term_store:

; 634  : 
; 635  :         H=internalize(KV,H,&result);

  00169	8b 54 24 14	 mov	 edx, DWORD PTR _H$[esp+12]
  0016d	8d 4c 24 18	 lea	 ecx, DWORD PTR _result$5838[esp+12]
  00171	51		 push	 ecx
  00172	52		 push	 edx
  00173	55		 push	 ebp
  00174	e8 00 00 00 00	 call	 _internalize
  00179	89 44 24 20	 mov	 DWORD PTR _H$[esp+24], eax

; 636  :         BP_result=result;

  0017d	8b 44 24 24	 mov	 eax, DWORD PTR _result$5838[esp+24]
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
  00184	89 46 f0	 mov	 DWORD PTR [esi-16], eax
  00187	5d		 pop	 ebp
$LN57@term_store:

; 637  :       }
; 638  :     }
; 639  : 
; 640  :     case PUSH_TERM_K_V: {
; 641  :       Term K=externalize(C2T(BP_input));

  00188	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 _externalize

; 642  :       Term V=externalize(C2T(BP_data));

  00191	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  00194	52		 push	 edx
  00195	8b f8		 mov	 edi, eax
  00197	e8 00 00 00 00	 call	 _externalize

; 643  :       pushTerm(K,V);

  0019c	50		 push	 eax
  0019d	57		 push	 edi
  0019e	e8 00 00 00 00	 call	 _pushTerm

; 745  :   }
; 746  : 
; 747  :   return H;

  001a3	8b 44 24 20	 mov	 eax, DWORD PTR _H$[esp+24]
  001a7	83 c4 10	 add	 esp, 16			; 00000010H
  001aa	5f		 pop	 edi
  001ab	5b		 pop	 ebx
  001ac	5e		 pop	 esi

; 748  : }

  001ad	c3		 ret	 0
$LN16@term_store:

; 644  :     }
; 645  :     break;
; 646  :     case PUT_TERM_K_V: /*termTester()*/;
; 647  :       { Term K; Term V;     
; 648  :         K=externalize(C2T(BP_input));

  001ae	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 _externalize

; 649  :         V=externalize(C2T(BP_data));  

  001b7	8b 4e f4	 mov	 ecx, DWORD PTR [esi-12]
  001ba	51		 push	 ecx
  001bb	8b f8		 mov	 edi, eax
  001bd	e8 00 00 00 00	 call	 _externalize

; 650  :         putTerm(K,V);

  001c2	50		 push	 eax
  001c3	57		 push	 edi
  001c4	e8 00 00 00 00	 call	 _putTerm

; 745  :   }
; 746  : 
; 747  :   return H;

  001c9	8b 44 24 20	 mov	 eax, DWORD PTR _H$[esp+24]
  001cd	83 c4 10	 add	 esp, 16			; 00000010H
  001d0	5f		 pop	 edi
  001d1	5b		 pop	 ebx
  001d2	5e		 pop	 esi

; 748  : }

  001d3	c3		 ret	 0
$LN15@term_store:

; 651  :       }
; 652  :       break;
; 653  :     case NEW_ITERATOR_K: {
; 654  :         Term K=externalize(C2T(BP_input));

  001d4	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  001d7	52		 push	 edx
  001d8	e8 00 00 00 00	 call	 _externalize

; 655  :         ulong i=newIterator(K);

  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 _newIterator
  001e3	83 c4 08	 add	 esp, 8

; 656  :         BP_result=BP_integer(i);

  001e6	03 c0		 add	 eax, eax
  001e8	03 c0		 add	 eax, eax
  001ea	5f		 pop	 edi
  001eb	83 c8 01	 or	 eax, 1
  001ee	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  001f1	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  001f5	5b		 pop	 ebx
  001f6	5e		 pop	 esi

; 748  : }

  001f7	c3		 ret	 0
$LN14@term_store:

; 657  :       }
; 658  :       break;
; 659  :     case CLOSE_ITERATOR_I:{
; 660  :         ulong i;
; 661  :         BP_get_integer(BP_input,i); 

  001f8	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  001fb	c1 f8 02	 sar	 eax, 2

; 662  :         closeIterator(i);

  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 _closeIterator

; 745  :   }
; 746  : 
; 747  :   return H;

  00204	8b 44 24 14	 mov	 eax, DWORD PTR _H$[esp+12]
  00208	83 c4 04	 add	 esp, 4
  0020b	5f		 pop	 edi
  0020c	5b		 pop	 ebx
  0020d	5e		 pop	 esi

; 748  : }

  0020e	c3		 ret	 0
$LN13@term_store:

; 663  :       }
; 664  :       break;
; 665  :     case HAS_TERMS_K: {
; 666  :         Term K=externalize(C2T(BP_input));

  0020f	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 _externalize

; 667  :         BP_result=BP_integer(hasTerms(K));

  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 _hasTerms
  0021e	0f b6 d0	 movzx	 edx, al

; 745  :   }
; 746  : 
; 747  :   return H;

  00221	8b 44 24 18	 mov	 eax, DWORD PTR _H$[esp+16]
  00225	83 c4 08	 add	 esp, 8
  00228	03 d2		 add	 edx, edx
  0022a	03 d2		 add	 edx, edx
  0022c	5f		 pop	 edi
  0022d	83 ca 01	 or	 edx, 1
  00230	5b		 pop	 ebx
  00231	89 56 f0	 mov	 DWORD PTR [esi-16], edx
  00234	5e		 pop	 esi

; 748  : }

  00235	c3		 ret	 0
$LN12@term_store:

; 668  :       }
; 669  :       break;
; 670  :     case GET_NEXT_TERM_I:  {
; 671  :          bp_long i; Term V;cell result=ZERO;
; 672  :          BP_get_integer(BP_input,i);

  00236	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00239	c1 f8 02	 sar	 eax, 2

; 673  :          V=getNextTerm(i);

  0023c	50		 push	 eax
  0023d	89 5c 24 18	 mov	 DWORD PTR _result$5896[esp+12], ebx
  00241	e8 00 00 00 00	 call	 _getNextTerm

; 674  :          H=internalize(V,H,&result);  

  00246	8b 54 24 14	 mov	 edx, DWORD PTR _H$[esp+12]
  0024a	8d 4c 24 18	 lea	 ecx, DWORD PTR _result$5896[esp+12]
  0024e	51		 push	 ecx
  0024f	52		 push	 edx
  00250	50		 push	 eax
  00251	e8 00 00 00 00	 call	 _internalize
  00256	83 c4 10	 add	 esp, 16			; 00000010H
  00259	89 44 24 10	 mov	 DWORD PTR _H$[esp+8], eax

; 675  :          BP_result=result;

  0025d	8b 44 24 14	 mov	 eax, DWORD PTR _result$5896[esp+8]
  00261	5f		 pop	 edi
  00262	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  00265	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  00269	5b		 pop	 ebx
  0026a	5e		 pop	 esi

; 748  : }

  0026b	c3		 ret	 0
$LN11@term_store:

; 676  :       }
; 677  :       break;
; 678  :     case REMOVE_CURRENT_TERM_I:  {
; 679  :          ulong i;
; 680  :          BP_get_integer(BP_input,i);

  0026c	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  0026f	c1 f9 02	 sar	 ecx, 2

; 681  :          removeCurrentTerm(i);

  00272	51		 push	 ecx
  00273	e8 00 00 00 00	 call	 _removeCurrentTerm

; 745  :   }
; 746  : 
; 747  :   return H;

  00278	8b 44 24 14	 mov	 eax, DWORD PTR _H$[esp+12]
  0027c	83 c4 04	 add	 esp, 4
  0027f	5f		 pop	 edi
  00280	5b		 pop	 ebx
  00281	5e		 pop	 esi

; 748  : }

  00282	c3		 ret	 0
$LN10@term_store:

; 682  :       }
; 683  :       break;
; 684  :     case UPDATE_CURRENT_TERM_I:  {
; 685  :          ulong i; Term V;
; 686  :          BP_get_integer(BP_input,i);
; 687  :          V=externalize(C2T(BP_data));

  00283	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  00286	8b 7e f8	 mov	 edi, DWORD PTR [esi-8]
  00289	52		 push	 edx
  0028a	c1 ff 02	 sar	 edi, 2
  0028d	e8 00 00 00 00	 call	 _externalize

; 688  :          updateCurrentTerm(i,V);

  00292	50		 push	 eax
  00293	57		 push	 edi
  00294	e8 00 00 00 00	 call	 _updateCurrentTerm

; 745  :   }
; 746  : 
; 747  :   return H;

  00299	8b 44 24 1c	 mov	 eax, DWORD PTR _H$[esp+20]
  0029d	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a0	5f		 pop	 edi
  002a1	5b		 pop	 ebx
  002a2	5e		 pop	 esi

; 748  : }

  002a3	c3		 ret	 0
$LN9@term_store:

; 689  :       }
; 690  :     break;
; 691  :     case DELETE_ALL_TERMS_K: {
; 692  :       Term K=externalize(C2T(BP_input));

  002a4	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  002a7	50		 push	 eax
  002a8	e8 00 00 00 00	 call	 _externalize

; 693  :       deleteAllTerms(K);

  002ad	50		 push	 eax
  002ae	e8 00 00 00 00	 call	 _deleteAllTerms

; 745  :   }
; 746  : 
; 747  :   return H;

  002b3	8b 44 24 18	 mov	 eax, DWORD PTR _H$[esp+16]
  002b7	83 c4 08	 add	 esp, 8
  002ba	5f		 pop	 edi
  002bb	5b		 pop	 ebx
  002bc	5e		 pop	 esi

; 748  : }

  002bd	c3		 ret	 0
$LN8@term_store:

; 694  :     }
; 695  :     break;
; 696  :     case COUNT_TERMS_K: {
; 697  :       Term K=externalize(C2T(BP_input));

  002be	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  002c1	51		 push	 ecx
  002c2	e8 00 00 00 00	 call	 _externalize

; 698  :       BP_result=BP_integer(countTerms(K));

  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 _countTerms
  002cd	83 c4 08	 add	 esp, 8
  002d0	03 c0		 add	 eax, eax
  002d2	03 c0		 add	 eax, eax
  002d4	5f		 pop	 edi
  002d5	83 c8 01	 or	 eax, 1
  002d8	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  002db	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  002df	5b		 pop	 ebx
  002e0	5e		 pop	 esi

; 748  : }

  002e1	c3		 ret	 0
$LN7@term_store:

; 699  :     }
; 700  :     break;
; 701  : 
; 702  :     case NEW_TERM_K: {
; 703  :       Term K=externalize(C2T(BP_input));

  002e2	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  002e5	52		 push	 edx
  002e6	e8 00 00 00 00	 call	 _externalize
  002eb	83 c4 04	 add	 esp, 4

; 704  :       BP_result=BP_integer((cell)K);

  002ee	03 c0		 add	 eax, eax
  002f0	03 c0		 add	 eax, eax
  002f2	5f		 pop	 edi
  002f3	83 c8 01	 or	 eax, 1
  002f6	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  002f9	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  002fd	5b		 pop	 ebx
  002fe	5e		 pop	 esi

; 748  : }

  002ff	c3		 ret	 0
$LN6@term_store:

; 705  :     }
; 706  :     break;
; 707  : 
; 708  :     case INSTANCE_OF_I: {
; 709  :       cell handle;ulong result=ZERO;
; 710  :       BP_get_integer(BP_input,handle);

  00300	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]

; 711  :       { Term K=(Term)handle;
; 712  :         H=internalize(K,H,&result); 

  00303	8b 54 24 10	 mov	 edx, DWORD PTR _H$[esp+8]
  00307	8d 4c 24 14	 lea	 ecx, DWORD PTR _result$5956[esp+8]
  0030b	51		 push	 ecx
  0030c	c1 f8 02	 sar	 eax, 2
  0030f	52		 push	 edx
  00310	50		 push	 eax
  00311	89 5c 24 20	 mov	 DWORD PTR _result$5956[esp+20], ebx
  00315	e8 00 00 00 00	 call	 _internalize
  0031a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031d	89 44 24 10	 mov	 DWORD PTR _H$[esp+8], eax

; 713  :       }
; 714  :       BP_result=result;

  00321	8b 44 24 14	 mov	 eax, DWORD PTR _result$5956[esp+8]
  00325	5f		 pop	 edi
  00326	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  00329	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  0032d	5b		 pop	 ebx
  0032e	5e		 pop	 esi

; 748  : }

  0032f	c3		 ret	 0
$LN5@term_store:

; 715  :     }
; 716  :     break;
; 717  : 
; 718  :     case FREE_TERM_I: {
; 719  :       cell handle;
; 720  :       BP_get_integer(BP_input,handle);

  00330	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00333	c1 f9 02	 sar	 ecx, 2

; 721  :       { Term K=(Term)handle;
; 722  :         freeTerm(K);

  00336	51		 push	 ecx
  00337	e8 00 00 00 00	 call	 _freeTerm

; 745  :   }
; 746  : 
; 747  :   return H;

  0033c	8b 44 24 14	 mov	 eax, DWORD PTR _H$[esp+12]
  00340	83 c4 04	 add	 esp, 4
  00343	5f		 pop	 edi
  00344	5b		 pop	 ebx
  00345	5e		 pop	 esi

; 748  : }

  00346	c3		 ret	 0
$LN4@term_store:

; 723  :       }
; 724  :     }
; 725  :     break;
; 726  : 
; 727  :     case NEW_KEY_ITERATOR: {
; 728  :         bp_long i=newKeyIterator();

  00347	e8 00 00 00 00	 call	 _newKeyIterator

; 729  :         BP_result=BP_integer(i);

  0034c	03 c0		 add	 eax, eax
  0034e	03 c0		 add	 eax, eax
  00350	5f		 pop	 edi
  00351	83 c8 01	 or	 eax, 1
  00354	89 46 f0	 mov	 DWORD PTR [esi-16], eax

; 745  :   }
; 746  : 
; 747  :   return H;

  00357	8b 44 24 0c	 mov	 eax, DWORD PTR _H$[esp+4]
  0035b	5b		 pop	 ebx
  0035c	5e		 pop	 esi

; 748  : }

  0035d	c3		 ret	 0
$LN3@term_store:

; 730  :     }
; 731  :     break;
; 732  : 
; 733  :     case PROCESS_TERM_F_X: {
; 734  :       bp_long f; Term X,Y; ulong result=ZERO;
; 735  :       BP_get_integer(BP_input,f);
; 736  :       X=externalize(C2T(BP_data));

  0035e	8b 56 f4	 mov	 edx, DWORD PTR [esi-12]
  00361	8b 7e f8	 mov	 edi, DWORD PTR [esi-8]
  00364	52		 push	 edx
  00365	89 5c 24 18	 mov	 DWORD PTR _result$5992[esp+12], ebx
  00369	c1 ff 02	 sar	 edi, 2
  0036c	e8 00 00 00 00	 call	 _externalize

; 737  :       Y=processTerm(f,X);

  00371	50		 push	 eax
  00372	57		 push	 edi
  00373	e8 00 00 00 00	 call	 _processTerm

; 738  :       H=internalize(Y,H,&result);

  00378	8b 4c 24 1c	 mov	 ecx, DWORD PTR _H$[esp+20]
  0037c	8b f8		 mov	 edi, eax
  0037e	8d 44 24 20	 lea	 eax, DWORD PTR _result$5992[esp+20]
  00382	50		 push	 eax
  00383	51		 push	 ecx
  00384	57		 push	 edi
  00385	e8 00 00 00 00	 call	 _internalize
  0038a	83 c4 18	 add	 esp, 24			; 00000018H
  0038d	89 44 24 10	 mov	 DWORD PTR _H$[esp+8], eax

; 739  :       if(NULL!=Y) freeTerm(Y);

  00391	3b fb		 cmp	 edi, ebx
  00393	74 09		 je	 SHORT $LN2@term_store
  00395	57		 push	 edi
  00396	e8 00 00 00 00	 call	 _freeTerm
  0039b	83 c4 04	 add	 esp, 4
$LN2@term_store:

; 740  :       BP_result=result;

  0039e	8b 54 24 14	 mov	 edx, DWORD PTR _result$5992[esp+8]

; 745  :   }
; 746  : 
; 747  :   return H;

  003a2	8b 44 24 10	 mov	 eax, DWORD PTR _H$[esp+8]
  003a6	5f		 pop	 edi
  003a7	5b		 pop	 ebx
  003a8	89 56 f0	 mov	 DWORD PTR [esi-16], edx
  003ab	5e		 pop	 esi

; 748  : }

  003ac	c3		 ret	 0
$LN1@term_store:
  003ad	5f		 pop	 edi
  003ae	5b		 pop	 ebx
  003af	5e		 pop	 esi

; 741  :     }
; 742  :     break;
; 743  :     default: 
; 744  :       return LOCAL_ERR(BP_op,"bad op-code in term_store_op");

  003b0	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _regs$[esp-4], OFFSET ??_C@_0BN@NOGECHEG@bad?5op?9code?5in?5term_store_op?$AA@
  003b8	89 44 24 04	 mov	 DWORD PTR _H$[esp-4], eax
  003bc	e9 00 00 00 00	 jmp	 _local_error
  003c1	8d 49 00	 npad	 3
$LN63@term_store:

; 748  : }

  003c4	00 00 00 00	 DD	 $LN18@term_store
  003c8	00 00 00 00	 DD	 $LN57@term_store
  003cc	00 00 00 00	 DD	 $LN16@term_store
  003d0	00 00 00 00	 DD	 $LN15@term_store
  003d4	00 00 00 00	 DD	 $LN14@term_store
  003d8	00 00 00 00	 DD	 $LN13@term_store
  003dc	00 00 00 00	 DD	 $LN12@term_store
  003e0	00 00 00 00	 DD	 $LN11@term_store
  003e4	00 00 00 00	 DD	 $LN10@term_store
  003e8	00 00 00 00	 DD	 $LN9@term_store
  003ec	00 00 00 00	 DD	 $LN8@term_store
  003f0	00 00 00 00	 DD	 $LN7@term_store
  003f4	00 00 00 00	 DD	 $LN6@term_store
  003f8	00 00 00 00	 DD	 $LN5@term_store
  003fc	00 00 00 00	 DD	 $LN4@term_store
  00400	00 00 00 00	 DD	 $LN3@term_store
_term_store_op ENDP
_TEXT	ENDS
PUBLIC	_NIL
; Function compile flags: /Ogtpy
;	COMDAT _NIL
_TEXT	SEGMENT
_NIL	PROC						; COMDAT

; 27   : Term NIL() {

  00000	56		 push	 esi

; 28   :   Term T=newTerm(0);

  00001	6a 00		 push	 0
  00003	e8 00 00 00 00	 call	 _newTerm
  00008	8b f0		 mov	 esi, eax
  0000a	83 c4 04	 add	 esp, 4

; 29   :   setArg(0,T,STRING_TYPE,S2O(sNIL));

  0000d	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00010	7e 1c		 jle	 SHORT $LN6@NIL
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _sNIL
  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001b	51		 push	 ecx
  0001c	c6 00 01	 mov	 BYTE PTR [eax], 1
  0001f	e8 00 00 00 00	 call	 _newTermString
  00024	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00027	89 02		 mov	 DWORD PTR [edx], eax
  00029	83 c4 04	 add	 esp, 4

; 30   :   return T;

  0002c	8b c6		 mov	 eax, esi
$LN6@NIL:
  0002e	5e		 pop	 esi

; 31   : }

  0002f	c3		 ret	 0
_NIL	ENDP
_TEXT	ENDS
PUBLIC	_isNIL
; Function compile flags: /Ogtpy
;	COMDAT _isNIL
_TEXT	SEGMENT
_T$ = 8							; size = 4
_isNIL	PROC						; COMDAT

; 34   :   return (BYTE)(T->size==1 && STRING_TYPE==T->types[0] && 0==strcmp(sNIL,O2S(T->args[0])));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _T$[esp-4]
  00004	83 38 01	 cmp	 DWORD PTR [eax], 1
  00007	75 43		 jne	 SHORT $LN3@isNIL
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	80 39 01	 cmp	 BYTE PTR [ecx], 1
  0000f	75 3b		 jne	 SHORT $LN3@isNIL
  00011	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR _sNIL
  0001b	eb 03 8d 49 00	 npad	 5
$LL7@isNIL:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00024	75 1a		 jne	 SHORT $LN8@isNIL
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN9@isNIL
  0002a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00030	75 0e		 jne	 SHORT $LN8@isNIL
  00032	83 c0 02	 add	 eax, 2
  00035	83 c1 02	 add	 ecx, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL7@isNIL
$LN9@isNIL:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN10@isNIL
$LN8@isNIL:
  00040	1b c0		 sbb	 eax, eax
  00042	83 d8 ff	 sbb	 eax, -1
$LN10@isNIL:
  00045	85 c0		 test	 eax, eax
  00047	75 03		 jne	 SHORT $LN3@isNIL
  00049	b0 01		 mov	 al, 1

; 35   : }

  0004b	c3		 ret	 0
$LN3@isNIL:

; 34   :   return (BYTE)(T->size==1 && STRING_TYPE==T->types[0] && 0==strcmp(sNIL,O2S(T->args[0])));

  0004c	32 c0		 xor	 al, al

; 35   : }

  0004e	c3		 ret	 0
_isNIL	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	_newStringList
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _newStringList
_TEXT	SEGMENT
_head$ = 8						; size = 4
_tail$ = 12						; size = 4
_newStringList PROC					; COMDAT

; 128  : Term newStringList(char *head, Term tail) {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 129  :   Term T=newTerm(2);

  00002	6a 02		 push	 2
  00004	e8 00 00 00 00	 call	 _newTerm
  00009	8b f0		 mov	 esi, eax

; 130  :   /* Prolog compatible list functor */
; 131  :   setArg(0,T,STRING_TYPE,S2O("."));

  0000b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000d	83 c4 04	 add	 esp, 4
  00010	85 ff		 test	 edi, edi
  00012	7e 18		 jle	 SHORT $LN6@newStringL
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  0001c	c6 00 01	 mov	 BYTE PTR [eax], 1
  0001f	e8 00 00 00 00	 call	 _newTermString
  00024	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00027	83 c4 04	 add	 esp, 4
  0002a	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@newStringL:

; 132  :   /* head of a list - assumed a String */
; 133  :   setArg(1,T,STRING_TYPE,S2O(head));

  0002c	83 ff 01	 cmp	 edi, 1
  0002f	7e 1a		 jle	 SHORT $LN17@newStringL
  00031	8b 44 24 0c	 mov	 eax, DWORD PTR _head$[esp+4]
  00035	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00038	50		 push	 eax
  00039	c6 42 01 01	 mov	 BYTE PTR [edx+1], 1
  0003d	e8 00 00 00 00	 call	 _newTermString
  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	83 c4 04	 add	 esp, 4
  00048	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN17@newStringL:

; 134  :   /* tail of the list - should be another String list or NIL() */
; 135  :   setArg(2,T,TERM_TYPE,T2O(tail));

  0004b	83 ff 02	 cmp	 edi, 2
  0004e	7e 11		 jle	 SHORT $LN36@newStringL
  00050	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00053	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00056	8b 4c 24 10	 mov	 ecx, DWORD PTR _tail$[esp+4]
  0005a	c6 42 02 05	 mov	 BYTE PTR [edx+2], 5
  0005e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN36@newStringL:

; 136  :   /* return the new List as a Term */
; 137  :   return T;

  00061	5f		 pop	 edi
  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi

; 138  : }

  00065	c3		 ret	 0
_newStringList ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PBAEMKBI@?6?$CK?$CK?$CKEXITING?5termTester?6?$AA@ ; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_0BM@ENHIHFBC@arg?52?5of?5G?5is?5a?5string?$DN?$DO?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_01PAPGNFGE@c?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	__real@4048f5c3
PUBLIC	??_C@_01INIBCBCB@f?$AA@				; `string'
PUBLIC	??_C@_0BJ@LPPLOHDN@?6?$CK?$CK?$CKENTERING?5termTester?6?$AA@ ; `string'
PUBLIC	_termTester
;	COMDAT ??_C@_0BI@PBAEMKBI@?6?$CK?$CK?$CKEXITING?5termTester?6?$AA@
CONST	SEGMENT
??_C@_0BI@PBAEMKBI@?6?$CK?$CK?$CKEXITING?5termTester?6?$AA@ DB 0aH, '***E'
	DB	'XITING termTester', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ENHIHFBC@arg?52?5of?5G?5is?5a?5string?$DN?$DO?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@ENHIHFBC@arg?52?5of?5G?5is?5a?5string?$DN?$DO?$CFs?6?$AA@ DB 'a'
	DB	'rg 2 of G is a string=>%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT
??_C@_01PAPGNFGE@c?$AA@ DB 'c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4048f5c3
CONST	SEGMENT
__real@4048f5c3 DD 04048f5c3r			; 3.14
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT
??_C@_01INIBCBCB@f?$AA@ DB 'f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPPLOHDN@?6?$CK?$CK?$CKENTERING?5termTester?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LPPLOHDN@?6?$CK?$CK?$CKENTERING?5termTester?6?$AA@ DB 0aH, '***'
	DB	'ENTERING termTester', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _termTester
_TEXT	SEGMENT
$T6714 = -4						; size = 4
_termTester PROC					; COMDAT

; 37   : void termTester() {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 38   :   printf("\n***ENTERING termTester\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LPPLOHDN@?6?$CK?$CK?$CKENTERING?5termTester?6?$AA@
  00008	e8 00 00 00 00	 call	 _printf

; 39   :   {
; 40   :   Term F=newTerm(2);

  0000d	6a 02		 push	 2
  0000f	e8 00 00 00 00	 call	 _newTerm
  00014	8b f8		 mov	 edi, eax
  00016	83 c4 08	 add	 esp, 8

; 41   :   setArg(0,F,STRING_TYPE,S2O("f"));

  00019	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0001c	7e 18		 jle	 SHORT $LN6@termTester
  0001e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_01INIBCBCB@f?$AA@
  00026	c6 00 01	 mov	 BYTE PTR [eax], 1
  00029	e8 00 00 00 00	 call	 _newTermString
  0002e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00031	83 c4 04	 add	 esp, 4
  00034	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@termTester:

; 42   :   setArg(1,F,INT_TYPE,I2O(99));

  00036	83 3f 01	 cmp	 DWORD PTR [edi], 1
  00039	7e 11		 jle	 SHORT $LN17@termTester
  0003b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0003e	c6 42 01 02	 mov	 BYTE PTR [edx+1], 2
  00042	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00045	c7 40 04 63 00
	00 00		 mov	 DWORD PTR [eax+4], 99	; 00000063H
$LN17@termTester:

; 43   :   setArg(2,F,FLOAT_TYPE,F2O(3.14));

  0004c	83 3f 02	 cmp	 DWORD PTR [edi], 2
  0004f	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@4048f5c3
  00055	d9 5c 24 08	 fstp	 DWORD PTR $T6714[esp+12]
  00059	7e 11		 jle	 SHORT $LN28@termTester
  0005b	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0005e	8b 44 24 08	 mov	 eax, DWORD PTR $T6714[esp+12]
  00062	c6 41 02 03	 mov	 BYTE PTR [ecx+2], 3
  00066	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00069	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN28@termTester:

; 44   :   {
; 45   :   Term G=newTerm(2);

  0006c	6a 02		 push	 2
  0006e	e8 00 00 00 00	 call	 _newTerm
  00073	8b f0		 mov	 esi, eax
  00075	83 c4 04	 add	 esp, 4

; 46   :   setArg(0,G,STRING_TYPE,S2O("g"));

  00078	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0007b	7e 18		 jle	 SHORT $LN39@termTester
  0007d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_01JEJKBAGA@g?$AA@
  00085	c6 01 01	 mov	 BYTE PTR [ecx], 1
  00088	e8 00 00 00 00	 call	 _newTermString
  0008d	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00090	83 c4 04	 add	 esp, 4
  00093	89 02		 mov	 DWORD PTR [edx], eax
$LN39@termTester:

; 47   :   setArg(1,G,TERM_TYPE,T2O(F));

  00095	83 3e 01	 cmp	 DWORD PTR [esi], 1
  00098	7e 0d		 jle	 SHORT $LN50@termTester
  0009a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009d	c6 40 01 05	 mov	 BYTE PTR [eax+1], 5
  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a4	89 79 04	 mov	 DWORD PTR [ecx+4], edi
$LN50@termTester:

; 48   :   setArg(2,G,STRING_TYPE,S2O("c"));

  000a7	83 3e 02	 cmp	 DWORD PTR [esi], 2
  000aa	7e 1a		 jle	 SHORT $LN61@termTester
  000ac	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_01PAPGNFGE@c?$AA@
  000b4	c6 42 02 01	 mov	 BYTE PTR [edx+2], 1
  000b8	e8 00 00 00 00	 call	 _newTermString
  000bd	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c0	83 c4 04	 add	 esp, 4
  000c3	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN61@termTester:

; 49   :   { Term F1=O2T(getArg(1,G));

  000c6	83 3e 01	 cmp	 DWORD PTR [esi], 1
  000c9	7f 04		 jg	 SHORT $LN70@termTester
  000cb	33 c0		 xor	 eax, eax
  000cd	eb 06		 jmp	 SHORT $LN71@termTester
$LN70@termTester:
  000cf	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000d2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
$LN71@termTester:

; 50   :     showTerm(F1);printf("\n");

  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _showTerm
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000e0	e8 00 00 00 00	 call	 _printf
  000e5	83 c4 08	 add	 esp, 8

; 51   :   }
; 52   :   { char *s=O2S(getArg(2,G));

  000e8	83 3e 02	 cmp	 DWORD PTR [esi], 2
  000eb	7f 04		 jg	 SHORT $LN76@termTester
  000ed	33 c0		 xor	 eax, eax
  000ef	eb 06		 jmp	 SHORT $LN77@termTester
$LN76@termTester:
  000f1	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN77@termTester:

; 53   :     printf("arg 2 of G is a string=>%s\n",s);

  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@ENHIHFBC@arg?52?5of?5G?5is?5a?5string?$DN?$DO?$CFs?6?$AA@
  000fd	e8 00 00 00 00	 call	 _printf

; 54   :   }
; 55   :   showTerm(G);printf("\n");

  00102	56		 push	 esi
  00103	e8 00 00 00 00	 call	 _showTerm
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  0010d	e8 00 00 00 00	 call	 _printf

; 56   :   freeTerm(G); /* this also frees F that's part of G */

  00112	56		 push	 esi
  00113	e8 00 00 00 00	 call	 _freeTerm

; 57   :   }
; 58   :   { Term Tail=newStringList("b",NIL());

  00118	6a 00		 push	 0
  0011a	e8 00 00 00 00	 call	 _newTerm
  0011f	8b f0		 mov	 esi, eax
  00121	83 c4 18	 add	 esp, 24			; 00000018H
  00124	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00127	7e 1a		 jle	 SHORT $LN86@termTester
  00129	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _sNIL
  0012f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00132	52		 push	 edx
  00133	c6 01 01	 mov	 BYTE PTR [ecx], 1
  00136	e8 00 00 00 00	 call	 _newTermString
  0013b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0013e	83 c4 04	 add	 esp, 4
  00141	89 01		 mov	 DWORD PTR [ecx], eax
$LN86@termTester:
  00143	56		 push	 esi
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_01OJONOECF@b?$AA@
  00149	e8 00 00 00 00	 call	 _newStringList

; 59   :     Term L=newStringList("a",Tail);

  0014e	50		 push	 eax
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_01MCMALHOG@a?$AA@
  00154	e8 00 00 00 00	 call	 _newStringList
  00159	8b f0		 mov	 esi, eax

; 60   :     showTerm(L);

  0015b	56		 push	 esi
  0015c	e8 00 00 00 00	 call	 _showTerm

; 61   :     freeTerm(L);

  00161	56		 push	 esi
  00162	e8 00 00 00 00	 call	 _freeTerm

; 62   :   }
; 63   :   }
; 64   :   printf("\n***EXITING termTester\n");

  00167	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@PBAEMKBI@?6?$CK?$CK?$CKEXITING?5termTester?6?$AA@
  0016c	e8 00 00 00 00	 call	 _printf
  00171	83 c4 1c	 add	 esp, 28			; 0000001cH
  00174	5f		 pop	 edi
  00175	5e		 pop	 esi

; 65   : }

  00176	59		 pop	 ecx
  00177	c3		 ret	 0
_termTester ENDP
_TEXT	ENDS
END
